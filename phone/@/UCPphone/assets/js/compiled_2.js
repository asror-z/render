var AreminderC = UCPMC.extend({
    init: function(){
        var self = this;
        self.thistable = null;
    },
    displayWidget: function(widget_id,dash_id) {
        var id = $(".grid-stack-item[data-id='"+widget_id+"']").data('widget_type_id');
        $(".grid-stack-item[data-id='"+widget_id+"'] table").on("post-body.bs.table", function() {
            $(".grid-stack-item[data-id='"+widget_id+"'] table .notes").click(function(e){
                var client = $(this).data("id"),
                    selected = $(this).data("status");
                e.preventDefault();
                $.post(UCP.ajaxUrl, { module:"areminder", command:"getNotes", id:id },function(data){
                    UCP.showDialog(
                        _('Notes'),
                        $(".grid-stack-item[data-id='"+widget_id+"'] .modal-content").html(),
                        '<button type="button" class="btn btn-default" data-dismiss="modal">'+_("Close")+'</button>'+
                        '<button type="button" class="btn btn-primary save-notes">'+_("Save Changes")+'</button>',
                        function() {
                            if(data.notes !== null){
                                $("#globalModal .notes-text").val(data.notes);
                            } else {
                                $("#globalModal .notes-text").val("");
                            }
                            $("#globalModal select[name='arstatus'] option:contains("+selected+")").prop('selected',true);
                            //save
                            $("#globalModal .save-notes").click(function(){
                                var notes = $("#globalModal .notes-text").val();
                                var status = $("#globalModal select[name='arstatus']").val();
                                $.post(UCP.ajaxUrl, { module:"areminder", command:"updateNotes", id:client, notes: notes, status:status },function(data){
                                    $(".grid-stack-item[data-id='"+widget_id+"'] table").bootstrapTable('refresh');
                                    UCP.hideDialog();
                                });
                            });
                        }
                    );
                },"json");
            });
        });
        $(".grid-stack-item[data-id='"+widget_id+"'] .arenable").change(function(){
            var command = 'disableReminder';
            if(this.checked){
                command = 'enableReminder';
            }
            $.post(UCP.ajaxUrl, { module:"areminder", command:command, id:id},function(data){
            });
        });
    },
    notesFormatter: function(val,row){
        return '<a href="#" class="notes" data-id="'+val+'" data-status="'+row.status+'"><i class="fa fa-edit"></i></a>';
    },
    dateFormatter: function(val,row){
        if(val == "None"){
            return val;
        }
        return UCP.dateTimeFormatter(Date.parse(val)/1000);
    }
});

var CallforwardC = UCPMC.extend({
    init: function(){
        this.stopPropagation = {
            'CFU': {},
            'CFB': {},
            'CF': {},
            'ringtimer': {}
        };
    },
    prepoll: function() {
        var exts = [];
        $(".grid-stack-item[data-rawname=callforward]").each(function() {
            exts.push($(this).data("widget_type_id"));
        });
        return exts;
    },
    poll: function(data) {
        var self = this;
        $.each(data.states, function(extension,data) {
            $.each(data, function(type,number) {
                var state = (number !== false);
                if(typeof self.stopPropagation[type][extension] !== "undefined" && self.stopPropagation[type][extension]) {
                    return true;
                }
                var widget = $(".grid-stack-item[data-rawname=callforward][data-widget_type_id='"+extension+"']:visible input[data-type='"+type+"']"),
                    sidebar = $(".widget-extra-menu[data-module=callforward][data-widget_type_id='"+extension+"']:visible input[data-type='"+type+"']"),
                    sstate = state ? "on" : "off";
                if(widget.length && (widget.is(":checked") !== state)) {
                    self.stopPropagation[type][extension] = true;
                    widget.bootstrapToggle(sstate);
                    if(state) {
                        widget.parents(".parent").find(".display").removeClass("hidden").find(".text").text(number);
                    } else {
                        widget.parents(".parent").find(".display").addClass("hidden").find(".text").text("");
                    }
                    self.stopPropagation[type][extension] = false;
                }
                if(sidebar.length && (sidebar.is(":checked") !== state)) {
                    self.stopPropagation[type][extension] = true;
                    sidebar.bootstrapToggle(sstate);
                    if(state) {
                        sidebar.parents(".parent").find(".display").removeClass("hidden").find(".text").text(number);
                    } else {
                        sidebar.parents(".parent").find(".display").addClass("hidden").find(".text").text("");
                    }
                    self.stopPropagation[type][extension] = false;
                }
            });
        });
    },
    displayWidget: function(widget_id,dashboard_id) {
        var self = this;
        $(".grid-stack-item[data-id='"+widget_id+"'][data-rawname=callforward] .widget-content input[type='checkbox']").change(function(e) {
            var name = $(this).prop("name"),
                nice = $(this).data("nice"),
                parent = $(this).parents("."+name),
                type = $(this).data("type"),
                checked = $(this).is(':checked'),
                extension = $(".grid-stack-item[data-id='"+widget_id+"']").data("widget_type_id"),
                widget = $(this),
                sidebar = $(".widget-extra-menu[data-module='callforward'][data-widget_type_id='"+extension+"']:visible input[data-type='"+type+"']");

            if(typeof self.stopPropagation[type][extension] !== "undefined" && self.stopPropagation[type][extension]) {
                return true;
            }

            if(!$(this).is(":checked")) {
                if(sidebar.length && sidebar.is(":checked")) {
                    sidebar.bootstrapToggle('off');
                    sidebar.parents("."+name).find(".display").addClass("hidden").find(".text").text("");
                }
                self.saveSettings(extension,type,"",function() {
                    parent.find(".display").addClass("hidden").find(".text").text("");
                });
                return;
            }

            if(sidebar.length && !sidebar.is(":checked")) {
                sidebar.bootstrapToggle('on');
            }
            self.showDialog(this, extension, function(state, number) {
                if(state == 'off') {
                    widget.bootstrapToggle('off');
                    parent.find(".display").addClass("hidden").find(".text").text("");
                    if(sidebar.length && sidebar.is(":checked")) {
                        sidebar.bootstrapToggle('off');
                        sidebar.parents("."+name).find(".display").addClass("hidden").find(".text").text("");
                    }
                } else {
                    if(sidebar.length) {
                        sidebar.parents("."+name).find(".display").removeClass("hidden").find(".text").text(number);
                    }
                    parent.find(".display").removeClass("hidden").find(".text").text(number);
                }
            });
        });
    },
    showDialog: function(el, extension, callback) {
        var nice = $(el).data("nice"),
            type = $(el).data("type"),
            self = this;

        self.stopPropagation[type][extension] = true;
        UCP.showDialog(
            sprintf(_("Set Forwarding for %s"),nice),
            '<label for="cfnumber">'+_("Enter a number")+'</label><input id="cfnumber" name="cfnumber" class="form-control">',
            '<button class="btn btn-primary" id="cfsave">'+_("Save")+'</button>',
            function() {
                var value = '';
                $("#globalModal").one("hide.bs.modal", function() {
                    self.stopPropagation[type][extension] = false;
                    if(value === '') {
                        callback('off','');
                    }
                });
                $("#cfsave").click(function(e) {
                    e.preventDefault();
                    value = $("#cfnumber").val();
                    if(value === "") {
                        UCP.showAlert(_("A valid number needs to be entered"),"warning");
                        return;
                    }

                    callback('on',value);
                    self.stopPropagation[type][extension] = false;
                    self.saveSettings(extension, type, value, function(data) {
                        if(data.status) {
                            UCP.closeDialog();
                        } else {
                            callback('off','');
                            UCP.showAlert(data.message, 'danger');
                        }
                    });
                });
            }
        );
    },
    saveSettings: function(extension, type, value, callback) {
        var self = this;
        data = {
            ext: extension,
            type: type,
            module: "callforward",
            command: "settings"
        };
        if(value !== "") {
            data.value = value;
        }
        self.stopPropagation[type][extension] = true;
        $.post( UCP.ajaxUrl, data, callback).always(function() {
            self.stopPropagation[type][extension] = false;
        }).fail(function() {
            UCP.showAlert(_('An Unknown error occured'),'danger');
        });
    },
    displayWidgetSettings: function(widget_id,dashboard_id) {
        var self = this,
            extension = $("div[data-id='"+widget_id+"']").data("widget_type_id");
        $("#cfringtimer").change(function() {
            self.saveSettings(extension, 'ringtimer', $(this).val(), function() {
                console.log("saved!");
            });
        });
    },
    displaySimpleWidget: function(widget_id) {
        var self = this;
        $(".widget-extra-menu[data-id='"+widget_id+"'] input[type='checkbox']").change(function(e) {
            var type = $(this).data("type"),
                checked = $(this).is(':checked'),
                extension = $(".widget-extra-menu[data-id='"+widget_id+"']").data("widget_type_id"),
                name = $(this).prop("name"),
                parent = $(this).parents("."+name),
                el = $(".grid-stack-item[data-widget_type_id='"+extension+"'][data-rawname=callforward] .widget-content input[data-type='"+type+"']");

            if(typeof self.stopPropagation[type][extension] !== "undefined" && self.stopPropagation[type][extension]) {
                return true;
            }

            if(!checked) {
                parent.find(".display").addClass("hidden").find(".text").text("");
            }

            if(el.length) {
                if(el.is(":checked") !== checked) {
                    var state = checked ? "on" : "off";
                    el.bootstrapToggle(state);
                }
            } else {
                if(checked) {
                    self.showDialog(this, extension, function(state, number) {
                        if(state == 'on') {
                            parent.find(".display").removeClass("hidden").find(".text").text(number);
                        } else {
                            el.bootstrapToggle('off');
                            parent.find(".display").addClass("hidden").find(".text").text("");
                        }
                    });
                } else {
                    self.saveSettings(extension, type, '', function(data) {
                        if(!data.status) {
                            UCP.showAlert(data.message, 'danger');
                        }
                    });
                }
            }
        });
    },
    displaySimpleWidgetSettings: function(widget_id) {
        this.displayWidgetSettings(widget_id);
    }
});

var CallwaitingC = UCPMC.extend({
    init: function(){
        this.stopPropagation = {};
    },
    prepoll: function() {
        var exts = [];
        $(".grid-stack-item[data-rawname=callwaiting]").each(function() {
            exts.push($(this).data("widget_type_id"));
        });
        return exts;
    },
    poll: function(data) {
        var self = this;
        $.each(data.states, function(ext,state) {
            if(typeof self.stopPropagation[ext] !== "undefined" && self.stopPropagation[ext]) {
                return true;
            }
            var widget = $(".grid-stack-item[data-rawname=callwaiting][data-widget_type_id='"+ext+"']:visible input[name='cwenable']"),
                sidebar = $(".widget-extra-menu[data-module='callwaiting'][data-widget_type_id='"+ext+"']:visible input[name='cwenable']"),
                sstate = state ? "on" : "off";
            if(widget.length && (widget.is(":checked") !== state)) {
                self.stopPropagation[extension] = true;
                widget.bootstrapToggle(sstate);
                self.stopPropagation[extension] = false;
            } else if(sidebar.length && (sidebar.is(":checked") !== state)) {
                self.stopPropagation[extension] = true;
                sidebar.bootstrapToggle(sstate);
                self.stopPropagation[extension] = false;
            }
        });
    },
    displayWidget: function(widget_id,dashboard_id) {
        var self = this;
        $(".grid-stack-item[data-id='"+widget_id+"'][data-rawname=callwaiting] .widget-content input[name='cwenable']").change(function() {
            var extension = $(".grid-stack-item[data-id='"+widget_id+"'][data-rawname=callwaiting]").data("widget_type_id"),
                el = $(".widget-extra-menu[data-module='callwaiting'][data-widget_type_id='"+extension+"']:visible input[name='cwenable']"),
                checked = $(this).is(':checked'),
                name = $(this).prop('name');
            if(el.length && el.is(":checked") !== checked) {
                var state = checked ? "on" : "off";
                el.bootstrapToggle(state);
            }
            self.saveSettings(extension, {enable: checked});
        });
    },
    saveSettings: function(extension, data, callback) {
        var self = this;
        data.ext = extension;
        data.module = "Callwaiting";
        data.command = "enable";
        this.stopPropagation[extension] = true;
        $.post( UCP.ajaxUrl, data, callback).always(function() {
            self.stopPropagation[extension] = false;
        });
    },
    displaySimpleWidget: function(widget_id) {
        var self = this;
        $(".widget-extra-menu[data-id='"+widget_id+"'] input[name='cwenable']").change(function(e) {
            var extension = $(".widget-extra-menu[data-id='"+widget_id+"']").data("widget_type_id"),
                checked = $(this).is(':checked'),
                name = $(this).prop('name'),
                el = $(".grid-stack-item[data-rawname=callwaiting][data-widget_type_id='"+extension+"']:visible input[name='cwenable']");

            if(el.length) {
                if(el.is(":checked") !== checked) {
                    var state = checked ? "on" : "off";
                    el.bootstrapToggle(state);
                }
            } else {
                self.saveSettings(extension, {enable: checked});
            }
        });
    }
});

var CdrC = UCPMC.extend({
    init: function() {
        this.playing = null;
    },
    resize: function(widget_id) {
        $(".grid-stack-item[data-id='"+widget_id+"'] .cdr-grid").bootstrapTable('resetView',{height: $(".grid-stack-item[data-id='"+widget_id+"'] .widget-content").height()-1});
    },
    poll: function(data, url) {

    },
    displayWidget: function(widget_id, dashboard_id) {
        var self = this,
            extension = $("div[data-id='"+widget_id+"']").data("widget_type_id");

        $(".grid-stack-item[data-id='"+widget_id+"'] .cdr-grid").one("post-body.bs.table", function() {
            setTimeout(function() {
                self.resize(widget_id);
            },250);
        });

        $('.grid-stack-item[data-id='+widget_id+'] .cdr-grid').on("post-body.bs.table", function () {
            self.bindPlayers(widget_id);
            $(".cdr-grid .clickable").click(function(e) {
                var text = $(this).text();
                if (UCP.validMethod("Contactmanager", "showActionDialog")) {
                    UCP.Modules.Contactmanager.showActionDialog("number", text, "phone");
                }
            });
        });
    },
    formatDescription: function (value, row, index) {
        var icons = '';
        if(typeof row.icons !== "undefined") {
            $.each(row.icons, function(i, v) {
                icons += '<i class="fa '+v+'"></i> ';
            });
        }
        return icons + " " + value;
    },
    formatActions: function (value, row, index) {
        var settings = UCP.Modules.Cdr.staticsettings;
        if(row.recordingfile === '' || settings.showDownload === "0") {
            return '';
        }
        var link = '<a class="download" alt="'+_("Download")+'" href="'+UCP.ajaxUrl+'?module=cdr&amp;command=download&amp;msgid='+row.uniqueid+'&amp;type=download&amp;ext='+row.requestingExtension+'"><i class="fa fa-cloud-download"></i></a>';
        return link;
    },
    formatPlayback: function (value, row, index) {
        var settings = UCP.Modules.Cdr.staticsettings,
            rand = Math.floor(Math.random() * 10000);
        if(row.recordingfile.length === 0 || settings.showPlayback === "0") {
            return '';
        }
        return '<div id="jquery_jplayer_'+row.niceUniqueid+'-'+rand+'" class="jp-jplayer" data-container="#jp_container_'+row.niceUniqueid+'-'+rand+'" data-id="'+row.uniqueid+'"></div><div id="jp_container_'+row.niceUniqueid+'-'+rand+'" data-player="jquery_jplayer_'+row.niceUniqueid+'-'+rand+'" class="jp-audio-freepbx" role="application" aria-label="media player">'+
            '<div class="jp-type-single">'+
            '<div class="jp-gui jp-interface">'+
            '<div class="jp-controls">'+
            '<i class="fa fa-play jp-play"></i>'+
            '<i class="fa fa-undo jp-restart"></i>'+
            '</div>'+
            '<div class="jp-progress">'+
            '<div class="jp-seek-bar progress">'+
            '<div class="jp-current-time" role="timer" aria-label="time">&nbsp;</div>'+
            '<div class="progress-bar progress-bar-striped active" style="width: 100%;"></div>'+
            '<div class="jp-play-bar progress-bar"></div>'+
            '<div class="jp-play-bar">'+
            '<div class="jp-ball"></div>'+
            '</div>'+
            '<div class="jp-duration" role="timer" aria-label="duration">&nbsp;</div>'+
            '</div>'+
            '</div>'+
            '<div class="jp-volume-controls">'+
            '<i class="fa fa-volume-up jp-mute"></i>'+
            '<i class="fa fa-volume-off jp-unmute"></i>'+
            '</div>'+
            '</div>'+
            '<div class="jp-no-solution">'+
            '<span>Update Required</span>'+
            sprintf(_("You are missing support for playback in this browser. To fully support HTML5 browser playback you will need to install programs that can not be distributed with the PBX. If you'd like to install the binaries needed for these conversions click <a href='%s'>here</a>"),"http://wiki.freepbx.org/display/FOP/Installing+Media+Conversion+Libraries")+
            '</div>'+
            '</div>'+
            '</div>';
    },
    formatDuration: function (value, row, index) {
        return row.niceDuration;
    },
    formatDate: function(value, row, index) {
        return UCP.dateTimeFormatter(value);
    },
    bindPlayers: function(widget_id) {
        var extension = $("div[data-id='"+widget_id+"']").data("widget_type_id");
        $(".grid-stack-item[data-id="+widget_id+"] .jp-jplayer").each(function() {
            var container = $(this).data("container"),
                player = $(this),
                id = $(this).data("id");
            $(this).jPlayer({
                ready: function() {
                    $(container + " .jp-play").click(function() {
                        if($(this).parents(".jp-controls").hasClass("recording")) {
                            var type = $(this).parents(".jp-audio-freepbx").data("type");
                            $this.recordGreeting(type);
                            return;
                        }
                        if(!player.data("jPlayer").status.srcSet) {
                            $(container).addClass("jp-state-loading");
                            $.ajax({
                                type: 'POST',
                                url: "index.php?quietmode=1",
                                data: {module: "cdr", command: "gethtml5", id: id, ext: extension},
                                dataType: 'json',
                                timeout: 30000,
                                success: function(data) {
                                    if(data.status) {
                                        player.on($.jPlayer.event.error, function(event) {
                                            $(container).removeClass("jp-state-loading");
                                            console.log(event);
                                        });
                                        player.one($.jPlayer.event.canplay, function(event) {
                                            $(container).removeClass("jp-state-loading");
                                            player.jPlayer("play");
                                        });
                                        player.jPlayer( "setMedia", data.files);
                                    } else {
                                        alert(data.message);
                                        $(container).removeClass("jp-state-loading");
                                    }
                                }
                            });
                        }
                    });
                    var $this = this;
                    $(container).find(".jp-restart").click(function() {
                        if($($this).data("jPlayer").status.paused) {
                            $($this).jPlayer("pause",0);
                        } else {
                            $($this).jPlayer("play",0);
                        }
                    });
                },
                timeupdate: function(event) {
                    $(container).find(".jp-ball").css("left",event.jPlayer.status.currentPercentAbsolute + "%");
                },
                ended: function(event) {
                    $(container).find(".jp-ball").css("left","0%");
                },
                swfPath: "/js",
                supplied: UCP.Modules.Cdr.staticsettings.supportedHTML5,
                cssSelectorAncestor: container,
                wmode: "window",
                useStateClassSkin: true,
                remainingDuration: true,
                toggleDuration: true
            });
            $(this).on($.jPlayer.event.play, function(event) {
                $(this).jPlayer("pauseOthers");
            });
        });

        var acontainer = null;
        $('.jp-play-bar').mousedown(function (e) {
            acontainer = $(this).parents(".jp-audio-freepbx");
            updatebar(e.pageX);
        });
        $(document).mouseup(function (e) {
            if (acontainer) {
                updatebar(e.pageX);
                acontainer = null;
            }
        });
        $(document).mousemove(function (e) {
            if (acontainer) {
                updatebar(e.pageX);
            }
        });

        //update Progress Bar control
        var updatebar = function (x) {
            var player = $("#" + acontainer.data("player")),
                progress = acontainer.find('.jp-progress'),
                maxduration = player.data("jPlayer").status.duration,
                position = x - progress.offset().left,
                percentage = 100 * position / progress.width();

            //Check within range
            if (percentage > 100) {
                percentage = 100;
            }
            if (percentage < 0) {
                percentage = 0;
            }

            player.jPlayer("playHead", percentage);

            //Update progress bar and video currenttime
            acontainer.find('.jp-ball').css('left', percentage+'%');
            acontainer.find('.jp-play-bar').css('width', percentage + '%');
            player.jPlayer.currentTime = maxduration * percentage / 100;
        };
    }
});

var CelC = UCPMC.extend({
    init: function() {
    },
    poll: function(data, url) {
    },
    resize: function(widget_id) {
        $(".grid-stack-item[data-id='"+widget_id+"'] .cel-grid").bootstrapTable('resetView',{height: $(".grid-stack-item[data-id='"+widget_id+"'] .widget-content").height()-1});
    },
    displayWidget: function(widget_id) {
        var self = this,
            extension = $("div[data-id='"+widget_id+"']").data("widget_type_id");

        $(".grid-stack-item[data-id='"+widget_id+"'] .cel-grid").one("post-body.bs.table", function() {
            setTimeout(function() {
                self.resize(widget_id);
            },250);
        });

        $(".grid-stack-item[data-id='"+widget_id+"'] .cel-grid").on("post-body.bs.table", function() {
            self.bindPlayers(widget_id);
        });
        $(".grid-stack-item[data-id='"+widget_id+"'] .cel-grid").on("click-cell.bs.table", function(event, field, value, row) {
            if(field == "file" || field == "controls") {
                return;
            }

            $.getJSON(UCP.ajaxUrl+'?module=cel&command=eventmodal', function(data){
                if (data.status === true){
                    UCP.showDialog(_("Call Events"),
                        data.message,
                        '<button type="button" class="btn btn-primary" data-dismiss="modal">'+_("Close")+'</button>',
                        function() {
                            $("#globalModal .cel-detail-grid").bootstrapTable();
                            $("#globalModal .cel-detail-grid").bootstrapTable('load', row.moreinfo);
                        }
                    );
                } else {
                    UCP.showAlert(_("Error getting form"),'danger');
                }
            }).always(function() {
            }).fail(function() {
                UCP.showAlert(_("Error getting form"),'danger');
            });
        });
    },
    formatDuration: function (value, row, index) {
        return sprintf(_("%s seconds"),value);
    },
    formatDate: function(value, row, index) {
        return UCP.dateTimeFormatter(value);
    },
    formatControls: function (value, row, index) {
        var settings = UCP.Modules.Cel.staticsettings;
        if(typeof row.file === "undefined" || settings.showDownload === "0") {
            return '';
        }
        var links = '';
        links = '<a class="download" alt="'+_("Download")+'" href="'+UCP.ajaxUrl+'?module=cel&amp;command=download&amp;id='+encodeURIComponent(row.uniqueid)+'&amp;type=download"><i class="fa fa-cloud-download"></i></a>';
        return links;
    },
    formatPlayback: function (value, row, index) {
        var settings = UCP.Modules.Cel.staticsettings,
            rand = Math.floor(Math.random() * 10000);

        if(typeof row.file === "undefined" || settings.showPlayback === "0") {
            return '';
        }

        var recordings = [row.file];

        var html = '',
            count = 0;
        $.each(recordings, function(k, v){
            if(v === false) {
                return true;
            }
            html += '<div id="jquery_jplayer_'+index+'_'+count+'-'+rand+'" class="jp-jplayer" data-container="#jp_container_'+index+'_'+count+'-'+rand+'" data-playbackuniqueid="'+row.uniqueid+'" data-id="'+k+'"></div>'+
                '<div id="jp_container_'+index+'_'+count+'-'+rand+'" data-player="jquery_jplayer_'+index+'_'+count+'-'+rand+'" class="jp-audio-freepbx" role="application" aria-label="media player">'+
                '<div class="jp-type-single">'+
                '<div class="jp-gui jp-interface">'+
                '<div class="jp-controls">'+
                '<i class="fa fa-play jp-play"></i>'+
                '<i class="fa fa-undo jp-restart"></i>'+
                '</div>'+
                '<div class="jp-progress">'+
                '<div class="jp-seek-bar progress">'+
                '<div class="jp-current-time" role="timer" aria-label="time">&nbsp;</div>'+
                '<div class="progress-bar progress-bar-striped active" style="width: 100%;"></div>'+
                '<div class="jp-play-bar progress-bar"></div>'+
                '<div class="jp-play-bar">'+
                '<div class="jp-ball"></div>'+
                '</div>'+
                '<div class="jp-duration" role="timer" aria-label="duration">&nbsp;</div>'+
                '</div>'+
                '</div>'+
                '<div class="jp-volume-controls">'+
                '<i class="fa fa-volume-up jp-mute"></i>'+
                '<i class="fa fa-volume-off jp-unmute"></i>'+
                '</div>'+
                '</div>'+
                '<div class="jp-no-solution">'+
                '<span>Update Required</span>'+
                sprintf(_("You are missing support for playback in this browser. To fully support HTML5 browser playback you will need to install programs that can not be distributed with the PBX. If you'd like to install the binaries needed for these conversions click <a href='%s'>here</a>"),"http://wiki.freepbx.org/display/FOP/Installing+Media+Conversion+Libraries")+
                '</div>'+
                '</div>';
        });
        return html;
    },
    bindPlayers: function(widget_id) {
        $(".grid-stack-item[data-id='"+widget_id+"'] .jp-jplayer").each(function() {
            var container = $(this).data("container"),
                player = $(this),
                playback = $(this).data("playbackuniqueid");

            $(this).jPlayer({
                ready: function() {
                    $(container + " .jp-play").click(function() {
                        if($(this).parents(".jp-controls").hasClass("recording")) {
                            var type = $(this).parents(".jp-audio-freepbx").data("type");
                            $this.recordGreeting(type);
                            return;
                        }
                        if(!player.data("jPlayer").status.srcSet) {
                            $(container).addClass("jp-state-loading");
                            $.ajax({
                                type: 'POST',
                                url: "ajax.php",
                                data: {module: "cel", command: "gethtml5", uniqueid: playback, ext: extension},
                                dataType: 'json',
                                timeout: 30000,
                                success: function(data) {
                                    if(data.status) {
                                        player.on($.jPlayer.event.error, function(event) {
                                            $(container).removeClass("jp-state-loading");
                                            console.log(event);
                                        });
                                        player.one($.jPlayer.event.canplay, function(event) {
                                            $(container).removeClass("jp-state-loading");
                                            player.jPlayer("play");
                                        });
                                        player.jPlayer( "setMedia", data.files);
                                    } else {
                                        alert(data.message);
                                        $(container).removeClass("jp-state-loading");
                                    }
                                }
                            });
                        }
                    });
                    var $this = this;
                    $(container).find(".jp-restart").click(function() {
                        if($($this).data("jPlayer").status.paused) {
                            $($this).jPlayer("pause",0);
                        } else {
                            $($this).jPlayer("play",0);
                        }
                    });
                },
                timeupdate: function(event) {
                    $(container).find(".jp-ball").css("left",event.jPlayer.status.currentPercentAbsolute + "%");
                },
                ended: function(event) {
                    $(container).find(".jp-ball").css("left","0%");
                },
                swfPath: "/js",
                supplied: UCP.Modules.Cel.staticsettings.supportedHTML5,
                cssSelectorAncestor: container,
                wmode: "window",
                useStateClassSkin: true,
                remainingDuration: true,
                toggleDuration: true
            });
            $(this).on($.jPlayer.event.play, function(event) {
                $(this).jPlayer("pauseOthers");
            });
        });

        var acontainer = null;
        $(".grid-stack-item[data-id='"+widget_id+"'] .jp-play-bar").mousedown(function (e) {
            acontainer = $(this).parents(".jp-audio-freepbx");
            updatebar(e.pageX);
        });
        $(document).mouseup(function (e) {
            if (acontainer) {
                updatebar(e.pageX);
                acontainer = null;
            }
        });
        $(document).mousemove(function (e) {
            if (acontainer) {
                updatebar(e.pageX);
            }
        });

        //update Progress Bar control
        var updatebar = function (x) {
            var player = $("#" + acontainer.data("player")),
                progress = acontainer.find('.jp-progress'),
                maxduration = player.data("jPlayer").status.duration,
                position = x - progress.offset().left,
                percentage = 100 * position / progress.width();

            //Check within range
            if (percentage > 100) {
                percentage = 100;
            }
            if (percentage < 0) {
                percentage = 0;
            }

            player.jPlayer("playHead", percentage);

            //Update progress bar and video currenttime
            acontainer.find('.jp-ball').css('left', percentage+'%');
            acontainer.find('.jp-play-bar').css('width', percentage + '%');
            player.jPlayer.currentTime = maxduration * percentage / 100;
        };
    }
});

var ConferencesproC = UCPMC.extend({
    init: function() {
        this.socket = null;
        this.subscribed = [];
        this.wasTalking = {};
    },
    displayWidget: function(widget_id,dashboard_id) {
        var $this = this,
            conference = $(".grid-stack-item[data-rawname=conferencespro][data-id='"+widget_id+"']").data("widget_type_id");
        $(".grid-stack-item[data-rawname=conferencespro][data-id='"+widget_id+"'] .invite-action").click(function(e){
            e.preventDefault();
            var adminable = $(".grid-stack-item[data-rawname=conferencespro][data-id='"+widget_id+"']").find(".conference-data").data("admin-allowed");
            UCP.showDialog(_("Invite to Conference"),
                '<label for="type">'+_("User Type")+'</label>'+
                '<select id="type" data-toggle="select" class="form-control"><option value="user">'+_("User")+'</option>'+(adminable ? '<option value="admin">'+_("Admin")+'</option>' : '')+'</select>'+
                '<label for="invite">'+_("Number")+':</label><input class="form-control" id="invite" multiple>',
                '<button class="btn btn-default" id="inviteConference">'+_("Invite")+'</button>',
                function() {
                    var call = function(to, type) {
                        if(to === "") {
                            UCP.showAlert(_("Please enter a valid number!"),'danger');
                            return;
                        }
                        $this.invite(conference, to, type);
                        UCP.closeDialog();
                    };
                    $("#inviteConference").click(function() {
                        call($("#invite").val(), $("#type").val());
                    });
                    $("#invite").keypress(function(event) {
                        if (event.keyCode == 13) {
                            call($("#invite").val(), $("#type").val());
                        }
                    });
                }
            );
        });
        $(".grid-stack-item[data-rawname=conferencespro][data-id='"+widget_id+"'] .conference-room.room .user-list tr .kick").click(function() {
            $this.kick($(".grid-stack-item[data-rawname=conferencespro][data-id='"+widget_id+"']"), $(this).parents("tr").data("channel"));
        });
        $(".grid-stack-item[data-rawname=conferencespro][data-id='"+widget_id+"'] .conference-room.room .user-list tr .muter").click(function() {
            $this.toggleMute($(".grid-stack-item[data-rawname=conferencespro][data-id='"+widget_id+"']"), $(this).parents("tr").data("channel"));
        });
        $(".grid-stack-item[data-rawname=conferencespro][data-id='"+widget_id+"'] .lock i").click(function() {
            $this.toggleLock($(".grid-stack-item[data-rawname=conferencespro][data-id='"+widget_id+"']"));
        });
    },
    displayWidgetSettings: function(widget_id, dashboard_id) {
        var $this = this;
        var conference = $("#widget_settings .widget-settings-content .conferencesettings").data("id");
        $('#widget_settings .widget-settings-content .conferencesettings input[type!=checkbox], .conferencesettings select').change(function() {
            $this.saveSettings(conference, { key: $(this).prop("name"), value: $(this).val() });
        });
        $('#widget_settings .widget-settings-content .conferencesettings input[type=checkbox]').change(function() {
            var val = "";
            if ($(this).is(":checked")) {
                val = $(this).val();
            }
            $this.saveSettings(conference, { key: $(this).prop("name"), value: val });
        });
    },
    prepoll: function(data) {
        var conferences = [];
        $(".grid-stack-item[data-rawname=conferencespro]").each(function() {
            conferences.push($(this).data("widget_type_id"));
        });
        return {
            websocket: (this.socket !== null && this.socket.connected),
            conferences: conferences
        };
    },
    poll: function(data, url) {
        var $this = this;
        if ((this.socket === null || !this.socket.connected) && data.status) {
            $(".grid-stack-item[data-rawname=conferencespro]").each(function() {
                var id = $(this).data("widget_type_id");
                if(typeof data.conferences[id] === "undefined" && $(this).find(".conference-room.room:visible").length) {
                    $this.endRoom($(this));
                }
            });
            async.forEachOf(data.conferences, function (data, id, callback) {
                var widget = $(".grid-stack-item[data-rawname=conferencespro][data-widget_type_id="+id+"]"),
                    appType = widget.find(".conference-room.room").data("type"),
                    channels = [];

                widget.find(".statuses .lock span").text(data.Locked);
                widget.find(".statuses .marked span").text(data.Marked);
                widget.find(".statuses .users span").text(data.Parties);

                $this.startRoom(widget);

                $.each(data.users, function(i, v) {
                    channels.push(v.ChannelClean);
                    if (widget.find("[data-channel-clean=" + v.ChannelClean + "]").length) {
                        $this.updateUser(widget, v.Channel, v.type);
                    } else {
                        $this.addUser(widget, v.Channel, v.CallerIDName, v.CallerIDNum, v.type, appType);
                    }
                });
                $.each(widget.find(".user-list tr"), function() {
                    if (jQuery.inArray( $(this).data("channel-clean"), channels ) < 0) {
                        var chan  = $(this).data("channel-clean");
                        $this.removeUser(widget, chan);
                    }
                });

                callback();
            }, function (err) {
                if (err) console.error(err.message);

            });
        }
    },
    startRoom: function(widget) {
        if(!widget.find(".conference-room.room").is(":visible")) {
            widget.find(".conference-room.room").removeClass("hidden");
            widget.find(".conference-room.no-data").addClass("hidden");
        }
    },
    endRoom: function(widget) {
        if(widget.find(".conference-room.room").is(":visible")) {
            widget.find(".conference-room.room").addClass("hidden");
            widget.find(".conference-room.no-data").removeClass("hidden");
            widget.find(".conference-room.room table").html("");
            widget.find(".lock i").addClass("fa-unlock").removeClass("fa-lock");
            widget.find(".lock span").text(_("No"));
        }
    },
    updateTalk: function(widget, channel, talking) {
        var id = channel.replace(/[^a-z0-9\-]/ig, "");
        if (talking) {
            widget.find(".user-list tr[data-channel-clean=" + id + "]").data("talking", true);
            widget.find(".user-list tr[data-channel-clean=" + id + "] .talking i").removeClass("hidden");
        } else {
            widget.find(".user-list tr[data-channel-clean=" + id + "]").data("talking", false);
            widget.find(".user-list tr[data-channel-clean=" + id + "] .talking i").addClass("hidden");
        }
    },
    updateUser: function(widget, channel, type) {
        var id = channel.replace(/[^a-z0-9\-]/ig, "");
        var admin = widget.find(".user-list tr[data-channel-clean=" + id + "]").data("admin");
        widget.find(".user-list tr[data-channel-clean=" + id + "]").data("waiting", false);
        widget.find(".user-list tr[data-channel-clean=" + id + "]").data("muted", false);

        type = (type !== null) ? type : (admin ? 'admin' : '');

        switch (type) {
            case "waiting":
                widget.find(".user-list tr[data-channel-clean=" + id + "]").data("waiting", true);
                widget.find(".user-list tr[data-channel-clean=" + id + "] .muter").addClass("hidden");
                widget.find(".user-list tr[data-channel-clean=" + id + "] .muter .mute").addClass("muted");
                widget.find(".user-list tr[data-channel-clean=" + id + "] .user .fa-user").removeClass().addClass("fa fa-user fa-stack-1x muted");
                widget.find(".user-list tr[data-channel-clean=" + id + "] .talking i").addClass("hidden");
                break;
            case "muted":
                widget.find(".user-list tr[data-channel-clean=" + id + "]").data("muted", true);
                widget.find(".user-list tr[data-channel-clean=" + id + "] .muter").removeClass("hidden");
                widget.find(".user-list tr[data-channel-clean=" + id + "] .muter .mute").addClass("muted");
                widget.find(".user-list tr[data-channel-clean=" + id + "] .user .fa-user").removeClass().addClass("fa fa-user fa-stack-1x muted");

                //track the talking state when muted as Asterisk keeps the state
                //"true" until the channel is unlocked, meaning no talk monitoring
                //is done unitl after the user is unmuted, therefore the states stay
                //the same
                if(widget.find(".user-list tr[data-channel-clean=" + id + "]").data("talking")) {
                    widget.find(".user-list tr[data-channel-clean=" + id + "] .talking i").addClass("hidden");
                    widget.find(".user-list tr[data-channel-clean=" + id + "]").data("talking",true);
                    this.wasTalking[id] = true;
                }
                break;
            case "admin":
                widget.find(".user-list tr[data-channel-clean=" + id + "]").data("admin", true);
                widget.find(".user-list tr[data-channel-clean=" + id + "] .muter").removeClass("hidden");
                widget.find(".user-list tr[data-channel-clean=" + id + "] .muter .mute").removeClass("muted");
                widget.find(".user-list tr[data-channel-clean=" + id + "] .user .fa-user").removeClass().addClass("fa fa-user fa-stack-1x admin");
                break;
            default:
                widget.find(".user-list tr[data-channel-clean=" + id + "] .muter").removeClass("hidden");
                widget.find(".user-list tr[data-channel-clean=" + id + "] .muter .mute").removeClass("muted");
                if (widget.find(".user-list tr[data-channel-clean=" + id + "]").data("admin")) {
                    widget.find(".user-list tr[data-channel-clean=" + id + "] .user .fa-user").removeClass().addClass("fa fa-user fa-stack-1x admin");
                } else {
                    widget.find(".user-list tr[data-channel-clean=" + id + "] .user .fa-user").removeClass().addClass("fa fa-user fa-stack-1x");
                }
                //Part of talking tracking
                if(typeof this.wasTalking[id] !== "undefined" && $("#" + id + " .talking i").hasClass("hidden")) {
                    widget.find(".user-list tr[data-channel-clean=" + id + "] .talking i").removeClass("hidden");
                    delete(this.wasTalking[id]);
                }
                break;
        }
    },
    addUser: function(widget, channel, cnam, cnum, type, appType) {
        var $this = this,
            kick = (appType == "app_confbridge") ? "<td><i class=\"fa fa-times kick\"></i></td>" : "",
            id = channel.replace(/[^a-z0-9\-]/ig, ""),
            displayname = '';

        // added for bringing callerid from the bridged channel. if the connected  conference channel's callerid is invalid eg:Conf: (\XXX conference room)
        //FREEPBX-14512 UCP Conference "INVITE Contact"
        var thisRegex = new RegExp(/^Conf:/i);
        if(thisRegex.test(cnam)) {
            //its call with invalid callerid So read the dialed number from channel Local/{dialed_no}@xxxx
            cnam = channel.substr(6).split('@')[0];
            cnum = _('Outbound Call');
        }
        displayName = (cnam != cnum) ? cnam + " &lt;" + cnum + "&gt;" : cnum;

        widget.find(".conference-room.room table").append(
            '<tr data-channel-clean="' + id +'"  data-admin="' + ((type == "admin") ? "true" : "false") + '" data-channel="' + encodeURIComponent(channel) + '" data-muted="'+((type == "muted") ? "true" : "false")+'" data-waiting="'+((type == "waiting") ? "true" : "false")+'" data-talking="false">' +
            '<td class="user"><span class="fa-stack"><i class="fa fa-user fa-stack-1x ' + ((type == "waiting") ? "muted" : type) + '"></i></td>' +
            '<td class="talking"><i class="fa fa-volume-up hidden"></i></td>' +
            '<td>'+ displayName + '</td>' +
            '<td><span class="fa-stack muter ' + ((type == "waiting") ? "hidden" : "") + '"><i class="fa fa-volume-off fa-stack-1x"></i><i class="fa fa-fw fa-ban fa-stack-1x mute '+((type == "muted") ? "muted" : "")+'"></i></span></td>' +
            '<td><span class="fa-stack '+((appType == "app_meetme") ? "hidden" : "")+'"><i class="fa fa-fw fa-times fa-stack-1x kick"></i></span></td>' +
            '</tr>');

        widget.find(".conference-room.room .user-list tr[data-channel-clean='"+id+"'] .kick").click(function() {
            $this.kick(widget, encodeURIComponent(channel));
        });
        widget.find(".conference-room.room .user-list tr[data-channel-clean='"+id+"'] .muter").click(function() {
            $this.toggleMute(widget, encodeURIComponent(channel));
        });
        var count = widget.find(".statuses .users span").text();
        count = parseInt(count) + 1;
        widget.find(".statuses .users span").text(count);
    },
    removeUser: function(widget, channel) {
        var id = channel.replace(/[^a-z0-9\-]/ig, "");
        widget.find(".user-list tr[data-channel-clean=" + id + "]").remove();
        if(!widget.find(".user-list tr").length) {
            this.endRoom(widget);
        }
        var count = widget.find(".statuses .users span").text();
        count = parseInt(count) - 1;
        widget.find(".statuses .users span").text(count);
    },
    sendEvent: function(key, value) {
        if (this.socket !== null && this.socket.connected) {
            this.socket.emit(key, value);
        }
    },
    toggleLock: function(widget) {
        if(widget.find(".conference-room.no-data").is(":visible")) {
            UCP.showAlert(_("Conference room is not active so it can not be locked"));
            return;
        }
        var mode = !widget.find(".conference-data").data("locked"),
            $this = this;
        if (this.socket !== null && this.socket.connected) {
            this.sendEvent("lock", {
                conference: widget.data("widget_type_id"),
                enable: mode
            });
        } else {
            $.post( UCP.ajaxUrl+"?module=conferencespro&command=lock", { conference: conference }, function( data ) {
                widget.find(".conference-data").data("locked",mode);
                if (mode) {
                    widget.find(".lock i").removeClass("fa-unlock").addClass("fa-lock");
                    widget.find(".lock span").text(_("Yes"));
                } else {
                    widget.find(".lock i").addClass("fa-unlock").removeClass("fa-lock");
                    widget.find(".lock span").text(_("No"));
                }
            });
        }
    },
    toggleMute: function(widget, channel) {
        var mode = !widget.find(".user-list tr[data-channel='" + channel + "']").data("muted"),
            conference = widget.data("widget_type_id"),
            $this = this;
        if (this.socket !== null && this.socket.connected) {
            this.sendEvent("mute", {
                conference: conference,
                channel: decodeURIComponent(channel),
                enable: mode
            });
        } else {
            var command = (mode) ? "mute" : "unmute";
            $.post( UCP.ajaxUrl+"?module=conferencespro&command="+command, { channel: decodeURIComponent(channel), conference: conference }, function( data ) {
                $this.updateUser(widget, decodeURIComponent(channel), (mode ? "muted" : null));
            });
        }
    },
    kick: function(widget, channel) {
        var $this = this;
        if (this.socket !== null && this.socket.connected) {
            this.sendEvent("kick", {
                conference: widget.data("widget_type_id"),
                channel: decodeURIComponent(channel)
            });
        } else {
            $.post( UCP.ajaxUrl+"?module=conferencespro&command=kick", { channel: decodeURIComponent(channel), conference: widget.data("widget_type_id") }, function( data ) {
                $this.removeUser(widget, decodeURIComponent(channel));
            });
        }
    },
    saveSettings: function(conference, data) {
        var $this = this;
        data.conference = conference;
        $.post( UCP.ajaxUrl+"?module=conferencespro&command=settings", data, function( data ) {
            if(data.alert == 'success'){
                $(".conferencesettings #message").text(data.message).removeClass("alert-danger");
            }
            $(".conferencesettings #message").text(data.message).addClass("alert-" + data.alert).fadeIn("fast", function() {
                $(this).delay(5000).fadeOut("fast");
            });
        });
    },
    invite: function(conference, invite, type) {
        $.post( UCP.ajaxUrl+"?module=conferencespro&command=invite", { channel: invite, conference: conference, type: type }, function( data ) {

        });
    },
    subscribe: function(conference) {
        if(this.subscribed.indexOf(conference) === -1) {
            this.sendEvent("subscribe", conference);
            this.subscribed.push(conference);
        }
    },
    unsubscribe: function(conference) {
        this.sendEvent("unsubscribe", conference);
        var index = this.subscribed.indexOf(conference);
        if(index > -1) {
            this.subscribed.splice(index, 1);
        }
    },
    disconnect: function() {
        var $this = this,
            listeners = [ "disconnect",
                "connect",
                "list",
                "lock",
                "mute",
                "join",
                "leave",
                "starting",
                "ending",
                "talking" ];
        if (this.socket !== null) {
            $.each(listeners, function(i, v) {
                $this.socket.removeAllListeners(v);
            });
            this.subscribed = [];
        }
    },
    connect: function() {
        var $this = this;
        try {
            UCP.wsconnect("conferences", function(socket) {
                if (socket === false) {
                    $this.socket = null;
                    return false;
                } else {
                    $this.socket = socket;

                    $(".grid-stack-item[data-rawname=conferencespro]").each(function() {
                        var conference = $(this).data("widget_type_id");
                        $this.subscribe(conference);
                    });

                    $this.socket.on("list", function(conf) {
                        if (conf.status) {
                            var widget = $(".grid-stack-item[data-rawname=conferencespro][data-widget_type_id='"+conf.conference+"']");
                            if(!widget.length) {
                                //TODO: unsubscribe it's not here!
                                return;
                            }

                            widget.find(".conference-data").data("locked",conf.locked);
                            if(conf.locked) {
                                widget.find(".lock i").removeClass("fa-unlock").addClass("fa-lock");
                                widget.find(".lock span").text(_("Yes"));
                            } else {
                                widget.find(".lock i").addClass("fa-unlock").removeClass("fa-lock");
                                widget.find(".lock span").text(_("No"));
                            }

                            if(Object.keys(conf.users).length) {
                                $this.startRoom(widget);
                            }

                            $.each(conf.users, function(i, u) {
                                var type = "user";
                                if( Array.isArray(u) == false) {
                                    return;
                                }
                                if (u.admin) {
                                    type = "admin";
                                } else if (u.waiting) {
                                    type = "waiting";
                                }
                                if (u.muted) {
                                    type = "muted";
                                }
                                $this.updateUser(widget, u.channel, type);
                                $this.updateTalk(widget, u.channel, u.talking);
                            });
                        }
                    });
                    $this.socket.on("mute", function(data) {
                        var widget = $(".grid-stack-item[data-rawname=conferencespro][data-widget_type_id='"+data.conference+"']");
                        if(!widget.length) {
                            //TODO: unsubscribe it's not here!
                            return;
                        }
                        $this.updateUser(widget, data.channel, (data.enabled ? "muted" : null));
                    });
                    $this.socket.on("lock", function(data) {
                        var widget = $(".grid-stack-item[data-rawname=conferencespro][data-widget_type_id='"+data.conference+"']");
                        if(!widget.length) {
                            //TODO: unsubscribe it's not here!
                            return;
                        }
                        widget.find(".conference-data").data("locked",data.enabled);
                        if (data.enabled) {
                            widget.find(".lock i").removeClass("fa-unlock").addClass("fa-lock");
                            widget.find(".lock span").text(_("Yes"));
                        } else {
                            widget.find(".lock i").addClass("fa-unlock").removeClass("fa-lock");
                            widget.find(".lock span").text(_("No"));
                        }
                    });
                    $this.socket.on("join", function(data) {
                        var widget = $(".grid-stack-item[data-rawname=conferencespro][data-widget_type_id='"+data.conference+"']");
                        if(!widget.length) {
                            //TODO: unsubscribe it's not here!
                            return;
                        }
                        $this.addUser(widget, data.channel, data.calleridname, data.calleridnum, (data.admin == "Yes" ? 'admin' : 'user'));
                        //have to ask for the list because we don't get user state on join
                        $this.sendEvent("list", data.conference);
                    });
                    $this.socket.on("leave", function(data) {
                        var widget = $(".grid-stack-item[data-rawname=conferencespro][data-widget_type_id='"+data.conference+"']");
                        if(!widget.length) {
                            //TODO: unsubscribe it's not here!
                            return;
                        }
                        $this.removeUser(widget, data.channel);
                    });
                    $this.socket.on("starting", function(data) {
                        $this.sendEvent("list", data.conference);
                    });
                    $this.socket.on("ending", function(data) {
                        var widget = $(".grid-stack-item[data-rawname=conferencespro][data-widget_type_id='"+data.conference+"']");
                        if(!widget.length) {
                            //TODO: unsubscribe it's not here!
                            return;
                        }
                    });
                    $this.socket.on("talking", function(data) {
                        var widget = $(".grid-stack-item[data-rawname=conferencespro][data-widget_type_id='"+data.conference+"']");
                        if(!widget.length) {
                            //TODO: unsubscribe it's not here!
                            return;
                        }
                        $this.updateTalk(widget, data.channel, data.enabled);
                    });
                }
            });
        }catch (err) {}
    }
});


$(document).on("post-body.widgets", function(event, widget_id, dashboard_id) {
    if(widget_id === null && typeof UCP.Modules.Conferencespro !== "undefined" && UCP.Modules.Conferencespro.socket !== null) {
        var Conferencespro = UCP.Modules.Conferencespro;
        if(UCP.Modules.Conferencespro.subscribed.length) {
            $.each(UCP.Modules.Conferencespro.subscribed, function(k,v) {
                Conferencespro.unsubscribe(v);
            });
        }
        //dashboard finished loading
        $(".grid-stack-item[data-rawname=conferencespro]").each(function() {
            var conference = $(this).data("widget_type_id");
            Conferencespro.subscribe(conference);
        });
    }
});

var ContactmanagerC = UCPMC.extend({
    init: function(UCP) {
        var cm = this;
        this.contacts = {};
        $(document).bind("staticSettingsFinished", function( event ) {
            if (cm.staticsettings.enabled) {
                cm.contacts = cm.staticsettings.contacts;
            }
        });
    },
    resize: function(widget_id) {
        $(".grid-stack-item[data-id='"+widget_id+"'] .contacts-grid").bootstrapTable('resetView',{height: $(".grid-stack-item[data-id='"+widget_id+"'] .widget-content").height()});
    },
    groupClick: function(el, widget_id) {
        $(".grid-stack-item[data-id="+widget_id+"] .group").removeClass("active");
        $(el).addClass("active");
        var group = $(el).data("group");

        if ($(el).data('readonly') || group.length === 0) {
            $(".grid-stack-item[data-id="+widget_id+"] .deletegroup").prop("disabled",true);
            $(".grid-stack-item[data-id="+widget_id+"] .addcontact").prop("disabled",true);
        } else {
            $(".grid-stack-item[data-id="+widget_id+"] .deletegroup").prop("disabled",false);
            $(".grid-stack-item[data-id="+widget_id+"] .addcontact").prop("disabled",false);
        }

        $.ajax({
            url: UCP.ajaxUrl+'?module=contactmanager&command=grid&group=' + group,
            type: "POST",
            async: false,
            success: function(data){
                $('.grid-stack-item[data-id='+widget_id+'] .contacts-grid').bootstrapTable("refreshOptions", {url: UCP.ajaxUrl+'?module=contactmanager&command=grid&group=' + group});
            }
        });
    },
    displayWidget: function(widget_id, dashboard_id) {
        var self = this;

        $(".grid-stack-item[data-id='"+widget_id+"'] .contacts-grid").one("post-body.bs.table", function() {
            setTimeout(function() {
                self.resize(widget_id);
            },250);
        });

        $(".grid-stack-item[data-id='"+widget_id+"'] .group").click(function() {
            self.groupClick(this, widget_id);
        });

        $('.grid-stack-item[data-id='+widget_id+'] .contacts-grid').on('click-row.bs.table', function (e, row, $element, field) {
            $.post(UCP.ajaxUrl, {
                module: "contactmanager",
                command: "showcontact",
                group: row.groupid,
                id: row.uid
            }, function(data) {
                if(data.status) {
                    UCP.showDialog(data.title,
                        data.body,
                        data.footer,
                        function() {
                            $("#globalModal .clickable").click(function(e) {
                                var type = $(this).data("type"),
                                    text = $(this).text(),
                                    primary = $(this).data("primary");
                                self.showActionDialog(type, text, primary);
                            });
                            $("#deletecontact").click(function() {
                                $("#deletecontact").prop("disabled",true);
                                UCP.showConfirm(_("Are you sure you wish to delete this contact?"), 'info', function() {
                                    $.post( UCP.ajaxUrl, {
                                        module: "contactmanager",
                                        command: "deletecontact",
                                        id: row.uid
                                    }, function( data ) {
                                        if (data.status) {
                                            $('.grid-stack-item[data-id='+widget_id+'] .contacts-grid').bootstrapTable("refreshOptions", {url: UCP.ajaxUrl+'?module=contactmanager&command=grid&group=' + group});
                                            UCP.closeDialog();
                                        } else {
                                            UCP.showAlert(_("Error deleting user"),'danger');
                                        }
                                    });
                                });
                            });
                            $("#editcontact").click(function() {
                                $.getJSON(UCP.ajaxUrl, {
                                    module: "contactmanager",
                                    command: "editcontactmodal",
                                    group: row.groupid,
                                    id: row.uid
                                }, function(data){
                                    if (data.status === true){
                                        UCP.showDialog(_("Edit Contact"),
                                            data.message,
                                            '<button type="button" class="btn btn-secondary" data-dismiss="modal">'+_("Close")+'</button><button id="save" type="button" class="btn btn-primary">'+ _("Save changes")+'</button>',
                                            function() {
                                                self.displayEditContact(widget_id);
                                            }
                                        );
                                    } else {
                                        UCP.showAlert(_("Error getting form"),'danger');
                                    }
                                }).always(function() {
                                }).fail(function() {
                                    UCP.showAlert(_("Error getting form"),'danger');
                                });
                            });
                        }
                    );
                }
            });
        });

        $(".grid-stack-item[data-id='"+widget_id+"'] .addgroup").click(function() {
            $.getJSON(UCP.ajaxUrl+'?module=contactmanager&command=addgroupmodal', function(data){
                if (data.status === true){
                    UCP.showDialog(_("Add Group"),
                        data.message,
                        '<button type="button" class="btn btn-secondary" data-dismiss="modal">'+_("Close")+'</button><button type="button" class="btn btn-primary" id="save">'+ _("Save changes")+'</button>',
                        function() {
                            $("#groupname").focus();
                            $('#contactmanager-addgroup').submit(function() {
                                $('#save').click();
                                return false;
                            });
                            $('#save').one('click',function() {
                                $.ajax({
                                    type: 'POST',
                                    url: UCP.ajaxUrl+'?module=contactmanager&command=addgroup',
                                    data: $('#contactmanager-addgroup').serialize(),
                                    success: function (data) {
                                        $(".grid-stack-item[data-id='"+widget_id+"'] .group-list").append('<div class="group" data-name="' + $("#groupname").val() + '" data-group="' + data.id + '" data-readonly="false"><a href="#" class="group-inner">' + $("#groupname").val() + '<span class="badge">0</span></a></div>');
                                        $(".grid-stack-item[data-id='"+widget_id+"'] .group[data-group=" + data.id + "]").click(function() {
                                            self.groupClick(this, widget_id);
                                        });
                                        UCP.closeDialog();
                                    }
                                });
                            });
                        });
                } else {
                    UCP.showDialog(_("Add Group"),_("Error getting form"),'<button type="button" class="btn btn-secondary" data-dismiss="modal">'+_("Close"));
                }
            });
        });

        $(".grid-stack-item[data-id="+widget_id+"] .deletegroup").click(function(e) {
            e.preventDefault();
            UCP.showConfirm(_("Are you sure you want to delete this group and all of it's contacts?"), 'info', function() {
                var group = $(".grid-stack-item[data-id='"+widget_id+"'] .group-list .group.active").data("group");

                $.post( UCP.ajaxUrl+"?module=contactmanager&command=deletegroup", { id: group }, function( data ) {
                    if (data.status) {
                        $(".group[data-group='']").trigger("click");
                        $(".grid-stack-item[data-id='"+widget_id+"'] .group-list .group[data-group='" + group + "']").remove();
                    }
                }).fail(function() {
                    UCP.showAlert(_("There was an error removing this group"),"danger");
                });
            });
        });

        $(".grid-stack-item[data-id="+widget_id+"] .addcontact").click(function(e) {
            e.preventDefault();

            var $this = this;

            $($this).prop("disabled",true);

            $.getJSON(UCP.ajaxUrl+'?module=contactmanager&command=addcontactmodal', function(data){
                if (data.status === true){
                    UCP.showDialog(_("Add Contact"),
                        data.message,
                        '<button type="button" class="btn btn-secondary" data-dismiss="modal">'+_("Close")+'</button><button id="save" type="button" class="btn btn-primary">'+ _("Save changes")+'</button>',
                        function() {
                            self.displayEditContact(widget_id);
                        }
                    );
                } else {
                    UCP.showAlert(_("Error getting form"),'danger');
                }
            }).always(function() {
                $($this).prop("disabled",false);
            }).fail(function() {
                UCP.showAlert(_("Error getting form"),'danger');
            });
        });
    },
    poll: function(data) {
        var cm = this;
        if (data.enabled) {
            cm.contacts = data.contacts;
        }
    },
    contactClickInitiateCallTo: function(did) {
        window.location.replace("tel:" + did);
    },
    contactClickInitiateFacetime: function(did) {
        window.location.replace("facetime:" + did);
    },
    contactClickOptions: function(type) {
        if (type != "number" || false) {
            return false;
        }
        var options = [ { text: _("Call To"), function: "contactClickInitiateCallTo", type: "phone" }];
        if (navigator.appVersion.indexOf("Mac")!=-1) {
            options.push({ text: _("Facetime"), function: "contactClickInitiateFacetime", type: "phone" });
        }
        return options;
    },
    showActionDialog: function(type, text, p) {
        var options = "", count = 0, operation = [], primary = "";
        if (typeof type === "undefined" || typeof text === "undefined" ) {
            return;
        }

        primary = (typeof p !== "undefined") ? p : "";
        if(primary.indexOf(",") !=-1) {
            var primaries = primary.split(",");
        }
        if (type == "number") {
            text = text.replace(/\D/g, "");
        }
        $.each(modules, function( index, module ) {
            if (UCP.validMethod(module, "contactClickOptions")) {
                var o = UCP.Modules[module].contactClickOptions(type), selected = "";
                if (o !== false && Array.isArray(o)) {
                    $.each(o, function(k, v) {
                        if(typeof primaries !== "undefined") {
                            if (primaries.indexOf(v.type) !=-1) {
                                if(primaries.indexOf(v.type) === 0) {
                                    options = "<option data-function='" + v.function + "' data-module='" + module + "' " + selected + ">" + v.text + "</option>" + options;
                                } else {
                                    options = options + "<option data-function='" + v.function + "' data-module='" + module + "' " + selected + ">" + v.text + "</option>";
                                }
                                v.module = module;
                                operation = v;
                                count++;
                            }
                        } else {
                            if ((typeof v.type !== "undefined") && (v.type == primary)) {
                                options = "<option data-function='" + v.function + "' data-module='" + module + "' " + selected + ">" + v.text + "</option>" + options;
                                v.module = module;
                                operation = v;
                                count++;
                            }
                        }
                    });
                }
            }
        });

        if (count === 0) {
            alert(_("There are no actions for this type"));
        } else if (count === 1) {
            if (UCP.validMethod(operation.module, operation.function)) {
                UCP.Modules[operation.module][operation.function](text);
            }
        } else if (count > 1) {
            UCP.showDialog(_("Select an Action"),
                "<select id=\"contactmanageraction\" class=\"form-control\">" + options + "</select>",
                "<button class=\"btn btn-default\" id=\"initiateaction\" style=\"margin-left: 72px;\">"+_("Initiate")+"</button>",
                function() {
                    $("#initiateaction").click(function() {
                        var func = $("#contactmanageraction option:selected").data("function"),
                            mod = $("#contactmanageraction option:selected").data("module");
                        if (UCP.validMethod(mod, func)) {
                            UCP.closeDialog(function() {
                                UCP.Modules[mod][func](text);
                            });
                        } else {
                            alert(_("Function call does not exist!"));
                        }
                    });
                }
            );
        }
    },
    displayEditContact: function(widget_id) {
        $('#globalModal input[type=checkbox][data-toggle="toggle"]:visible').bootstrapToggle();
        $("#globalModal").on("blur", "input.number-sd", function(e) {
            var orig = $(this).data("orig"),
                val = $(this).val(),
                $this = $(this),
                entry = null;

            orig = (typeof orig !== "undefined") ? orig : "";

            if(val !== "") {
                var indexes = [];
                var stop = false;
                $(".number-sd").each(function() {
                    if($(this).val() === "") {
                        return true;
                    }
                    if($.inArray(val, indexes) > -1) {
                        UCP.showAlert(_("This speed dial id conflicts with another speed dial on this page"),'warning');
                        $this.val(orig);
                        stop = true;
                        return false;
                    }
                    indexes.push($(this).val());
                });
                if(stop) {
                    return false;
                }
                $.post( UCP.ajaxUrl + "?module=contactmanager&command=checksd", {id: val, entryid: entry}, function( data ) {
                    if(!data.status) {
                        UCP.showAlert(_("This speed dial id conflicts with another contact"),'warning');
                        $this.val(orig);
                    } else {
                        $this.data("value",val);
                    }
                });
            } else {
                $this.data("value",val);
            }
        });
        $('#save').on('click',function() {
            var data = {
                id: $("#id").val(),
                displayname: $("#displayname").val(),
                fname: $("#fname").val(),
                lname: $("#lname").val(),
                title: $("#title").val(),
                company: $("#company").val(),
                numbers: [],
                xmpps: [],
                emails: [],
                websites: [],
                image:$("#contactmanager_image").val()
            };
            $("input[data-name=number]").each(function() {
                var val = $(this).val(),
                    parent = $(this).parents(".form-inline"),
                    type = parent.find("select[data-name=type]").val(),
                    sms = parent.find("input[data-name=smsflag]").is(":checked"),
                    fax = parent.find("input[data-name=faxflag]").is(":checked"),
                    locale = parent.find("select[data-name=locale]").val(),
                    flags = [],
                    speeddial = '';
                if(val === "") {
                    return true;
                }
                if(parent.find("input[data-name=numbersd]:enabled").length) {
                    speeddial = parent.find("input[data-name=numbersd]:enabled").val();
                }

                if(sms) {
                    flags.push('sms')
                }

                if(fax) {
                    flags.push('fax')
                }

                data.numbers.push({
                    number: val,
                    type: type,
                    flags: flags,
                    speeddial: speeddial,
                    locale: locale
                });
            });
            $("input[data-name=websites], input[data-name=emails], input[data-name=xmpps]").each(function() {
                var val = $(this).val(),
                    name = $(this).data("name"),
                    type = $(this).data("type");
                if(val === "") {
                    return true;
                }
                var obj = {};
                obj[type] = val;
                data[name].push(obj);
            });

            var group = $(".grid-stack-item[data-id='"+widget_id+"'] .group-list .group.active").data("group");

            var params = {
                module: "contactmanager",
                command: (data.id === "" ? "addcontact" : "updatecontact"),
                group: group,
                contact: data
            };

            $.post({
                url: UCP.ajaxUrl,
                data: params,
                success: function (data) {
                    if(data.status) {
                        $(".grid-stack-item[data-id='"+widget_id+"'] .contacts-grid").bootstrapTable("refreshOptions", {url: UCP.ajaxUrl+'?module=contactmanager&command=grid&group=' + group});
                        UCP.closeDialog();
                    } else {
                        UCP.showAlert(data.message, 'danger');
                    }
                }
            }).fail(function() {
                UCP.showAlert(_("There was an error"), 'danger');
            });
        });
        var changeSpeedDial = function() {
            var el = $(this).parents(".input-group").find(".number-sd");
            el.prop("disabled",!$(this).is(":checked"));
            if(!$(this).is(":checked")) {
                el.val("");
            } else {
                if(typeof el.data("value") !== "undefined") {
                    el.val(el.data("value"));
                }
            }
        };
        $(".enable-sd").change(changeSpeedDial);
        $(".add-additional").click(function(e) {
            e.preventDefault();
            e.stopPropagation();
            var name = $(this).data("type"),
                container = $("input[data-name="+name+"]").one().parents(".item-container").first();

            if(name === "number") {
                $('#globalModal input[data-name=smsflag], #globalModal input[data-name=faxflag]').bootstrapToggle('destroy');
            }
            var html = container.clone();
            html.find("input").val("");
            var cmlocale = navigator.language.split('-')[1];
            cmlocale = cmlocale ? cmlocale : navigator.language.split('-')[0]
            html.find("select[data-name=locale]").val(cmlocale)
            container.after(html);
            if(name === "number") {
                $('#globalModal input[data-name=smsflag], #globalModal input[data-name=faxflag]').bootstrapToggle();
            }
            $(".enable-sd").off("change");
            $(".enable-sd").change(changeSpeedDial);

        });
        $(document).on("click",".item-container .delete",function() {
            var name = $(this).data("type");
            if($("input[data-name="+name+"]").length === 1) {
                $("input[data-name="+name+"]").val("");
                if(name == "number") {
                    $("input[data-name=smsflag]").bootstrapToggle("off");
                    $("input[data-name=faxflag]").bootstrapToggle("off");
                }
            } else {
                $(this).parents(".item-container").remove();
            }

        });
        $('#contactmanager_dropzone').on('drop dragover', function (e) {
            e.preventDefault();
        });
        $('#contactmanager_dropzone').on('dragleave drop', function (e) {
            $(this).removeClass("activate");
        });
        $('#contactmanager_dropzone').on('dragover', function (e) {
            $(this).addClass("activate");
        });
        var supportedRegExp = "png|jpg|jpeg";
        $( document ).ready(function() {
            $('#contactmanager_imageupload').fileupload({
                dataType: 'json',
                dropZone: $("#contactmanager_dropzone"),
                add: function (e, data) {
                    //TODO: Need to check all supported formats
                    var sup = "\.("+supportedRegExp+")$",
                        patt = new RegExp(sup),
                        submit = true;
                    $.each(data.files, function(k, v) {
                        if(!patt.test(v.name.toLowerCase())) {
                            submit = false;
                            alert(_("Unsupported file type"));
                            return false;
                        }
                    });
                    if(submit) {
                        $("#contactmanager_upload-progress .progress-bar").addClass("progress-bar-striped active");
                        data.submit();
                    }
                },
                drop: function () {
                    $("#contactmanager_upload-progress .progress-bar").css("width", "0%");
                },
                dragover: function (e, data) {
                },
                change: function (e, data) {
                },
                done: function (e, data) {
                    $("#contactmanager_upload-progress .progress-bar").removeClass("progress-bar-striped active");
                    $("#contactmanager_upload-progress .progress-bar").css("width", "0%");

                    if(data.result.status) {
                        $("#contactmanager_dropzone img").attr("src",data.result.url);
                        $("#contactmanager_image").val(data.result.filename);
                        $("#contactmanager_dropzone img").removeClass("hidden");
                        $("#contactmanager_del-image").removeClass("hidden");
                        $("#contactmanager_gravatar").prop('checked', false);
                    } else {
                        alert(data.result.message);
                    }
                },
                progressall: function (e, data) {
                    var progress = parseInt(data.loaded / data.total * 100, 10);
                    $("#contactmanager_upload-progress .progress-bar").css("width", progress+"%");
                },
                fail: function (e, data) {
                },
                always: function (e, data) {
                }
            });

            $("#contactmanager_del-image").click(function(e) {
                e.preventDefault();
                e.stopPropagation();
                var grouptype = 'external';
                $.post( "?quietmode=1&module=Contactmanager&type=contact&command=delimage", {id: $("#id").val(), grouptype: grouptype, img: $("#contactmanager_image").val()}, function( data ) {
                    if(data.status) {
                        $("#contactmanager_image").val("");
                        $("#contactmanager_dropzone img").addClass("hidden");
                        $("#contactmanager_dropzone img").attr("src","");
                        $("#contactmanager_del-image").addClass("hidden");
                        $("#contactmanager_gravatar").prop('checked', false);
                    }
                });
            });

            $("#contactmanager_gravatar").change(function() {
                if($(this).is(":checked")) {
                    var grouptype = 'external';
                    if($("#email").val() === "") {
                        alert(_("No email defined"));
                        $("#contactmanager_gravatar").prop('checked', false);
                        return;
                    }
                    var t = $("label[for=contactmanager_gravatar]").text();
                    $("label[for=contactmanager_gravatar]").text(_("Loading..."));
                    $.post( "?quietmode=1&module=Contactmanager&type=contact&command=getgravatar", {id: $("#id").val(), grouptype: grouptype, email: $("input[data-name=emails]:visible").one().val()}, function( data ) {
                        $("label[for=contactmanager_gravatar]").text(t);
                        if(data.status) {
                            $("#contactmanager_dropzone img").data("oldsrc",$("#dropzone img").attr("src"));
                            $("#contactmanager_dropzone img").attr("src",data.url);
                            $("#contactmanager_image").data("old",$("#image").val());
                            $("#contactmanager_image").val(data.filename);
                            $("#contactmanager_dropzone img").removeClass("hidden");
                            $("#contactmanager_del-image").removeClass("hidden");
                        } else {
                            alert(data.message);
                            $("#contactmanager_gravatar").prop('checked', false);
                        }
                    });
                } else {
                    var oldsrc = $("#contactmanager_dropzone img").data("oldsrc");
                    if(typeof oldsrc !== "undefined" && oldsrc !== "") {
                        $("#contactmanager_dropzone img").attr("src",oldsrc);
                        $("#contactmanager_image").val($("#image").data("old"));
                    } else {
                        $("#contactmanager_image").val("");
                        $("#contactmanager_dropzone img").addClass("hidden");
                        $("#contactmanager_dropzone img").attr("src","");
                        $("#contactmanager_del-image").addClass("hidden");
                    }
                }
            });
        });
    },
    /**
     * Lookup a contact from the directory
     * @param  {string} search The string to look for
     * @param  {object} regExp The regular expression object (make sure /g is on the end)
     * @return {string} replaced value
     */
    lookup: function(search, regExp) {
        var o = this.recursiveObjectSearch(search, this.contacts), contact;
        if (o !== false) {
            contact = this.contacts[o[0]];
            if (contact !== false) {
                contact.ignore = o[0];
                contact.key = o[o.length - 1];
            }
            return contact;
        }
        return false;
    },
    recursiveObjectSearch: function(search, haystack, key, strict, stack) {
        var k, o, pattern = new RegExp(search);
        for (k in haystack) {
            if (haystack.hasOwnProperty(k) && haystack[k] !== null) {
                if (typeof stack === "undefined") {
                    stack = [];
                }
                if (typeof haystack[k] === "object") {
                    stack.push(k);
                    o = this.recursiveObjectSearch(search, haystack[k], key, strict, stack);
                    if (o !== false) {
                        return stack;
                    } else {
                        stack = [];
                    }
                } else if (pattern.test(haystack[k])) {
                    stack.push(k);
                    return stack;
                }
            }
        }
        return false;
    }
});

var DonotdisturbC = UCPMC.extend({
    init: function(){
        this.stopPropagation = {};
    },
    prepoll: function() {
        var exts = [];
        $(".grid-stack-item[data-rawname=donotdisturb]").each(function() {
            exts.push($(this).data("widget_type_id"));
        });
        return exts;
    },
    poll: function(data) {
        var self = this;
        $.each(data.states, function(ext,state) {
            if(typeof self.stopPropagation[ext] !== "undefined" && self.stopPropagation[ext]) {
                return true;
            }
            var widget = $(".grid-stack-item[data-rawname=donotdisturb][data-widget_type_id='"+ext+"']:visible input[name='dndenable']"),
                sidebar = $(".widget-extra-menu[data-module='donotdisturb'][data-widget_type_id='"+ext+"']:visible input[name='dndenable']"),
                sstate = state ? "on" : "off";
            if(widget.length && (widget.is(":checked") !== state)) {
                self.stopPropagation[ext] = true;
                widget.bootstrapToggle(sstate);
                self.stopPropagation[ext] = false;
            } else if(sidebar.length && (sidebar.is(":checked") !== state)) {
                self.stopPropagation[ext] = true;
                sidebar.bootstrapToggle(sstate);
                self.stopPropagation[ext] = false;
            }
        });
    },
    displayWidget: function(widget_id,dashboard_id) {
        var self = this;
        $(".grid-stack-item[data-id='"+widget_id+"'][data-rawname=donotdisturb] .widget-content input[name='dndenable']").change(function() {
            var extension = $(".grid-stack-item[data-id='"+widget_id+"'][data-rawname=donotdisturb]").data("widget_type_id"),
                sidebar = $(".widget-extra-menu[data-module='donotdisturb'][data-widget_type_id='"+extension+"']:visible input[name='dndenable']"),
                checked = $(this).is(':checked'),
                name = $(this).prop('name');
            if(sidebar.length && sidebar.is(":checked") !== checked) {
                var state = checked ? "on" : "off";
                sidebar.bootstrapToggle(state);
            }
            self.saveSettings(extension, {enable: checked});
        });
    },
    saveSettings: function(extension, data, callback) {
        var self = this;
        data.ext = extension;
        data.module = "donotdisturb";
        data.command = "enable";
        this.stopPropagation[extension] = true;
        $.post( UCP.ajaxUrl, data, callback).always(function() {
            self.stopPropagation[extension] = false;
        });
    },
    displaySimpleWidget: function(widget_id) {
        var self = this;
        $(".widget-extra-menu[data-id='"+widget_id+"'] input[name='dndenable']").change(function(e) {
            var extension = $(".widget-extra-menu[data-id='"+widget_id+"']").data("widget_type_id"),
                checked = $(this).is(':checked'),
                name = $(this).prop('name'),
                el = $(".grid-stack-item[data-rawname=donotdisturb][data-widget_type_id='"+extension+"']:visible input[name='dndenable']");

            if(el.length) {
                if(el.is(":checked") !== checked) {
                    var state = checked ? "on" : "off";
                    el.bootstrapToggle(state);
                }
            } else {
                self.saveSettings(extension, {enable: checked});
            }
        });
    }
});

var EndpointC = UCPMC.extend({
    init: function() {

    },
    poll: function(data) {

    },
    displayWidgetSettings: function(widget_id, dashboard_id) {
        //Below is to handle sortable on our ajax calls.
        var EndpointSortable = function() {
            var hidden, result;
            hidden = void 0;
            result = void 0;
            if ($("#widget_settings .modal-body ul.sortable").length <= 0) {
                return true;
            }
            $("#widget_settings .modal-body ul.sortable").sortable({
                update: function(event, ui) {
                    var test;
                    test = void 0;
                    var result = [];

                    //Can't use sortable('toArray') here
                    $(this).find('li').each(function(i, el){
                        result.push($(el).attr('id'));
                    });

                    test = result[0].split("_"[0]);
                    //model_keytype_order
                    hidden = test[0] + "_" + test[1] + "_order";

                    $("input[name=" + hidden + "]").val(result);

                }
            });
        };

        EndpointSortable();

        $("#widget_settings .modal-body a.info").each(function() {
            $(this).after("<span class=\"help\"><i class=\"fa fa-question-circle\" data-placement=\"bottom\"  data-toggle=\"tooltip\" title=\""+$(this).find("span").html()+"\"></i></span>");
            $(this).find("span").remove();
            $(this).replaceWith($(this).html());
        });

        $('#widget_settings .modal-body [data-toggle="tooltip"]').tooltip()

        $("#widget_settings .modal-body .horDropDown").change(function() {
            var name = $(this).prop('name');
            var length = name.length;
            name = name.substr(0, length - 5);
            var txt = $(this).find("option:selected").text();
            var lTxt = txt.length;
            switch($(this).find("option:selected").text()){
                case 'REST-Apps':
                case 'REST-Call Flow':
                case 'REST-Call Forward':
                case 'REST-Conference':
                case 'REST-Contacts':
                case 'REST-DND':
                case 'REST-Follow Me':
                case 'REST-Login':
                case 'REST-Parking':
                case 'REST-Presence':
                case 'REST-Queues':
                case 'REST-Queue Agent':
                case 'REST-Time Conditions':
                case 'REST-Transfer VM':
                case 'REST-Voicemail':
                    txt = txt.substr(5, lTxt);
                    $("#" + name + 'label').val(txt);
                    break;

                default:
                    $("#" + name + 'label').val(txt);
                    break;
            }
        });

        $("#widget_settings .modal-body .xmlDropDown").change(function() {
            var name = $(this).prop('name');
            var length = name.length;
            name = name.substr(0, length - 3);
            var txt = $(this).find("option:selected").text();
            var lTxt = txt.length;
            txt = txt.substr(5, lTxt);
            switch($(this).find("option:selected").text()){
                case 'REST-Apps':
                case 'REST-Call Flow':
                case 'REST-Call Forward':
                case 'REST-Conference':
                case 'REST-Contacts':
                case 'REST-DND':
                case 'REST-Follow Me':
                case 'REST-Login':
                case 'REST-Parking':
                case 'REST-Presence':
                case 'REST-Queues':
                case 'REST-Queue Agent':
                case 'REST-Time Conditions':
                case 'REST-Transfer VM':
                case 'REST-Voicemail':
                    $("#" + name + 'label').val(txt);
                    break;

                default:
                    break;
            }
        });

        $("#widget_settings .modal-body .saveTemplate").click(function(event) {
            event.preventDefault();
            event.stopPropagation();

            var e = document.getElementById("task");
            var task = e.options[e.selectedIndex].value;

            var data = $("#widget_settings .modal-body form");

            var formData = {};
            data.serializeArray().forEach(function(x) {
                //For blf keys, the ucp gui is saving the state key name with [] at the end.
                //This ends up causing problems, and will be stripped:
                //ex. S700_linekeys_2_state[] = 'Audio '
                //Also, the state value comes in as a string, but is expected to be an array
                //in the POST, which can have up to 2 items, ex. ['Audio ', 'Visual ']
                if (x.name.match(/_linekeys_/) && x.name.match(/_state\[\]$/)) {
                    x.name = x.name.replace(/\[\]$/, '');
                    if (formData[x.name]) {
                        formData[x.name].push(x.value);
                    } else {
                        formData[x.name] = new Array(x.value);
                    }
                } else {
                    formData[x.name] = x.value;
                }
            });

            //save not needed, because we always save, option is just for looks
            if (task == 'rebuild') {
                formData['rebuild'] = "1";
            }
            if (task == 'restart') {
                formData['rebuild'] = "1";
                formData['restart'] = "1";
            }
            if (task == 'reset') {
                formData['reset'] = "1";
            }
            $.post( UCP.ajaxUrl+"?module=endpoint&command=savesettings", { data : JSON.stringify(formData) } , function( data ) {
                if (data.status) {
                    $("#widget_settings").modal('toggle');
                    return true;
                } else {
                    return false;
                }
            });
        });

        $("#widget_settings .modal-body .keyType").change(function() {
            var name = $(this).prop('name'),
                length = name.length,
                secname = name.substr(8, length);
            $(".hideKeys").hide();
            if($(this).is(":checked")) {
                $("#" + secname).show();
            }
            //someone should have just used a radio instead of a checkbox
            $("#widget_settings .modal-body .keyType").each(function() {
                if($(this).prop('name') !== name) {
                    $(this).prop("checked",false);
                }
            });
        });

        $("#widget_settings .modal-body .hkeyType").change(function() {
            var name = $(this).prop('name');
            $(".hideHorSoftKeys").hide();
            if($(this).is(":checked")) {
                $("." + name).show();
            }
            //someone should have just used a radio instead of a checkbox
            $("#widget_settings .modal-body .hkeyType").each(function() {
                if($(this).prop('name') !== name) {
                    $(this).prop("checked",false);
                }
            });
        });

        $("#widget_settings .modal-body .type").change(function() {
            var name = $(this).prop('name');
            var length = name.length;
            name = name.substr(0, length - 4);

            if($("#" + name + 'acct').val() === ''){
                $("#" + name + 'acct').val('account1');
            } else {
                if($(this).find("option:selected").text() == 'Blank'){
                    $("#" + name + 'acct').val('');
                    $("#" + name + 'label').val('');
                    $("#" + name + 'value').val('');
                }
            }


            switch($(this).find("option:selected").text()){
                //line keys first
                case 'Line':
                    $("." + name + 'value').hide();
                    $("." + name + 'valueFill').show();
                    $("." + name + 'label').hide();
                    $("." + name + 'labelFill').show();
                    $("#" + name + 'xml').hide();
                    $("." + name + 'state').hide();
                    break;

                //now xml-api
                case 'XML-API':
                    $("#" + name + 'xml').show();
                    $("." + name + 'value').show();
                    $("#" + name + 'value').hide();
                    $("." + name + 'valueFill').hide();
                    $("." + name + 'label').show();
                    $("." + name + 'labelFill').hide();
                    $("." + name + 'state').hide();
                    break;

                //now park
                case 'Call Park':
                    $("#" + name + 'park').show();
                    $("#" + name + 'xml').hide();
                    $("." + name + 'value').hide();
                    $("#" + name + 'value').hide();
                    $("." + name + 'valueFill').hide();
                    $("." + name + 'label').show();
                    $("." + name + 'labelFill').hide();
                    $("." + name + 'state').hide();
                    break;

                case 'Voicemail':
                case 'Intercom':
                case 'DND':
                case 'Record':
                case 'LDAP':
                    $("#" + name + 'park').hide();
                    $("#" + name + 'xml').hide();
                    $("." + name + 'value').hide();
                    $("#" + name + 'value').hide();
                    $("." + name + 'valueFill').show();
                    $("#" + name + 'label').val($(this).find("option:selected").text());
                    $("." + name + 'labelFill').hide();
                    $("." + name + 'state').hide();
                    break;

                case 'BLF':
                    $("." + name + 'state').show();
                    $("." + name + 'value').show();
                    $("." + name + 'valueFill').hide();
                    $("." + name + 'label').show();
                    $("." + name + 'labelFill').hide();
                    break;

                default:
                    $("#" + name + 'xml').hide();
                    $("#" + name + 'value').show();
                    $("." + name + 'value').show();
                    $("." + name + 'valueFill').hide();
                    $("." + name + 'label').show();
                    $("." + name + 'labelFill').hide();
                    $("#" + name + 'park').hide();
                    $("." + name + 'state').hide();
                    break;
            }
        });
    },
    validatePass: function(passInfo){
        if (passInfo.field.val() === undefined) {
            return;
        }
        if (passInfo) {
            //it's NOT valid
            if (passInfo.field.val().length > 0) {
                if(passInfo.field.val().length <6){
                    passInfo.field.addClass("globalError");
                    passInfo.error.text(passInfo.name + " Password MUST be at least 6 characters");
                    passInfo.error.addClass("globalError");
                    return false;
                } else { //it's valid
                    passInfo.field.removeClass("globalError");
                    passInfo.error.text(" ");
                    passInfo.error.removeClass("globalError");
                    return true;
                }
            }
        }
    }
});

$(document).ready(function() {
    //for admin view on extension mapping
    $(".saveAdmin").click(function(event) {
        event.preventDefault();
        event.stopPropagation();

        var e = document.getElementById("taskAdmin");
        var task = e.options[e.selectedIndex].value;
        var data = $('.saveAdminForm').serialize();

        //save not needed, because we always save, option is just for looks
        data = (task == "rebuild") ? data + "&rebuild=1":data;
        data = (task == "restart") ? data + "&rebuild=1&restart=1":data;
        data = (task == "reset") ? data + "&reset=1":data;

        $.post( endpointBaseAjaxUrl + "&quietmode=1&command=savesettings", data, function( data ) {
            if (data.status) {
                location.reload(true);
                return true;
            } else {
                location.reload(true);
                return false;
            }
        });
    });

    //uncheck all boxes for keytypes
    $(document).on('change', '.keyType', function() {
        var box = $(this).attr('name');
        $('.keyType').prop("checked", false);
        $('#' + box).prop("checked", true);
    });
    //uncheck all boxes for horizontal states
    $(document).on('change', '.hkeyType', function() {
        var box = $(this).attr('name');
        $('.hkeyType').prop("checked", false);
        $('#' + box).prop("checked", true);
    });

    //show/hide boxes for horizontal states
    $(document).on('change', '.hkeyType', function() {
        var box = $(this).attr('name');
        $('.hideHorSoftKeys').hide();
        $('.' + box).show();
    });

    //show/hide boxes for algo 8128 mode selection
    $(document).on('change', '.mode', function() {
        $('.modeNotify').hide();
        $('.modeMessage').hide();
        $('.modeRing').hide();
        var box = $(this).attr('id');
        $('.' + box).show();
        //console.log($(this).attr('id'));
    });

    $(document).on('change', '.type', function() {
        var name = $(this).prop('name');
        var length = name.length;
        name = name.substr(0, length - 4);

        if($("#" + name + 'acct').val() == ''){
            $("#" + name + 'acct').val('account1')
        } else {
            if($(this).find("option:selected").text() == 'Blank'){
                $("#" + name + 'acct').val('');
                $("#" + name + 'label').val('');
                $("#" + name + 'value').val('');
            }
        }


        switch($(this).find("option:selected").text()){
            //line keys first
            case 'Line':
                $("." + name + 'value').hide();
                $("." + name + 'valueFill').show();
                $("." + name + 'label').hide();
                $("." + name + 'labelFill').show();
                $("#" + name + 'xml').hide();
                $("."+name+'state').hide();
                break;
            //now xml-api
            case 'XML-API':
                $("#" + name + 'xml').show();
                $("." + name + 'value').show();
                $("#" + name + 'value').hide();
                $("." + name + 'valueFill').hide();
                $("." + name + 'label').show();
                $("." + name + 'labelFill').hide();
                $("."+name+'state').hide();
                break;
            //now park
            case 'Call Park':
                $("#" + name + 'park').show();
                $("#" + name + 'xml').hide();
                $("." + name + 'value').hide();
                $("#" + name + 'value').hide();
                $("." + name + 'valueFill').hide();
                $("." + name + 'label').show();
                $("." + name + 'labelFill').hide();
                $("."+name+'state').hide();
                break;
            case 'Voicemail':
            case 'Intercom':
            case 'DND':
            case 'Record':
                $("#" + name + 'park').hide();
                $("#" + name + 'xml').hide();
                $("." + name + 'value').hide();
                $("#" + name + 'value').hide();
                $("." + name + 'valueFill').show();
                $("#" + name + 'label').val($(this).find("option:selected").text());
                $("." + name + 'labelFill').hide();
                $("."+name+'state').hide();
                break;
            case 'BLF':
                $("."+name+'state').show();
                $("#" + name + 'xml').hide();
                $("#" + name + 'value').show();
                $("." + name + 'value').show();
                $("." + name + 'valueFill').hide();
                $("." + name + 'label').show();
                $("." + name + 'labelFill').hide();
                $("#" + name + 'park').hide();

                break;
            default:
                $("#" + name + 'xml').hide();
                $("#" + name + 'value').show();
                $("." + name + 'value').show();
                $("." + name + 'valueFill').hide();
                $("." + name + 'label').show();
                $("." + name + 'labelFill').hide();
                $("#" + name + 'park').hide();
                $("."+name+'state').hide();
                break;
        }
    });
    $(document).on('change', '.xmlDropDown', function() {
        var name = $(this).prop('name');
        var length = name.length;
        name = name.substr(0, length - 3);
        var txt = $(this).find("option:selected").text();
        var lTxt = txt.length;
        txt = txt.substr(5, lTxt);
        switch($(this).find("option:selected").text()){
            case 'REST-Apps':
            case 'REST-Call Flow':
            case 'REST-Call Forward':
            case 'REST-Conference':
            case 'REST-Contacts':
            case 'REST-DND':
            case 'REST-Follow Me':
            case 'REST-Login':
            case 'REST-Parking':
            case 'REST-Presence':
            case 'REST-Queues':
            case 'REST-Queue Agent':
            case 'REST-Time Conditions':
            case 'REST-Transfer VM':
            case 'REST-SPM':
            case 'REST-Voicemail':
                $("#" + name + 'label').val(txt);
                break;

            default:
                break;
        }
    });

    $(document).on('click', '.blfAlert, .none', function(e){
        var clickedInput = $(this);
        var parent = $(this).parent();
        if (clickedInput.hasClass('none')) {
            var allChildInputs = parent.children('input.blfAlert');
        } else {
            var allChildInputs = parent.children('input.none');
        }
        allChildInputs.each(function(k,v) {
            $(this).prop('checked', false);
        });
    });


    //for hor states
    $(document).on('change', '.horDropDown', function() {
        var name = $(this).prop('name');
        var length = name.length;
        name = name.substr(0, length - 5);
        var txt = $(this).find("option:selected").text();
        var lTxt = txt.length;
        console.log(name);
        switch($(this).find("option:selected").text()){
            case 'REST-Apps':
            case 'REST-Call Flow':
            case 'REST-Call Forward':
            case 'REST-Conference':
            case 'REST-Contacts':
            case 'REST-DND':
            case 'REST-Follow Me':
            case 'REST-Login':
            case 'REST-Parking':
            case 'REST-Presence':
            case 'REST-Queues':
            case 'REST-Queue Agent':
            case 'REST-Time Conditions':
            case 'REST-Transfer VM':
            case 'REST-SPM':
            case 'REST-Voicemail':
                txt = txt.substr(5, lTxt);
                $("#" + name + 'label').val(txt);
                break;

            default:
                $("#" + name + 'label').val(txt);
                break;
        }
    });
});

//$("#fax-grid").bootstrapTable('showRow', {index: 1444166808988, isIdField: true})
function faxpro_get_dest_from_initiate(){
    /*
		Get the destionation number from contact Widget.
	*/
    if(typeof did_init === "undefined"){
        return null;
    }
    else{
        return did_init;
    }
}

var FaxproC = UCPMC.extend({
    init: function() {
        this.forwardID = null;
        this.initalized = false;
        this.faxData = { files: [] };
        this.folderCounts = {};
    },
    resize: function(widget_id) {
        $(".grid-stack-item[data-id='"+widget_id+"'] .fax-grid").bootstrapTable('resetView',{height: $(".grid-stack-item[data-id='"+widget_id+"'] .widget-content").height()});
        //$(".grid-stack-item[data-id='"+widget_id+"'] .fixed-table-container").css("max-height",$(".grid-stack-item[data-id='"+widget_id+"'] .widget-content").height());
    },
    saveSettings: function() {
        var data = {};
        $("#widget_settings input[type!=checkbox]").each(function( index ) {
            data[$(this).prop("name")] = $(this).val();
        });
        $("#widget_settings select").each(function( index ) {
            data[$(this).prop("name")] = $(this).val();
        });
        $.post( UCP.ajaxUrl+"?module=faxpro&command=save", data, function( data ) {
            $("#message").addClass("alert-success").text("Saved Settings").fadeIn("slow", function(event) {
                setTimeout(function() { $("#message").fadeOut("slow"); }, 2000);
            });
        });
    },
    displayWidgetSettings: function(widget_id, dashboard_id) {
        var $this = this,
            extension = $("div[data-id='"+widget_id+"']").data("widget_type_id");

        $('#widget_settings .widget-settings-content input[type!=checkbox]').change(function() {
            $(this).one("blur",function() {
                $this.saveSettings();
            });
        });
        $('#widget_settings .widget-settings-content select').change(function() {
            $this.saveSettings();
        });

        $('#widget_settings .widget-settings-content input[type=checkbox]').change(function() {
            Cookies.remove('fax-refresh-'+extension, {path: ''});
            if($(this).is(":checked")) {
                Cookies.set('fax-refresh-'+extension, 1);
            } else {
                Cookies.set('fax-refresh-'+extension, 0);
            }
        });
        if((typeof Cookies.get('fax-refresh-'+extension) === "undefined" && (typeof Cookies.get('fax-refresh-'+extension) === "undefined" || Cookies.get('fax-refresh-'+extension) == 1)) || Cookies.get('fax-refresh-'+extension) == 1) {
            $("#widget_settings .widget-settings-content input[id=fax-refresh]").prop("checked",true);
        } else {
            $("#widget_settings .widget-settings-content input[id=fax-refresh]").prop("checked",false);
        }
        $("#widget_settings .widget-settings-content input[id=fax-refresh]").bootstrapToggle('destroy');
        $("#widget_settings .widget-settings-content input[id=fax-refresh]").bootstrapToggle({
            on: _("Enable"),
            off: _("Disable")
        });
    },
    displayWidget: function(widget_id, dashboard_id) {
        var $this = this,
            extension = $(".grid-stack-item[data-rawname=faxpro][data-id='"+widget_id+"']").data("widget_type_id");

        $(".grid-stack-item[data-id='"+widget_id+"'] .voicemail-grid").one("post-body.bs.table", function() {
            setTimeout(function() {
                $this.resize(widget_id);
            },250);
        });

        $(".grid-stack-item[data-id='"+widget_id+"'] .fax-grid").on("post-body.bs.table", function()  {
            $(".grid-stack-item[data-id='"+widget_id+"'] .fax-grid .showFax").click(function() {
                $this.showPDF($(this).data("id"));
            });
            $(".grid-stack-item[data-id='"+widget_id+"'] .fax-grid .forwardFax").click(function() {
                $this.forward($(this).data("id"), $(this).data("dest"));
            });
            $(".grid-stack-item[data-id='"+widget_id+"'] .fax-grid .stopFax").click(function() {
                var id = $(this).data("id");
                $this.stopFax(id, function(data) {
                    if(data.status) {
                        $(".grid-stack-item[data-rawname=faxpro][data-id='"+widget_id+"'] .fax-grid").bootstrapTable('hideRow', {index: id, isIdField: true});
                        //$this.updateFolderCount("out","-",1);
                    }
                });
            });
            $(".grid-stack-item[data-id='"+widget_id+"'] .fax-grid .deleteFax").click(function() {
                var id = $(this).data("id");
                $this.deleteFax(id, function(data) {
                    if(data.status) {
                        $(".grid-stack-item[data-rawname=faxpro][data-id='"+widget_id+"'] .fax-grid").bootstrapTable('hideRow', {index: id, isIdField: true});
                        //$this.updateFolderCount("delete","-",1);
                    }
                });
            });
        });

        $(".grid-stack-item[data-rawname=faxpro][data-id='"+widget_id+"'] .folder").click(function() {
            $(".grid-stack-item[data-rawname=faxpro][data-id='"+widget_id+"'] .folder").removeClass("active");
            $(this).addClass("active");
            folder = $(this).data("folder");
            if(folder == 'out' || folder == 'failed' || folder == 'sent') {
                $(".grid-stack-item[data-rawname=faxpro][data-id='"+widget_id+"'] .fax-grid").bootstrapTable('showColumn','dest');
                $(".grid-stack-item[data-rawname=faxpro][data-id='"+widget_id+"'] .fax-grid").bootstrapTable('hideColumn','callid');
            } else {
                $(".grid-stack-item[data-rawname=faxpro][data-id='"+widget_id+"'] .fax-grid").bootstrapTable('hideColumn','dest');
                $(".grid-stack-item[data-rawname=faxpro][data-id='"+widget_id+"'] .fax-grid").bootstrapTable('showColumn','callid');
            }
            $(".grid-stack-item[data-rawname=faxpro][data-id='"+widget_id+"'] .fax-grid").bootstrapTable('refreshOptions',{
                url: UCP.ajaxUrl+'?module=faxpro&command=grid&folder='+folder+'&ext='+extension
            });
        });

        $(".grid-stack-item[data-rawname=faxpro][data-id='"+widget_id+"'] .fax-grid").on("check.bs.table uncheck.bs.table check-all.bs.table uncheck-all.bs.table", function () {
            var sel = $(this).bootstrapTable('getAllSelections'),
                dis = true;
            if(sel.length) {
                dis = false;
            }
            $(".grid-stack-item[data-rawname=faxpro][data-id='"+widget_id+"'] .delete-selection").prop("disabled",dis);
            //$("#forward-selection").prop("disabled",dis);
        });

        $(".grid-stack-item[data-rawname=faxpro][data-id='"+widget_id+"'] .delete-selection").click(function() {
            UCP.showConfirm(_("Are you sure you wish to delete these faxes?"),'info',function() {
                var sel = $(".grid-stack-item[data-rawname=faxpro][data-id='"+widget_id+"'] .fax-grid").bootstrapTable('getAllSelections');
                $.each(sel, function(i, v){
                    $this.deleteFax(v.faxid, function(data) {
                        if(data.status) {
                            $(".grid-stack-item[data-rawname=faxpro][data-id='"+widget_id+"'] .fax-grid").bootstrapTable('hideRow', {index: v.faxid, isIdField: true});
                        }
                    });
                });
                $(".grid-stack-item[data-rawname=faxpro][data-id='"+widget_id+"'] .delete-selection").prop("disabled",true);
            });
        });

        $(".grid-stack-item[data-rawname=faxpro][data-id='"+widget_id+"'] .send-fax").click(function() {
            UCP.showDialog(_("Send Fax"),UCP.Modules.Widgets.activateWidgetLoading(),'<button id="send-btn" class="btn btn-default">'+_('Send')+'</button>',function() {
                $.post( UCP.ajaxUrl+"?module=faxpro&command=senddialog", { extension: extension }, function( data ) {
                    $("#globalModal .modal-body").html(data.html);
                    $("#globalModal #coversheet").bootstrapToggle({
                        on: _("On"),
                        off: _("Off")
                    });
                    var initalDropMessage = $("#globalModal .faxsend .filedrop .message").html();
                    $("#globalModal .faxsend #coversheet").change(function(event) {
                        if ($(this).is(":checked") && !$(".faxsend .extras").is(":visible")) {
                            $(".faxsend .extras").removeClass("hidden");
                        } else if ($(".faxsend .extras").is(":visible")) {
                            $(".faxsend .extras").addClass("hidden");
                        }
                    });
                    var fq = Cookies.get("faxquality");
                    if(typeof fq !== "undefined") {
                        $("#globalModal .faxsend #faxresolution").val(fq);
                    }
                    $("#globalModal .faxsend #faxresolution").change(function() {
                        Cookies.set("faxquality",$(this).val());
                    });
                    $("#globalModal .faxsend input[type=\"file\"]").fileupload({
                        url: UCP.ajaxUrl + "?module=faxpro&command=upload",
                        dropZone: $(".faxsend .filedrop"),
                        dataType: "json",
                        add: function(e, data) {
                            var badFile = null;
                            $.each(data.files, function(i, v) {
                                if(v.size > maxFileSize.size) {
                                    badFile = v;
                                    return false;
                                }
                            });
                            if(badFile === null) {
                                $("#globalModal .faxsend .filedrop .message").text(_("Uploading..."));
                                data.submit();
                            } else {
                                UCP.showAlert(sprintf(_("File was too large. Please reduce the file size or increase %s"), maxFileSize.type),'warning');
                                data.abort();
                            }
                        },
                        done: function(e, data) {
                            if (data.result.status) {
                                var html = "<li id=\"attachment-" + data.result.id + "\" class=\"list-group-item attachment\" data-filename=\"" + data.result.localfilename + "\">" +
                                    "<div>" + data.result.filename + " <div class='icons'>" +
                                    "<a target='_blank' href='"+UCP.ajaxUrl+"?module=faxpro&command=viewtemp&faxid=" + data.result.localfilename + "'><i class=\"fa fa-file-pdf-o\"></i></a>" +
                                    "<a onclick=\"UCP.Modules.Faxpro.deleteAttachment('" + data.result.id + "')\"><i class=\"fa fa-trash-o\"></i><a>" +
                                    "</div></div></li>";
                                $("#globalModal .files .list-group").append(html);
                                $("#globalModal .files").removeClass("hidden");
                                $("#globalModal .faxsend .filedrop .pbar").css("width", "0%");
                                $("#globalModal .faxsend .filedrop .message").html(initalDropMessage);
                                $this.faxData.files.push(data.result.localfilename);
                            } else {
                                $("#globalModal .faxsend .filedrop .pbar").css("width", "0%");
                                $("#globalModal .faxsend .filedrop .message").text(data.result.message);
                            }
                        },
                        progressall: function(e, data) {
                            var progress = parseInt(data.loaded / data.total * 100, 10);
                            $("#globalModal .faxsend .filedrop .pbar").css("width", progress + "%");
                        },
                        drop: function(e, data) {
                            $("#globalModal .faxsend .filedrop").removeClass("hover");
                        },
                        submit: function(e, data) {
                            var $this = $(this);
                            data.formData = { test: "123" };
                            $this.fileupload("send", data);
                            return false;
                        }
                    });

                    $("#globalModal .faxsend .filedrop").on("dragover", function(event) {
                        if (event.preventDefault) {
                            event.preventDefault(); // Necessary. Allows us to drop.
                        }
                        $(this).addClass("hover");
                    });
                    $("#globalModal .faxsend .filedrop").on("dragleave", function(event) {
                        $(this).removeClass("hover");
                    });
                    $("#globalModal .faxsend #msg").bind("input propertychange", function() {
                        var max = 1340;
                        $("#globalModal #msg-left").text(max - $(this).val().length);
                        if ((max - $(this).val().length) < 0) {
                            $("#globalModal #msg-left").addClass("red");
                        } else {
                            $("#globalModal #msg-left").removeClass("red");
                        }
                    });
                    $("#globalModal #send-btn").click(function() {
                        $this.sendFax();
                    });
                });
            });
        });
    },
    contactClickOptions: function(type) {
        if (type != "number" || false) {
            return false;
        }
        return [ { text: _("Send Fax"), function: "contactClickInitiate", type: "fax" } ];
    },
    contactClickInitiate: function(did) {
        /*
			Globalizing did initiate 'did_init'
		*/
        did_init    = did;
        var ext 	= $("#faxpro-module").attr("data-ext"); // Get extension number (user)
        var faxpro 	= $('#faxpro-toolbar-'+ext).val();
        var dest	= $("#destination").val();				// Get destination number.
        if(faxpro === undefined) {
            UCP.showAlert('This functionality requires FAX widget to be selected in the dashboard. Please add the same.','warning');
            return false;
        }
        if ((dest === undefined || dest === null) && (faxpro !== undefined || faxpro !== null)) {
            /*
				Send a click event to the button "Send Fax" if the Widget is present.
				If Faxpro is not present, There's nothing to do.
			*/
            $(".send-fax").click();
        }
    },
    updateFolderCount: function(folder,operation,amount) {
        var count = (operation == "+") ? this.folderCount[folder] + parseInt(amount) : this.folderCount[folder] - parseInt(amount);
        $(".grid-stack-item[data-rawname=faxpro] .folder-list .folder[data-folder="+folder+"] .badge").text(count);
    },
    poll: function(data) {
        if (data.status && $(".grid-stack-item[data-rawname=faxpro]").length) {
            if(typeof this.folderCounts.new !== "undefined") {
                if ((this.folderCounts.new.count < data.folderCounts.new.count) && UCP.notify) {
                    var faxproNotification = new Notify("Fax", {
                        body: sprintf(_("You Have %s New Fax"), (data.folderCounts.new.count - this.folderCounts.new.count)),
                        icon: "modules/Faxpro/assets/images/fax.png"
                    });
                    faxproNotification.show();
                }
            }

            var folder = $(".grid-stack-item[data-rawname=faxpro] .folder-list .folder.active").data("folder"),
                extension = $(".grid-stack-item[data-rawname=faxpro]").data("widget_type_id");

            if(typeof this.folderCounts[folder] !== "undefined" && (data.folderCounts[folder].count != this.folderCounts[folder].count) && (typeof Cookies.get('fax-refresh-'+extension) === "undefined" && (typeof Cookies.get('fax-refresh-'+extension) === "undefined" || Cookies.get('fax-refresh-'+extension) == 1)) || Cookies.get('fax-refresh-'+extension) == 1) {
                $(".grid-stack-item[data-rawname=faxpro] .fax-grid").bootstrapTable('refresh',{silent: true});
            }

            this.folderCounts = data.folderCounts;
            $.each(data.folderCounts, function( folder, data ) {
                $(".grid-stack-item[data-rawname=faxpro] .folder-list .folder[data-folder="+folder+"] .badge").text(data.count);
            });
        }
    },
    deleteAttachment: function(id) {
        var $this = this;
        if ($("#globalModal #attachment-" + id).length !== 0) {
            if ($("#globalModal .files .list-group-item").length === 1) {
                $("#globalModal .files").addClass("hidden");
                $.post( UCP.ajaxUrl + "?module=faxpro&command=deleteattachment", { name: $("#attachment-" + id).data("filename") }, function( data ) {
                    if (data.status) {
                        var i = $this.faxData.files.indexOf($("#attachment-" + id).data("filename"));
                        if (i != -1) {
                            $this.faxData.files.splice(i, 1);
                        }
                        $("#attachment-" + id).remove();
                    }
                });
            } else {
                $.post( UCP.ajaxUrl + "?module=faxpro&command=deleteattachment", { name: $("#attachment-" + id).data("filename") }, function( data ) {
                    if (data.status) {
                        var i = $this.faxData.files.indexOf($("#globalModal #attachment-" + id).data("filename"));
                        if (i != -1) {
                            $this.faxData.files.splice(i, 1);
                        }
                        $("#globalModal #attachment-" + id).remove();
                    }
                });
            }
        }
    },
    stopFax: function(id, callback) {
        UCP.showConfirm(_("Are you sure you wish to stop this fax?"),'info', function() {
            $.post( UCP.ajaxUrl + "?module=faxpro&command=stopfax", { id: id }, function( data ) {
                if(typeof callback === "function") {
                    callback(data);
                }
            });
        });
    },
    deleteFax: function(id, callback) {
        UCP.showConfirm(_("Are you sure you wish to delete this fax?"),'info', function() {
            $.post( UCP.ajaxUrl + "?module=faxpro&command=deletefax", { id: id }, function( data ) {
                if(typeof callback === "function") {
                    callback(data);
                }
            });
        });
    },
    sendFax: function() {
        var $this = this;
        if ($("#globalModal #destination").val() === null || !$("#globalModal #destination").val().length || !$("#globalModal #destination").val().match(/^[0-9*#]+(?:;[0-9*#]+)*$/)) {
            UCP.showAlert(_("Please Enter a valid Destination"),'warning');
            $("#globalModal #destination").focus();
            return false;
        }
        if (!$this.faxData.files.length && !$("#globalModal #coversheet").is(":checked")) {
            UCP.showAlert(_("Please upload at least one file or enable a coversheet"),'warning');
            return false;
        }
        $this.faxData.destination = $("#globalModal #destination").val();
        $("input[type!=\"checkbox\"][type!=\"file\"]").each(function( index ) {
            $this.faxData[$(this).prop("name")] = $(this).val();
        });
        $("input[type=\"checkbox\"]").each(function( index ) {
            $this.faxData[$(this).prop("name")] = $(this).is(":checked");
        });
        $("select[name!=\"destination\"]").each(function( index ) {
            $this.faxData[$(this).prop("name")] = $(this).val();
        });
        $("textarea").each(function( index ) {
            $this.faxData[$(this).prop("name")] = $(this).val();
        });
        $("#globalModal #send-btn").prop("disabled", true);
        $("#globalModal #destination").prop("disabled", true);
        $("#globalModal .file-controls").hide();
        $("#globalModal .filedrop").hide();
        $("#globalModal #coversheet").prop("disabled", true);
        $("#globalModal .attachment img").remove();
        $.post( UCP.ajaxUrl + "?module=faxpro&command=sendfax", $this.faxData, function( data ) {
            if (data.status) {
                UCP.closeDialog(function() {
                    $(".grid-stack-item[data-rawname=faxpro] .folder-list .folder[data-folder=out]").click();
                });
            } else {
                $("#globalModal #message").addClass("alert-danger").text(data.message).fadeIn("slow");
                $("#globalModal #send-btn").prop("disabled", false);
            }
            $("#globalModal #dashboard-content").animate({ scrollTop: 0 }, "slow");
            //clear files
            $this.faxData = { files: [] };
        });
    },
    showPDF: function(id) {
        UCP.showDialog(_("Fax Preview"),
            "<object type='application/pdf' width='100%' height='100%' data='"+UCP.ajaxUrl + "?module=faxpro&command=view&faxid="+id+"'>" +
            "<p>"+sprintf(_('Your Web browser is not configured to display PDF files. Click here %s to download the PDF file'),"<span class='link'><a href='"+UCP.ajaxUrl+"?module=faxpro&command=view&faxid="+id+">"+_('Here')+"</a></span>")+"</a></p>" +
            "</object>",
            '<a class="btn btn-info download" href="'+UCP.ajaxUrl + "?module=faxpro&command=download&faxid="+id+'"><i class="fa fa-cloud-download"></i> '+_("Download")+'</a><button type="button" class="btn btn-default" data-dismiss="modal">'+_("Close")+'</button>',
            function() {
                $("#globalModal .modal-body object").css("height","calc(100vh - 218px)");
            }
        );
    },
    forward: function(id, dest) {
        UCP.showDialog(_("Forward Fax"), "<label>" + _("Please enter a phone number or extension") + ":</label><br/>" +
            "<input type='text' class='form-control' name='dest' value='"+dest+"'></br>" +
            "<div class='row'>"+
            "<div class='col-md-12'>"+
            "<span id='destination-help' class='help-block fpbx-help-block'>Phone numbers or extensions should be separated by semicolon(;) </spam>"+
            "</div>"+
            "</div>"+
            "<div class='form-group'>" +
            "<label for='faxresolution'>"+_('Resolution')+"</label>" +
            "<select id='faxresolution' name='resolution' class='form-control'>" +
            "<option value='standard'>"+_("Standard")+"</option>" +
            "<option value='fine' selected>"+_("Fine")+"</option>" +
            "<option value='superfine'>"+_("Super Fine")+"</option>" +
            "</select>" +
            "</div>",
            "<button class='btn btn-default send'>"+_("Send")+"</button>",function(){
                $("#globalModal .send").click(function() {
                    var dest = $("#globalModal input[name=dest]").val(), local, resolution = 'fine';
                    if (dest === "") {
                        UCP.showAlert(_("Destination Can Not Be Blank"));
                    } else {
                        local = $("#globalModal checkbox[name=faxlocal]").is(":checked");
                        resolution = $("#globalModal checkbox[name=resolution]").val();
                        $.post( UCP.ajaxUrl + "?module=faxpro&command=forward", { dest: dest, resolution: resolution, local: local, id: id }, function( data ) {
                            if (data.status) {
                                UCP.closeDialog(function() {
                                    $(".grid-stack-item[data-rawname=faxpro] .folder-list .folder[data-folder=out]").click();
                                });
                            } else {
                                UCP.showAlert(data.message);
                            }
                        });
                    }
                });
            });
    },
    controlFormatter: function (value, row, index) {
        var folder = $(".grid-stack-item[data-rawname=faxpro] .folder-list .folder.active").data("folder"),
            controls = '',
            dest = '';

        if(folder == "failed") {
            dest = row.dest;
        }
        controls += '<a class="showFax" data-id="'+row.faxid+'"><i class="fa fa-file-pdf-o"></i></a><a href='+UCP.ajaxUrl+'?module=faxpro&command=download&faxid='+row.faxid+' target="_blank"><i class="fa fa-cloud-download"></i></a>';
        if(folder !== "out") {
            controls += '<a class="forwardFax" data-id="'+row.faxid+'" data-dest="'+dest+'"><i class="fa fa-share"></i></a>';
            controls += '<a class="deleteFax" data-id="'+row.faxid+'"><i class="fa fa-trash-o"></i></a>';
        } else {
            controls += '<a class="stopFax" data-id="'+row.faxid+'"><i class="fa fa-times"></i></a>';
        }
        return controls;
    },
    dateFormatter: function(value, row, index) {
        return UCP.dateFormatter(value);
    },
    dateTimeFormatter: function(value, row, index) {
        return UCP.dateTimeFormatter(value);
    },
});

var FindmefollowC = UCPMC.extend({
    init: function(){
        this.stopPropagation = {};
    },
    prepoll: function() {
        var exts = [];
        $(".grid-stack-item[data-rawname=findmefollow]").each(function() {
            exts.push($(this).data("widget_type_id"));
        });
        return exts;
    },
    poll: function(data) {
        var self = this;
        $.each(data.states, function(ext,state) {
            if(typeof self.stopPropagation[ext] !== "undefined" && self.stopPropagation[ext]) {
                return true;
            }
            var widget = $(".grid-stack-item[data-rawname=findmefollow][data-widget_type_id='"+ext+"']:visible input[name='ddial']"),
                sidebar = $(".widget-extra-menu[data-module='findmefollow'][data-widget_type_id='"+ext+"']:visible input[name='ddial']"),
                sstate = state ? "on" : "off";
            if(widget.length && (widget.is(":checked") !== state)) {
                widget.bootstrapToggle(sstate);
            } else if(sidebar.length && (sidebar.is(":checked") !== state)) {
                sidebar.bootstrapToggle(sstate);
            }
        });
    },
    displayWidget: function(widget_id,dashboard_id) {
        var self = this;
        $(".grid-stack-item[data-id='"+widget_id+"'][data-rawname=findmefollow] .widget-content input[name='ddial']").change(function() {
            var extension = $(".grid-stack-item[data-id='"+widget_id+"'][data-rawname=findmefollow]").data("widget_type_id"),
                el = $(".widget-extra-menu[data-module='findmefollow'][data-widget_type_id='"+extension+"']:visible input[name='ddial']"),
                checked = $(this).is(':checked'),
                name = $(this).prop('name');
            if(el.length && el.is(":checked") !== checked) {
                var state = checked ? "on" : "off";
                el.bootstrapToggle(state);
            }
            self.saveSettings(extension, {key: name, value: checked});
        });
    },
    saveSettings: function(extension, data, callback) {
        var self = this;
        data.ext = extension;
        data.module = "findmefollow";
        data.command = "settings";
        this.stopPropagation[extension] = true;
        $.post(UCP.ajaxUrl, data, callback).always(function() {
            self.stopPropagation[extension] = false;
        });
    },
    displayWidgetSettings: function(widget_id,dashboard_id) {
        var self = this;
        var extension = $("div[data-id='"+widget_id+"']").data("widget_type_id");

        $("#widget_settings .widget-settings-content textarea").blur(function() {
            self.saveSettings(extension, {key: $(this).prop('name'), value: $(this).val()});
        });
        $("#widget_settings .widget-settings-content select").change(function() {
            self.saveSettings(extension, {key: $(this).prop('name'), value: $(this).val()});
        });
        $("#widget_settings .widget-settings-content input[type='checkbox']").change(function() {
            self.saveSettings(extension, {key: $(this).prop('name'), value: $(this).is(':checked')});
        });
    },
    displaySimpleWidget: function(widget_id) {
        var self = this;
        $(".widget-extra-menu[data-id='"+widget_id+"'] input[name='ddial']").change(function() {
            var extension = $(".widget-extra-menu[data-id='"+widget_id+"']").data("widget_type_id"),
                checked = $(this).is(':checked'),
                name = $(this).prop('name'),
                el = $(".grid-stack-item[data-rawname=findmefollow][data-widget_type_id='"+extension+"']:visible input[name='ddial']");

            if(el.length) {
                if(el.is(":checked") !== checked) {
                    var state = checked ? "on" : "off";
                    el.bootstrapToggle(state);
                }
            } else {
                self.saveSettings(extension, {key: name, value: checked});
            }
        });
    },
    displaySimpleWidgetSettings: function(widget_id) {
        this.displayWidgetSettings(widget_id);
    }
});

var HomeC = UCPMC.extend({
    init: function() {
        this.packery = false;
        this.doit = null;
    },
    poll: function(data) {
        //console.log(data)
    },
    display: function(event) {
        $(window).on("resize.Home", this.resize);
        this.resize();
    },
    hide: function(event) {
        $(window).off("resize.Home");
        //$(".masonry-container").packery("destroy");
        this.packery = false;
    },
    contactClickOptions: function(type) {
        if (type != "number" || !UCP.Modules.Home.staticsettings.enableOriginate) {
            return false;
        }
        return [ { text: _("Originate Call"), function: "contactClickInitiate", type: "phone" } ];
    },
    contactClickInitiate: function(did) {
        var Webrtc = this,
            sfrom = "",
            temp = "",
            name = did,
            selected = "";
        if (UCP.validMethod("Contactmanager", "lookup")) {
            if (typeof UCP.Modules.Contactmanager.lookup(did).displayname !== "undefined") {
                name = UCP.Modules.Contactmanager.lookup(did).displayname;
            } else {
                temp = String(did).length == 11 ? String(did).substring(1) : did;
                if (typeof UCP.Modules.Contactmanager.lookup(temp).displayname !== "undefined") {
                    name = UCP.Modules.Contactmanager.lookup(temp).displayname;
                }
            }
        }
        $.each(UCP.Modules.Home.staticsettings.extensions, function(i, v) {
            sfrom = sfrom + "<option>" + v + "</option>";
        });

        selected = "<option value=\"" + did + "\" selected>" + name + "</option>";
        UCP.showDialog(_("Originate Call"),
            "<label for=\"originateFrom\">From:</label><select id=\"originateFrom\" class=\"form-control\">" + sfrom + "</select><label for=\"originateTo\">To:</label><select class=\"form-control\" id=\"originateTo\" data-toggle=\"select\" data-size=\"auto\">" + selected + "</select>",
            "<button class=\"btn btn-primary text-center\" id=\"originateCall\" style=\"margin-left: 72px;\">" + _("Originate") + "</button>",
            function() {
                $("#originateCall").click(function() {
                    setTimeout(function() {
                        UCP.Modules.Home.originate();
                    }, 50);
                });
                $("#originateTo").keypress(function(event) {
                    if (event.keyCode == 13) {
                        setTimeout(function() {
                            UCP.Modules.Home.originate();
                        }, 50);
                    }
                });
            }
        );
    },
    refresh: function(module, id) {
        $("#"  +  module  +  "-title-"  +  id + " i.fa-refresh").addClass("fa-spin");
        $.post( "?quietmode=1&module=" + module + "&command=homeRefresh&id=" + id, {}, function( data ) {
            $("#" + module + "-title-" + id + " i.fa-refresh").removeClass("fa-spin");
            $("#" + module + "-content-" + id).html(data.content);
        });
    },
    originate: function() {
        if ($("#originateTo").val() !== null && $("#originateTo").val()[0] === "") {
            alert(_("Nothing Entered"));
            return;
        }
        $.post( "index.php?quietmode=1&module=home&command=originate",
            { from: $("#originateFrom").val(),
                to: $("#originateTo").val() },
            function( data ) {
                if (data.status) {
                    UCP.closeDialog();
                }
            }
        )
            .fail(function(xhr, status, error) {
                alert(status +" "+ error);
            });
    },
    resize: function() {
        return;
        var wasPackeryEnabled = this.packery;
        this.packery = $(window).width() >= 768;
        if (this.packery !== wasPackeryEnabled) {
            if (this.packery) {
                clearTimeout(this.doit);
                this.doit = setTimeout(function() {
                    $(".widget").css("width", "33.33%");
                    $(".widget").css("margin-bottom", "");
                    $(".masonry-container").packery({
                        columnWidth: 40,
                        gutter: 10,
                        itemSelector: ".widget"
                    });
                }, 100);
            } else {
                this.packery = false;
                $(".masonry-container").packery("destroy");
                $(".widget").css("width", "100%");
                $(".widget").css("margin-bottom", "10px");
            }
        } else if (!this.packery) {
            $(".widget").css("width", "100%");
            $(".widget").css("margin-bottom", "10px");
        }
    }
});

$(document).bind("logIn", function( event ) {
    $("#settings-menu a.originate").on("click", function() {
        var sfrom = "";
        $.each(UCP.Modules.Home.staticsettings.extensions, function(i, v) {
            sfrom = sfrom + "<option>" + v + "</option>";
        });

        UCP.showDialog(_("Originate Call"),
            "<label for=\"originateFrom\">From:</label> <select id=\"originateFrom\" class=\"form-control\">" + sfrom + "</select><label for=\"originateTo\">To:</label><select class=\"form-control Tokenize Fill\" id=\"originateTo\" multiple></select><button class=\"btn btn-default\" id=\"originateCall\" style=\"margin-left: 72px;\">" + _("Originate") + "</button>",
            200,
            250,
            function() {
                $("#originateTo").tokenize({ maxElements: 1, datas: "index.php?quietmode=1&module=home&command=contacts" });
                $("#originateCall").click(function() {
                    setTimeout(function() {
                        UCP.Modules.Home.originate();
                    }, 50);
                });
                $("#originateTo").keypress(function(event) {
                    if (event.keyCode == 13) {
                        setTimeout(function() {
                            UCP.Modules.Home.originate();
                        }, 50);
                    }
                });
            }
        );
    });
});

var UcphelloworldC = UCPMC.extend({
    /**
     * This function is similar to PHP's __construct
     * class variables are declared in this method using 'this.variable'
     */
    init: function(){
        this.socket = null;
        this.time = moment.utc().unix();
        console.log('%c'+sprintf(_("Hello World has been loaded at %s"),UCP.dateTimeFormatter(this.time)),'background: #222; color: #bada55');
        console.log('%c'+sprintf(_("Hello World has been loaded at %s"),UCP.timeFormatter(this.time)),'background: #222; color: #bada55');
        console.log('%c'+sprintf(_("Hello World has been loaded at %s"),UCP.dateFormatter(this.time)),'background: #222; color: #bada55');
        console.log('%c'+sprintf(_("Your Timezone is %s"),timezone),'background: #222; color: #bada55');
        console.log('%c'+sprintf(_("Your Moment date format is %s"),dateformat),'background: #222; color: #bada55');
        console.log('%c'+sprintf(_("Your Moment time format is %s"),timeformat),'background: #222; color: #bada55');
        console.log('%c'+sprintf(_("Your Moment date/time format is %s"),datetimeformat),'background: #222; color: #bada55');

        /**
         * This trigger is executed when the user logs in (Or page is refreshed)
         * @method
         * @link https://wiki.freepbx.org/pages/viewpage.action?pageId=78479865#DevelopingforUCP14+-logIn
         * @param  object event The event object
         */
        $(document).on("logIn", function(event) {
            console.log("User has logged in!");
        });

        /**
         * This trigger is executed when the user logs out
         * @method
         * @link https://wiki.freepbx.org/pages/viewpage.action?pageId=71271742#DevelopingforUCP14+-logOut
         * @param  object event The event object
         */
        $(document).on("logOut", function(event) {
            console.log("User has logged out!");
        });
    },
    /**
     * Add Simple Widget
     * This method is executed when the side bar widget has been added to the side bar.
     * @method addSimpleWidget
     * @link https://wiki.freepbx.org/pages/viewpage.action?pageId=71271742#DevelopingforUCP14+-addSimpleWidget
     * @param  {string}      widget_id    The widget UUID on the dashboard
     */
    addSimpleWidget: function(widget_id) {
        //jQuery Object
        $(".grid-stack-item[data-id='"+widget_id+"']");
    },
    /**
     * Display Widget
     * This method is executed when the side bar widget has finished loading.
     * @method displayWidget
     * @link https://wiki.freepbx.org/pages/viewpage.action?pageId=71271742#DevelopingforUCP14+-displayWidget
     * @param  {string}      widget_id    The widget ID on the dashboard
     * @param  {string}      dashboard_id The dashboard ID the widget has been placed on
     */
    displayWidget: function(widget_id,dashboard_id) {
        //jQuery Object
        $(".grid-stack-item[data-id='"+widget_id+"']");
    },
    /**
     * Display Side Bar Widget
     * This method is executed after the side bar widget has been clicked and the window has fully extended has finished loading.
     * @method displaySimpleWidget
     * @link https://wiki.freepbx.org/pages/viewpage.action?pageId=71271742#DevelopingforUCP14+-displaySimpleWidget
     * @param  {string}            widget_id The widget id in the sidebar
     */
    displaySimpleWidget: function(widget_id) {
        //jQuery Object
        $(".widget-extra-menu[data-id="+widget_id+"]");
    },
    /**
     * Display Widget Settings
     * This method is executed when the settings window has finished loading.
     * @method displayWidgetSettings
     * @link https://wiki.freepbx.org/pages/viewpage.action?pageId=71271742#DevelopingforUCP14+-displayWidgetSettings
     * @param  {string}      widget_id    The widget ID on the dashboard
     * @param  {string}      dashboard_id The dashboard ID
     */
    displayWidgetSettings: function(widget_id, dashboard_id) {
        //jQuery Bootstrap Modal Object
        $("#widget_settings .widget-settings-content");
    },
    /**
     * Display Simple Widget Settings
     * This method is executed when the settings window has finished loading.
     * @method displaySimpleWidgetSettings
     * @link https://wiki.freepbx.org/pages/viewpage.action?pageId=71271742#DevelopingforUCP14+-displaySimpleWidgetSettings
     * @param  {string}      widget_id    The widget ID on the sidebar
     */
    displaySimpleWidgetSettings: function(widget_id) {
        //jQuery Bootstrap Modal Object
        $("#widget_settings .widget-settings-content")
    },
    /**
     * Resize Widget
     * The method is executed when the widget has been resized
     * @method resize
     * @link https://wiki.freepbx.org/pages/viewpage.action?pageId=71271742#DevelopingforUCP14+-resize
     * @param  {string}      widget_id    The widget ID on the dashboard
     * @param  {string}      dashboard_id The dashboard ID
     */
    resize: function(widget_id,dashboard_id) {
        //jQuery Object
        $(".grid-stack-item[data-id='"+widget_id+"']");
    },
    /**
     * When the dashboard is displayed and has finished loading
     * This method is executed when the dashboard has finished loading
     * @method showDashboard
     * @link https://wiki.freepbx.org/pages/viewpage.action?pageId=71271742#DevelopingforUCP14+-showDashboard
     * @param  {string}            dashboard_id The dashboard id
     */
    showDashboard: function(dashboard_id) {
        console.log('%c'+sprintf(_("Dashbord '%s' is currently visible"),dashboard_id),'background: #222; color: #bada55');
    },
    /**
     * Window State
     * The method is executed when the tab in the browser (Or the browser itself) is brought into focus or out of focus
     * @method windowState
     * @link https://wiki.freepbx.org/pages/viewpage.action?pageId=71271742#DevelopingforUCP14+-windowState
     * @param  {string}      state    The window state. Can be "hidden" or "visible"
     */
    windowState: function(state) {
        console.log('%c'+sprintf(_("The window state is '%s'"),state),'background: #222; color: #bada55');
    },
    /**
     * Pre Poll (Before the poll)
     * This method is used to populate data to send to the PHP poll function for this module
     * @method prepoll
     * @link https://wiki.freepbx.org/pages/viewpage.action?pageId=71271742#DevelopingforUCP14+-prepoll
     * @return  {mixed}      Data to send back to the PHP poll function for this module
     */
    prepoll: function() {
        var items = {};
        $(".grid-stack-item[data-rawname=ucphelloworld][data-widget_type_id=poll]").each(function() {
            var id = $(this).data("id");
            if($(this).find(".number").length) {
                items[id] = $(this).find(".number").text();
            }
        });
        return items;
    },
    /**
     * Poll
     * This method is used to process data returned from the PHP poll function for this module
     * @method prepoll
     * @link https://wiki.freepbx.org/pages/viewpage.action?pageId=71271742#DevelopingforUCP14+-poll(Javascript)
     * @param  {mixed}      data    Data returned from the PHP poll function for this module
     */
    poll: function(data){
        $.each(data.items, function(id, value){
            $(".grid-stack-item[data-id="+id+"] .number").text(value);
        });
        //$("#ucphelloworld-badge").text(data.total);
        //$("#nav-btn-ucphelloworld .badge").text(data.total);
        console.log('%c'+sprintf(_("Time since you started this session: %s"),UCP.humanDiff(this.time)),'background: #222; color: #bada55');
    },
    /**
     * Websocket Disconnect
     * @method
     */
    disconnect: function() {
        var $this = this,
            listeners = [ "hello" ];
        if (this.socket !== null) {
            //remove all listeners so we don't get double binds on a reconnect
            $.each(listeners, function(i, v) {
                $this.socket.removeAllListeners(v);
            });
            this.subscribed = [];
        }
    },
    /**
     * Websocket Connect
     * @method
     */
    connect: function() {
        var $this = this;
        try {
            //connect to the namespace we want to reach in UCP Node Server
            UCP.wsconnect("ucphelloworld", function(socket) {
                if (socket === false) {
                    $this.socket = null;
                    return false;
                } else {
                    $this.socket = socket;
                }

                //emit our event
                $this.socket.emit("hello", "");

                //bind for a response
                $this.socket.on("hello", function(response) {
                    console.log(response);
                });
            });
        } catch(e) {

        }
    }
});

var PmsC = UCPMC.extend({
    init: function() {
        this.socket = null;
        this.subscribed = 0;
        this.wasTalking = {};
    },
    display: function() {
        $.getScript( "/admin/modules/pms/ucp/assets/js/canvasjs/canvasjs.min.js", function( data, textStatus, jqxhr ) {});

        $.getScript( "/admin/modules/pms/ucp/assets/js/canvasjs/jquery.canvasjs.min.js", function( data, textStatus, jqxhr ) {});
    },
    displayWidget: function() {
        if(typeof window.CanvasJS === "undefined") {
            $.getScript( "/admin/modules/pms/ucp/assets/js/canvasjs/canvasjs.min.js", function( data, textStatus, jqxhr ) {
                $(document).trigger("canvasjsloaded");
            });

            $.getScript( "/admin/modules/pms/ucp/assets/js/canvasjs/jquery.canvasjs.min.js", function( data, textStatus, jqxhr ) {
            });
        }
        $("#datepicker_ci").datepicker();
        $("#datepicker_co").datepicker();
        $("#timepicker_ci").timepicker({timeFormat: 'h:ia', step: 5});
        $("#timepicker_co").timepicker({timeFormat: 'h:ia', step: 5});
        $('[data-toggle="tooltip"]').tooltip();

        $('#checkin').submit(function() {
            var date_ci = document.forms["checkin"]["date_ci"].value;
            var date_co = document.forms["checkin"]["date_co"].value;
            var time_ci = document.forms["checkin"]["time_ci"].value;
            var time_co = document.forms["checkin"]["time_co"].value;
            var first_n = document.forms["checkin"]["first_name"].value;
            var last_n  = document.forms["checkin"]["last_name"].value;
            var dt_ci	= date_ci.split('/');
            var tm_ci	= time_ci.split(':');
            var dt_co	= date_co.split('/');
            var tm_co	= time_co.split(':');
            var d_ci	= new Date(dt_ci[2],dt_ci[0]-1,dt_ci[1],0,0).getTime();
            var d_co	= new Date(dt_co[2],dt_co[0]-1,dt_co[1],0,0).getTime();
            var today 	= new Date();
            var now		= new Date(today.getFullYear(),today.getMonth(),today.getDate()).getTime();

            if( $("#message").html() != ""){
                return false;
            }

            if (d_co < d_ci) {
                $('#message').html("<div class='alert alert-warning alert-dismissable'><button type='button' class='close' data-dismiss='alert' aria-hidden='true'>&times;</button><div class='tac'><div class='text-danger'>"+ _("The check-out date must be longer than the check-in date.") + "</div></div></div>");
                return false;
            }

            if(check_group() === false){
                $('#message').html("<div class='alert alert-warning alert-dismissable'><button type='button' class='close' data-dismiss='alert' aria-hidden='true'>&times;</button><div class='tac'><div class='text-danger'>"+ _("The group relating Hotel Guests seems to be corrupted! Please fix check it, submit and try again.") + "</div></div></div>");
                return false;
            }

            if ( d_ci < now && $("#BTbooking").val() == _("Check-in") ) {
                $('#message').html("<div class='alert alert-warning alert-dismissable'><button type='button' class='close' data-dismiss='alert' aria-hidden='true'>&times;</button><div class='tac'><div class='text-danger'>"+ _("Check-in date must be longer than today.") + "</div></div></div>");
                return false;
            }

            if ( date_ci == "" || date_co == "" || time_ci == "" || time_co == "" || first_n == "" || last_n == "") {
                $('#message').html("<div class='alert alert-warning alert-dismissable'><button type='button' class='close' data-dismiss='alert' aria-hidden='true'>&times;</button><div class='tac'><div class='text-danger'>"+ _("Some fields must be filled out. Check please and try again.") + "</div></div></div>");
                return false;
            }

            if ( d_ci > now && $("#BTbooking").val() == _("Booking") ) {
                $('#message').html("<div class='alert alert-warning alert-dismissable'><button type='button' class='close' data-dismiss='alert' aria-hidden='true'>&times;</button><div class='tac'><div class='text-danger'>"+ _("Check-in date should not be longer than today.") + "</div></div></div>");
                return false;
            }
            if ( !room ){
                $('#message').html("<div class='alert alert-warning alert-dismissable'><button type='button' class='close' data-dismiss='alert' aria-hidden='true'>&times;</button><div class='tac'><div class='text-danger'>"+ _("No more room available for check in!! You have been switched in Booking mode right now.") + "</div></div></div>");
                return false;
            }
            window.scrollTo(0, 0);

            // submit the form Check-in
            var queryString = $(this).formSerialize();
            $.post({
                url: "ajax.php?module=pms&command=ci&"+queryString,
                dataType:"json",
                success: function (json) {
                    var ci_result = JSON.parse(json.message);
                    $("#message").html(ci_result["message"]);
                    $("#datepicker_ci").html(ci_result["today"]);
                    $("#timepicker_ci").html(ci_result["now"]);
                    $("#language").empty().append(ci_result["language"]);
                    $("#vm_pwd").html(ci_result["vm_pwd"]);
                    $("#Sroom").html(ci_result["Sroom"]);
                    $("#Sextension").html(ci_result["Sextension"]);
                    $("#Sname").html(ci_result["Sname"]);
                    $("#Svm_password").html(ci_result["Svm_password"]);
                    $("#Svm_prefix").html(ci_result["Svm_prefix"]);
                    $("#Sweb_user").html(ci_result["Sweb_user"]);
                    $("#Sweb_password").html(ci_result["Sweb_password"]);
                    $("#ticket_footer").val(ci_result["ticket_footer"]);
                    $("#ticket_body").val(ci_result["ticket_body"]);
                    $("#ticket_header").val(ci_result["ticket_header"]);
                    $("#room_list").empty().append(ci_result["room_list"]);
                    if(ci_result["Sname"] != "" && ci_result["message"] == ""){;
                        $("#summary").modal('show');
                        $("#reload_button").modal('show');
                    }

                    if($('#BTbooking').val() == _("Check-in")){
                        location.reload();
                    }

                }
            });

            return false;
        });

        $('#group_list').submit(function() {
            // submit the form group list
            var queryString = $(this).formSerialize();
            $.post('ajax.php?module=pms&command=gl', queryString);
            $("#group").val("");
            $("#rooms").val([]);
            $("#getgrouptable").bootstrapTable("removeAll");
            $("#getgrouptable").bootstrapTable("refresh", {silent: true});
            return false;
        });

        function setCookie(key, value) {
            var expires = new Date();
            expires.setTime(expires.getTime() + (60 * 1000));
            document.cookie = key + '=' + value + ';expires=' + expires.toUTCString();
        }

        $('#booking_list').submit(function() {
            // submit the form  booking list
            var queryString = $(this).formSerialize();
            $.post('ajax.php?module=pms&command=bl', queryString);
            $("#bookinglisttable").bootstrapTable("removeAll");
            $("#bookinglisttable").bootstrapTable("refresh", {silent: true});
            location.reload();
            return false;
        });

        $('#booking_status').submit(function() {
            // submit the form  booking status
            setCookie("date_ci", $("#datepicker_ci").val());
            setCookie("date_co", $("#datepicker_co").val());
            return true;
        });

        $('#customer_edit').submit(function() {
            // submit the form customer edit.
            var queryString = $(this).formSerialize();
            $.post('ajax.php?module=pms&command=ce', queryString);
            $("#list").show();
            $("#edit").hide();
            $("#message").html("<div class='alert alert-warning alert-dismissable'><button type='button' class='close' data-dismiss='alert' aria-hidden='true'>&times;</button><div class='tac'><div class='text-danger'>"+_("Guest updated.")+"</div></div></div>");
            window.scrollTo(0, 0);
            $("#customertable").bootstrapTable("removeAll");
            $("#customertable").bootstrapTable("refresh", {silent: true});
            return false;
        });

    },
    poll: function(data) {
        var Pms = this;

        // Detect if emergency alert is present and forwarding url, excepted if it's on emergency page.
        page = window.location.href;

        if (data["emergency_alert"] != "none"){

            if($("#emergency").val() != "ok" && (typeof rl == 'undefined')) {
                rl = "1";
                window.location.reload();

            };
        };

        /**
         * Get messages and billing
         */
        if($("#ext").length){
            var ext= $("#ext").html();
            $.ajax({
                url: "index.php?quietmode=1&display=dashboard&module=pms&view=room_status&command=get_billing&ext="+ext,
                dataType:"json",
                success: function (json) {
                    var list_billing = jQuery.parseJSON(json.message);
                    $("#billing").html(list_billing);
                },
            });

            $.ajax({
                url: "index.php?quietmode=1&display=dashboard&module=pms&view=room_status&command=get_messages&ext="+ext,
                dataType:"json",
                success: function (json) {
                    var list_msg = jQuery.parseJSON(json.message);
                    $("#list_msg").html(list_msg);
                },
            });
        }

        /**
         * Get all wakeup call
         */
        if ($("[name='room']").length) {
            var dest  = $("[name='room']").val();
            $.post({
                url: "index.php?quietmode=1&module=pms&command=wu&get_wu="+dest,
                dataType:"json",
                success: function (json) {
                    if (json.message != null){
                        $("#wakeup").html(jQuery.parseJSON(json.message));
                    };
                },
            });
        }

        // Detect any room services.
        if ($("#roomlisttable").length){
            new_nbrs = $("#nbrs").val();
            $.ajax({
                url: "?quietmode=1&module=pms&command=room_services",
                dataType:"json",
                success: function (json) {
                    var room_service = JSON.parse(json.message);
                    if(room_service != "none"){
                        cur_nbrs = 0;
                        $.each(room_service, function(room_ext, v) {
                            cur_nbrs++;
                            $("#"+room_ext).html("<i class='fa fa-trash' onclick='del_rs(\""+room_ext+"\")'></i> "+v['lab']+" "+v['plv']);
                            $("#message").html("<div class='alert alert-warning alert-dismissable'><button type='button' class='close' data-dismiss='alert' aria-hidden='true'>&times;</button><div style='text-align:center;'><div class='text-danger'>"+_("Room Service present!")+"</div></div></div>");
                        });
                        if(cur_nbrs != parseInt(new_nbrs) ){
                            window.location.reload();
                        }
                    };
                },
            });
        };
    },
});

(function(e){typeof define=="function"&&define.amd?define(["jquery"],e):e(jQuery)})(function(e){function o(t){var r=t.data("timepicker-settings"),i=t.data("timepicker-list");i&&i.length&&(i.remove(),t.data("timepicker-list",!1)),i=e("<ul />",{tabindex:-1,"class":"ui-timepicker-list"}),r.className&&i.addClass(r.className),i.css({display:"none",position:"absolute"}),(r.minTime!==null||r.durationTime!==null)&&r.showDuration&&i.addClass("ui-timepicker-with-duration");var s=r.durationTime!==null?r.durationTime:r.minTime,o=r.minTime!==null?r.minTime:0,u=r.maxTime!==null?r.maxTime:o+n-1;u<=o&&(u+=n);for(var a=o;a<=u;a+=r.step*60){var f=a%n,l=e("<li />");l.data("time",f),l.text(m(f,r.timeFormat));if((r.minTime!==null||r.durationTime!==null)&&r.showDuration){var h=e("<span />");h.addClass("ui-timepicker-duration"),h.text(" ("+v(a-s)+")"),l.append(h)}i.append(l)}i.data("timepicker-input",t),t.data("timepicker-list",i);var p=r.appendTo;typeof p=="string"?p=e(p):typeof p=="function"&&(p=p(t)),p.append(i),c(t,i),i.on("click","li",function(n){t.addClass("ui-timepicker-hideme"),t[0].focus(),i.find("li").removeClass("ui-timepicker-selected"),e(this).addClass("ui-timepicker-selected"),d(t),i.hide()})}function u(){var e=new Date,t=e.getTimezoneOffset()*6e4;e.setHours(0),e.setMinutes(0),e.setSeconds(0);var n=e.getTimezoneOffset()*6e4;return new Date(e.valueOf()-n+t)}function a(){"ontouchstart"in document?e("body").on("touchstart.ui-timepicker",f):(e("body").on("mousedown.ui-timepicker",f),e(window).on("scroll.ui-timepicker",f))}function f(t){var n=e(t.target),r=n.closest(".ui-timepicker-input");r.length===0&&n.closest(".ui-timepicker-list").length===0&&s.hide(),e("body").unbind(".ui-timepicker"),e(window).unbind(".ui-timepicker")}function l(t,n,r){if(!r&&r!==0)return!1;var i=t.data("timepicker-settings"),s=!1,o=i.step*30;return n.find("li").each(function(t,n){var i=e(n),u=i.data("time")-r;if(Math.abs(u)<o||u==o)return s=i,!1}),s}function c(e,t){var n=g(e.val()),r=l(e,t,n);r&&r.addClass("ui-timepicker-selected")}function h(){if(this.value==="")return;var t=e(this),n=g(this.value);if(n===null){t.trigger("timeFormatError");return}var r=t.data("timepicker-settings");if(r.forceRoundTime){var i=n%(r.step*60);i>=r.step*30?n+=r.step*60-i:n-=i}var s=m(n,r.timeFormat);t.val(s)}function p(t){var n=e(this),r=n.data("timepicker-list");if(!r.is(":visible")){if(t.keyCode!=40)return!0;n.focus()}switch(t.keyCode){case 13:return d(n),s.hide.apply(this),t.preventDefault(),!1;case 38:var i=r.find(".ui-timepicker-selected");i.length?i.is(":first-child")||(i.removeClass("ui-timepicker-selected"),i.prev().addClass("ui-timepicker-selected"),i.prev().position().top<i.outerHeight()&&r.scrollTop(r.scrollTop()-i.outerHeight())):(r.children().each(function(t,n){if(e(n).position().top>0)return i=e(n),!1}),i.addClass("ui-timepicker-selected"));break;case 40:i=r.find(".ui-timepicker-selected"),i.length===0?(r.children().each(function(t,n){if(e(n).position().top>0)return i=e(n),!1}),i.addClass("ui-timepicker-selected")):i.is(":last-child")||(i.removeClass("ui-timepicker-selected"),i.next().addClass("ui-timepicker-selected"),i.next().position().top+2*i.outerHeight()>r.outerHeight()&&r.scrollTop(r.scrollTop()+i.outerHeight()));break;case 27:r.find("li").removeClass("ui-timepicker-selected"),r.hide();break;case 9:s.hide();break;case 16:case 17:case 18:case 19:case 20:case 33:case 34:case 35:case 36:case 37:case 39:case 45:return;default:r.find("li").removeClass("ui-timepicker-selected");return}}function d(e){var t=e.data("timepicker-settings"),n=e.data("timepicker-list"),r=null,i=n.find(".ui-timepicker-selected");i.length?r=i.data("time"):e.val()&&(r=g(e.val()),c(e,n));if(r!==null){var s=m(r,t.timeFormat);e.val(s)}e.trigger("change").trigger("changeTime")}function v(e){var t=Math.round(e/60),n;if(Math.abs(t)<60)n=[t,i.mins];else if(t==60)n=["1",i.hr];else{var r=(t/60).toFixed(1);i.decimal!="."&&(r=r.replace(".",i.decimal)),n=[r,i.hrs]}return n.join(" ")}function m(e,n){if(e===null)return;var r=new Date(t.valueOf()+e*1e3),i="",s,o;for(var u=0;u<n.length;u++){o=n.charAt(u);switch(o){case"a":i+=r.getHours()>11?"pm":"am";break;case"A":i+=r.getHours()>11?"PM":"AM";break;case"g":s=r.getHours()%12,i+=s===0?"12":s;break;case"G":i+=r.getHours();break;case"h":s=r.getHours()%12,s!==0&&s<10&&(s="0"+s),i+=s===0?"12":s;break;case"H":s=r.getHours(),i+=s>9?s:"0"+s;break;case"i":var a=r.getMinutes();i+=a>9?a:"0"+a;break;case"s":e=r.getSeconds(),i+=e>9?e:"0"+e;break;default:i+=o}}return i}function g(e){if(e==="")return null;if(e+0==e)return e;typeof e=="object"&&(e=e.getHours()+":"+e.getMinutes()+":"+e.getSeconds());var t=new Date(0),n=e.toLowerCase().match(/(\d{1,2})(?::(\d{1,2}))?(?::(\d{2}))?\s*([pa]?)/);if(!n)return null;var r=parseInt(n[1]*1,10),i;n[4]?r==12?i=n[4]=="p"?12:0:i=r+(n[4]=="p"?12:0):i=r;var s=n[2]*1||0,o=n[3]*1||0;return i*3600+s*60+o}var t=u(),n=86400,r={className:null,minTime:null,maxTime:null,durationTime:null,step:30,showDuration:!1,timeFormat:"g:ia",scrollDefaultNow:!1,scrollDefaultTime:!1,selectOnBlur:!1,forceRoundTime:!1,appendTo:"body"},i={decimal:".",mins:"mins",hr:"hr",hrs:"hrs"},s={init:function(t){return this.each(function(){var n=e(this);if(n[0].tagName=="SELECT"){var o={type:"text",value:n.val()},u=n[0].attributes;for(var a=0;a<u.length;a++)o[u[a].nodeName]=u[a].nodeValue;var f=e("<input />",o);n.replaceWith(f),n=f}var l=e.extend({},r);t&&(l=e.extend(l,t)),l.minTime&&(l.minTime=g(l.minTime)),l.maxTime&&(l.maxTime=g(l.maxTime)),l.durationTime&&(l.durationTime=g(l.durationTime)),l.lang&&(i=e.extend(i,l.lang)),n.data("timepicker-settings",l),n.prop("autocomplete","off"),n.on("click.timepicker focus.timepicker",s.show),n.on("blur.timepicker",h),n.on("keydown.timepicker",p),n.addClass("ui-timepicker-input"),h.call(n.get(0))})},show:function(t){var n=e(this);"ontouchstart"in document&&n.blur();var r=n.data("timepicker-list");if(n.prop("readonly"))return;if(!r||r.length===0)o(n),r=n.data("timepicker-list");if(n.hasClass("ui-timepicker-hideme")){n.removeClass("ui-timepicker-hideme"),r.hide();return}if(r.is(":visible"))return;s.hide(),n.offset().top+n.outerHeight(!0)+r.outerHeight()>e(window).height()+e(window).scrollTop()?r.css({left:n.offset().left,top:n.offset().top-r.outerHeight()}):r.css({left:n.offset().left,top:n.offset().top+n.outerHeight()}),r.show();var i=n.data("timepicker-settings"),u=r.find(".ui-timepicker-selected");u.length||(n.val()?u=l(n,r,g(n.val())):i.scrollDefaultNow?u=l(n,r,g(new Date)):i.scrollDefaultTime!==!1&&(u=l(n,r,g(i.scrollDefaultTime))));if(u&&u.length){var f=r.scrollTop()+u.position().top-u.outerHeight();r.scrollTop(f)}else r.scrollTop(0);a(),n.trigger("showTimepicker")},hide:function(t){e(".ui-timepicker-list:visible").each(function(){var t=e(this),n=t.data("timepicker-input"),r=n.data("timepicker-settings");r&&r.selectOnBlur&&d(n),t.hide(),n.trigger("hideTimepicker")})},option:function(t,n){var r=e(this),i=r.data("timepicker-settings"),s=r.data("timepicker-list");if(typeof t=="object")i=e.extend(i,t);else if(typeof t=="string"&&typeof n!="undefined")i[t]=n;else if(typeof t=="string")return i[t];i.minTime&&(i.minTime=g(i.minTime)),i.maxTime&&(i.maxTime=g(i.maxTime)),i.durationTime&&(i.durationTime=g(i.durationTime)),r.data("timepicker-settings",i),s&&(s.remove(),r.data("timepicker-list",!1))},getSecondsFromMidnight:function(){return g(e(this).val())},getTime:function(){return new Date(t.valueOf()+g(e(this).val())*1e3)},setTime:function(t){var n=e(this),r=m(g(t),n.data("timepicker-settings").timeFormat);n.val(r)},remove:function(){var t=e(this);if(!t.hasClass("ui-timepicker-input"))return;t.removeAttr("autocomplete","off"),t.removeClass("ui-timepicker-input"),t.removeData("timepicker-settings"),t.off(".timepicker"),t.data("timepicker-list")&&t.data("timepicker-list").remove(),t.removeData("timepicker-list")}};e.fn.timepicker=function(t){if(s[t])return s[t].apply(this,Array.prototype.slice.call(arguments,1));if(typeof t=="object"||!t)return s.init.apply(this,arguments);e.error("Method "+t+" does not exist on jQuery.timepicker")}});
// Auto completion.

function FindGuest(find_guest)
{
    var arrAction            = new Array();
    var last_name			 = "";
    var first_name			 = "";
    var guest			     = "";
    var id					 = "";
    arrAction["find"]        = find_guest;
    if(find_guest.length == 0) {
        // Hide the suggestion box.
        $('#suggestions').hide();
    }
    else
    {
        request("index.php?quietmode=1&module=pms&command=find",arrAction, true, function(arrData,statusResponse,error)
            {
                var result 			= $.parseJSON(arrData);
                $.each(result, function(k, v) {
                    //Loading datas in variables.
                    last_name 		= v.last_name;
                    first_name 		= v.first_name;
                    id				= v.id;
                    guest 			+= '<ol onClick="fill(\''+id+'\');">' + last_name + ' ' + first_name + '</ol>';


                });
                if(arrData.length >0) {
                    $('#suggestions').show();
                    $('#autoSuggestionsList').html(guest);
                }
            }
        );
    }
}

function find_rooms(sort){
    var arrAction            = new Array();
    var room_name			 = "";
    var extension			 = "";
    var room_list			 = "";
    arrAction["find_rooms"]  = sort;
    request("index.php?quietmode=1&module=pms&command=find_rooms",arrAction, true, function(arrData,statusResponse,error){
            var result 			= $.parseJSON(arrData);
            $.each(result, function(k, v) {
                //Loading datas in variables.
                extension		= v.extension;
                room_name		= v.room_name;
                if(v.free != "1"){
                    room_list	+= '<option value=\''+extension+'\'>'+room_name+' &#xf071;</option>';
                }
                else{
                    room_list	+= '<option value=\''+extension+'\'>'+room_name+'</option>';
                }

            });
            if(arrData.length >0) {
                $('#room').empty();
                $('#room').append(room_list);
            }
        }
    );
}

function fill(thisValue) {
    var arrAction		= new Array();
    var arrData			= "";
    arrAction["get"]	= thisValue;
    setTimeout("$('#suggestions').hide();", 200);
    if(thisValue){
        request("index.php?quietmode=1&module=pms&command=get",arrAction, false, function(arrData,statusResponse,error)
        {
            var result  = $.parseJSON(arrData);
            $('#first_name').val(result["first_name"]);
            $('#last_name').val(result["last_name"]);
            $('#address').val(result["address"]);
            $('#cp').val(result["cp"]);
            $('#city').val(result["city"]);
            $('#phone').val(result["phone"]);
            $('#mobile').val(result["mobile"]);
            $('#fax').val(result["fax"]);
            $('#mail').val(result["mail"]);
            $('#NIF').val(result["NIF"]);
            $('#Off_Doc').val(result["Off_Doc"]);
            $('#comments').val(result["comments"]);

            if(result["lang"].length> 0){
                console.log(result["lang"]);
                $('#language').empty();
                $('#language').append('<option value=\''+result["lang"]+'\'>'+result["lang"]+'</option>');
            }
            else{
                $('#language').empty();
                $('#language').append('<option value=\'en\'>en</option>\n<option value=\'fr\'>fr</option>\n<option value=\'es\'>es</option>\n<option value=\'it\'>it</option>');
            }
        });
    }
}


// Below, (c) Elastix team.
//-------------------------
var current_setTimeout = null;
function request(url,arrParams, recursive, callback)
{
    callback           = callback  || null;
    recursive          = recursive || null;

    var params = {};
    var empty_array = new Array();
    for (var k in arrParams) {

        if (!(Array.prototype.isPrototypeOf(arrParams) && typeof arrParams[k] == typeof empty_array[k]))
            params[k] = arrParams[k];
    }

    $.post(url,
        params,
        function(dataResponse){
            var message        = dataResponse.message;
            var statusResponse = dataResponse.statusResponse;
            var error          = dataResponse.error;
            var stop_recursive = false;

            if(statusResponse == "ERROR_SESSION"){
                $.unblockUI();
                var r = confirm(error);
                if (r==true)
                    location.href = 'ajax.php?module=pms';
                return;
            }

            if(callback)
                stop_recursive = callback(message,statusResponse,error);
            if(statusResponse){
                if(recursive & !stop_recursive){
                    current_setTimeout = setTimeout(function(){request(url,arrParams,recursive,callback)},2);

                }
            }
            else{
                //
            }
        },
        'json');
}

function mode() {
    md = document.getElementById('BTbooking').value;

    if ( md == _("Booking")){
        $('#BTbooking').val(_("Check-in"));
        $("#bk0").toggle();
        $("#bk1").toggle();
        $("#bk2").toggle();
        $("#bk3").toggle();
        $('#booking').val('on');
        find_rooms("");
    }
    else{
        $('#BTbooking').val(_("Booking"));
        $("#bk0").toggle();
        $("#bk1").toggle();
        $("#bk2").toggle();
        $("#bk3").toggle();
        $('#booking').val('off');
        find_rooms("1");
    }
}






// https://developers.google.com/chart/interactive/docs/gallery/piechart#options
function decodeEntities(encodedString) {
    var textArea = document.createElement('textarea');
    textArea.innerHTML = encodedString;
    return textArea.value;
}

function linkFormatter(value, row, index) {
    return decodeEntities(value);
}

function check_int(thisvalue) {
    if ( $.isNumeric(thisvalue) == false){
        $('#message').html("<div class='alert alert-warning alert-dismissable'><button type='button' class='close' data-dismiss='alert' aria-hidden='true'>&times;</button><div class='tac'><div class='text-danger'>"+ _("Please enter a valid Number.") + "</div></div></div>");
    }
}

function check_group(){
    $.ajax({
        url: "index.php?quietmode=1&module=pms&command=check_group",
        dataType:"json",
        async: false,
        success: function (json) {
            if (json.message != null){
                var result = JSON.parse(json.message);
                if(result === "OK"){
                    window.return = true;
                }
                else{
                    window.return = false;
                }
            };
        },
        error: function(d) {
            d.suppresserrors = true;
        }
    });
    return window.return;
}

function cellStyle(value, row, index, field) {
    return {
        classes: 'bg-white',
    };
}

function cellStyle_c(value, row, index, field) {
    return {
        classes: 'bg-white tac',
    };
}

function cellUCP(value, row, index, field) {
    return {
        css: {"background": "white"},
    };
}

function check_val(thisvalue) {
    if ( $.isNumeric(thisvalue) == false){
        $('#message').html("<div class='alert alert-warning alert-dismissable'><button type='button' class='close' data-dismiss='alert' aria-hidden='true'>&times;</button><div class='tac'><div class='text-danger'>"+ _("Please enter a valid Number.") + "</div></div></div>");
    }
    if ( thisvalue == 0){
        $('#message').html("<div class='alert alert-warning alert-dismissable'><button type='button' class='close' data-dismiss='alert' aria-hidden='true'>&times;</button><div class='tac'><div class='text-danger'>"+ _("The value must be greater than zero.") + "</div></div></div>");
    }
}

// Room list
function Transfer(exten, Vtitle) {
    $("#transfer").modal({backdrop: false});
    $("#TrExt").val(exten);
    $("#transfermodalbody").html($("#DialTrans"+exten).html());
}

function valid_transfer() {
    var exten = $("#TrExt").val();
    console.log("extension d'origine pour le transfert = "+exten);
    $.post("index.php", {quietmode: "1", command: "transfer", transfer: "yes", module: "pms", from: exten, to: $("#select"+exten).val() }, function( data ) {

        if(data.status){
            $("#reload_button").show();
            $("#transfer").modal('hide');
        };
    });
}

// DND Toggle
function dnd_status(extension,status) {
    if (status == "NO")
    {
        $.ajax({
            url: "index.php?quietmode=1&module=pms&command=dnd&room_dnd="+extension+"&st=NO",
            dataType:"json",
            success: function (json) {
                if (json.message != null){
                    $("#dnd"+extension).html("<i class='fa fa-user green_text' aria-hidden='true' onclick='dnd_status(\""+extension+"\",\"YES\")'></i>");
                    $("#roomlisttable").bootstrapTable("refresh", "{silent: true}");
                };
            }
        });
    }
    else
    {
        $.ajax({
            url: "index.php?quietmode=1&module=pms&command=dnd&room_dnd="+extension+"&st=YES",
            dataType:"json",
            success: function (json) {
                if (json.message != null){
                    $("#dnd"+extension).html("<i class='fa fa-user red_text' aria-hidden='true' onclick='dnd_status(\""+extension+"\",\"NO\")'></i>");
                    $("#roomlisttable").bootstrapTable("refresh", "{silent: true}");
                };

            }
        });

    }
}

function wu_del(filename){
    $.ajax({
        url: "index.php?quietmode=1&module=pms&command=wu&wu_del="+filename,
        dataType:"json",
        success: function (json) {
            if (json.message != null){

            };
        }
    });
}

// Clean Toggle
function clean_status(extension,st) {
    if (st == "NO"){
        $.post("index.php", {quietmode: "1", command: "clean", module: "pms", room_clean: extension, st: "NO"}, function( data ) {
            if(data.status){
                $("#clean"+extension).html("<i class='fa fa-times green_text' aria-hidden='true' onclick='clean_status(\""+extension+"\",\"YES\")'></i>");
                $("#roomlisttable").bootstrapTable("refresh", "{silent: true}");
            };
        });
    }
    else
    {
        $.post("index.php", {quietmode: "1", command: "clean", module: "pms", room_clean: extension, st: "YES"}, function( data ) {
            if(data.status){
                $("#clean"+extension).html("<i class='fa fa-times red_text' aria-hidden='true' onclick='clean_status(\""+extension+"\",\"NO\")'></i>");
                $("#roomlisttable").bootstrapTable("refresh", "{silent: true}");
            };
        });
    };
}

// Message box in Room List.
function infobox(thisvalue, ext) {
    $("#snd_button").click(function(){
        $.post("index.php", {quietmode: "1", command: "summary", module: "pms", ext: ext}, function( data ) {});
        $("#snd_button").off();
    });
    var detail 		= thisvalue;
    $.post("index.php", {quietmode: "1", command: "cdr", module: "pms", ext: ext}, function( data ) {
        if(data.status){
            $("#info").modal();
            $("#infomodalbody").html(detail+JSON.parse(data.message));
        }
    });
}

function del_rs(extension){
    $.ajax({
        url: "?quietmode=1&module=pms&command=get_maid_services",
        dataType:"json",
        async: false,
        success: function (json) {
            var maid_services = JSON.parse(json.message);
            window.rs_options = "";
            if($.isArray(maid_services)){
                $.each(maid_services, function(idx, detail) {
                    window.rs_options += "<option value='"+detail["service_number"]+"'>"+detail["label"]+"</option>";
                });
            }
        },
    });

    $.ajax({
        url: "index.php?quietmode=1&module=pms&command=delete_rs&delete_rs="+extension,
        dataType:"json",
        success: function (json) {
            list_box_rs  =	"<div class='row'>";
            list_box_rs +=	"<div class='col-md-12'>";
            list_box_rs +=	"<select class='form-control' name='message' id='message'>";
            list_box_rs +=	window.rs_options;
            list_box_rs +=	"</select>";
            list_box_rs +=	"<br>";
            list_box_rs +=	"<button type='button' class='btn btn-primary' onclick='send_rs(\""+extension+"\")'>"+_("Send")+"</button></div></div>";
            $("#msg_rs").html(list_box_rs);
        }
    });
}

function send_rs(extension){
    var message = "";
    $.ajax({
        url: "?quietmode=1&module=pms&command=room_services",
        dataType:"json",
        async: false,
        success: function (json) {
            var room_service = JSON.parse(json.message);
            if(room_service != "none"){
                cur_nbrs = 0;
                $.each(room_service, function(room_ext, v) {
                    cur_nbrs++;
                    if(room_ext == extension){
                        message = v['lab'];
                        $("#msg_rs").html("<li><b>"+message+"</b></li><br><button type='button' class='btn btn-primary' onclick='del_rs(\""+extension+"\")'>"+_("Delete")+"</button>");
                    }
                });
            };
        },
    });

    $.ajax({
        url: "index.php?quietmode=1&display=dashboard&module=pms&command=send_rs&ext="+extension+"&rs="+$("#message").val(),
        dataType:"json",
        success: function (json) {
            if(json.message != "true"){
                console.debug(json);
            }
        }
    });
};

//---------------

// Delete emergency alerts

function delete_emergency_alert(){
    $.ajax({
        url: "index.php?quietmode=1&display=dashboard&module=pms&command=delete_emergency_alert&checked=Ok",
        dataType:"json",
        success: function (json) {
            window.location.reload();
        }
    });
};

//---------------

// Wake up call
$(document).ready(function (){

    var room = $("[name='room']").val();
    if (room == "") {
        $('#modal-container-alert').modal('show');
        $("#add-wu").removeAttr("style").hide();
    }
});

function send_checkout(res_num, extension, ba){
    $.ajax({
        url: "index.php?quietmode=1&display=dashboard&module=pms&command=send_checkout&res_num="+res_num+"&room_num="+extension+"&ba="+ba,
        dataType:"json",
        success: function (json) {

        }
    });
}
function add_wu(){
    var dt_wu = $("[name='date_wu']").val();
    var tm_wu = $("[name='time_wu']").val();
    var dest  = $("[name='room']").val();

    $.post( "index.php", {quietmode: "1", command: "savecall", module: "pms", destination: dest, time: tm_wu, day: dt_wu}, function( data ) {
        if(!data.status) {
            $('#modal-container-warning').modal('show');
            $("#message_warning").html(data.message);
        } else {
            $('#modal-container-success').modal('show');
            $("#message_success").html(_("Alarm clock scheduled"));
        }
        $('#btn_alarm').click();
    })
};
//------------------------------



$(document).ready(

    /* This is the function that will get executed after the DOM is fully loaded */
    function () {
        $("#datepicker_ci").datepicker();
        $("#datepicker_co").datepicker();
        $("#timepicker_ci").timepicker({timeFormat: 'h:ia', step: 5});
        $("#timepicker_co").timepicker({timeFormat: 'h:ia', step: 5});
        $('[data-toggle="tooltip"]').tooltip();
    });



var PresencestateC = UCPMC.extend({
    init: function() {
        this.presenceStates = {};
        this.presenceSpecials = { startSessionStatus: null, endSessionStatus: null };
        this.menu = null;
    },
    poll: function(data) {
        if (data.status) {
            this.menu = data.menu;
            this.statusUpdate(data.presence.State, data.presence.Message);
        }
    },
    displayWidget: function(widget_id,dashboard_id) {
        var self = this;

        $(".grid-stack-item[data-id='"+widget_id+"'][data-rawname='presencestate'] select[name='status']").change(function() {
            var selected = $(this).find("option:selected");
            if (selected !== null) {
                id = $(selected).data('id');

                self.saveState(id);
            }
        });
    },
    displayWidgetSettings: function(widget_id, dashboard_id) {
        var self = this;

        /* Settings changes binds */
        $("div[data-rawname='presencestate'] .widget-settings-content .pssettings select").change(function() {
            self.savePSSettings();
        });
    },
    displaySimpleWidget: function(widget_id) {
        var self = this;
        $(".widget-extra-menu[data-id='"+widget_id+"'] select[name='status']").change(function() {
            var selected = $(this).find("option:selected");
            if (selected !== null) {
                id = $(selected).data('id');

                self.saveState(id);
            }
        });
    },
    displaySimpleWidgetSettings: function(widget_id) {
        this.displayWidgetSettings(widget_id);
    },
    statusUpdate: function(type, message) {
        $(".grid-stack-item[data-rawname='presencestate'] select[name='status']").selectpicker('val', type + (message !== '' ? ' (' + message + ')' : ''));
        $(".widget-extra-menu[data-module='presencestate'] select[name='status']").selectpicker('val', type + (message !== '' ? ' (' + message + ')' : ''));
    },
    saveState: function(id) {
        var self = this;

        data = { state: id };
        data.module = "presencestate";
        data.command = "set";

        $.post(UCP.ajaxUrl, data, null).always(function(data) {
            self.menu = data.poller.menu;
            self.statusUpdate(data.State, data.Message);
        });
    },
    savePSSettings: function() {
        var self = this;

        var data = {};
        data.events = {};

        $("div[data-rawname='presencestate'] .widget-settings-content .pssettings select").each(function( index ) {
            if ($(this).hasClass("event")) {
                data.events[$( this ).attr("name")] = $(this).val();
            } else {
                data[$( this ).attr("name")] = $(this).val();
            }
        });

        data.module = "presencestate";
        data.command = "savesettings";

        $.post(UCP.ajaxUrl, data, null).always(function(data) {
            if (data.status) {
                self.presenceSpecials.startSessionStatus = (data.startsessionstatus !== null) ? data.startsessionstatus.id : null;
                self.presenceSpecials.endSessionStatus = (data.endsessionstatus !== null) ? data.endsessionstatus.id : null;
            } else {
                return false;
            }
        });
    }
});

$(document).ready(function() {
    $(window).bind("beforeunload", function() {
        if ((typeof UCP.Modules.Presencestate !== 'undefined') && UCP.Modules.Presencestate.presenceSpecials.endSessionStatus !== null && navigator.onLine) {
            $.ajax({
                url: UCP.ajaxUrl + "?module=presencestate&command=set",
                type: "POST",
                data: { state: UCP.Modules.Presencestate.presenceSpecials.endSessionStatus },
                async: false, //block the browser from closing to send our request, hacky I know
                timeout: 2000
            });
        }
    });
});

$(document).on("logIn", function() {
    if (typeof UCP.Modules.Presencestate !== 'undefined'){
        UCP.Modules.Presencestate.presenceSpecials.startSessionStatus = UCP.Modules.Presencestate.staticsettings.startSessionStatus;
        UCP.Modules.Presencestate.presenceSpecials.endSessionStatus = UCP.Modules.Presencestate.staticsettings.endSessionStatus;
        if (UCP.Modules.Presencestate.presenceSpecials.startSessionStatus !== null && navigator.onLine) {
            $.ajax({
                url: UCP.ajaxUrl + "?module=presencestate&command=set",
                type: "POST",
                data: { state: UCP.Modules.Presencestate.presenceSpecials.startSessionStatus }
            });
        }
    }
});

/**
 *
 * @preserve CanvasJS HTML5 & JavaScript Charts - v1.9.10 GA - https://canvasjs.com/
 * Copyright 2017 fenopix
 *
 *  --------------------- License Information --------------------
 * CanvasJS is a commercial product which requires purchase of license. Without a commercial license you can use it for evaluation purposes for upto 30 days. Please refer to the following link for further details.
 *     https://canvasjs.com/license-canvasjs/
 *
 *
 */


/* jshint -W099 */ //Ignore warning "Mixed Spaces and Tabs"

(function () {

    var isDebugMode = false;
    var global = {};

    var isCanvasSupported = !!document.createElement("canvas").getContext;
    //isCanvasSupported = false;

    //Default values for all Chart Elements that can be set by the user. CanvasJSObject.setOptions looks into this while setting the default/user-defined values.
    var defaultOptions = {
        Chart: {
            width: 500,
            height: 400,
            zoomEnabled: false,
            zoomType: "x",
            backgroundColor: "white",
            theme: "theme1",
            animationEnabled: false,
            animationDuration: 1200,

            dataPointWidth: null,
            dataPointMinWidth: null,
            dataPointMaxWidth: null,

            colorSet: "colorSet1",
            culture: "en",
            creditHref: "",
            creditText: "CanvasJS",
            interactivityEnabled: true,
            exportEnabled: false,
            exportFileName: "Chart",

            rangeChanging: null,
            rangeChanged: null,


            publicProperties: {
                "title": "readWrite",
                "subtitles": "readWrite",
                "toolTip": "readWrite",
                "legend": "readWrite",
                "axisX": "readWrite",
                "axisY": "readWrite",
                "axisX2": "readWrite",
                "axisY2": "readWrite",
                "data": "readWrite",

                "options": "readWrite",
                "bounds": "readOnly",
                "container": "readOnly"
            }
        },

        Title: {
            padding: 0,
            text: null,
            verticalAlign: "top",//top, center, bottom
            horizontalAlign: "center",//left, center, right
            fontSize: 20,//in pixels
            fontFamily: "Calibri",
            fontWeight: "normal", //normal, bold, bolder, lighter,
            fontColor: "black",
            fontStyle: "normal", // normal, italic, oblique

            borderThickness: 0,
            borderColor: "black",
            cornerRadius: 0,
            backgroundColor: isCanvasSupported ? "transparent" : null,
            margin: 5,
            wrap: true,
            maxWidth: null,

            dockInsidePlotArea: false,


            publicProperties: {
                "options": "readWrite",
                "bounds": "readOnly",
                "chart": "readOnly"
            }
            //toolTipContent: null//string - To be implemented (TBI)
        },

        Subtitle: {
            padding: 0,
            text: null,
            verticalAlign: "top",//top, center, bottom
            horizontalAlign: "center",//left, center, right
            fontSize: 14,//in pixels
            fontFamily: "Calibri",
            fontWeight: "normal", //normal, bold, bolder, lighter,
            fontColor: "black",
            fontStyle: "normal", // normal, italic, oblique

            borderThickness: 0,
            borderColor: "black",
            cornerRadius: 0,
            backgroundColor: null,
            margin: 2,
            wrap: true,
            maxWidth: null,

            dockInsidePlotArea: false,


            publicProperties: {
                "options": "readWrite",
                "bounds": "readOnly",
                "chart": "readOnly"
            }
            //toolTipContent: null//string - To be implemented (TBI)
        },

        Legend: {
            name: null,
            verticalAlign: "center",
            horizontalAlign: "right",

            fontSize: 14,//in pixels
            fontFamily: "calibri",
            fontWeight: "normal", //normal, bold, bolder, lighter,
            fontColor: "black",
            fontStyle: "normal", // normal, italic, oblique

            cursor: null,
            itemmouseover: null,
            itemmouseout: null,
            itemmousemove: null,
            itemclick: null,

            dockInsidePlotArea: false,
            reversed: false,

            backgroundColor: isCanvasSupported ? "transparent" : null,
            borderColor: isCanvasSupported ? "transparent" : null,
            borderThickness: 0,
            cornerRadius: 0,

            maxWidth: null,
            maxHeight: null,
            markerMargin: null,

            itemMaxWidth: null,
            itemWidth: null,
            itemWrap: true,
            itemTextFormatter: null,


            publicProperties: {
                "options": "readWrite",

                "bounds": "readOnly",
                "chart": "readOnly"
            }
        },

        ToolTip: {
            enabled: true,
            shared: false,
            animationEnabled: true,
            content: null,
            contentFormatter: null,

            reversed: false,

            backgroundColor: isCanvasSupported ? "rgba(255,255,255,.9)" : "rgb(255,255,255)",

            borderColor: null,
            borderThickness: 2, //in pixels
            cornerRadius: 5, // in pixels

            fontSize: 14, // in pixels
            fontColor: "black",
            fontFamily: "Calibri, Arial, Georgia, serif;",
            fontWeight: "normal", //normal, bold, bolder, lighter,
            fontStyle: "italic",  // normal, italic, oblique

            publicProperties: {
                "options": "readWrite",

                "chart": "readOnly"
            }
        },

        Axis: {
            minimum: null, //Minimum value to be shown on the Axis
            maximum: null, //Minimum value to be shown on the Axis
            viewportMinimum: null,
            viewportMaximum: null,
            interval: null, // Interval for tick marks and grid lines
            intervalType: null, //number, millisecond, second, minute, hour, day, month, year
            reversed: false,
            logarithmic: false,
            logarithmBase: 10,

            title: null, // string
            titleFontColor: "black",
            titleFontSize: 20,
            titleFontFamily: "arial",
            titleFontWeight: "normal",
            titleFontStyle: "normal",
            titleWrap: true,
            titleMaxWidth: null,
            titleBackgroundColor: isCanvasSupported ? "transparent" : null,
            titleBorderColor: isCanvasSupported ? "transparent" : null,
            titleBorderThickness: 0,
            titleCornerRadius: 0,

            labelAngle: 0,
            labelFontFamily: "arial",
            labelFontColor: "black",
            labelFontSize: 12,
            labelFontWeight: "normal",
            labelFontStyle: "normal",
            labelAutoFit: true,
            labelWrap: true,
            labelMaxWidth: null,//null for auto
            labelFormatter: null,
            labelBackgroundColor: isCanvasSupported ? "transparent" : null,
            labelBorderColor: isCanvasSupported ? "transparent" : null,
            labelBorderThickness: 0,
            labelCornerRadius: 0,

            prefix: "",
            suffix: "",

            includeZero: true, //Applies only for axisY. Ignored in axisX.

            tickLength: 5,
            tickColor: "black",
            tickThickness: 1,

            lineColor: "black",
            lineThickness: 1,
            lineDashType: "solid",

            gridColor: "A0A0A0",
            gridThickness: 0,
            gridDashType: "solid",

            interlacedColor: isCanvasSupported ? "transparent" : null,

            valueFormatString: null,

            margin: 2,

            stripLines: [], // Just a placeholder. Does not have any effect on the actual number of striplines


            publicProperties: {
                "options": "readWrite",

                "bounds": "readOnly",
                "chart": "readOnly"
            }
        },

        StripLine: {
            value: null,
            startValue: null,
            endValue: null,

            color: "orange",
            opacity: null,
            thickness: 2,
            lineDashType: "solid",
            label: "",
            labelPlacement: "inside",//"outside"
            labelAlign: "far",//"near" , "center" , "far"
            labelWrap: true,
            labelMaxWidth: null,
            labelBackgroundColor: isCanvasSupported ? "transparent" : null,
            labelBorderColor: isCanvasSupported ? "transparent" : null,
            labelBorderThickness: 0,
            labelCornerRadius: 0,
            labelFontFamily: "arial",
            labelFontColor: "orange",
            labelFontSize: 12,
            labelFontWeight: "normal",
            labelFontStyle: "normal",
            labelFormatter: null,

            showOnTop: false,

            publicProperties: {
                "options": "readWrite",

                "axis": "readOnly",
                "bounds": "readOnly",
                "chart": "readOnly"
            }
        },

        DataSeries: {
            name: null,
            dataPoints: null,
            label: "",
            bevelEnabled: false,
            highlightEnabled: true,

            cursor: "default",

            indexLabel: "",
            indexLabelPlacement: "auto",  //inside, outside, auto
            indexLabelOrientation: "horizontal",
            indexLabelFontColor: "black",
            indexLabelFontSize: 12,
            indexLabelFontStyle: "normal", //   italic ,oblique, normal
            indexLabelFontFamily: "Arial", 	// fx: Arial Verdana "Courier New" Serif
            indexLabelFontWeight: "normal", 	// bold ,bolder, lighter, normal
            indexLabelBackgroundColor: null,
            indexLabelLineColor: "gray",
            indexLabelLineThickness: 1,
            indexLabelLineDashType: "solid",
            indexLabelMaxWidth: null,
            indexLabelWrap: true,
            indexLabelFormatter: null,

            lineThickness: 2,
            lineDashType: "solid",
            connectNullData: false,
            nullDataLineDashType: "dash",

            color: null,
            lineColor: null,
            risingColor: "white",
            fillOpacity: null,

            startAngle: 0,

            radius: null,
            innerRadius: null,

            type: "column", //line, column, bar, area, scatter stackedColumn, stackedBar, stackedArea, stackedColumn100, stackedBar100, stackedArea100, pie, doughnut
            xValueType: "number", //number, dateTime
            axisXType: "primary",
            axisYType: "primary",
            axisXIndex: 0,
            axisYIndex: 0,

            xValueFormatString: null,
            yValueFormatString: null,
            zValueFormatString: null,
            percentFormatString: null,

            showInLegend: null,
            legendMarkerType: null,
            legendMarkerColor: null,
            legendText: null,
            legendMarkerBorderColor: isCanvasSupported ? "transparent" : null,
            legendMarkerBorderThickness: 0,

            markerType: "circle", //none, circle, square, cross, triangle, line
            markerColor: null,
            markerSize: null,
            markerBorderColor: isCanvasSupported ? "transparent" : null,
            markerBorderThickness: 0,
            //animationEnabled: true,
            mouseover: null,
            mouseout: null,
            mousemove: null,
            click: null,
            toolTipContent: null,

            visible: true,

            publicProperties: {
                "options": "readWrite",
                "axisX": "readWrite",
                "axisY": "readWrite",
                "chart": "readOnly"
            }
        },

        //Private
        TextBlock: {
            x: 0,
            y: 0,
            width: null,//read only
            height: null,//read only
            maxWidth: null,
            maxHeight: null,
            padding: 0,
            angle: 0,
            text: "",
            horizontalAlign: "center",//left, center, right
            fontSize: 12,//in pixels
            fontFamily: "calibri",
            fontWeight: "normal", //normal, bold, bolder, lighter,
            fontColor: "black",
            fontStyle: "normal", // normal, italic, oblique

            borderThickness: 0,
            borderColor: "black",
            cornerRadius: 0,
            backgroundColor: null,
            textBaseline: "top"
        },

        CultureInfo: {
            decimalSeparator: ".",
            digitGroupSeparator: ",",
            zoomText: "Zoom",
            panText: "Pan",
            resetText: "Reset",

            menuText: "More Options",
            saveJPGText: "Save as JPEG",
            savePNGText: "Save as PNG",
            printText: "Print",

            days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
            shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],

            months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
            shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
        }
    };

    //#region Cultures

    var cultures = {
        "en": {
            //Derives from the default options
        }//,
        //"es": {
        //    decimalSeparator: ",",
        //    digitGroupSeparator: ".",
        //    zoomText: "zoom",
        //    panText: "pan",
        //    resetText: "reset",
        //    days: ["domingo", "lunes", "martes", "mircoles", "jueves", "viernes", "sbado"],
        //}
    };

    //#endregion Cultures

    //#region Themes

    var colorSets = {

        "colorSet1": [
            "#369EAD",
            "#C24642",
            "#7F6084",
            //"#96C412",
            "#86B402",
            "#A2D1CF",
            //"#D8C641",
            "#C8B631",
            "#6DBCEB",
            //"#4A4946",
            "#52514E",
            "#4F81BC",
            "#A064A1",
            "#F79647"
        ],
        "colorSet2": [
            "#4F81BC",
            "#C0504E",
            "#9BBB58",
            "#23BFAA",
            //"#FAA586",
            "#8064A1",
            "#4AACC5",
            "#F79647",
            //"#77AA33",
            //"#7F6084"
            "#33558B"
        ],
        "colorSet3": [
            "#8CA1BC",
            "#36845C",
            "#017E82",
            "#8CB9D0",
            "#708C98",
            "#94838D",
            "#F08891",
            "#0366A7",
            "#008276",
            "#EE7757",
            "#E5BA3A",
            "#F2990B",
            "#03557B",
            "#782970"
        ]//,
        //"colorSet4": [
        //    "#3698C5",
        //    "#009B8D",
        //    "#F1D691",
        //    "#F8B90C",
        //    "#0081B8",
        //    "#5B5A96",
        //    "#ACBDD1",
        //    "#88A891",
        //    "#39969D",
        //    "#AECEDD",
        //    "#A0B2BC",
        //    "#BBAEB7",
        //    "#A0C65F",
        //    "#EEA6AA",
        //    "#3798C5"
        //],
        //"colorSet5": [
        //    "#88ADBF",
        //    "#84C336",
        //    "#7B91C3",
        //    "#4661EE",
        //    "#EC5657",
        //    "#1BCDD1",
        //    "#8FAABB",
        //    "#B08BEB",
        //    "#3EA0DD",
        //    "#F5A52A",
        //    "#23BFAA",
        //    "#FAA586",
        //    "#EB8CC6"
        //]

    };

    var themes =
        {
            "theme1": {
                Chart:
                    {
                        colorSet: "colorSet1"
                    },
                Title: {
                    fontFamily: isCanvasSupported ? "Calibri, Optima, Candara, Verdana, Geneva, sans-serif" : "calibri",
                    fontSize: 33,
                    fontColor: "#3A3A3A",
                    fontWeight: "bold",
                    verticalAlign: "top",
                    margin: 5
                },
                Subtitle: {
                    fontFamily: isCanvasSupported ? "Calibri, Optima, Candara, Verdana, Geneva, sans-serif" : "calibri",
                    fontSize: 16,
                    fontColor: "#3A3A3A",
                    fontWeight: "bold",
                    verticalAlign: "top",
                    margin: 5
                },
                Axis: {
                    titleFontSize: 26,
                    //titleFontColor: "rgb(98,98,98)",
                    titleFontColor: "#666666",
                    //titleFontFamily: "arial black",
                    //titleFontFamily: "Verdana, Geneva, Calibri, sans-serif",
                    titleFontFamily: isCanvasSupported ? "Calibri, Optima, Candara, Verdana, Geneva, sans-serif" : "calibri",
                    //titleFontWeight: "bold",

                    //labelFontFamily: "Times New Roman, Times, serif",
                    labelFontFamily: isCanvasSupported ? "Calibri, Optima, Candara, Verdana, Geneva, sans-serif" : "calibri",
                    //labelFontFamily: "Helvetica Neue, Helvetica",
                    labelFontSize: 18,
                    labelFontColor: "grey",
                    //labelFontWeight: "bold",
                    tickColor: "#BBBBBB",
                    tickThickness: 2,
                    gridThickness: 2,
                    gridColor: "#BBBBBB",
                    lineThickness: 2,
                    lineColor: "#BBBBBB"
                },
                Legend: {
                    verticalAlign: "bottom",
                    horizontalAlign: "center",
                    fontFamily: isCanvasSupported ? "monospace, sans-serif,arial black" : "calibri"
                },
                DataSeries: {
                    //bevelEnabled: true,
                    indexLabelFontColor: "grey",
                    //indexLabelFontFamily: "Trebuchet MS, monospace, Courier New, Courier",
                    indexLabelFontFamily: isCanvasSupported ? "Calibri, Optima, Candara, Verdana, Geneva, sans-serif" : "calibri",
                    //indexLabelFontWeight: "bold",
                    indexLabelFontSize: 18,
                    //indexLabelLineColor: "lightgrey",
                    indexLabelLineThickness: 1
                }
            },

            "theme2": {
                Chart:
                    {
                        colorSet: "colorSet2"
                    },
                Title: {
                    fontFamily: "impact, charcoal, arial black, sans-serif",
                    fontSize: 32,//fontColor: "rgb(58,58,58)",
                    fontColor: "#333333",
                    verticalAlign: "top",
                    margin: 5
                },
                Subtitle: {
                    fontFamily: "impact, charcoal, arial black, sans-serif",
                    fontSize: 14,//fontColor: "rgb(58,58,58)",
                    fontColor: "#333333",
                    verticalAlign: "top",
                    margin: 5
                },
                Axis: {
                    titleFontSize: 22,
                    titleFontColor: "rgb(98,98,98)",
                    //titleFontFamily: "arial black",
                    titleFontFamily: isCanvasSupported ? "monospace, sans-serif,arial black" : "arial",
                    titleFontWeight: "bold",


                    labelFontFamily: isCanvasSupported ? "monospace, Courier New, Courier" : "arial",
                    //labelFontFamily: "Helvetica Neue, Helvetica",
                    labelFontSize: 16,
                    labelFontColor: "grey",
                    labelFontWeight: "bold",
                    tickColor: "grey",
                    tickThickness: 2,
                    gridThickness: 2,
                    gridColor: "grey",
                    lineColor: "grey",
                    lineThickness: 0
                },
                Legend: {
                    verticalAlign: "bottom",
                    horizontalAlign: "center",
                    fontFamily: isCanvasSupported ? "monospace, sans-serif,arial black" : "arial"
                },
                DataSeries: {
                    indexLabelFontColor: "grey",
                    //indexLabelFontFamily: "Trebuchet MS, monospace, Courier New, Courier",
                    indexLabelFontFamily: isCanvasSupported ? "Courier New, Courier, monospace" : "arial",
                    indexLabelFontWeight: "bold",
                    indexLabelFontSize: 18,
                    //indexLabelLineColor: "lightgrey",
                    indexLabelLineThickness: 1
                }
            },

            "theme3": {
                Chart:
                    {
                        colorSet: "colorSet1"
                    },
                Title: {
                    fontFamily: isCanvasSupported ? "Candara, Optima, Trebuchet MS, Helvetica Neue, Helvetica, Trebuchet MS, serif" : "calibri",
                    fontSize: 32,
                    fontColor: "#3A3A3A",
                    fontWeight: "bold",
                    verticalAlign: "top",
                    margin: 5
                },
                Subtitle: {
                    fontFamily: isCanvasSupported ? "Candara, Optima, Trebuchet MS, Helvetica Neue, Helvetica, Trebuchet MS, serif" : "calibri",
                    fontSize: 16,
                    fontColor: "#3A3A3A",
                    fontWeight: "bold",
                    verticalAlign: "top",
                    margin: 5
                },
                Axis: {
                    titleFontSize: 22,
                    titleFontColor: "rgb(98,98,98)",
                    //titleFontFamily: "arial black",
                    titleFontFamily: isCanvasSupported ? "Verdana, Geneva, Calibri, sans-serif" : "calibri",
                    //titleFontWeight: "bold",

                    //labelFontFamily: "Times New Roman, Times, serif",
                    labelFontFamily: isCanvasSupported ? "Calibri, Optima, Candara, Verdana, Geneva, sans-serif" : "calibri",
                    //labelFontFamily: "Helvetica Neue, Helvetica",
                    labelFontSize: 18,
                    labelFontColor: "grey",
                    //labelFontWeight: "bold",
                    tickColor: "grey",
                    tickThickness: 2,
                    gridThickness: 2,
                    gridColor: "grey",
                    lineThickness: 2,
                    lineColor: "grey"
                },
                Legend: {
                    verticalAlign: "bottom",
                    horizontalAlign: "center",
                    fontFamily: isCanvasSupported ? "monospace, sans-serif,arial black" : "calibri"
                },
                DataSeries: {
                    bevelEnabled: true,
                    indexLabelFontColor: "grey",
                    //indexLabelFontFamily: "Trebuchet MS, monospace, Courier New, Courier",
                    indexLabelFontFamily: isCanvasSupported ? "Candara, Optima, Calibri, Verdana, Geneva, sans-serif" : "calibri",
                    //indexLabelFontWeight: "bold",
                    indexLabelFontSize: 18,
                    indexLabelLineColor: "lightgrey",
                    indexLabelLineThickness: 2
                }
            }
        };

    //#endregion Themes

    var constants = {
        numberDuration: 1,
        yearDuration: 1000 * 60 * 60 * 24 * 364,
        monthDuration: 1000 * 60 * 60 * 24 * 30,
        weekDuration: 1000 * 60 * 60 * 24 * 7,
        dayDuration: 1000 * 60 * 60 * 24,
        hourDuration: 1000 * 60 * 60,
        minuteDuration: 1000 * 60,
        secondDuration: 1000,
        millisecondDuration: 1,

        dayOfWeekFromInt: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"]
    };

    //#region Static Methods & variables

    function extend(derived, base) {
        derived.prototype = inherit(base.prototype);
        derived.prototype.constructor = derived;
        derived.base = base.prototype;
    }

    function inherit(proto) {
        function F() { }
        F.prototype = proto;
        return new F();
    }

    function addToDateTime(dateTime, num, type) {

        if (type === "millisecond")
            dateTime.setMilliseconds(dateTime.getMilliseconds() + 1 * num);
        else if (type === "second")
            dateTime.setSeconds(dateTime.getSeconds() + 1 * num);
        else if (type === "minute")
            dateTime.setMinutes(dateTime.getMinutes() + 1 * num);
        else if (type === "hour")
            dateTime.setHours(dateTime.getHours() + 1 * num);
        else if (type === "day")
            dateTime.setDate(dateTime.getDate() + 1 * num);
        else if (type === "week")
            dateTime.setDate(dateTime.getDate() + 7 * num);
        else if (type === "month")
            dateTime.setMonth(dateTime.getMonth() + 1 * num);
        else if (type === "year")
            dateTime.setFullYear(dateTime.getFullYear() + 1 * num);

        return dateTime;
    }

    function convertToNumber(num, type) {
        return constants[type + "Duration"] * num;
    }

    function pad(value, length) {
        var isNegative = false;
        if (value < 0) {
            isNegative = true;
            value *= -1;
        }

        value = "" + value;
        length = !length ? 1 : length;

        while (value.length < length) value = "0" + value;

        return isNegative ? "-" + value : value;
    }

    function trimString(str) {
        if (!str)
            return str;

        str = str.replace(/^\s\s*/, '');
        var ws = /\s/;
        var i = str.length;
        while (ws.test(str.charAt(--i))) { }
        return str.slice(0, i + 1);
    }

    function extendCtx(context) {
        context.roundRect = function (x, y, width, height, radius, borderThickness, backgroundColor, borderColor) {
            ///<signature>
            ///<summary>Creates a rounded rectangle with given fill/stroke parameters</summary>
            ///<param name="x" type="number">x value</param>
            ///<param name="y" type="number">y value</param>
            ///<param name="width" type="number">Border Width</param>
            ///<param name="height" type="number">Border Height</param>
            ///<param name="radius" type="number">Border CornerRadius</param>
            ///<param name="borderThickness" type="number">Border Thickess</param>
            ///<param name="backgroundColor" type="number">Background Color</param>
            ///<param name="borderColor" type="number">Border Color</param>
            ///</signature>

            if (backgroundColor) {
                this.fillStyle = backgroundColor;
            }

            if (borderColor) {
                this.strokeStyle = borderColor;
            }

            //if (typeof stroke == "undefined") {
            //	stroke = true;
            //}

            if (typeof radius === "undefined") {
                radius = 5;
            }

            this.lineWidth = borderThickness;

            this.beginPath();
            this.moveTo(x + radius, y);
            this.lineTo(x + width - radius, y);
            this.quadraticCurveTo(x + width, y, x + width, y + radius);
            this.lineTo(x + width, y + height - radius);
            this.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
            this.lineTo(x + radius, y + height);
            this.quadraticCurveTo(x, y + height, x, y + height - radius);
            this.lineTo(x, y + radius);
            this.quadraticCurveTo(x, y, x + radius, y);
            this.closePath();

            if (backgroundColor) {
                this.fill();
            }

            if (borderColor && borderThickness > 0) {
                this.stroke();
            }
        };
    }

    function compareNumbers(a, b) {
        return a - b;
    }

    function compareDataPointX(dataPoint1, dataPoint2) {
        return dataPoint1.x - dataPoint2.x;
    }

    function intToHexColorString(num) {
        var r = ((num & 0xFF0000) >> 16).toString(16);
        var g = ((num & 0x00FF00) >> 8).toString(16);
        var b = ((num & 0x0000FF) >> 0).toString(16);

        r = r.length < 2 ? "0" + r : r;
        g = g.length < 2 ? "0" + g : g;
        b = b.length < 2 ? "0" + b : b;

        return "#" + r + g + b;
    }

    function RGBToInt(r, g, b) {
        var num = (r << 16) | (g << 8) | (b);

        return num;
    }

    function intToRGB(num) {
        var rgb = [];
        var r = ((num & 0xFF0000) >> 16);
        var g = ((num & 0x00FF00) >> 8);
        var b = ((num & 0x0000FF) >> 0);

        //r = r.length < 2 ? "0" + r : r;
        //g = g.length < 2 ? "0" + g : g;
        //b = b.length < 2 ? "0" + b : b;

        rgb[0] = r;
        rgb[1] = g;
        rgb[2] = b;

        return rgb;
    }

    function arrayIndexOf(elt /*, from*/) {
        var len = this.length >>> 0;

        var from = Number(arguments[1]) || 0;
        from = (from < 0)
            ? Math.ceil(from)
            : Math.floor(from);
        if (from < 0)
            from += len;

        for (; from < len; from++) {
            if (from in this &&
                this[from] === elt)
                return from;
        }
        return -1;
    };

    function isNullOrUndefined(value) {
        return value === null || typeof (value) === "undefined";
    }

    //IE8- Fix: indexOf is not supported in IE8- for arrays
    function addArrayIndexOf(obj) {
        if (!obj.indexOf) {
            obj.indexOf = arrayIndexOf;
        }

        return obj;
    }

    function firstCharToLower(str) {
        if (!str || str.length === 0)
            return;

        var result = str.charAt(0).toLowerCase();

        if (str.length > 1)
            result = result.concat(str.slice(1));

        return result;
    }

    var fontHeightInPixels = {};
    var textMeasureEl = null;
    function getFontHeightInPixels(fontFamily, fontSize, fontWeight) {

        //return fontSize;

        fontWeight = fontWeight || "normal";

        var entry = fontFamily + "_" + fontSize + "_" + fontWeight;
        var height = fontHeightInPixels[entry];

        if (isNaN(height)) {
            try {
                var style = "position:absolute; left:0px; top:-20000px; padding:0px;margin:0px;border:none;white-space:pre;line-height:normal;" + "font-family:" + fontFamily + "; " + "font-size:" + fontSize + "px; font-weight:" + fontWeight + ";";
                //console.log(style);
                if (!textMeasureEl) {
                    var body = document.body;
                    textMeasureEl = document.createElement("span");
                    textMeasureEl.innerHTML = "";
                    var textNode = document.createTextNode("Mpgyi");
                    textMeasureEl.appendChild(textNode);
                    body.appendChild(textMeasureEl);
                }

                textMeasureEl.style.display = "";
                textMeasureEl.setAttribute("style", style);

                height = Math.round(textMeasureEl.offsetHeight);
                textMeasureEl.style.display = "none";
                //body.removeChild(tempDiv);

                //if (window.console)
                //	window.console.log(fontSize + ": " + height);
            }
            catch (e) {
                height = Math.ceil(fontSize * 1.1);
            }

            height = Math.max(height, fontSize);

            fontHeightInPixels[entry] = height;
        }

        return height;
    }

    function getLineDashArray(lineDashType, lineThickness) {
        var lineDashArray = [];

        lineDashType = lineDashType || "solid";

        var lineDashTypeMap = {
            "solid": [],
            "shortDash": [3, 1],
            "shortDot": [1, 1],
            "shortDashDot": [3, 1, 1, 1],
            "shortDashDotDot": [3, 1, 1, 1, 1, 1],
            "dot": [1, 2],
            "dash": [4, 2],
            "dashDot": [4, 2, 1, 2],
            "longDash": [8, 2],
            "longDashDot": [8, 2, 1, 2],
            "longDashDotDot": [8, 2, 1, 2, 1, 2]
        };

        lineDashArray = lineDashTypeMap[lineDashType];

        if (lineDashArray) {

            for (var i = 0; i < lineDashArray.length; i++) {
                lineDashArray[i] *= lineThickness;
            }
        } else
            lineDashArray = [];

        return lineDashArray;
    }

    //userCapture is optional. Defaults to false
    function addEvent(obj, eventType, fn, useCapture) {
        if (obj.addEventListener) {
            obj.addEventListener(eventType, fn, useCapture || false);
            return fn;
        }
        else if (obj.attachEvent) {
            var f = function (e) {
                e = e || window.event;
                e.preventDefault = e.preventDefault || function () { e.returnValue = false; };
                e.stopPropagation = e.stopPropagation || function () { e.cancelBubble = true; };
                fn.call(obj, e);
            };
            obj.attachEvent("on" + eventType, f);
            return f;
        } else
            return false;
    }

    function removeEvent(obj, eventType, fn) {
        var f;
        if (obj.removeEventListener) {
            obj.removeEventListener(eventType, fn);
        }
        else if (obj.detachEvent) {
            obj.detachEvent("on" + eventType, fn);
        } else
            return false;
    }

    //#region formatting functions/methods
    var dateFormat = function () {
        var reg = /D{1,4}|M{1,4}|Y{1,4}|h{1,2}|H{1,2}|m{1,2}|s{1,2}|f{1,3}|t{1,2}|T{1,2}|K|z{1,3}|"[^"]*"|'[^']*'/g;

        var defDays = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"];
        var defShortDays = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"];

        var defMonths = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];
        var defShortMonths = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];

        var timezone = /\b(?:[PMCEA][SDP]T|(?:Pacific|Mountain|Central|Eastern|Atlantic) (?:Standard|Daylight|Prevailing) Time|(?:GMT|UTC)(?:[-+]\d{4})?)\b/g;
        var timezoneClip = /[^-+\dA-Z]/g;

        return function (dt, formatString, cultureInfo) {

            var days = cultureInfo ? cultureInfo.days : defDays;
            var months = cultureInfo ? cultureInfo.months : defMonths;

            var shortDays = cultureInfo ? cultureInfo.shortDays : defShortDays;
            var shortMonths = cultureInfo ? cultureInfo.shortMonths : defShortMonths;

            var result = "";
            var utc = false;

            dt = dt && dt.getTime ? dt : dt ? new Date(dt) : new Date;
            if (isNaN(dt)) throw SyntaxError("invalid date");

            if (formatString.slice(0, 4) === "UTC:") {
                formatString = formatString.slice(4);
                utc = true;
            }

            var pre = utc ? "getUTC" : "get";
            var date = dt[pre + "Date"]();
            var day = dt[pre + "Day"]();
            var month = dt[pre + "Month"]();
            var year = dt[pre + "FullYear"]();
            var hours = dt[pre + "Hours"]();
            var minutes = dt[pre + "Minutes"]();
            var seconds = dt[pre + "Seconds"]();
            var milliseconds = dt[pre + "Milliseconds"]();
            var offset = utc ? 0 : dt.getTimezoneOffset();

            result = formatString.replace(reg, function (key) {

                switch (key) {

                    case "D":
                        return date;
                    case "DD":
                        return pad(date, 2);
                    case "DDD":
                        return shortDays[day];
                    case "DDDD":
                        return days[day];


                    case "M":
                        return month + 1;
                    case "MM":
                        return pad(month + 1, 2);
                    case "MMM":
                        return shortMonths[month];
                    case "MMMM":
                        return months[month];


                    case "Y":
                        return parseInt(String(year).slice(-2));
                    case "YY":
                        return pad(String(year).slice(-2), 2);
                    case "YYY":
                        return pad(String(year).slice(-3), 3);
                    case "YYYY":
                        return pad(year, 4);


                    case "h":
                        return hours % 12 || 12;
                    case "hh":
                        return pad(hours % 12 || 12, 2);


                    case "H":
                        return hours;
                    case "HH":
                        return pad(hours, 2);

                    case "m":
                        return minutes;
                    case "mm":
                        return pad(minutes, 2);


                    case "s":
                        return seconds;
                    case "ss":
                        return pad(seconds, 2);

                    case "f":
                        return String(milliseconds).slice(0, 1);
                    case "ff":
                        return pad(String(milliseconds).slice(0, 2), 2);
                    case "fff":
                        return pad(String(milliseconds).slice(0, 3), 3);


                    case "t":
                        return hours < 12 ? "a" : "p";
                    case "tt":
                        return hours < 12 ? "am" : "pm";
                    case "T":
                        return hours < 12 ? "A" : "P";
                    case "TT":
                        return hours < 12 ? "AM" : "PM";


                    case "K":
                        return utc ? "UTC" : (String(dt).match(timezone) || [""]).pop().replace(timezoneClip, ""); // Time Zone;
                    case "z":
                        return (offset > 0 ? "-" : "+") + Math.floor(Math.abs(offset) / 60); // Hour Offset from UTC without padding
                    case "zz":
                        return (offset > 0 ? "-" : "+") + pad(Math.floor(Math.abs(offset) / 60), 2); // Hour Offset from UTC with padding
                    case "zzz":
                        return (offset > 0 ? "-" : "+") + pad(Math.floor(Math.abs(offset) / 60), 2) + pad(Math.abs(offset) % 60, 2); // Hour and Minute Offset from UTC with padding

                    default:
                        return key.slice(1, key.length - 1);

                }
            });

            return result;
        };
    }();


    var numberFormat = function (v, fs, cultureInfo) {
        if (v === null)
            return "";

        v = Number(v);
        var isNegative = v < 0 ? true : false;
        if (isNegative) v *= -1;

        var decimalSeparator = cultureInfo ? cultureInfo.decimalSeparator : ".";
        var digitGroupSeparator = cultureInfo ? cultureInfo.digitGroupSeparator : ",";

        var vString = "";
        fs = String(fs);
        var multiplier = 1;
        var temp;
        var result = "";

        var matches = "";
        var decimalPosition = -1;
        var fsBeforeDecimal = [];
        var fsAfterDecimal = [];
        var noPhBeforeDecimal = 0; // Number of Placeholders before Decimal
        var noPhAfterDecimal = 0; // Number of Placeholders after Decimal
        var noComma = 0;
        var isScientificNotation = false;
        var exponent = 0;

        matches = fs.match(/"[^"]*"|'[^']*'|[eE][+-]*[0]+|[,]+[.]||./g);
        //window.console.log(matches + " = " + matches.length);
        var match = null;

        for (var i = 0; matches && i < matches.length; i++) {
            match = matches[i];

            if (match === "." && decimalPosition < 0) {
                decimalPosition = i;
                continue;
            } else if (match === "%") {
                multiplier *= 100;
            } else if (match === "") {
                multiplier *= 1000;
                continue;
            } else if (match[0] === "," && match[match.length - 1] === ".") {
                multiplier /= Math.pow(1000, match.length - 1);
                decimalPosition = i + match.length - 1;
                continue;
            } else if ((match[0] === "E" || match[0] === "e") && match[match.length - 1] === "0") {
                isScientificNotation = true;
            }

            if (decimalPosition < 0) {
                fsBeforeDecimal.push(match);
                if (match === "#" || match === "0")
                    noPhBeforeDecimal++;
                else if (match === ",")
                    noComma++;
            }
            else {
                fsAfterDecimal.push(match);
                if (match === "#" || match === "0")
                    noPhAfterDecimal++;
            }
        }

        if (isScientificNotation) {
            var integer = Math.floor(v);
            var noOfZerosAfterDecimal = -Math.floor(Math.log(v) / Math.LN10 + 1);
            exponent = v === 0 ? 0 : integer === 0 ? -(noPhBeforeDecimal + noOfZerosAfterDecimal) : String(integer).length - noPhBeforeDecimal;
            multiplier /= Math.pow(10, exponent);
        }

        v *= multiplier;

        if (decimalPosition < 0)
            decimalPosition = i;

        vString = v.toFixed(noPhAfterDecimal);
        var split = vString.split(".");
        //window.console.log(split);
        var vStringBeforeDecimal = (split[0] + "").split("");
        var vStringAfterDecimal = (split[1] + "").split("");

        if (vStringBeforeDecimal && vStringBeforeDecimal[0] === "0")
            vStringBeforeDecimal.shift();

        //window.console.log(fsBeforeDecimal + "<---------->" + fsAfterDecimal + " &        " + vStringBeforeDecimal + "<---------->" + vStringAfterDecimal);

        var noPhProcessed = 0;
        var noDigitsAdded = 0;
        var noCommaAdded = 0;
        var commaDistance = 0;
        var distanceFromLastComma = 0;

        while (fsBeforeDecimal.length > 0) {
            match = fsBeforeDecimal.pop();

            if (match === "#" || match === "0") {
                noPhProcessed++;

                if (noPhProcessed === noPhBeforeDecimal) {
                    var digits = vStringBeforeDecimal;
                    vStringBeforeDecimal = [];

                    if (match === "0") {
                        //var totalDigits = result.match(/[0-9]/g).length;
                        var toPad = noPhBeforeDecimal - noDigitsAdded - (digits ? digits.length : 0);

                        while (toPad > 0) {
                            digits.unshift("0");
                            toPad--;
                        }
                    }

                    while (digits.length > 0) {
                        result = digits.pop() + result;
                        distanceFromLastComma++;

                        if (distanceFromLastComma % commaDistance === 0 && noCommaAdded === noComma && digits.length > 0)
                            result = digitGroupSeparator + result;
                    }

                    //if (isNegative)
                    //	result = "-" + result;

                } else {
                    if (vStringBeforeDecimal.length > 0) {
                        result = vStringBeforeDecimal.pop() + result;
                        noDigitsAdded++;
                        distanceFromLastComma++;
                    }
                    else if (match === "0") {
                        result = "0" + result;
                        noDigitsAdded++;
                        distanceFromLastComma++;
                    }

                    if (distanceFromLastComma % commaDistance === 0 && noCommaAdded === noComma && vStringBeforeDecimal.length > 0)
                        result = digitGroupSeparator + result;
                }


            } else if ((match[0] === "E" || match[0] === "e") && match[match.length - 1] === "0" && /[eE][+-]*[0]+/.test(match)) {
                if (exponent < 0)
                    match = match.replace("+", "").replace("-", "");
                else
                    match = match.replace("-", "");

                result += match.replace(/[0]+/, function ($0) {
                    return pad(exponent, $0.length);
                });


            } else {
                if (match === ",") {
                    noCommaAdded++;
                    commaDistance = distanceFromLastComma;
                    distanceFromLastComma = 0;

                    if (vStringBeforeDecimal.length > 0)
                        result = digitGroupSeparator + result;
                } else if (match.length > 1 && ((match[0] === "\"" && match[match.length - 1] === "\"") || (match[0] === "'" && match[match.length - 1] === "'"))) {
                    result = match.slice(1, match.length - 1) + result;
                }
                else
                    result = match + result;
            }
        }

        var charCount = 0;
        var resultAfterDecimal = "";
        var addDecimalSeparator = false;

        while (fsAfterDecimal.length > 0) {
            match = fsAfterDecimal.shift();

            if (match === "#" || match === "0") {
                if (vStringAfterDecimal.length > 0 && Number(vStringAfterDecimal.join("")) !== 0) {
                    resultAfterDecimal += vStringAfterDecimal.shift();
                    addDecimalSeparator = true;
                }
                else if (match === "0") {
                    resultAfterDecimal += "0";
                    addDecimalSeparator = true;
                }
            } else if (match.length > 1 && ((match[0] === "\"" && match[match.length - 1] === "\"") || (match[0] === "'" && match[match.length - 1] === "'"))) {
                resultAfterDecimal += match.slice(1, match.length - 1);
                //addDecimalSeparator = true;
            } else if ((match[0] === "E" || match[0] === "e") && match[match.length - 1] === "0" && /[eE][+-]*[0]+/.test(match)) {
                if (exponent < 0)
                    match = match.replace("+", "").replace("-", "");
                else
                    match = match.replace("-", "");
                resultAfterDecimal += match.replace(/[0]+/, function ($0) {
                    return pad(exponent, $0.length);
                });
            } else {
                resultAfterDecimal += match;
                //addDecimalSeparator = true;
            }
        }

        result += (addDecimalSeparator ? decimalSeparator : "") + resultAfterDecimal;
        //window.console.log(result);
        return isNegative ? "-" + result : result;
    };

    //#endregion formatting functions/methods

    function getObjectId(x, y, ctx) {
        x *= devicePixelBackingStoreRatio;
        y *= devicePixelBackingStoreRatio;
        var pixels = ctx.getImageData(x, y, 2, 2).data;
        var isObject = true;

        for (var i = 0; i < 4; i++) {

            if (pixels[i] !== pixels[i + 4] | pixels[i] !== pixels[i + 8] | pixels[i] !== pixels[i + 12]) {
                isObject = false;
                break;
            }
        }

        if (isObject) {
            return RGBToInt(pixels[0], pixels[1], pixels[2]);
        } else {
            return 0;
        }

        //window.console.log(pixels);
    }

    //extracts mouse coordinates from the event parameters
    var getMouseCoordinates = function (ev) {
        var x = 0;
        var y = 0;

        ev = ev || window.event;

        if (ev.offsetX || ev.offsetX === 0) {
            x = ev.offsetX;
            y = ev.offsetY;
        } else if (ev.layerX || ev.layerX == 0) { // Firefox
            x = ev.layerX;
            y = ev.layerY;
        }
        else {
            x = ev.pageX - ev.target.offsetLeft;
            y = ev.pageY - ev.target.offsetTop;
        }

        return { x: x, y: y };
    };

    function getFontString(prefix, object, fallbackObject) {
        var fontString = "";

        var fontStyleString = prefix ? prefix + "FontStyle" : "fontStyle";
        var fontWeightString = prefix ? prefix + "FontWeight" : "fontWeight";
        var fontSizeString = prefix ? prefix + "FontSize" : "fontSize";
        var fontFamilyString = prefix ? prefix + "FontFamily" : "fontFamily";



        fontString += object[fontStyleString] ? object[fontStyleString] + " " : (fallbackObject && fallbackObject[fontStyleString]) ? (fallbackObject[fontStyleString] + " ") : "";
        fontString += object[fontWeightString] ? object[fontWeightString] + " " : (fallbackObject && fallbackObject[fontWeightString]) ? (fallbackObject[fontWeightString] + " ") : "";
        fontString += object[fontSizeString] ? object[fontSizeString] + "px " : (fallbackObject && fallbackObject[fontSizeString]) ? (fallbackObject[fontSizeString] + "px ") : "";


        var fontFamily = object[fontFamilyString] ? object[fontFamilyString] + "" : (fallbackObject && fallbackObject[fontFamilyString]) ? (fallbackObject[fontFamilyString] + "") : "";

        if (!isCanvasSupported && fontFamily) {
            var firstFontFamily = fontFamily.split(",")[0];

            if (firstFontFamily[0] !== "'" && firstFontFamily[0] !== "\"")
                firstFontFamily = "'" + firstFontFamily + "'";

            fontString += firstFontFamily;
        } else
            fontString += fontFamily;

        return fontString;
    }

    function getProperty(propertyName, object, fallbackObject) {

        var value = propertyName in object ? object[propertyName] : fallbackObject[propertyName];

        return value;
    }

    var optimizeForHiDPI = true;
    //optimizeForHiDPI = false;

    var devicePixelRatio = window.devicePixelRatio || 1;
    var backingStoreRatio = 1;
    var devicePixelBackingStoreRatio = optimizeForHiDPI ? devicePixelRatio / backingStoreRatio : 1;


    function setCanvasSize(canvas, width, height) {

        if (isCanvasSupported && !!optimizeForHiDPI) {
            var ctx = canvas.getContext("2d");
            backingStoreRatio = ctx.webkitBackingStorePixelRatio ||
                ctx.mozBackingStorePixelRatio ||
                ctx.msBackingStorePixelRatio ||
                ctx.oBackingStorePixelRatio ||
                ctx.backingStorePixelRatio || 1;


            devicePixelBackingStoreRatio = devicePixelRatio / backingStoreRatio;

            canvas.width = width * devicePixelBackingStoreRatio;
            canvas.height = height * devicePixelBackingStoreRatio;

            if (devicePixelRatio !== backingStoreRatio) {

                canvas.style.width = width + 'px';
                canvas.style.height = height + 'px';

                ctx.scale(devicePixelBackingStoreRatio, devicePixelBackingStoreRatio);

            }

            //window.alert(backingStoreRatio);
            //window.alert(devicePixelRatio);

        } else {
            canvas.width = width;
            canvas.height = height;
        }

    }

    var disableLnk = (window && window.location && window.location.href && window.location.href.indexOf && (window.location.href.indexOf("canvasjs.com") !== -1 || window.location.href.indexOf("fenopix.com") !== -1 || window.location.href.indexOf("fiddle") !== -1));
    function addCreditLink(chart) {
        if (disableLnk)
            return;

        var creditTextChanged = false;
        var creditHrefChanged = false;

        if (typeof (defaultOptions.Chart.creditHref) === "undefined") {
            chart.creditHref = "https://canvasjs.com/";
            chart.creditText = "CanvasJS.com";
        } else {
            creditTextChanged = chart.updateOption("creditText");
            creditHrefChanged = chart.updateOption("creditHref");
        }

        if (!chart.creditHref || !chart.creditText)
            return;

        if (!chart._creditLink) {
            chart._creditLink = document.createElement("a");
            chart._creditLink.setAttribute("class", "canvasjs-chart-credit");
            chart._creditLink.setAttribute("style", "outline:none;margin:0px;position:absolute;right:2px;top:" + (chart.height - 14) + "px;color:dimgrey;text-decoration:none;font-size:11px;font-family: Calibri, Lucida Grande, Lucida Sans Unicode, Arial, sans-serif");

            chart._creditLink.setAttribute("tabIndex", -1);

            chart._creditLink.setAttribute("target", "_blank");
        }

        if (chart.renderCount === 0 || (creditTextChanged || creditHrefChanged)) {
            chart._creditLink.setAttribute("href", chart.creditHref);
            chart._creditLink.innerHTML = chart.creditText;
        }

        if (chart._creditLink && chart.creditHref && chart.creditText) {
            if (!chart._creditLink.parentElement)
                chart._canvasJSContainer.appendChild(chart._creditLink);

            chart._creditLink.style.top = (chart.height - 14) + "px";
        } else if (chart._creditLink.parentElement)
            chart._canvasJSContainer.removeChild(chart._creditLink);
    }


    function createCanvas(width, height) {
        var canvas = document.createElement("canvas");
        canvas.setAttribute("class", "canvasjs-chart-canvas");

        setCanvasSize(canvas, width, height);

        if (!isCanvasSupported && typeof (G_vmlCanvasManager) !== "undefined") {
            G_vmlCanvasManager.initElement(canvas);
        }

        return canvas;
    }

    function exportCanvas(canvas, format, fileName) {
        if (!canvas || !format || !fileName)
            return;

        var fullFileName = fileName + "." + format;
        var mimeType = "image/" + format;
        var img = canvas.toDataURL(mimeType);
        var saved = false;

        var downloadLink = document.createElement("a");
        downloadLink.download = fullFileName;
        downloadLink.href = img;
        downloadLink.target = "_blank";
        var e;


        if (typeof (Blob) !== "undefined" && !!new Blob()) {

            var imgData = img.replace(/^data:[a-z\/]*;base64,/, '');

            var byteString = atob(imgData);
            var buffer = new ArrayBuffer(byteString.length);
            var intArray = new Uint8Array(buffer);
            for (var i = 0; i < byteString.length; i++) {
                intArray[i] = byteString.charCodeAt(i);
            }

            var blob = new Blob([intArray.buffer], { type: "image/" + format });

            // Save the blob
            try {
                window.navigator.msSaveBlob(blob, fullFileName);
                saved = true;
            }
            catch (e) {
                downloadLink.dataset.downloadurl = [mimeType, downloadLink.download, downloadLink.href].join(':');
                downloadLink.href = window.URL.createObjectURL(blob);
            }
        }

        if (!saved) {

            try {

                event = document.createEvent("MouseEvents");

                event.initMouseEvent("click", true, false, window,
                    0, 0, 0, 0, 0, false, false, false,
                    false, 0, null);

                if (downloadLink.dispatchEvent) {
                    //alert("dispatchEvent");
                    downloadLink.dispatchEvent(event);
                }
                else if (downloadLink.fireEvent) {
                    //alert("fireEvent");
                    downloadLink.fireEvent("onclick");
                }

            } catch (e) {
                var win = window.open();
                //alert("<IE10");
                //window.console.log("IE");
                win.document.write("<img src='" + img + "'></img><div>Please right click on the image and save it to your device</div>");
                win.document.close();
            }
        }
    }

    var base64Images = {
        reset: {
            image: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAcCAYAAAAAwr0iAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAALEgAACxIB0t1+/AAAABx0RVh0U29mdHdhcmUAQWRvYmUgRmlyZXdvcmtzIENTNui8sowAAAKRSURBVEiJrdY/iF1FFMfxzwnZrGISUSR/JLGIhoh/QiRNBLWxMLIWEkwbgiAoFgoW2mhlY6dgpY2IlRBRxBSKhSAKIklWJRYuMZKAhiyopAiaTY7FvRtmZ+/ed9/zHRjezLw5v/O9d86cuZGZpmURAfdn5o9DfdZNLXpjz+LziPgyIl6MiG0jPTJzZBuyDrP4BVm0P/AKbljTb4ToY/gGewYA7KyCl+1b3DUYANvwbiHw0gCAGRzBOzjTAXEOu0cC4Ch+r5x/HrpdrcZmvIDFSucMtnYCYC++6HmNDw8FKDT34ETrf639/azOr5vwRk/g5fbeuABtgC04XWk9VQLciMP4EH/3AFzErRNC7MXlQmsesSoHsGPE23hmEoBW+61K66HMXFmIMvN8myilXS36R01ub+KfYvw43ZXwYDX+AHP4BAci4pFJomfmr/ihmNofESsBImJGk7mlncrM45n5JPbhz0kAWpsv+juxaX21YIPmVJS2uNzJMS6ZNexC0d+I7fUWXLFyz2kSZlpWPvASlmqAf/FXNXf3FAF2F/1LuFifAlionB6dRuSI2IwHi6lzmXmp6xR8XY0fiIh7psAwh+3FuDkRHQVjl+a8lkXjo0kLUKH7XaV5oO86PmZ1FTzyP4K/XGl9v/zwfbW7BriiuETGCP5ch9bc9f97HF/vcFzCa5gdEPgWq+t/4v0V63oE1uF4h0DiFJ7HnSWMppDdh1dxtsPvJ2wcBNAKbsJXa0Ck5opdaBPsRNu/usba09i1KsaAVzmLt3sghrRjuK1Tf4xkegInxwy8gKf7dKMVH2QRsV5zXR/Cftyu+aKaKbbkQrsdH+PTzLzcqzkOQAVzM+7FHdiqqe2/YT4zF/t8S/sPmawyvC974vcAAAAASUVORK5CYII="
        },
        pan: {
            image: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAALEgAACxIB0t1+/AAAABx0RVh0U29mdHdhcmUAQWRvYmUgRmlyZXdvcmtzIENTNui8sowAAAJVSURBVFiFvZe7a1RBGMV/x2hWI4JpfKCIiSBKOoOCkID/wP4BFqIIFkE02ChIiC8QDKlSiI3YqRBsBVGwUNAUdiIEUgjiAzQIIsuKJsfizsXr5t7d+8jmwLDfzHz3nLOzc7+ZxTZlGyDgZiWOCuJ9wH2gCUyuqQFgF/AGcKJNrYkBYBj40CIet+muGQi/96kM4WS7C/Tm5VUg7whJg8BkEGkCR4BDYfodsADUgP6wErO5iCtswsuJb32hdbXy8qzL5TIdmzJinHdZoZIBZcSFkGlAKs1Z3YCketZcBtouuaQNkrblMiBpBrhme7mAgU4wMCvpcFsDkq4C54DFVRTH9h+i6vlE0r5UA5ImgCuh28jB28iIs7BIVCOeStoZD64P4uPAjUTygKSx2FsK2TIwkugfk9Qkfd/E+yMWHQCeSRqx/R3gOp3LazfaS2C4B5gHDgD7U9x3E3uAH7KNpC3AHHAwTL4FHgM9GQ8vAaPA0dB/Abxqk2/gBLA9MXba9r1k/d4LfA3JtwueBeM58ucS+edXnAW23wP10N3advEi9CXizTnyN4bPS7Zn4sH/dq3t18AY4e1YLYSy3g/csj2VnFshZPuOpOeSKHCodUINuGj7YetE6je1PV9QoNPJ9StNHKodx7nRbiWrGHBGXAi5DUiqtQwtpcWK0Jubt8CltA5MEV1IfwO7+VffPwGfia5m34CT4bXujIIX0Qna1/cGMNqV/wUJE2czxD8CQ4X5Sl7Jz7SILwCDpbjKPBRMHAd+EtX4HWV5Spdc2w8kDQGPbH8py/MXMygM69/FKz4AAAAASUVORK5CYII="
        },
        zoom: {
            image: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAK6wAACusBgosNWgAAABx0RVh0U29mdHdhcmUAQWRvYmUgRmlyZXdvcmtzIENTNui8sowAAAMqSURBVFiFvdfbj91TFMDxz57U6GUEMS1aYzyMtCSSDhWjCZMInpAI3khE/QHtgzdRkXgSCS8SES9epKLi0oRKNETjRahREq2KS1stdRujtDPtbA97n5zdn9+5zJxTK9k5v3POXmt991p7r71+IcaoGwkhTOIebMRqzOBTvIG3Y4zTXRmqSoyx5cAKbMJOHMFJnMZ8/jyFaXyMR7G6nb1aH22cP4BvcBxziG3GKfyTIR9D6BYg1KUghPBCDveFlb/24Av8iuUYw41YVsz5G7uxKcZ4aMEpwGt5NY3V/YbHsQ6rcAHOw/kYxigewr5CZw4fYGxBKcCLOFEYehXrMdRhr5yLETxVScsOLOkKAPfn1TYMPIvLFrShUlS2FDZm8XRHACzFAWl3R2xbqPMCYhmeLCAOYEMngAczbcTvuHYxzguIy/FesR9e6gSwU/OoPYHBHgHgviIKX2Flq7k34KhmcVnbi/PC8JX4MgMcxb118wZwdz5aISscqx7VRcox7MrPQ7i+btIAJrAkf9+bI9EPmZY2IAxiTSuAldLq4Y9+AcSUh78KP0tbAcwU35cXMD1JCIFUoGiehlqAz6TNB1f1C0DK+0h+nsNPrQC2a4bqGmlD9kOGcWt+Po6pVgDvSxfJaSkFd4UQBvoAsBYbCoB3a2flM7slA0R8iyt6rAFDeDPbm8eOTpVwGD9qVq7nLbIaZnmksPU1JtsCZMXNmpdRxFasWITzh6Xj3LCzra1OxcD2QjHiGVzdpfORnMqZio2PcF23ABdJF1Np4BPptlyPi6WzPYBzpJZtHe7A6xW9cnyP8TqA//SEIYRL8Bxul7rihvwgtVn78WcGGZXa9HGd5TDujDHuOePXNiHdKjWgZX/YbsxLx/ktqbjVzTlcjUSnvI5JrdlUVp6WesZZ6R1hRrpq9+EVTGS9jTjYAuKIouGpbcurEkIYxC051KNSamazsc+xK8b4S0VnEi/j0hqTP+M27O258egQwZuzs7pI7Mf4WQXIEDc5s9sux+5+1Py2EmP8UOq6GvWhIScxfdYjUERiAt9Jd84J6a16zf8JEKT3yCm8g1UxRv8CC4pyRhzR1uUAAAAASUVORK5CYII="
        },
        menu: {
            image: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAgCAYAAAAbifjMAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAK6wAACusBgosNWgAAABx0RVh0U29mdHdhcmUAQWRvYmUgRmlyZXdvcmtzIENTNui8sowAAAAWdEVYdENyZWF0aW9uIFRpbWUAMDcvMTUvMTTPsvU0AAAAP0lEQVRIie2SMQoAIBDDUvH/X667g8sJJ9KOhYYOkW0qGaU1MPdC0vGSbV19EACo3YMPAFH5BUBUjsqfAPpVXtNgGDfxEDCtAAAAAElFTkSuQmCC"
        }
    }

    function setButtonState(chart, button, state) {
        if (button.getAttribute("state") !== state) {

            button.setAttribute("state", state);
            button.setAttribute("type", 'button');
            button.style.position = "relative";
            button.style.margin = "0px 0px 0px 0px";
            button.style.padding = "3px 4px 0px 4px";
            button.style.cssFloat = "left";
            button.setAttribute("title", chart._cultureInfo[state + "Text"]);
            button.innerHTML = "<img style='height:16px;' src='" + base64Images[state].image + "' alt='" + chart._cultureInfo[state + "Text"] + "' />";
        }
    }

    //TR:


    function show() {

        var element = null;

        for (var i = 0; i < arguments.length; i++) {
            element = arguments[i];
            if (element.style)
                element.style.display = "inline";
        }
    }

    function hide() {

        var element = null;

        for (var i = 0; i < arguments.length; i++) {
            element = arguments[i];
            if (element && element.style)
                element.style.display = "none";
        }
    }

    //#endregion Static Methods & variables

    //#region Class Definitions

    //#region Class CanvasJSObject
    function CanvasJSObject(defaultsKey, options, theme, parent) {
        this._defaultsKey = defaultsKey;

        this.parent = parent;

        this._eventListeners = [];//Multidimentional array with an array for each event type

        var currentThemeOptions = {};

        if (theme && themes[theme] && themes[theme][defaultsKey])
            currentThemeOptions = themes[theme][defaultsKey];

        this.options = options ? options : { _isPlaceholder: true };
        this.setOptions(this.options, currentThemeOptions);
    }

    CanvasJSObject.prototype.setOptions = function (options, currentThemeOptions) {

        if (!defaultOptions[this._defaultsKey]) {
            if (isDebugMode && window.console)
                console.log("defaults not set");
        }
        else {
            var defaults = defaultOptions[this._defaultsKey];

            for (var prop in defaults) {

                if (prop === "publicProperties")
                    continue;

                if (defaults.hasOwnProperty(prop)) {
                    if (options && prop in options)
                        this[prop] = options[prop];
                    else if (currentThemeOptions && prop in currentThemeOptions)
                        this[prop] = currentThemeOptions[prop];
                    else this[prop] = defaults[prop];

                    //if (typeof this[prop] === "function") {
                    //    alert("function");
                    //    this[prop] = this[prop]();
                    //}
                }

            }
        }
    };

    CanvasJSObject.prototype.get = function (name) {
        var defaults = defaultOptions[this._defaultsKey];

        if (name === "options") {
            if (this.options && this.options._isPlaceholder)
                return null;
            else
                return this.options;
        }
        else if (defaults.hasOwnProperty(name) || (defaults.publicProperties && defaults.publicProperties.hasOwnProperty(name)))
            return this[name];
        else {
            if (window.console)
                window.console.log("Property \"" + name + "\" doesn't exist. Please check for typo.")
            return;
        }
    }

    CanvasJSObject.prototype.set = function (name, value, updateChart) {
        updateChart = (typeof (updateChart) === "undefined") ? true : updateChart;

        var defaults = defaultOptions[this._defaultsKey];

        if (name === "options") {
            this.createUserOptions(value);
        }
        else if (defaults.hasOwnProperty(name) || (defaults.publicProperties && defaults.publicProperties.hasOwnProperty(name) && defaults.publicProperties[name] === "readWrite")) {
            if (this.options._isPlaceholder)
                this.createUserOptions();

            this.options[name] = value;
        }
        else {

            if (window.console) {
                if (defaults.publicProperties && defaults.publicProperties.hasOwnProperty(name) && defaults.publicProperties[name] === "readOnly")
                    window.console.log("Property \"" + name + "\" is read-only.")
                else
                    window.console.log("Property \"" + name + "\" doesn't exist. Please check for typo.")
            }
            return;
        }

        if (updateChart) {
            chart = this.chart || this;
            chart.render();
        }
    }

    //Adds new object to an array at a given index. Inserts it to the end if index is null or not provided
    CanvasJSObject.prototype.addTo = function (name, options, index, updateChart) {
        updateChart = (typeof (updateChart) === "undefined") ? true : updateChart;
        var defaults = defaultOptions[this._defaultsKey];

        var arr;

        if (defaults.hasOwnProperty(name) || (defaults.publicProperties && defaults.publicProperties.hasOwnProperty(name) && defaults.publicProperties[name] === "readWrite")) {
            if (this.options._isPlaceholder)
                this.createUserOptions();

            if (typeof (this.options[name]) === "undefined")
                this.options[name] = [];

            arr = this.options[name];

            index = (typeof (index) === "undefined" || index === null) ? arr.length : index;

            arr.splice(index, 0, options);
        }
        else {

            if (window.console) {
                if (defaults.publicProperties && defaults.publicProperties.hasOwnProperty(name) && defaults.publicProperties[name] === "readOnly")
                    window.console.log("Property \"" + name + "\" is read-only.")
                else
                    window.console.log("Property \"" + name + "\" doesn't exist. Please check for typo.")
            }
            return;
        }

        if (updateChart) {
            chart = this.chart || this;
            chart.render();
        }

    }

    //Adds an empty options Object inside the parent's user options
    CanvasJSObject.prototype.createUserOptions = function (options) {
        if (typeof (options) === "undefined" && !this.options._isPlaceholder)
            return;

        if (this.parent.options._isPlaceholder)
            this.parent.createUserOptions();

        if (!!this.isOptionsInArray) {

            if (!this.parent.options[this.optionsName])
                this.parent.options[this.optionsName] = [];

            var optionsArray = this.parent.options[this.optionsName];

            var optionsIndex = optionsArray.length;

            if (!this.options._isPlaceholder) {
                addArrayIndexOf(optionsArray);
                optionsIndex = optionsArray.indexOf(this.options);
            }

            this.options = typeof (options) === "undefined" ? {} : options;

            optionsArray[optionsIndex] = this.options;
        } else {

            this.options = typeof (options) === "undefined" ? {} : options;
            this.parent.options[this.optionsName ? this.optionsName : firstCharToLower(this._defaultsKey)] = this.options;
        }

    }

    CanvasJSObject.prototype.remove = function (updateChart) {
        updateChart = (typeof (updateChart) === "undefined") ? true : updateChart;

        if (this.isOptionsInArray) {
            var optionsArray = this.parent.options[this.optionsName];

            addArrayIndexOf(optionsArray);
            var optionsIndex = optionsArray.indexOf(this.options);

            if (optionsIndex >= 0) {
                optionsArray.splice(optionsIndex, 1)
            }
        } else {
            delete this.parent.options[this.optionsName];
        }

        if (updateChart) {
            chart = this.chart || this;
            chart.render();
        }
    }

    // Update options. Returns true if changed or else false
    CanvasJSObject.prototype.updateOption = function (prop) {

        if (!defaultOptions[this._defaultsKey] && isDebugMode && window.console)
            console.log("defaults not set");

        var defaults = defaultOptions[this._defaultsKey];
        var theme = this.options.theme ? this.options.theme : (this.chart && this.chart.options.theme) ? this.chart.options.theme : "theme1";

        var currentThemeOptions = {};
        var newValue = this[prop];

        if (theme && themes[theme] && themes[theme][this._defaultsKey])
            currentThemeOptions = themes[theme][this._defaultsKey];

        if (prop in defaults) {
            if (prop in this.options)
                newValue = this.options[prop];
            else if (currentThemeOptions && prop in currentThemeOptions)
                newValue = currentThemeOptions[prop];
            else newValue = defaults[prop];
        }

        if (newValue === this[prop])
            return false;

        this[prop] = newValue;
        return true;
    }

    //Stores values in _oldOptions so that it can be tracked for any changes
    CanvasJSObject.prototype.trackChanges = function (option) {
        if (!this.sessionVariables)
            throw "Session Variable Store not set";

        this.sessionVariables[option] = this.options[option];
    };

    CanvasJSObject.prototype.isBeingTracked = function (option) {
        if (!this.options._oldOptions)
            this.options._oldOptions = {};

        if (this.options._oldOptions[option])
            return true;
        else
            return false;
    };

    CanvasJSObject.prototype.hasOptionChanged = function (option) {
        if (!this.sessionVariables)
            throw "Session Variable Store not set";

        var hasChanged = !(this.sessionVariables[option] === this.options[option]);

        return hasChanged;
    };

    CanvasJSObject.prototype.addEventListener = function (eventName, eventHandler, context) {
        if (!eventName || !eventHandler)
            return;

        context = context || this;

        this._eventListeners[eventName] = this._eventListeners[eventName] || [];

        this._eventListeners[eventName].push({ context: context, eventHandler: eventHandler });
    }

    CanvasJSObject.prototype.removeEventListener = function (eventName, eventHandler) {
        if (!eventName || !eventHandler || !this._eventListeners[eventName])
            return;

        var listeners = this._eventListeners[eventName];
        for (var i = 0; i < listeners.length; i++) {

            if (listeners[i].eventHandler === eventHandler) {
                listeners[i].splice(i, 1);
                break;
            }
        }
    }

    CanvasJSObject.prototype.removeAllEventListeners = function () {
        this._eventListeners = [];
    }

    CanvasJSObject.prototype.dispatchEvent = function (eventName, eventParameter, context) {

        //For Internal Events
        if (eventName && this._eventListeners[eventName]) {

            eventParameter = eventParameter || {};

            var listeners = this._eventListeners[eventName];
            for (var i = 0; i < listeners.length; i++) {

                listeners[i].eventHandler.call(listeners[i].context, eventParameter);
            }
        }

        //External Events do not require registering as the property name is suffient to fire the event.
        if (typeof (this[eventName]) === "function") {
            this[eventName].call(context || this.chart, eventParameter);
        }
    }

    //#endregion Class CanvasJSObject

    //#region Class Chart
    function Chart(containerId, options) {

        options = options || {};

        Chart.base.constructor.call(this, "Chart", options, options.theme ? options.theme : "theme1");

        var _this = this;

        this._containerId = containerId;
        this._objectsInitialized = false;
        this.ctx = null;
        this.overlaidCanvasCtx = null;
        this._indexLabels = [];
        this._panTimerId = 0;
        this._lastTouchEventType = "";
        this._lastTouchData = null;
        this.isAnimating = false;
        this.renderCount = 0;
        this.animatedRender = false;
        this.disableToolTip = false;


        this.panEnabled = false;
        this._defaultCursor = "default";
        this.plotArea = { canvas: null, ctx: null, x1: 0, y1: 0, x2: 0, y2: 0, width: 0, height: 0 };
        this._dataInRenderedOrder = [];

        this.container = typeof (this._containerId) === "string" ? document.getElementById(this._containerId) : this._containerId;

        if (!this.container) {
            if (window.console)
                window.console.log("CanvasJS Error: Chart Container with id \"" + this._containerId + "\" was not found");
            return;
        }

        this.container.innerHTML = "";

        var width = 0;
        var height = 0;

        if (this.options.width)
            width = this.width;
        else
            width = this.container.clientWidth > 0 ? this.container.clientWidth : this.width;

        if (this.options.height)
            height = this.height;
        else
            height = this.container.clientHeight > 0 ? this.container.clientHeight : this.height;

        this.width = width;
        this.height = height;

        this.x1 = this.y1 = 0;
        this.x2 = this.width;
        this.y2 = this.height;


        this._selectedColorSet = typeof (colorSets[this.colorSet]) !== "undefined" ? colorSets[this.colorSet] : colorSets["colorSet1"];

        this._canvasJSContainer = document.createElement("div");
        this._canvasJSContainer.setAttribute("class", "canvasjs-chart-container");

        this._canvasJSContainer.style.position = "relative";
        this._canvasJSContainer.style.textAlign = "left";
        this._canvasJSContainer.style.cursor = "auto";
        if (!isCanvasSupported) {
            this._canvasJSContainer.style.height = "0px";//In IE6 toolTip doesn't show at proper position if not set.
        }
        this.container.appendChild(this._canvasJSContainer);


        this.canvas = createCanvas(width, height);

        this.canvas.style.position = "absolute";
        if (this.canvas.getContext) {
            //try {
            //	this.canvas.style.background = this.backgroundColor;
            //} catch (e) { }
            this._canvasJSContainer.appendChild(this.canvas);
            this.ctx = this.canvas.getContext("2d");
            this.ctx.textBaseline = "top";
            extendCtx(this.ctx);
        } else
            return;

        //this.canvas.style.cursor = "pointer";

        if (!isCanvasSupported) {
            this.plotArea.canvas = createCanvas(width, height);
            this.plotArea.canvas.style.position = "absolute";
            this.plotArea.canvas.setAttribute("class", "plotAreaCanvas");
            this._canvasJSContainer.appendChild(this.plotArea.canvas);

            this.plotArea.ctx = this.plotArea.canvas.getContext("2d");
        } else {
            this.plotArea.ctx = this.ctx;
        }

        this.overlaidCanvas = createCanvas(width, height);
        this.overlaidCanvas.style.position = "absolute";
        this._canvasJSContainer.appendChild(this.overlaidCanvas);
        this.overlaidCanvasCtx = this.overlaidCanvas.getContext("2d");
        this.overlaidCanvasCtx.textBaseline = "top";

        this._eventManager = new EventManager(this);

        this.windowResizeHandler = addEvent(window, "resize", function () {

            if (_this._updateSize())
                _this.render();
        });


        this._toolBar = document.createElement("div");
        this._toolBar.setAttribute("class", "canvasjs-chart-toolbar");
        this._toolBar.style.cssText = "position: absolute; right: 1px; top: 1px;";
        this._canvasJSContainer.appendChild(this._toolBar);


        this.bounds = { x1: 0, y1: 0, x2: this.width, y2: this.height };

        addEvent(this.overlaidCanvas, 'click', function (e) {
            _this._mouseEventHandler(e);
        });

        addEvent(this.overlaidCanvas, 'mousemove', function (e) {
            _this._mouseEventHandler(e);
        });

        addEvent(this.overlaidCanvas, 'mouseup', function (e) {
            _this._mouseEventHandler(e);
        });

        addEvent(this.overlaidCanvas, 'mousedown', function (e) {
            _this._mouseEventHandler(e);
            hide(_this._dropdownMenu);
        });

        addEvent(this.overlaidCanvas, 'mouseout', function (e) {
            _this._mouseEventHandler(e);
        });


        addEvent(this.overlaidCanvas, window.navigator.msPointerEnabled ? "MSPointerDown" : "touchstart", function (e) {
            _this._touchEventHandler(e);
        });

        addEvent(this.overlaidCanvas, window.navigator.msPointerEnabled ? "MSPointerMove" : 'touchmove', function (e) {
            _this._touchEventHandler(e);
        });

        addEvent(this.overlaidCanvas, window.navigator.msPointerEnabled ? "MSPointerUp" : 'touchend', function (e) {
            _this._touchEventHandler(e);
        });

        addEvent(this.overlaidCanvas, window.navigator.msPointerEnabled ? "MSPointerCancel" : 'touchcancel', function (e) {
            _this._touchEventHandler(e);
        });

        this.toolTip = new ToolTip(this, this.options.toolTip);


        this.data = null;
        this.axisX = [];
        this.axisX2 = [];
        this.axisY = [];
        this.axisY2 = [];



        this.sessionVariables = {
            axisX: [],
            axisX2: [],
            axisY: [],
            axisY2: []
        };
    }

    extend(Chart, CanvasJSObject);

    //Clear Chart from memory
    Chart.prototype.destroy = function () {
        removeEvent(window, "resize", this.windowResizeHandler);
    };

    //Update Chart Properties
    Chart.prototype._updateOptions = function () {
        var _this = this;

        this.updateOption("width");
        this.updateOption("height");

        this.updateOption("dataPointWidth");
        this.updateOption("dataPointMinWidth");
        this.updateOption("dataPointMaxWidth");

        this.updateOption("interactivityEnabled");
        this.updateOption("theme");

        if (this.updateOption("colorSet"))
            this._selectedColorSet = typeof (colorSets[this.colorSet]) !== "undefined" ? colorSets[this.colorSet] : colorSets["colorSet1"];

        this.updateOption("backgroundColor");
        if (!this.backgroundColor)
            this.backgroundColor = "rgba(0,0,0,0)";

        this.updateOption("culture");
        this._cultureInfo = new CultureInfo(this.options.culture);

        this.updateOption("animationEnabled");
        this.animationEnabled = this.animationEnabled && isCanvasSupported;
        this.updateOption("animationDuration");

        this.updateOption("rangeChanging");
        this.updateOption("rangeChanged");

        this.updateOption("exportEnabled");
        this.updateOption("exportFileName");

        this.updateOption("zoomType");

        //Need to check this.options.zoomEnabled because this.zoomEnabled is used internally to keep track of state - and hence changes.
        if (this.options.zoomEnabled) {

            if (!this._zoomButton) {

                hide(this._zoomButton = document.createElement("button"));

                setButtonState(this, this._zoomButton, "pan");

                this._toolBar.appendChild(this._zoomButton);
                addEvent(this._zoomButton, "click", function () {
                    if (_this.zoomEnabled) {
                        _this.zoomEnabled = false;
                        _this.panEnabled = true;

                        setButtonState(_this, _this._zoomButton, "zoom");

                    } else {
                        _this.zoomEnabled = true;
                        _this.panEnabled = false;

                        setButtonState(_this, _this._zoomButton, "pan");
                    }

                    _this.render();
                });
            }


            if (!this._resetButton) {
                hide(this._resetButton = document.createElement("button"));
                setButtonState(this, this._resetButton, "reset");
                this._toolBar.appendChild(this._resetButton);

                addEvent(this._resetButton, "click", function () {

                    _this.toolTip.hide();

                    if (_this.zoomEnabled || _this.panEnabled) {
                        _this.zoomEnabled = true;
                        _this.panEnabled = false;
                        setButtonState(_this, _this._zoomButton, "pan");

                        _this._defaultCursor = "default";
                        _this.overlaidCanvas.style.cursor = _this._defaultCursor;
                    } else {
                        _this.zoomEnabled = false;
                        _this.panEnabled = false;
                    }
                    //Reset axisX
                    if (_this.sessionVariables.axisX) {
                        for (var k = 0; k < _this.sessionVariables["axisX"].length; k++) {
                            _this.sessionVariables["axisX"][k].newViewportMinimum = null;
                            _this.sessionVariables["axisX"][k].newViewportMaximum = null;
                        }
                    }

                    //Reset axisX2
                    if (_this.sessionVariables.axisX2) {
                        for (var k = 0; k < _this.sessionVariables["axisX2"].length; k++) {
                            _this.sessionVariables["axisX2"][k].newViewportMinimum = null;
                            _this.sessionVariables["axisX2"][k].newViewportMaximum = null;
                        }
                    }

                    //Reset axisY
                    if (_this.sessionVariables.axisY) {
                        for (var k = 0; k < _this.sessionVariables["axisY"].length; k++) {
                            _this.sessionVariables["axisY"][k].newViewportMinimum = null;
                            _this.sessionVariables["axisY"][k].newViewportMaximum = null;
                        }
                    }

                    //Reset axisY2
                    if (_this.sessionVariables.axisY2) {
                        for (var k = 0; k < _this.sessionVariables["axisY2"].length; k++) {
                            _this.sessionVariables["axisY2"][k].newViewportMinimum = null;
                            _this.sessionVariables["axisY2"][k].newViewportMaximum = null;
                        }
                    }

                    _this.resetOverlayedCanvas();

                    hide(_this._zoomButton, _this._resetButton);

                    _this._dispatchRangeEvent("rangeChanging", "reset");
                    _this.render();
                    _this._dispatchRangeEvent("rangeChanged", "reset");
                });

                this.overlaidCanvas.style.cursor = _this._defaultCursor;
            }

            if (!this.zoomEnabled && !this.panEnabled) {
                if (!this._zoomButton) {
                    this.zoomEnabled = true;
                    this.panEnabled = false;
                } else {

                    if (_this._zoomButton.getAttribute("state") === _this._cultureInfo.zoomText) {
                        this.panEnabled = true;
                        this.zoomEnabled = false;
                    }
                    else {
                        this.zoomEnabled = true;
                        this.panEnabled = false;
                    }

                    show(_this._zoomButton, _this._resetButton);
                }
            }



        } else {
            this.zoomEnabled = false;
            this.panEnabled = false;
        }



        if (this._menuButton) {
            if (this.exportEnabled)
                show(this._menuButton);
            else
                hide(this._menuButton);
        } else if (this.exportEnabled && isCanvasSupported) {
            this._menuButton = document.createElement("button");
            setButtonState(this, this._menuButton, "menu");
            this._toolBar.appendChild(this._menuButton);

            addEvent(this._menuButton, "click", function () {
                if (_this._dropdownMenu.style.display === "none") {

                    if (_this._dropDownCloseTime && ((new Date()).getTime() - _this._dropDownCloseTime.getTime() <= 500))
                        return;

                    _this._dropdownMenu.style.display = "block";
                    _this._menuButton.blur();
                    _this._dropdownMenu.focus();
                }

            }, true);
        }


        if (!this._dropdownMenu && this.exportEnabled && isCanvasSupported) {
            this._dropdownMenu = document.createElement("div");
            this._dropdownMenu.setAttribute("tabindex", -1);
            this._dropdownMenu.style.cssText = "position: absolute; -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none; cursor: pointer;right: 1px;top: 25px;min-width: 120px;outline: 0;border: 1px solid silver;font-size: 14px;font-family: Calibri, Verdana, sans-serif;padding: 5px 0px 5px 0px;text-align: left;background-color: #fff;line-height: 20px;box-shadow: 2px 2px 10px #888888;";
            _this._dropdownMenu.style.display = "none";
            this._toolBar.appendChild(this._dropdownMenu);

            addEvent(this._dropdownMenu, "blur", function () {
                hide(_this._dropdownMenu);

                _this._dropDownCloseTime = new Date();
            }, true);

            var exportOption = document.createElement("div");
            exportOption.style.cssText = "padding: 2px 15px 2px 10px"
            exportOption.innerHTML = this._cultureInfo.printText;
            this._dropdownMenu.appendChild(exportOption);

            addEvent(exportOption, "mouseover", function () {
                this.style.backgroundColor = "#EEEEEE";
            }, true);

            addEvent(exportOption, "mouseout", function () {
                this.style.backgroundColor = "transparent";
            }, true);

            addEvent(exportOption, "click", function () {
                _this.print();
                hide(_this._dropdownMenu);
            }, true);


            var exportOption = document.createElement("div");
            exportOption.style.cssText = "padding: 2px 15px 2px 10px"
            exportOption.innerHTML = this._cultureInfo.saveJPGText;
            this._dropdownMenu.appendChild(exportOption);

            addEvent(exportOption, "mouseover", function () {
                this.style.backgroundColor = "#EEEEEE";
            }, true);

            addEvent(exportOption, "mouseout", function () {
                this.style.backgroundColor = "transparent";
            }, true);

            addEvent(exportOption, "click", function () {
                exportCanvas(_this.canvas, "jpeg", _this.exportFileName);
                hide(_this._dropdownMenu);
            }, true);

            var exportOption = document.createElement("div");
            exportOption.style.cssText = "padding: 2px 15px 2px 10px"
            exportOption.innerHTML = this._cultureInfo.savePNGText;
            this._dropdownMenu.appendChild(exportOption);

            addEvent(exportOption, "mouseover", function () {
                this.style.backgroundColor = "#EEEEEE";
            }, true);

            addEvent(exportOption, "mouseout", function () {
                this.style.backgroundColor = "transparent";
            }, true);

            addEvent(exportOption, "click", function () {
                exportCanvas(_this.canvas, "png", _this.exportFileName);
                hide(_this._dropdownMenu);
            }, true);
        }


        if (this._toolBar.style.display !== "none" && this._zoomButton) {

            this.panEnabled ? setButtonState(_this, _this._zoomButton, "zoom") : setButtonState(_this, _this._zoomButton, "pan");


            if (_this._resetButton.getAttribute("state") !== _this._cultureInfo.resetText)
                setButtonState(_this, _this._resetButton, "reset");
        }

        if (this.options.toolTip && this.toolTip.options !== this.options.toolTip)
            this.toolTip.options = this.options.toolTip

        for (var prop in this.toolTip.options) {

            if (this.toolTip.options.hasOwnProperty(prop)) {
                this.toolTip.updateOption(prop);
            }
        }

    }

    Chart.prototype._updateSize = function () {
        var width = 0;
        var height = 0;

        if (this.options.width)
            width = this.width;
        else
            this.width = width = this.container.clientWidth > 0 ? this.container.clientWidth : this.width;

        if (this.options.height)
            height = this.height;
        else
            this.height = height = this.container.clientHeight > 0 ? this.container.clientHeight : this.height;

        if (this.canvas.width !== width * devicePixelBackingStoreRatio || this.canvas.height !== height * devicePixelBackingStoreRatio) {
            setCanvasSize(this.canvas, width, height);

            setCanvasSize(this.overlaidCanvas, width, height);
            setCanvasSize(this._eventManager.ghostCanvas, width, height);

            return true;
        }

        return false;
    }

    // initialize chart objects
    Chart.prototype._initialize = function () {
        ///<signature>
        ///<summary>Initializes Chart objects/state. Creates DataSeries class instance for each DataSeries provided by ther user. Sets the Axis Type based on the user data</summary>
        ///</signature>
        //this.width = this.width;

        if (!this._animator)
            this._animator = new Animator(this);
        else {
            this._animator.cancelAllAnimations();
        }

        this.removeAllEventListeners();

        this.disableToolTip = false;

        this._axes = [];

        this.pieDoughnutClickHandler = null;
        //this._touchCurrentCoordinates = null;

        if (this.animationRequestId)
            this.cancelRequestAnimFrame.call(window, this.animationRequestId);

        this._updateOptions();

        this.animatedRender = isCanvasSupported && this.animationEnabled && (this.renderCount === 0);

        this._updateSize();

        //this._selectedColorSet = colorSets["colorSet2"];

        //this.ctx.clearRect(0, 0, this.width, this.height);
        this.clearCanvas();
        this.ctx.beginPath();

        this.axisX = [];
        this.axisX2 = [];
        this.axisY = [];
        this.axisY2 = [];
        this._indexLabels = [];
        this._dataInRenderedOrder = [];

        this._events = [];
        if (this._eventManager)
            this._eventManager.reset();

        this.plotInfo = {
            axisPlacement: null,
            axisXValueType: null,
            plotTypes: []//array of plotType: {type:"", axisYType: "primary", dataSeriesIndexes:[]}
        };

        this.layoutManager = new LayoutManager(0, 0, this.width, this.height, 2);

        if (this.plotArea.layoutManager)
            this.plotArea.layoutManager.reset();


        this.data = [];
        var dataSeriesIndex = 0;

        if (this.options.data) {
            for (var series = 0; series < this.options.data.length; series++) {
                //for (series in this.options.data) {

                dataSeriesIndex++;

                if (!(!this.options.data[series].type || Chart._supportedChartTypes.indexOf(this.options.data[series].type) >= 0))
                    continue;

                var dataSeries = new DataSeries(this, this.options.data[series], dataSeriesIndex - 1, ++this._eventManager.lastObjectId);
                if (dataSeries.name === null)
                    dataSeries.name = "DataSeries " + (dataSeriesIndex);

                if (dataSeries.color === null) {
                    if (this.options.data.length > 1) {
                        dataSeries._colorSet = [this._selectedColorSet[dataSeries.index % this._selectedColorSet.length]];
                        dataSeries.color = this._selectedColorSet[dataSeries.index % this._selectedColorSet.length];
                    } else {
                        if (dataSeries.type === "line" || dataSeries.type === "stepLine" || dataSeries.type === "spline" || dataSeries.type === "area"
                            || dataSeries.type === "stepArea" || dataSeries.type === "splineArea" || dataSeries.type === "stackedArea" || dataSeries.type === "stackedArea100"
                            || dataSeries.type === "rangeArea" || dataSeries.type === "rangeSplineArea" || dataSeries.type === "candlestick" || dataSeries.type === "ohlc") {
                            dataSeries._colorSet = [this._selectedColorSet[0]];
                        }
                        else
                            dataSeries._colorSet = this._selectedColorSet;
                    }
                } else {
                    dataSeries._colorSet = [dataSeries.color];
                }

                if (dataSeries.markerSize === null) {
                    if (((dataSeries.type === "line" || dataSeries.type === "stepLine" || dataSeries.type === "spline" || dataSeries.type.toLowerCase().indexOf("area") >= 0) && dataSeries.dataPoints && dataSeries.dataPoints.length < this.width / 16) || dataSeries.type === "scatter") {
                        //if (dataSeries.type === "line") {
                        dataSeries.markerSize = 8;
                    }
                }

                if ((dataSeries.type === "bubble" || dataSeries.type === "scatter") && dataSeries.dataPoints) {
                    if (dataSeries.dataPoints.some) {
                        if (dataSeries.dataPoints.some(function (element) { return element.x; }))
                            dataSeries.dataPoints.sort(compareDataPointX);
                    }
                    else
                        dataSeries.dataPoints.sort(compareDataPointX);
                }

                this.data.push(dataSeries);

                var seriesAxisPlacement = dataSeries.axisPlacement;

                var errorMessage;

                if (seriesAxisPlacement === "normal") {

                    if (this.plotInfo.axisPlacement === "xySwapped") {
                        errorMessage = "You cannot combine \"" + dataSeries.type + "\" with bar chart";
                    } else if (this.plotInfo.axisPlacement === "none") {
                        errorMessage = "You cannot combine \"" + dataSeries.type + "\" with pie chart";
                    } else if (this.plotInfo.axisPlacement === null)
                        this.plotInfo.axisPlacement = "normal";
                }
                else if (seriesAxisPlacement === "xySwapped") {

                    if (this.plotInfo.axisPlacement === "normal") {
                        errorMessage = "You cannot combine \"" + dataSeries.type + "\" with line, area, column or pie chart";
                    } else if (this.plotInfo.axisPlacement === "none") {
                        errorMessage = "You cannot combine \"" + dataSeries.type + "\" with pie chart";
                    } else if (this.plotInfo.axisPlacement === null)
                        this.plotInfo.axisPlacement = "xySwapped";
                }
                else if (seriesAxisPlacement == "none") {

                    if (this.plotInfo.axisPlacement === "normal") {
                        errorMessage = "You cannot combine \"" + dataSeries.type + "\" with line, area, column or bar chart";
                    } else if (this.plotInfo.axisPlacement === "xySwapped") {
                        errorMessage = "You cannot combine \"" + dataSeries.type + "\" with bar chart";
                    } else if (this.plotInfo.axisPlacement === null)
                        this.plotInfo.axisPlacement = "none";
                }

                if (errorMessage && window.console) {
                    window.console.log(errorMessage);
                    return;
                }
            }
        }
        //if (isDebugMode && window.console) {
        //    window.console.log("xMin: " + this.plotInfo.viewPortXMin + "; xMax: " + this.plotInfo.viewPortXMax + "; yMin: " + this.plotInfo.yMin + "; yMax: " + this.plotInfo.yMax);
        //}

        var _this = this;

        this.addEventListener("dataAnimationIterationEnd", function () {

            if (global.fAWm)
                global.fAWm(_this);

            if (_this.axisX.length === 0)
                return;

            if (global.fNg)
                global.fNg(_this);
        });

        addCreditLink(this);

        this._objectsInitialized = true;
    }

    //indexOf is not supported in IE8-
    Chart._supportedChartTypes = addArrayIndexOf(["line", "stepLine", "spline", "column", "area", "stepArea", "splineArea", "bar", "bubble", "scatter",
        "stackedColumn", "stackedColumn100", "stackedBar", "stackedBar100",
        "stackedArea", "stackedArea100",
        "candlestick",
        "ohlc",
        "rangeColumn",
        "rangeBar",
        "rangeArea",
        "rangeSplineArea",
        "pie", "doughnut", "funnel"
    ]);

    Chart.prototype.render = function (options) {
        if (options)
            this.options = options;



        this._initialize();

        var plotAreaElements = []; //Elements to be rendered inside the plotArea

        //Create Primary and Secondary axis and assign them to the series
        for (var i = 0; i < this.data.length; i++) {

            if (this.plotInfo.axisPlacement === "normal" || this.plotInfo.axisPlacement === "xySwapped") {
                if (!this.data[i].axisYType || this.data[i].axisYType === "primary") {

                    if (this.options.axisY && this.options.axisY.length > 0) {
                        if (!this.axisY.length) {
                            for (var k = 0; k < this.options.axisY.length; k++) {
                                if (this.plotInfo.axisPlacement === "normal") {
                                    this._axes.push(this.axisY[k] = new Axis(this, this.options.axisY[k], "axisY", "left", k));
                                }
                                else if (this.plotInfo.axisPlacement === "xySwapped") {
                                    this._axes.push(this.axisY[k] = new Axis(this, this.options.axisY[k], "axisY", "bottom", k));
                                }
                            }
                        }
                        this.data[i].axisY = this.axisY[(this.data[i].axisYIndex >= 0 && this.data[i].axisYIndex < this.axisY.length) ? this.data[i].axisYIndex : 0];
                        this.axisY[(this.data[i].axisYIndex >= 0 && this.data[i].axisYIndex < this.axisY.length) ? this.data[i].axisYIndex : 0].dataSeries.push(this.data[i]);
                    }
                    else {
                        if (!this.axisY.length) {
                            if (this.plotInfo.axisPlacement === "normal") {
                                this._axes.push(this.axisY[0] = new Axis(this, this.options.axisY, "axisY", "left", 0));
                            }
                            else if (this.plotInfo.axisPlacement === "xySwapped") {
                                this._axes.push(this.axisY[0] = new Axis(this, this.options.axisY, "axisY", "bottom", 0));
                            }
                        }

                        this.data[i].axisY = this.axisY[0];
                        this.axisY[0].dataSeries.push(this.data[i]);
                    }
                }
                if (this.data[i].axisYType === "secondary") {

                    if (this.options.axisY2 && this.options.axisY2.length > 0) {
                        if (!this.axisY2.length) {
                            for (var k = 0; k < this.options.axisY2.length; k++) {
                                if (this.plotInfo.axisPlacement === "normal") {
                                    this._axes.push(this.axisY2[k] = new Axis(this, this.options.axisY2[k], "axisY", "right", k));
                                }
                                else if (this.plotInfo.axisPlacement === "xySwapped") {
                                    this._axes.push(this.axisY2[k] = new Axis(this, this.options.axisY2[k], "axisY", "top", k));
                                }
                            }
                        }
                        this.data[i].axisY = this.axisY2[(this.data[i].axisYIndex >= 0 && this.data[i].axisYIndex < this.axisY2.length) ? this.data[i].axisYIndex : 0];
                        this.axisY2[(this.data[i].axisYIndex >= 0 && this.data[i].axisYIndex < this.axisY2.length) ? this.data[i].axisYIndex : 0].dataSeries.push(this.data[i]);
                    }
                    else {
                        if (!this.axisY2.length) {
                            if (this.plotInfo.axisPlacement === "normal") {
                                this._axes.push(this.axisY2[0] = new Axis(this, this.options.axisY2, "axisY", "right", 0));
                            }
                            else if (this.plotInfo.axisPlacement === "xySwapped") {
                                this._axes.push(this.axisY2[0] = new Axis(this, this.options.axisY2, "axisY", "top", 0));
                            }
                        }

                        this.data[i].axisY = this.axisY2[0];
                        this.axisY2[0].dataSeries.push(this.data[i]);
                    }
                }

                if (!this.data[i].axisXType || this.data[i].axisXType === "primary") {

                    if (this.options.axisX && this.options.axisX.length > 0) {
                        if (!this.axisX.length) {
                            for (var k = 0; k < this.options.axisX.length; k++) {
                                if (this.plotInfo.axisPlacement === "normal") {
                                    this._axes.push(this.axisX[k] = new Axis(this, this.options.axisX[k], "axisX", "bottom", k));
                                }
                                else if (this.plotInfo.axisPlacement === "xySwapped") {
                                    this._axes.push(this.axisX[k] = new Axis(this, this.options.axisX[k], "axisX", "left", k));
                                }
                            }
                        }
                        this.data[i].axisX = this.axisX[(this.data[i].axisXIndex >= 0 && this.data[i].axisXIndex < this.axisX.length) ? this.data[i].axisXIndex : 0];
                        this.axisX[(this.data[i].axisXIndex >= 0 && this.data[i].axisXIndex < this.axisX.length) ? this.data[i].axisXIndex : 0].dataSeries.push(this.data[i]);
                    }
                    else {
                        if (!this.axisX.length) {
                            if (this.plotInfo.axisPlacement === "normal") {
                                this._axes.push(this.axisX[0] = new Axis(this, this.options.axisX, "axisX", "bottom", 0));
                            }
                            else if (this.plotInfo.axisPlacement === "xySwapped") {
                                this._axes.push(this.axisX[0] = new Axis(this, this.options.axisX, "axisX", "left", 0));
                            }
                        }

                        this.data[i].axisX = this.axisX[0];
                        this.axisX[0].dataSeries.push(this.data[i]);
                    }
                }
                if (this.data[i].axisXType === "secondary") {

                    if (this.options.axisX2 && this.options.axisX2.length > 0) {
                        if (!this.axisX2.length) {
                            for (var k = 0; k < this.options.axisX2.length; k++) {
                                if (this.plotInfo.axisPlacement === "normal") {
                                    this._axes.push(this.axisX2[k] = new Axis(this, this.options.axisX2[k], "axisX", "top", k));
                                }
                                else if (this.plotInfo.axisPlacement === "xySwapped") {
                                    this._axes.push(this.axisX2[k] = new Axis(this, this.options.axisX2[k], "axisX", "right", k));
                                }
                            }
                        }
                        this.data[i].axisX = this.axisX2[(this.data[i].axisXIndex >= 0 && this.data[i].axisXIndex < this.axisX2.length) ? this.data[i].axisXIndex : 0];
                        this.axisX2[(this.data[i].axisXIndex >= 0 && this.data[i].axisXIndex < this.axisX2.length) ? this.data[i].axisXIndex : 0].dataSeries.push(this.data[i]);
                    }
                    else {
                        if (!this.axisX2.length) {
                            if (this.plotInfo.axisPlacement === "normal") {
                                this._axes.push(this.axisX2[0] = new Axis(this, this.options.axisX2, "axisX", "top", 0));
                            }
                            else if (this.plotInfo.axisPlacement === "xySwapped") {
                                this._axes.push(this.axisX2[0] = new Axis(this, this.options.axisX2, "axisX", "right", 0));
                            }
                        }

                        this.data[i].axisX = this.axisX2[0];
                        this.axisX2[0].dataSeries.push(this.data[i]);
                    }
                }
            }
        }

        //If Both Primary and Secondary axis are present, disable gridlines for one of them unless the user has set value for both
        if (this.axisY) {
            for (var k = 1; k < this.axisY.length; k++) {
                if (typeof (this.axisY[k].options.gridThickness) === "undefined")
                    this.axisY[k].gridThickness = 0;
            }
            for (var k = 0; k < this.axisY.length - 1; k++) {
                if (typeof (this.axisY[k].options.margin) === "undefined")
                    this.axisY[k].margin = 10;
            }
        }

        if (this.axisY2) {
            for (var k = 1; k < this.axisY2.length; k++) {
                if (typeof (this.axisY2[k].options.gridThickness) === "undefined")
                    this.axisY2[k].gridThickness = 0;
            }
            for (var k = 0; k < this.axisY2.length - 1; k++) {
                if (typeof (this.axisY2[k].options.margin) === "undefined")
                    this.axisY2[k].margin = 10;
            }
        }

        if ((this.axisY && this.axisY.length > 0) && (this.axisY2 && this.axisY2.length > 0)) {
            if (this.axisY[0].gridThickness > 0 && typeof (this.axisY2[0].options.gridThickness) === "undefined")
                this.axisY2[0].gridThickness = 0;
            else if (this.axisY2[0].gridThickness > 0 && typeof (this.axisY[0].options.gridThickness) === "undefined")
                this.axisY[0].gridThickness = 0;
        }

        if (this.axisX) {
            for (var k = 0; k < this.axisX.length; k++) {
                if (typeof (this.axisX[k].options.gridThickness) === "undefined")
                    this.axisX[k].gridThickness = 0;
            }
        }

        if (this.axisX2) {
            for (var k = 0; k < this.axisX2.length; k++) {
                if (typeof (this.axisX2[k].options.gridThickness) === "undefined")
                    this.axisX2[k].gridThickness = 0;
            }
        }

        if ((this.axisX && this.axisX.length > 0) && (this.axisX2 && this.axisX2.length > 0)) {
            if (this.axisX[0].gridThickness > 0 && typeof (this.axisX2[0].options.gridThickness) === "undefined")
                this.axisX2[0].gridThickness = 0;
            else if (this.axisX2[0].gridThickness > 0 && typeof (this.axisX[0].options.gridThickness) === "undefined")
                this.axisX[0].gridThickness = 0;
        }

        //Show toolBar when viewportMinimum/viewportMaximum are set
        var showToolBar = false;
        if (this._axes.length > 0 && (this.zoomEnabled || this.panEnabled)) {
            for (var i = 0; i < this._axes.length; i++) {
                if (this._axes[i].viewportMinimum !== null || this._axes[i].viewportMaximum !== null) {
                    showToolBar = true;
                    break;
                }
            }
        }

        if (showToolBar) {
            show(this._zoomButton, this._resetButton);
        } else {
            hide(this._zoomButton, this._resetButton);
            if (this.options.zoomEnabled) {
                this.zoomEnabled = true;
                this.panEnabled = false;
            }
        }


        this._processData();// Categorises the dataSeries and calculates min, max and other values

        if (this.options.title) {
            this.title = new Title(this, this.options.title);

            if (!this.title.dockInsidePlotArea)
                this.title.render();
            else
                plotAreaElements.push(this.title);
        }

        if (this.options.subtitles) {
            this.subtitles = [];
            for (var i = 0; i < this.options.subtitles.length; i++) {
                var subtitle = new Subtitle(this, this.options.subtitles[i]);
                this.subtitles.push(subtitle);

                if (!subtitle.dockInsidePlotArea)
                    subtitle.render();
                else
                    plotAreaElements.push(subtitle);
            }
        }

        this.legend = new Legend(this, this.options.legend);
        for (var i = 0; i < this.data.length; i++) {
            if (this.data[i].showInLegend || this.data[i].type === "pie" || this.data[i].type === "doughnut") {
                this.legend.dataSeries.push(this.data[i]);
            }
        }

        if (!this.legend.dockInsidePlotArea)
            this.legend.render();
        else
            plotAreaElements.push(this.legend);

        //TBI: Revisit and check if the functionality is enough.
        if (this.plotInfo.axisPlacement === "normal" || this.plotInfo.axisPlacement === "xySwapped") {

            //var freeSpace = this.layoutManager.getFreeSpace();

            Axis.setLayoutAndRender(this.axisX, this.axisX2, this.axisY, this.axisY2, this.plotInfo.axisPlacement, this.layoutManager.getFreeSpace());
        } else if (this.plotInfo.axisPlacement === "none") {
            //In case of charts with axis this method is called inside setLayoutAndRender
            this.preparePlotArea();
        }
        else {
            return;
        }

        for (var index = 0; index < plotAreaElements.length; index++) {
            plotAreaElements[index].render();
        }

        var animations = [];
        if (this.animatedRender) {
            var initialState = createCanvas(this.width, this.height);
            var initialStateCtx = initialState.getContext("2d");
            initialStateCtx.drawImage(this.canvas, 0, 0, this.width, this.height);
        }

        var defaultMiterLimit = this.ctx.miterLimit, plotUnitDefaultMiterLimit;
        this.ctx.miterLimit = 3;

        for (var i = 0; i < this.plotInfo.plotTypes.length; i++) {
            var plotType = this.plotInfo.plotTypes[i];

            for (var j = 0; j < plotType.plotUnits.length; j++) {

                var plotUnit = plotType.plotUnits[j];
                var animationInfo = null;

                plotUnit.targetCanvas = null; //In case chart updates before the animation is complete, previous canvases need to be removed

                if (this.animatedRender) {
                    plotUnit.targetCanvas = createCanvas(this.width, this.height);
                    plotUnit.targetCanvasCtx = plotUnit.targetCanvas.getContext("2d");
                    plotUnitDefaultMiterLimit = plotUnit.targetCanvasCtx.miterLimit;
                    plotUnit.targetCanvasCtx.miterLimit = 3;
                }

                if (plotUnit.type === "line")
                    animationInfo = this.renderLine(plotUnit);
                else if (plotUnit.type === "stepLine")
                    animationInfo = this.renderStepLine(plotUnit);
                else if (plotUnit.type === "spline")
                    animationInfo = this.renderSpline(plotUnit);
                else if (plotUnit.type === "column")
                    animationInfo = this.renderColumn(plotUnit);
                else if (plotUnit.type === "bar")
                    animationInfo = this.renderBar(plotUnit);
                else if (plotUnit.type === "area")
                    animationInfo = this.renderArea(plotUnit);
                else if (plotUnit.type === "stepArea")
                    animationInfo = this.renderStepArea(plotUnit);
                else if (plotUnit.type === "splineArea")
                    animationInfo = this.renderSplineArea(plotUnit);
                else if (plotUnit.type === "stackedColumn")
                    animationInfo = this.renderStackedColumn(plotUnit);
                else if (plotUnit.type === "stackedColumn100")
                    animationInfo = this.renderStackedColumn100(plotUnit);
                else if (plotUnit.type === "stackedBar")
                    animationInfo = this.renderStackedBar(plotUnit);
                else if (plotUnit.type === "stackedBar100")
                    animationInfo = this.renderStackedBar100(plotUnit);
                else if (plotUnit.type === "stackedArea")
                    animationInfo = this.renderStackedArea(plotUnit);
                else if (plotUnit.type === "stackedArea100")
                    animationInfo = this.renderStackedArea100(plotUnit);
                else if (plotUnit.type === "bubble")
                    animationInfo = animationInfo = this.renderBubble(plotUnit);
                else if (plotUnit.type === "scatter")
                    animationInfo = this.renderScatter(plotUnit);
                else if (plotUnit.type === "pie")
                    this.renderPie(plotUnit);
                else if (plotUnit.type === "doughnut")
                    this.renderPie(plotUnit);
                else if (plotUnit.type === "candlestick")
                    animationInfo = this.renderCandlestick(plotUnit);
                else if (plotUnit.type === "ohlc")
                    animationInfo = this.renderCandlestick(plotUnit);
                else if (plotUnit.type === "rangeColumn")
                    animationInfo = this.renderRangeColumn(plotUnit);
                else if (plotUnit.type === "rangeBar")
                    animationInfo = this.renderRangeBar(plotUnit);
                else if (plotUnit.type === "rangeArea")
                    animationInfo = this.renderRangeArea(plotUnit);
                else if (plotUnit.type === "rangeSplineArea")
                    animationInfo = this.renderRangeSplineArea(plotUnit);

                for (var k = 0; k < plotUnit.dataSeriesIndexes.length; k++) {
                    this._dataInRenderedOrder.push(this.data[plotUnit.dataSeriesIndexes[k]]);
                }

                if (this.animatedRender) {
                    plotUnit.targetCanvasCtx.miterLimit = plotUnitDefaultMiterLimit;
                    if (animationInfo)
                        animations.push(animationInfo);
                }
            }
        }

        this.ctx.miterLimit = defaultMiterLimit;

        if (this.animatedRender && this._indexLabels.length > 0) {
            var indexLabelCanvas = createCanvas(this.width, this.height);
            var indexLabelCanvasCtx = indexLabelCanvas.getContext("2d");
            animations.push(this.renderIndexLabels(indexLabelCanvasCtx));
        }

        var _this = this;

        if (animations.length > 0) {
            //var animationCount = 0;
            _this.disableToolTip = true;
            _this._animator.animate(200, _this.animationDuration, function (fractionComplete) {

                //console.log(fractionComplete);
                //animationCount++;

                _this.ctx.clearRect(0, 0, _this.width, _this.height);


                //  _this.ctx.drawImage(initialState, 0, 0, _this.width * devicePixelBackingStoreRatio, _this.height * devicePixelBackingStoreRatio, 0, 0, _this.width, _this.height);
                _this.ctx.drawImage(initialState, 0, 0, Math.floor(_this.width * devicePixelBackingStoreRatio), Math.floor(_this.height * devicePixelBackingStoreRatio), 0, 0, _this.width, _this.height);

                for (var l = 0; l < animations.length; l++) {

                    animationInfo = animations[l];

                    if (fractionComplete < 1 && typeof (animationInfo.startTimePercent) !== "undefined") {
                        if (fractionComplete >= animationInfo.startTimePercent) {
                            //animationInfo.animationCallback(AnimationHelper.easing.linear(fractionComplete - animationInfo.startTimePercent, 0, 1, 1 - animationInfo.startTimePercent), animationInfo);

                            animationInfo.animationCallback(animationInfo.easingFunction(fractionComplete - animationInfo.startTimePercent, 0, 1, 1 - animationInfo.startTimePercent), animationInfo);
                        }
                    } else {

                        animationInfo.animationCallback(animationInfo.easingFunction(fractionComplete, 0, 1, 1), animationInfo);
                    }
                }

                _this.dispatchEvent("dataAnimationIterationEnd",
                    {
                        chart: _this
                    });

            }, function () {

                animations = [];

                var count = 0;

                //Delete all render target canvases used for animation.
                for (var i = 0; i < _this.plotInfo.plotTypes.length; i++) {
                    var plotType = _this.plotInfo.plotTypes[i];

                    for (var j = 0; j < plotType.plotUnits.length; j++) {
                        var plotUnit = plotType.plotUnits[j];
                        plotUnit.targetCanvas = null;
                    }
                }

                initialState = null;
                _this.disableToolTip = false;
                //console.log("*********** Animation Complete - " + animationCount + " ***********");

            });
        } else {
            if (_this._indexLabels.length > 0)
                _this.renderIndexLabels();

            _this.dispatchEvent("dataAnimationIterationEnd",
                {
                    chart: _this
                });
        }

        this.attachPlotAreaEventHandlers();

        if (!this.zoomEnabled && !this.panEnabled && this._zoomButton && this._zoomButton.style.display !== "none") {
            hide(this._zoomButton, this._resetButton);
        }

        this.toolTip._updateToolTip();

        this.renderCount++;

        //if (window.console) {
        //    window.console.log(new Date().getTime() - dt);
        //}

        if (isDebugMode) {

            var _this = this;
            setTimeout(function () {
                var ghostCanvasCopy = document.getElementById("ghostCanvasCopy");

                if (ghostCanvasCopy) {
                    //console.log(ghostCanvasCopy.clientWidth);
                    setCanvasSize(ghostCanvasCopy, _this.width, _this.height);
                    var ghostCanvasCopyCtx = ghostCanvasCopy.getContext("2d");

                    //ghostCanvasCopyCtx.scale(1, 1);
                    //var imageData = this._eventManager.ghostCtx.getImageData(0, 0, this.container.clientWidth, this.container.clientHeight);
                    //this._eventManager.ghostCtx.drawImage(this._eventManager.ghostCanvas, 0, 0);
                    //this.ctx.drawImage(this._eventManager.ghostCanvas, 0, 0);

                    ghostCanvasCopyCtx.drawImage(_this._eventManager.ghostCanvas, 0, 0);
                    //_this._canvasJSContainer.appendChild(_this._eventManager.ghostCanvas);
                    //_this.overlaidCanvasCtx.drawImage(_this._eventManager.ghostCanvas, 0, 0);
                }
            }, 2000);
        }
    }

    Chart.prototype.attachPlotAreaEventHandlers = function () {

        //this._toolBar.style.display = "inline";

        this.attachEvent({
            context: this,
            chart: this,
            mousedown: this._plotAreaMouseDown,
            mouseup: this._plotAreaMouseUp,
            mousemove: this._plotAreaMouseMove,
            cursor: this.zoomEnabled ? "col-resize" : "move",
            cursor: this.panEnabled ? "move" : "default",
            capture: true,
            bounds: this.plotArea
        });

    }

    Chart.prototype.categoriseDataSeries = function () {
        var dataSeries = "";

        for (var i = 0; i < this.data.length; i++) {
            dataSeries = this.data[i]
            if (!dataSeries.dataPoints || dataSeries.dataPoints.length === 0 || !dataSeries.visible)
                continue;

            if (Chart._supportedChartTypes.indexOf(dataSeries.type) >= 0) {

                var plotType = null;
                var plotTypeExists = false;

                var plotUnit = null;
                var plotUnitExists = false;

                for (var j = 0; j < this.plotInfo.plotTypes.length; j++) {
                    if (this.plotInfo.plotTypes[j].type === dataSeries.type) {
                        plotTypeExists = true;
                        var plotType = this.plotInfo.plotTypes[j];
                        break;
                    }
                }

                if (!plotTypeExists) {
                    plotType = {
                        type: dataSeries.type,
                        totalDataSeries: 0,
                        plotUnits: []
                    };
                    this.plotInfo.plotTypes.push(plotType)
                }

                for (var j = 0; j < plotType.plotUnits.length; j++) {
                    if ((plotType.plotUnits[j].axisYType === dataSeries.axisYType && plotType.plotUnits[j].axisXType === dataSeries.axisXType) && (plotType.plotUnits[j].axisYIndex === dataSeries.axisYIndex && plotType.plotUnits[j].axisXIndex === dataSeries.axisXIndex)) {
                        plotUnitExists = true;
                        var plotUnit = plotType.plotUnits[j];
                        break;
                    }
                }

                if (!plotUnitExists) {
                    plotUnit = {
                        type: dataSeries.type,
                        previousDataSeriesCount: 0, //to be set next
                        index: plotType.plotUnits.length,
                        plotType: plotType,
                        axisXType: dataSeries.axisXType,
                        axisYType: dataSeries.axisYType,
                        axisYIndex: dataSeries.axisYIndex,
                        axisXIndex: dataSeries.axisXIndex,
                        axisY: dataSeries.axisYType === "primary" ? (this.axisY[(dataSeries.axisYIndex >= 0 && dataSeries.axisYIndex < this.axisY.length) ? dataSeries.axisYIndex : 0]) : (this.axisY2[(dataSeries.axisYIndex >= 0 && dataSeries.axisYIndex < this.axisY2.length) ? dataSeries.axisYIndex : 0]),
                        axisX: dataSeries.axisXType === "primary" ? (this.axisX[(dataSeries.axisXIndex >= 0 && dataSeries.axisXIndex < this.axisX.length) ? dataSeries.axisXIndex : 0]) : (this.axisX2[(dataSeries.axisXIndex >= 0 && dataSeries.axisXIndex < this.axisX2.length) ? dataSeries.axisXIndex : 0]),
                        dataSeriesIndexes: [], //index of dataSeries
                        yTotals: []
                    }
                    plotType.plotUnits.push(plotUnit);
                }

                plotType.totalDataSeries++;

                plotUnit.dataSeriesIndexes.push(i);

                dataSeries.plotUnit = plotUnit;

            }
        }

        for (var i = 0; i < this.plotInfo.plotTypes.length; i++) {
            var plotType = this.plotInfo.plotTypes[i];
            var previousDataSeriesCount = 0;

            for (var j = 0; j < plotType.plotUnits.length; j++) {

                plotType.plotUnits[j].previousDataSeriesCount = previousDataSeriesCount;

                previousDataSeriesCount += plotType.plotUnits[j].dataSeriesIndexes.length;
            }
        }
    }

    Chart.prototype.assignIdToDataPoints = function () {

        for (var i = 0; i < this.data.length; i++) {
            var dataSeries = this.data[i];

            if (!dataSeries.dataPoints)
                continue;

            var length = dataSeries.dataPoints.length;

            for (var j = 0; j < length; j++) {
                dataSeries.dataPointIds[j] = ++this._eventManager.lastObjectId;
            }
        }
    }

    Chart.prototype._processData = function () {
        this.assignIdToDataPoints();
        this.categoriseDataSeries();

        for (var i = 0; i < this.plotInfo.plotTypes.length; i++) {
            var plotType = this.plotInfo.plotTypes[i];

            for (var j = 0; j < plotType.plotUnits.length; j++) {

                var plotUnit = plotType.plotUnits[j];

                if (plotUnit.type === "line" || plotUnit.type === "stepLine" || plotUnit.type === "spline" || plotUnit.type === "column" || plotUnit.type === "area" || plotUnit.type === "stepArea" || plotUnit.type === "splineArea" || plotUnit.type === "bar" || plotUnit.type === "bubble" || plotUnit.type === "scatter")
                    this._processMultiseriesPlotUnit(plotUnit);
                else if (plotUnit.type === "stackedColumn" || plotUnit.type === "stackedBar" || plotUnit.type === "stackedArea")
                    this._processStackedPlotUnit(plotUnit);
                else if (plotUnit.type === "stackedColumn100" || plotUnit.type === "stackedBar100" || plotUnit.type === "stackedArea100")
                    this._processStacked100PlotUnit(plotUnit);
                else if (plotUnit.type === "candlestick" || plotUnit.type === "ohlc" || plotUnit.type === "rangeColumn" || plotUnit.type === "rangeBar" || plotUnit.type === "rangeArea" || plotUnit.type === "rangeSplineArea")
                    this._processMultiYPlotUnit(plotUnit);
            }
        }

    }

    Chart.prototype._processMultiseriesPlotUnit = function (plotUnit) {
        if (!plotUnit.dataSeriesIndexes || plotUnit.dataSeriesIndexes.length < 1)
            return;

        var axisYDataInfo = plotUnit.axisY.dataInfo;
        var axisXDataInfo = plotUnit.axisX.dataInfo;
        var dataPointX, dataPointY;
        var isDateTime = false;


        for (var j = 0; j < plotUnit.dataSeriesIndexes.length; j++) {
            var dataSeries = this.data[plotUnit.dataSeriesIndexes[j]];
            var i = 0;
            var isFirstDPInViewPort = false;
            var isLastDPInViewPort = false;
            var prevNonNullX;

            if (dataSeries.axisPlacement === "normal" || dataSeries.axisPlacement === "xySwapped") {

                var plotAreaXMin = plotUnit.axisX.sessionVariables.newViewportMinimum ? plotUnit.axisX.sessionVariables.newViewportMinimum : (this.options.axisX && this.options.axisX.viewportMinimum) ?
                    this.options.axisX.viewportMinimum : (this.options.axisX && this.options.axisX.minimum) ? this.options.axisX.minimum : plotUnit.axisX.logarithmic ? 0 : -Infinity;

                var plotAreaXMax = plotUnit.axisX.sessionVariables.newViewportMaximum ? plotUnit.axisX.sessionVariables.newViewportMaximum : (this.options.axisX && this.options.axisX.viewportMaximum) ?
                    this.options.axisX.viewportMaximum : (this.options.axisX && this.options.axisX.maximum) ? this.options.axisX.maximum : Infinity;
            }


            if (dataSeries.dataPoints[i].x && dataSeries.dataPoints[i].x.getTime || dataSeries.xValueType === "dateTime") {
                isDateTime = true;
            }

            for (i = 0; i < dataSeries.dataPoints.length; i++) {

                if (typeof dataSeries.dataPoints[i].x === "undefined") {
                    dataSeries.dataPoints[i].x = i + (plotUnit.axisX.logarithmic ? 1 : 0);
                }

                if (dataSeries.dataPoints[i].x.getTime) {
                    isDateTime = true;
                    dataPointX = dataSeries.dataPoints[i].x.getTime();//dataPointX is used so that getTime is called only once in case of dateTime values
                }
                else
                    dataPointX = dataSeries.dataPoints[i].x;

                dataPointY = dataSeries.dataPoints[i].y;


                if (dataPointX < axisXDataInfo.min)
                    axisXDataInfo.min = dataPointX;
                if (dataPointX > axisXDataInfo.max)
                    axisXDataInfo.max = dataPointX;

                if (dataPointY < axisYDataInfo.min && typeof dataPointY === "number")
                    axisYDataInfo.min = dataPointY;

                if (dataPointY > axisYDataInfo.max && typeof dataPointY === "number")
                    axisYDataInfo.max = dataPointY;


                if (i > 0) {
                    if (plotUnit.axisX.logarithmic) {
                        var xDiff = dataPointX / dataSeries.dataPoints[i - 1].x;
                        xDiff < 1 && (xDiff = 1 / xDiff); //If Condition shortcut

                        if (axisXDataInfo.minDiff > xDiff && xDiff !== 1) {
                            axisXDataInfo.minDiff = xDiff;
                        }
                    }
                    else {
                        var xDiff = dataPointX - dataSeries.dataPoints[i - 1].x;
                        xDiff < 0 && (xDiff = xDiff * -1); //If Condition shortcut

                        if (axisXDataInfo.minDiff > xDiff && xDiff !== 0) {
                            axisXDataInfo.minDiff = xDiff;
                        }
                    }

                    if (dataPointY !== null && dataSeries.dataPoints[i - 1].y !== null) {
                        if (plotUnit.axisY.logarithmic) {
                            var yDiff = dataPointY / dataSeries.dataPoints[i - 1].y;
                            yDiff < 1 && (yDiff = 1 / yDiff); //If Condition shortcut

                            if (axisYDataInfo.minDiff > yDiff && yDiff !== 1) {
                                axisYDataInfo.minDiff = yDiff;
                            }
                        }
                        else {
                            var yDiff = dataPointY - dataSeries.dataPoints[i - 1].y;
                            yDiff < 0 && (yDiff = yDiff * -1); //If Condition shortcut

                            if (axisYDataInfo.minDiff > yDiff && yDiff !== 0) {
                                axisYDataInfo.minDiff = yDiff;
                            }
                        }
                    }
                }

                // This section makes sure that partially visible dataPoints are included in the begining
                if (dataPointX < plotAreaXMin && !isFirstDPInViewPort) {
                    if (dataPointY !== null)
                        prevNonNullX = dataPointX;
                    continue;
                } else if (!isFirstDPInViewPort) {
                    isFirstDPInViewPort = true;

                    if (i > 0) {
                        i -= 2;
                        continue;
                    }
                }

                // This section makes sure that partially visible dataPoints are included at the end
                if (dataPointX > plotAreaXMax && !isLastDPInViewPort) {
                    isLastDPInViewPort = true;
                } else if (dataPointX > plotAreaXMax && isLastDPInViewPort) {
                    continue;
                }

                if (dataSeries.dataPoints[i].label)
                    plotUnit.axisX.labels[dataPointX] = dataSeries.dataPoints[i].label;


                if (dataPointX < axisXDataInfo.viewPortMin)
                    axisXDataInfo.viewPortMin = dataPointX;
                if (dataPointX > axisXDataInfo.viewPortMax)
                    axisXDataInfo.viewPortMax = dataPointX;

                if (dataPointY === null) {
                    if (axisXDataInfo.viewPortMin === dataPointX && prevNonNullX < dataPointX)
                        axisXDataInfo.viewPortMin = prevNonNullX;
                    continue;
                }


                if (dataPointY < axisYDataInfo.viewPortMin && typeof dataPointY === "number")
                    axisYDataInfo.viewPortMin = dataPointY;
                if (dataPointY > axisYDataInfo.viewPortMax && typeof dataPointY === "number")
                    axisYDataInfo.viewPortMax = dataPointY;
            }

            this.plotInfo.axisXValueType = dataSeries.xValueType = isDateTime ? "dateTime" : "number";
        }

        //this.dataPoints.sort(compareDataPointX);
        //this.dataPoints.sort(function (dataPoint1, dataPoint2) { return dataPoint1.x - dataPoint2.x; });
    }

    Chart.prototype._processStackedPlotUnit = function (plotUnit) {
        if (!plotUnit.dataSeriesIndexes || plotUnit.dataSeriesIndexes.length < 1)
            return;

        var axisYDataInfo = plotUnit.axisY.dataInfo;
        var axisXDataInfo = plotUnit.axisX.dataInfo;

        var dataPointX, dataPointY;
        var isDateTime = false;

        var dataPointYPositiveSums = [];
        var dataPointYNegativeSums = [];

        var yMinLimit = Infinity;
        var yMaxLimit = -Infinity;

        for (var j = 0; j < plotUnit.dataSeriesIndexes.length; j++) {
            var dataSeries = this.data[plotUnit.dataSeriesIndexes[j]];
            var i = 0;
            var isFirstDPInViewPort = false;
            var isLastDPInViewPort = false;
            var prevNonNullX;

            if (dataSeries.axisPlacement === "normal" || dataSeries.axisPlacement === "xySwapped") {

                var plotAreaXMin = this.sessionVariables.axisX.newViewportMinimum ? this.sessionVariables.axisX.newViewportMinimum : (this.options.axisX && this.options.axisX.viewportMinimum) ?
                    this.options.axisX.viewportMinimum : (this.options.axisX && this.options.axisX.minimum) ? this.options.axisX.minimum : -Infinity;

                var plotAreaXMax = this.sessionVariables.axisX.newViewportMaximum ? this.sessionVariables.axisX.newViewportMaximum : (this.options.axisX && this.options.axisX.viewportMaximum) ?
                    this.options.axisX.viewportMaximum : (this.options.axisX && this.options.axisX.maximum) ? this.options.axisX.maximum : Infinity;
            }


            if (dataSeries.dataPoints[i].x && dataSeries.dataPoints[i].x.getTime || dataSeries.xValueType === "dateTime") {
                isDateTime = true;
            }

            for (i = 0; i < dataSeries.dataPoints.length; i++) {

                // Requird when no x values are provided
                if (typeof dataSeries.dataPoints[i].x === "undefined") {
                    dataSeries.dataPoints[i].x = i + (plotUnit.axisX.logarithmic ? 1 : 0);
                }

                if (dataSeries.dataPoints[i].x.getTime) {
                    isDateTime = true;
                    dataPointX = dataSeries.dataPoints[i].x.getTime();//dataPointX is used so that getTime is called only once in case of dateTime values
                }
                else
                    dataPointX = dataSeries.dataPoints[i].x;

                if (!isNullOrUndefined(dataSeries.dataPoints[i].y)) {
                    dataPointY = dataSeries.dataPoints[i].y;
                }
                else {
                    dataPointY = 0;
                }

                if (dataPointX < axisXDataInfo.min)
                    axisXDataInfo.min = dataPointX;
                if (dataPointX > axisXDataInfo.max)
                    axisXDataInfo.max = dataPointX;

                if (i > 0) {
                    if (plotUnit.axisX.logarithmic) {
                        var xDiff = dataPointX / dataSeries.dataPoints[i - 1].x;
                        xDiff < 1 && (xDiff = 1 / xDiff); //If Condition shortcut

                        if (axisXDataInfo.minDiff > xDiff && xDiff !== 1) {
                            axisXDataInfo.minDiff = xDiff;
                        }
                    } else {
                        var xDiff = dataPointX - dataSeries.dataPoints[i - 1].x;
                        xDiff < 0 && (xDiff = xDiff * -1); //If Condition shortcut

                        if (axisXDataInfo.minDiff > xDiff && xDiff !== 0) {
                            axisXDataInfo.minDiff = xDiff;
                        }
                    }

                    if (dataPointY !== null && dataSeries.dataPoints[i - 1].y !== null) {
                        if (plotUnit.axisY.logarithmic) {
                            if (dataPointY > 0) {
                                var yDiff = dataPointY / dataSeries.dataPoints[i - 1].y;
                                yDiff < 1 && (yDiff = 1 / yDiff); //If Condition shortcut

                                if (axisYDataInfo.minDiff > yDiff && yDiff !== 1) {
                                    axisYDataInfo.minDiff = yDiff;
                                }
                            }
                        } else {
                            var yDiff = dataPointY - dataSeries.dataPoints[i - 1].y;
                            yDiff < 0 && (yDiff = yDiff * -1); //If Condition shortcut

                            if (axisYDataInfo.minDiff > yDiff && yDiff !== 0) {
                                axisYDataInfo.minDiff = yDiff;
                            }
                        }

                    }
                }

                // This section makes sure that partially visible dataPoints are included in the begining
                if (dataPointX < plotAreaXMin && !isFirstDPInViewPort) {
                    if (dataSeries.dataPoints[i].y !== null)
                        prevNonNullX = dataPointX;
                    continue;
                } else if (!isFirstDPInViewPort) {
                    isFirstDPInViewPort = true;

                    if (i > 0) {
                        i -= 2;
                        continue;
                    }
                }

                // This section makes sure that partially visible dataPoints are included at the end
                if (dataPointX > plotAreaXMax && !isLastDPInViewPort) {
                    isLastDPInViewPort = true;
                } else if (dataPointX > plotAreaXMax && isLastDPInViewPort) {
                    continue;
                }


                if (dataSeries.dataPoints[i].label)
                    plotUnit.axisX.labels[dataPointX] = dataSeries.dataPoints[i].label;

                if (dataPointX < axisXDataInfo.viewPortMin)
                    axisXDataInfo.viewPortMin = dataPointX;
                if (dataPointX > axisXDataInfo.viewPortMax)
                    axisXDataInfo.viewPortMax = dataPointX;

                if (dataSeries.dataPoints[i].y === null) {
                    if (axisXDataInfo.viewPortMin === dataPointX && prevNonNullX < dataPointX)
                        axisXDataInfo.viewPortMin = prevNonNullX;
                    continue;
                }

                plotUnit.yTotals[dataPointX] = (!plotUnit.yTotals[dataPointX] ? 0 : plotUnit.yTotals[dataPointX]) + Math.abs(dataPointY);

                if (dataPointY >= 0) {
                    if (dataPointYPositiveSums[dataPointX])
                        dataPointYPositiveSums[dataPointX] += dataPointY;
                    else {
                        dataPointYPositiveSums[dataPointX] = dataPointY;
                        yMinLimit = Math.min(dataPointY, yMinLimit);
                    }
                } else {
                    if (dataPointYNegativeSums[dataPointX])
                        dataPointYNegativeSums[dataPointX] += dataPointY;
                    else {
                        dataPointYNegativeSums[dataPointX] = dataPointY;
                        yMaxLimit = Math.max(dataPointY, yMaxLimit);
                    }
                }
            }

            this.plotInfo.axisXValueType = dataSeries.xValueType = isDateTime ? "dateTime" : "number";
        }

        for (i in dataPointYPositiveSums) {
            if (dataPointYPositiveSums.hasOwnProperty(i)) {
                if (isNaN(i)) {
                    continue;
                }
                var ySum = dataPointYPositiveSums[i];

                if (ySum < axisYDataInfo.min)
                    axisYDataInfo.min = Math.min(ySum, yMinLimit);

                if (ySum > axisYDataInfo.max)
                    axisYDataInfo.max = ySum;

                if (i < axisXDataInfo.viewPortMin || i > axisXDataInfo.viewPortMax)
                    continue;

                if (ySum < axisYDataInfo.viewPortMin)
                    axisYDataInfo.viewPortMin = Math.min(ySum, yMinLimit);
                if (ySum > axisYDataInfo.viewPortMax)
                    axisYDataInfo.viewPortMax = ySum;
            }

        }

        for (i in dataPointYNegativeSums) {

            if (dataPointYNegativeSums.hasOwnProperty(i)) {
                if (isNaN(i)) {
                    continue;
                }

                var ySum = dataPointYNegativeSums[i];

                if (ySum < axisYDataInfo.min)
                    axisYDataInfo.min = ySum;

                if (ySum > axisYDataInfo.max)
                    axisYDataInfo.max = Math.max(ySum, yMaxLimit);

                if (i < axisXDataInfo.viewPortMin || i > axisXDataInfo.viewPortMax)
                    continue;

                if (ySum < axisYDataInfo.viewPortMin)
                    axisYDataInfo.viewPortMin = ySum;
                if (ySum > axisYDataInfo.viewPortMax)
                    axisYDataInfo.viewPortMax = Math.max(ySum, yMaxLimit);
            }

        }


        //this.dataPoints.sort(compareDataPointX);
        //this.dataPoints.sort(function (dataPoint1, dataPoint2) { return dataPoint1.x - dataPoint2.x; });

        //window.console.log("viewPortYMin: " + plotInfo.viewPortYMin + "; viewPortYMax: " + plotInfo.viewPortYMax);
    }

    Chart.prototype._processStacked100PlotUnit = function (plotUnit) {
        if (!plotUnit.dataSeriesIndexes || plotUnit.dataSeriesIndexes.length < 1)
            return;

        var axisYDataInfo = plotUnit.axisY.dataInfo;
        var axisXDataInfo = plotUnit.axisX.dataInfo;

        var dataPointX, dataPointY;
        var isDateTime = false;
        var containsPositiveY = false;
        var containsNegativeY = false;

        var dataPointYSums = [];

        for (var j = 0; j < plotUnit.dataSeriesIndexes.length; j++) {
            var dataSeries = this.data[plotUnit.dataSeriesIndexes[j]];
            var i = 0;
            var isFirstDPInViewPort = false;
            var isLastDPInViewPort = false;
            var prevNonNullX;

            if (dataSeries.axisPlacement === "normal" || dataSeries.axisPlacement === "xySwapped") {

                var plotAreaXMin = this.sessionVariables.axisX.newViewportMinimum ? this.sessionVariables.axisX.newViewportMinimum : (this.options.axisX && this.options.axisX.viewportMinimum) ?
                    this.options.axisX.viewportMinimum : (this.options.axisX && this.options.axisX.minimum) ? this.options.axisX.minimum : -Infinity;

                var plotAreaXMax = this.sessionVariables.axisX.newViewportMaximum ? this.sessionVariables.axisX.newViewportMaximum : (this.options.axisX && this.options.axisX.viewportMaximum) ?
                    this.options.axisX.viewportMaximum : (this.options.axisX && this.options.axisX.maximum) ? this.options.axisX.maximum : Infinity;
            }


            if (dataSeries.dataPoints[i].x && dataSeries.dataPoints[i].x.getTime || dataSeries.xValueType === "dateTime") {
                isDateTime = true;
            }

            for (i = 0; i < dataSeries.dataPoints.length; i++) {

                // Requird when no x values are provided
                if (typeof dataSeries.dataPoints[i].x === "undefined") {
                    dataSeries.dataPoints[i].x = i + (plotUnit.axisX.logarithmic ? 1 : 0);
                }

                if (dataSeries.dataPoints[i].x.getTime) {
                    isDateTime = true;
                    dataPointX = dataSeries.dataPoints[i].x.getTime();//dataPointX is used so that getTime is called only once in case of dateTime values
                }
                else
                    dataPointX = dataSeries.dataPoints[i].x;
                if (!isNullOrUndefined(dataSeries.dataPoints[i].y))
                    dataPointY = dataSeries.dataPoints[i].y;
                else
                    dataPointY = null;



                if (dataPointX < axisXDataInfo.min)
                    axisXDataInfo.min = dataPointX;
                if (dataPointX > axisXDataInfo.max)
                    axisXDataInfo.max = dataPointX;

                if (i > 0) {
                    if (plotUnit.axisX.logarithmic) {
                        var xDiff = dataPointX / dataSeries.dataPoints[i - 1].x;
                        xDiff < 1 && (xDiff = 1 / xDiff); //If Condition shortcut

                        if (axisXDataInfo.minDiff > xDiff && xDiff !== 1) {
                            axisXDataInfo.minDiff = xDiff;
                        }
                    } else {
                        var xDiff = dataPointX - dataSeries.dataPoints[i - 1].x;
                        xDiff < 0 && (xDiff = xDiff * -1); //If Condition shortcut

                        if (axisXDataInfo.minDiff > xDiff && xDiff !== 0) {
                            axisXDataInfo.minDiff = xDiff;
                        }
                    }

                    if (!isNullOrUndefined(dataPointY) && dataSeries.dataPoints[i - 1].y !== null) {
                        if (plotUnit.axisY.logarithmic) {
                            if (dataPointY > 0) {
                                var yDiff = dataPointY / dataSeries.dataPoints[i - 1].y;
                                yDiff < 1 && (yDiff = 1 / yDiff); //If Condition shortcut

                                if (axisYDataInfo.minDiff > yDiff && yDiff !== 1) {
                                    axisYDataInfo.minDiff = yDiff;
                                }
                            }
                        } else {
                            var yDiff = dataPointY - dataSeries.dataPoints[i - 1].y;
                            yDiff < 0 && (yDiff = yDiff * -1); //If Condition shortcut

                            if (axisYDataInfo.minDiff > yDiff && yDiff !== 0) {
                                axisYDataInfo.minDiff = yDiff;
                            }
                        }
                    }
                }

                // This section makes sure that partially visible dataPoints are included in the begining
                if (dataPointX < plotAreaXMin && !isFirstDPInViewPort) {
                    if (dataPointY !== null)
                        prevNonNullX = dataPointX;
                    continue;
                } else if (!isFirstDPInViewPort) {
                    isFirstDPInViewPort = true;

                    if (i > 0) {
                        i -= 2;
                        continue;
                    }
                }

                // This section makes sure that partially visible dataPoints are included at the end
                if (dataPointX > plotAreaXMax && !isLastDPInViewPort) {
                    isLastDPInViewPort = true;
                } else if (dataPointX > plotAreaXMax && isLastDPInViewPort) {
                    continue;
                }

                if (dataSeries.dataPoints[i].label)
                    plotUnit.axisX.labels[dataPointX] = dataSeries.dataPoints[i].label;

                if (dataPointX < axisXDataInfo.viewPortMin)
                    axisXDataInfo.viewPortMin = dataPointX;
                if (dataPointX > axisXDataInfo.viewPortMax)
                    axisXDataInfo.viewPortMax = dataPointX;

                if (dataPointY === null) {
                    if (axisXDataInfo.viewPortMin === dataPointX && prevNonNullX < dataPointX)
                        axisXDataInfo.viewPortMin = prevNonNullX;
                    continue;
                }

                plotUnit.yTotals[dataPointX] = (!plotUnit.yTotals[dataPointX] ? 0 : plotUnit.yTotals[dataPointX]) + Math.abs(dataPointY);

                if (dataPointY >= 0) {
                    containsPositiveY = true;
                } else if (dataPointY < 0) {//If dataPointY is undefied or null
                    containsNegativeY = true;
                }

                if (dataPointYSums[dataPointX])
                    dataPointYSums[dataPointX] += Math.abs(dataPointY);
                else
                    dataPointYSums[dataPointX] = Math.abs(dataPointY);
            }

            this.plotInfo.axisXValueType = dataSeries.xValueType = isDateTime ? "dateTime" : "number";
        }

        if (plotUnit.axisY.logarithmic) {
            axisYDataInfo.max = (!isNullOrUndefined(axisYDataInfo.viewPortMax)) ? Math.max(axisYDataInfo.viewPortMax, 99 * Math.pow(plotUnit.axisY.logarithmBase, -0.05)) : 99 * Math.pow(plotUnit.axisY.logarithmBase, -0.05);
            axisYDataInfo.min = (!isNullOrUndefined(axisYDataInfo.viewPortMin)) ? Math.min(axisYDataInfo.viewPortMin, 1) : 1;
        }
        else if (containsPositiveY && !containsNegativeY) {
            axisYDataInfo.max = (!isNullOrUndefined(axisYDataInfo.viewPortMax)) ? Math.max(axisYDataInfo.viewPortMax, 99) : 99;
            axisYDataInfo.min = (!isNullOrUndefined(axisYDataInfo.viewPortMin)) ? Math.min(axisYDataInfo.viewPortMin, 1) : 1;
        } else if (containsPositiveY && containsNegativeY) {
            axisYDataInfo.max = (!isNullOrUndefined(axisYDataInfo.viewPortMax)) ? Math.max(axisYDataInfo.viewPortMax, 99) : 99;
            axisYDataInfo.min = (!isNullOrUndefined(axisYDataInfo.viewPortMin)) ? Math.min(axisYDataInfo.viewPortMin, -99) : -99;
        } else if (!containsPositiveY && containsNegativeY) {
            axisYDataInfo.max = (!isNullOrUndefined(axisYDataInfo.viewPortMax)) ? Math.max(axisYDataInfo.viewPortMax, -1) : -1;
            axisYDataInfo.min = (!isNullOrUndefined(axisYDataInfo.viewPortMin)) ? Math.min(axisYDataInfo.viewPortMin, -99) : -99;
        }
        //Max of array to max

        axisYDataInfo.viewPortMin = axisYDataInfo.min;
        axisYDataInfo.viewPortMax = axisYDataInfo.max;

        plotUnit.dataPointYSums = dataPointYSums;

        //this.dataPoints.sort(compareDataPointX);
        //this.dataPoints.sort(function (dataPoint1, dataPoint2) { return dataPoint1.x - dataPoint2.x; });

        //window.console.log("viewPortYMin: " + plotInfo.viewPortYMin + "; viewPortYMax: " + plotInfo.viewPortYMax);
    }

    Chart.prototype._processMultiYPlotUnit = function (plotUnit) {
        if (!plotUnit.dataSeriesIndexes || plotUnit.dataSeriesIndexes.length < 1)
            return;

        var axisYDataInfo = plotUnit.axisY.dataInfo;
        var axisXDataInfo = plotUnit.axisX.dataInfo;
        var dataPointX, dataPointY, dataPointYMin, dataPointYMax;
        var isDateTime = false;


        for (var j = 0; j < plotUnit.dataSeriesIndexes.length; j++) {
            var dataSeries = this.data[plotUnit.dataSeriesIndexes[j]];
            var i = 0;
            var isFirstDPInViewPort = false;
            var isLastDPInViewPort = false;
            var prevNonNullX;
            var currentDataNonNull;
            var firstNonNullX;

            if (dataSeries.axisPlacement === "normal" || dataSeries.axisPlacement === "xySwapped") {

                var plotAreaXMin = this.sessionVariables.axisX.newViewportMinimum ? this.sessionVariables.axisX.newViewportMinimum : (this.options.axisX && this.options.axisX.viewportMinimum) ?
                    this.options.axisX.viewportMinimum : (this.options.axisX && this.options.axisX.minimum) ? this.options.axisX.minimum : -Infinity;

                var plotAreaXMax = this.sessionVariables.axisX.newViewportMaximum ? this.sessionVariables.axisX.newViewportMaximum : (this.options.axisX && this.options.axisX.viewportMaximum) ?
                    this.options.axisX.viewportMaximum : (this.options.axisX && this.options.axisX.maximum) ? this.options.axisX.maximum : Infinity;
            }


            if (dataSeries.dataPoints[i].x && dataSeries.dataPoints[i].x.getTime || dataSeries.xValueType === "dateTime") {
                isDateTime = true;
            }

            for (i = 0; i < dataSeries.dataPoints.length; i++) {

                if (typeof dataSeries.dataPoints[i].x === "undefined") {
                    dataSeries.dataPoints[i].x = i + (plotUnit.axisX.logarithmic ? 1 : 0);
                }

                if (dataSeries.dataPoints[i].x.getTime) {
                    isDateTime = true;
                    dataPointX = dataSeries.dataPoints[i].x.getTime();//dataPointX is used so that getTime is called only once in case of dateTime values
                }
                else
                    dataPointX = dataSeries.dataPoints[i].x;

                dataPointY = dataSeries.dataPoints[i].y;

                if (dataPointY && dataPointY.length) {
                    dataPointYMin = Math.min.apply(null, dataPointY);
                    dataPointYMax = Math.max.apply(null, dataPointY);

                    currentDataNonNull = true;
                    for (var k = 0; k < dataPointY.length; k++)
                        if (dataPointY.k === null)
                            currentDataNonNull = false;
                    if (currentDataNonNull) {
                        if (!isFirstDPInViewPort)
                            firstNonNullX = prevNonNullX;
                        prevNonNullX = dataPointX;
                    }
                }


                if (dataPointX < axisXDataInfo.min)
                    axisXDataInfo.min = dataPointX;
                if (dataPointX > axisXDataInfo.max)
                    axisXDataInfo.max = dataPointX;

                if (dataPointYMin < axisYDataInfo.min)
                    axisYDataInfo.min = dataPointYMin;

                if (dataPointYMax > axisYDataInfo.max)
                    axisYDataInfo.max = dataPointYMax;


                if (i > 0) {
                    if (plotUnit.axisX.logarithmic) {
                        var xDiff = dataPointX / dataSeries.dataPoints[i - 1].x;
                        xDiff < 1 && (xDiff = 1 / xDiff); //If Condition shortcut

                        if (axisXDataInfo.minDiff > xDiff && xDiff !== 1) {
                            axisXDataInfo.minDiff = xDiff;
                        }
                    }
                    else {
                        var xDiff = dataPointX - dataSeries.dataPoints[i - 1].x;
                        xDiff < 0 && (xDiff = xDiff * -1); //If Condition shortcut

                        if (axisXDataInfo.minDiff > xDiff && xDiff !== 0) {
                            axisXDataInfo.minDiff = xDiff;
                        }
                    }

                    if (dataPointY && dataPointY[0] !== null && dataSeries.dataPoints[i - 1].y && dataSeries.dataPoints[i - 1].y[0] !== null) {
                        if (plotUnit.axisY.logarithmic) {
                            var yDiff = dataPointY[0] / dataSeries.dataPoints[i - 1].y[0];
                            yDiff < 1 && (yDiff = 1 / yDiff); //If Condition shortcut

                            if (axisYDataInfo.minDiff > yDiff && yDiff !== 1) {
                                axisYDataInfo.minDiff = yDiff;
                            }
                        }
                        else {
                            var yDiff = dataPointY[0] - dataSeries.dataPoints[i - 1].y[0];
                            yDiff < 0 && (yDiff = yDiff * -1); //If Condition shortcut

                            if (axisYDataInfo.minDiff > yDiff && yDiff !== 0) {
                                axisYDataInfo.minDiff = yDiff;
                            }
                        }
                    }
                }

                // This section makes sure that partially visible dataPoints are included in the begining
                if (dataPointX < plotAreaXMin && !isFirstDPInViewPort) {
                    continue;
                } else if (!isFirstDPInViewPort) {
                    isFirstDPInViewPort = true;

                    if (i > 0) {
                        i -= 2;
                        prevNonNullX = firstNonNullX;
                        continue;
                    }
                }

                // This section makes sure that partially visible dataPoints are included at the end
                if (dataPointX > plotAreaXMax && !isLastDPInViewPort) {
                    isLastDPInViewPort = true;
                } else if (dataPointX > plotAreaXMax && isLastDPInViewPort) {
                    continue;
                }

                if (dataSeries.dataPoints[i].label)
                    plotUnit.axisX.labels[dataPointX] = dataSeries.dataPoints[i].label;


                if (dataPointX < axisXDataInfo.viewPortMin)
                    axisXDataInfo.viewPortMin = dataPointX;
                if (dataPointX > axisXDataInfo.viewPortMax)
                    axisXDataInfo.viewPortMax = dataPointX;

                if (axisXDataInfo.viewPortMin === dataPointX && dataPointY)
                    for (var k = 0; k < dataPointY.length ; k++)
                        if (dataPointY[k] === null && prevNonNullX < dataPointX) {
                            axisXDataInfo.viewPortMin = prevNonNullX;
                            break;
                        }

                if (dataPointY === null) {
                    if (axisXDataInfo.viewPortMin === dataPointX && prevNonNullX < dataPointX)
                        axisXDataInfo.viewPortMin = prevNonNullX;
                    continue;
                }

                if (dataPointYMin < axisYDataInfo.viewPortMin)
                    axisYDataInfo.viewPortMin = dataPointYMin;
                if (dataPointYMax > axisYDataInfo.viewPortMax)
                    axisYDataInfo.viewPortMax = dataPointYMax;
            }

            this.plotInfo.axisXValueType = dataSeries.xValueType = isDateTime ? "dateTime" : "number";
        }

        //this.dataPoints.sort(compareDataPointX);
        //this.dataPoints.sort(function (dataPoint1, dataPoint2) { return dataPoint1.x - dataPoint2.x; });
    }

    //getClosest returns objects nearby and hence shouldn't be used for events like click, mouseover, mousemove, etc which require object that is exactly under the mouse.
    Chart.prototype.getDataPointAtXY = function (mouseX, mouseY, getClosest) {

        getClosest = getClosest || false;
        var results = [];

        for (var i = this._dataInRenderedOrder.length - 1; i >= 0; i--) {
            var dataSeries = this._dataInRenderedOrder[i];

            var result = null;

            result = dataSeries.getDataPointAtXY(mouseX, mouseY, getClosest);
            if (result)
                results.push(result);
        }

        var closestResult = null;
        var onlyLineAreaTypes = false;

        for (var m = 0; m < results.length; m++) {

            if (results[m].dataSeries.type === "line" || results[m].dataSeries.type === "stepLine" || results[m].dataSeries.type === "area" || results[m].dataSeries.type === "stepArea") {
                var markerSize = getProperty("markerSize", results[m].dataPoint, results[m].dataSeries) || 8;
                if (results[m].distance <= markerSize / 2) {
                    onlyLineAreaTypes = true;
                    break;
                }
            }
        }

        for (m = 0; m < results.length; m++) {

            if (onlyLineAreaTypes && results[m].dataSeries.type !== "line" && results[m].dataSeries.type !== "stepLine" && results[m].dataSeries.type !== "area" && results[m].dataSeries.type !== "stepArea")
                continue;

            if (!closestResult) {
                closestResult = results[m];
            } else if (results[m].distance <= closestResult.distance) {
                closestResult = results[m];
            }
        }

        return closestResult;
    }

    Chart.prototype.getObjectAtXY = function (mouseX, mouseY, getClosest) {
        getClosest = getClosest || false;

        var id = null;

        var dataPointInfo = this.getDataPointAtXY(mouseX, mouseY, getClosest);

        if (dataPointInfo) {
            id = dataPointInfo.dataSeries.dataPointIds[dataPointInfo.dataPointIndex];
        } else if (isCanvasSupported) {//IE9+
            id = getObjectId(mouseX, mouseY, this._eventManager.ghostCtx);
        }
        else {
            for (var i = 0; i < this.legend.items.length; i++) {
                var item = this.legend.items[i];

                if (mouseX >= item.x1 && mouseX <= item.x2 && mouseY >= item.y1 && mouseY <= item.y2) {
                    id = item.id;
                }
            }
        }

        return id;
    }

    /// <summary>Calculates Font Size based on standardSize and Chart Size</summary>
    /// <param name="standardSize" type="Number">Standard font size for a Chart with min(width,height) = 400px</param>
    /// <returns type="Number">The area.</returns>
    Chart.prototype.getAutoFontSize = function (standardSize, width, height) {

        width = width || this.width;
        height = height || this.height;

        var fontSizeScaleFactor = standardSize / 400;

        return Math.max(10, Math.round(Math.min(this.width, this.height) * fontSizeScaleFactor));
    }

    //#region Events

    Chart.prototype.resetOverlayedCanvas = function () {
        //var width = this.overlaidCanvas.width;
        //this.overlaidCanvas.width = 0;
        //this.overlaidCanvas.width = width;
        this.overlaidCanvasCtx.clearRect(0, 0, this.width, this.height);
    }

    Chart.prototype.clearCanvas = function () {
        this.ctx.clearRect(0, 0, this.width, this.height);

        if (this.backgroundColor) {
            this.ctx.fillStyle = this.backgroundColor;
            this.ctx.fillRect(0, 0, this.width, this.height);
        }
    }

    Chart.prototype.attachEvent = function (param) {
        this._events.push(param);
    }

    Chart.prototype._touchEventHandler = function (ev) {
        if (!ev.changedTouches || !this.interactivityEnabled)
            return;

        var mouseEvents = [];
        var touches = ev.changedTouches;
        var first = touches ? touches[0] : ev;
        var touchCurrentCoordinates = null;

        //window.console.log(touches.length);

        switch (ev.type) {
            case "touchstart": case "MSPointerDown":
                mouseEvents = ["mousemove", "mousedown"];
                this._lastTouchData = getMouseCoordinates(first);
                this._lastTouchData.time = new Date();
                break;
            case "touchmove": case "MSPointerMove": mouseEvents = ["mousemove"]; break;
            case "touchend": case "MSPointerUp": mouseEvents = (this._lastTouchEventType === "touchstart" || this._lastTouchEventType === "MSPointerDown") ? ["mouseup", "click"] : ["mouseup"];
                break;
            default: return;
        }

        if (touches && touches.length > 1) return;


        touchCurrentCoordinates = getMouseCoordinates(first);
        touchCurrentCoordinates.time = new Date();
        try {
            var dy = touchCurrentCoordinates.y - this._lastTouchData.y;
            var dx = touchCurrentCoordinates.x - this._lastTouchData.x;
            var dt = touchCurrentCoordinates.time - this._lastTouchData.time;

            //if (Math.abs(dy) > 15 && (!!this._lastTouchData.scroll || dt < 200)) {
            if (Math.abs(dy) > 15 && (!!this._lastTouchData.scroll)) {
                //this._lastTouchData.y = touchCurrentCoordinates.y;
                this._lastTouchData.scroll = true;

                var win = window.parent || window;
                if (win && win.scrollBy)
                    win.scrollBy(0, -dy);
            }
        } catch (e) { };

        this._lastTouchEventType = ev.type;

        if (!!this._lastTouchData.scroll && this.zoomEnabled) {
            if (this.isDrag)
                this.resetOverlayedCanvas();

            this.isDrag = false;
            return;
        }

        for (var i = 0; i < mouseEvents.length; i++) {

            var type = mouseEvents[i];
            var simulatedEvent = document.createEvent("MouseEvent");
            simulatedEvent.initMouseEvent(type, true, true, window, 1,
                first.screenX, first.screenY,
                first.clientX, first.clientY, false,
                false, false, false, 0, null);

            first.target.dispatchEvent(simulatedEvent);

            if (ev.preventManipulation) {
                //alert("preventManipulation");
                ev.preventManipulation();
            }

            //if (ev.preventdefault) {
            //	//alert("preventdefault");
            //	ev.preventdefault();
            //}
        }
    }

    Chart.prototype._dispatchRangeEvent = function (eventName, triggerSource) {
        var eventParameter = {};

        eventParameter.chart = this;
        eventParameter.type = eventName;
        eventParameter.trigger = triggerSource;

        var axes = [];

        if (this.axisX && this.axisX.length > 0)
            axes.push("axisX");
        if (this.axisX2 && this.axisX2.length > 0)
            axes.push("axisX2");
        if (this.axisY && this.axisY.length > 0)
            axes.push("axisY");
        if (this.axisY2 && this.axisY2.length > 0)
            axes.push("axisY2");

        for (var i = 0; i < axes.length; i++) {
            if (isNullOrUndefined(eventParameter[axes[i]]))
                eventParameter[axes[i]] = [];

            if (axes[i] === "axisY") {
                for (var k = 0; k < this.axisY.length; k++) {
                    eventParameter[axes[i]].push({
                        viewportMinimum: this[axes[i]][k].sessionVariables.newViewportMinimum,
                        viewportMaximum: this[axes[i]][k].sessionVariables.newViewportMaximum
                    });
                }
            }
            else if (axes[i] === "axisY2") {
                for (var k = 0; k < this.axisY2.length; k++) {
                    eventParameter[axes[i]].push({
                        viewportMinimum: this[axes[i]][k].sessionVariables.newViewportMinimum,
                        viewportMaximum: this[axes[i]][k].sessionVariables.newViewportMaximum
                    });
                }
            }
            else {
                if (axes[i] === "axisX") {
                    for (var k = 0; k < this.axisX.length; k++) {
                        eventParameter[axes[i]].push({
                            viewportMinimum: this[axes[i]][k].sessionVariables.newViewportMinimum,
                            viewportMaximum: this[axes[i]][k].sessionVariables.newViewportMaximum
                        });
                    }
                }
                else if (axes[i] === "axisX2") {
                    for (var k = 0; k < this.axisX2.length; k++) {
                        eventParameter[axes[i]].push({
                            viewportMinimum: this[axes[i]][k].sessionVariables.newViewportMinimum,
                            viewportMaximum: this[axes[i]][k].sessionVariables.newViewportMaximum
                        });
                    }
                }

            }
        }

        this.dispatchEvent(eventName, eventParameter, this);
    }

    Chart.prototype._mouseEventHandler = function (ev) {

        //IE8- uses srcElement instead of target. So instead of checking this condition everytime, its better to create a reference called target.
        if (typeof (ev.target) === "undefined" && ev.srcElement)
            ev.target = ev.srcElement;

        var xy = getMouseCoordinates(ev);
        var type = ev.type;
        var eventParam;
        var rightclick;

        if (!ev) var e = window.event;
        if (ev.which) rightclick = (ev.which == 3);
        else if (ev.button) rightclick = (ev.button == 2);

        releaseCapturedEvent();

        if (!this.interactivityEnabled)
            return;

        if (this._ignoreNextEvent) {
            this._ignoreNextEvent = false;
            return;
        }

        // stop panning and zooming so we can draw
        if (ev.preventManipulation) {
            //alert("preventManipulation");
            ev.preventManipulation();
        }

        // we are handling this event
        if (ev.preventDefault) {
            //alert("preventDefault");
            ev.preventDefault();
        }

        var bounds;

        //window.console.log(type + " --> x: " + xy.x + "; y:" + xy.y);

        //if (type === "mouseout") {
        //    this.toolTip.hide();
        //}

        if (isDebugMode && window.console) {
            window.console.log(type + " --> x: " + xy.x + "; y:" + xy.y);
            if (rightclick)
                window.console.log(ev.which);

            if (type === "mouseup")
                window.console.log("mouseup");
        }

        if (rightclick)
            return;

        //if (this.plotInfo.axisPlacement === "xySwapped") {
        //    //var temp = xy.x;
        //    //xy.x = xy.y;
        //    //xy.y = temp;
        //    xy = {x: xy.y, y: xy.x};
        //}

        function releaseCapturedEvent() {
            if (Chart.capturedEventParam) {
                eventParam = Chart.capturedEventParam;
                bounds = eventParam.bounds;

                if (type === "mouseup") {
                    Chart.capturedEventParam = null;

                    if (eventParam.chart.overlaidCanvas.releaseCapture)
                        eventParam.chart.overlaidCanvas.releaseCapture();
                    else
                        document.documentElement.removeEventListener("mouseup", eventParam.chart._mouseEventHandler, false);
                }

                if (eventParam.hasOwnProperty(type)) {

                    if (type === "mouseup" && !eventParam.chart.overlaidCanvas.releaseCapture) {
                        if (ev.target !== eventParam.chart.overlaidCanvas)
                            eventParam.chart.isDrag = false;
                    } else if (ev.target === eventParam.chart.overlaidCanvas)
                        eventParam[type].call(eventParam.context, xy.x, xy.y);

                }
            }
        }

        if (!Chart.capturedEventParam && this._events) {

            for (var i = 0; i < this._events.length; i++) {
                if (!this._events[i].hasOwnProperty(type))
                    continue;

                eventParam = this._events[i];
                bounds = eventParam.bounds;

                if (xy.x >= bounds.x1 && xy.x <= bounds.x2 && xy.y >= bounds.y1 && xy.y <= bounds.y2) {
                    eventParam[type].call(eventParam.context, xy.x, xy.y);

                    if (type === "mousedown" && eventParam.capture === true) {
                        Chart.capturedEventParam = eventParam;

                        if (this.overlaidCanvas.setCapture)
                            this.overlaidCanvas.setCapture();
                        else {
                            document.documentElement.addEventListener("mouseup", this._mouseEventHandler, false);
                            //addEvent(document.body, "mouseup", this._mouseEventHandler);
                        }
                    } else if (type === "mouseup") {
                        if (eventParam.chart.overlaidCanvas.releaseCapture)
                            eventParam.chart.overlaidCanvas.releaseCapture();
                        else
                            document.documentElement.removeEventListener("mouseup", this._mouseEventHandler, false);
                    }

                    break;
                }
                else
                    eventParam = null;
            }

            if (eventParam && eventParam.cursor) {
                ev.target.style.cursor = eventParam.cursor;
            }
            else
                ev.target.style.cursor = this._defaultCursor;

            //eventParam =
        }

        var plotArea = this.plotArea;
        if (xy.x < plotArea.x1 || xy.x > plotArea.x2 || xy.y < plotArea.y1 || xy.y > plotArea.y2) {
            if (this.toolTip && this.toolTip.enabled) {
                this.toolTip.hide();
            } else {
                this.resetOverlayedCanvas();
            }
        }


        if ((!this.isDrag || !this.zoomEnabled) && this._eventManager) {

            this._eventManager.mouseEventHandler(ev);
            //this._updateToolTip(ev.x, ev.y);
        }

        //if (this.toolTip.enabled)
        //    this.toolTip.mouseMoveHandler(ev.x, ev.y);
    }

    Chart.prototype._plotAreaMouseDown = function (x, y) {
        this.isDrag = true;

        this.dragStartPoint = {
            x: x, y: y
        };
    }

    Chart.prototype._plotAreaMouseUp = function (x, y) {
        var plotArea = this.plotArea;

        if (this.plotInfo.axisPlacement === "normal" || this.plotInfo.axisPlacement === "xySwapped") {
            if (this.isDrag) {
                var dragDelta = 0,
                    dragDeltaPY = y - this.dragStartPoint.y,
                    dragDeltaPX = x - this.dragStartPoint.x,
                    zoomPX = this.zoomType.indexOf("x") >= 0, //Whether to zoom horizontally
                    zoomPY = this.zoomType.indexOf("y") >= 0, //Whether to zoom vertically
                    reRender = false;

                this.resetOverlayedCanvas();

                if (this.plotInfo.axisPlacement === "xySwapped") {
                    var temp = zoomPY;
                    zoomPY = zoomPX;
                    zoomPX = temp;
                }

                if (this.panEnabled || this.zoomEnabled) {
                    if (this.panEnabled) {

                        var overflow = 0;

                        for (var i = 0; i < this._axes.length; i++) {
                            var axis = this._axes[i];
                            if (axis.logarithmic) {
                                if (axis.viewportMinimum < axis.minimum) {

                                    overflow = axis.minimum / axis.viewportMinimum;

                                    axis.sessionVariables.newViewportMinimum = axis.viewportMinimum * overflow;
                                    axis.sessionVariables.newViewportMaximum = axis.viewportMaximum * overflow;

                                    reRender = true;
                                } else if (axis.viewportMaximum > axis.maximum) {

                                    overflow = axis.viewportMaximum / axis.maximum;
                                    axis.sessionVariables.newViewportMinimum = axis.viewportMinimum / overflow;
                                    axis.sessionVariables.newViewportMaximum = axis.viewportMaximum / overflow;

                                    reRender = true;
                                }
                            }
                            else {
                                if (axis.viewportMinimum < axis.minimum) {

                                    overflow = axis.minimum - axis.viewportMinimum;

                                    axis.sessionVariables.newViewportMinimum = axis.viewportMinimum + overflow;
                                    axis.sessionVariables.newViewportMaximum = axis.viewportMaximum + overflow;

                                    reRender = true;
                                } else if (axis.viewportMaximum > axis.maximum) {

                                    overflow = axis.viewportMaximum - axis.maximum;
                                    axis.sessionVariables.newViewportMinimum = axis.viewportMinimum - overflow;
                                    axis.sessionVariables.newViewportMaximum = axis.viewportMaximum - overflow;

                                    reRender = true;
                                }
                            }
                        }

                    }
                    else if (((!zoomPX || Math.abs(dragDeltaPX) > 2) && (!zoomPY || Math.abs(dragDeltaPY) > 2)) && this.zoomEnabled) {

                        if (!this.dragStartPoint)
                            return;

                        var selectedRegion = {
                            x1: zoomPX ? this.dragStartPoint.x : this.plotArea.x1,
                            y1: zoomPY ? this.dragStartPoint.y : this.plotArea.y1,
                            x2: zoomPX ? x : this.plotArea.x2,
                            y2: zoomPY ? y : this.plotArea.y2
                        };

                        if (Math.abs(selectedRegion.x1 - selectedRegion.x2) > 2 && Math.abs(selectedRegion.y1 - selectedRegion.y2) > 2) {

                            if (this._zoomPanToSelectedRegion(selectedRegion.x1, selectedRegion.y1, selectedRegion.x2, selectedRegion.y2)) {

                                reRender = true;
                            }
                        }
                    }

                    if (reRender) {
                        this._ignoreNextEvent = true;//Required so that click event doesn't fire after zooming into a section of the chart.

                        this._dispatchRangeEvent("rangeChanging", "zoom");
                        this.render();
                        this._dispatchRangeEvent("rangeChanged", "zoom");

                        if (reRender && this.zoomEnabled && this._zoomButton.style.display === "none") {
                            show(this._zoomButton, this._resetButton);
                            setButtonState(this, this._zoomButton, "pan");
                            setButtonState(this, this._resetButton, "reset");
                        }
                    }
                }
            }

        }

        this.isDrag = false;
    }

    Chart.prototype._plotAreaMouseMove = function (x, y) {
        if (this.isDrag && this.plotInfo.axisPlacement !== "none") {

            var dragDeltaPX = 0,
                dragDeltaPY = 0,
                alpha = null,
                selectedRegion = null,
                zoomPX = this.zoomType.indexOf("x") >= 0, //Whether to zoom horizontally
                zoomPY = this.zoomType.indexOf("y") >= 0, //Whether to zoom vertically
                _this = this;

            if (this.plotInfo.axisPlacement === "xySwapped") {
                var temp = zoomPY;
                zoomPY = zoomPX;
                zoomPX = temp;
            }

            dragDeltaPX = this.dragStartPoint.x - x;
            dragDeltaPY = this.dragStartPoint.y - y;

            if (Math.abs(dragDeltaPX) > 2 && Math.abs(dragDeltaPX) < 8 && (this.panEnabled || this.zoomEnabled)) {
                this.toolTip.hide();
            } else if (!this.panEnabled && !this.zoomEnabled) {
                this.toolTip.mouseMoveHandler(x, y);
            }

            if (((!zoomPX || Math.abs(dragDeltaPX) > 2) || (!zoomPY || Math.abs(dragDeltaPY) > 2)) && (this.panEnabled || this.zoomEnabled)) {
                if (this.panEnabled) {

                    selectedRegion =
                        {
                            x1: zoomPX ? this.plotArea.x1 + dragDeltaPX : this.plotArea.x1,
                            y1: zoomPY ? this.plotArea.y1 + dragDeltaPY : this.plotArea.y1,
                            x2: zoomPX ? this.plotArea.x2 + dragDeltaPX : this.plotArea.x2,
                            y2: zoomPY ? this.plotArea.y2 + dragDeltaPY : this.plotArea.y2
                        };

                    clearTimeout(_this._panTimerId);
                    _this._panTimerId = setTimeout((function (x1, y1, x2, y2) {
                        return function () {
                            if (_this._zoomPanToSelectedRegion(x1, y1, x2, y2, true)) {
                                //console.log(x1, "->", x2);
                                _this._dispatchRangeEvent("rangeChanging", "pan");
                                _this.render();
                                _this._dispatchRangeEvent("rangeChanged", "pan");

                                _this.dragStartPoint.x = x;
                                _this.dragStartPoint.y = y;
                            }
                        };
                    })(selectedRegion.x1, selectedRegion.y1, selectedRegion.x2, selectedRegion.y2), 0);

                } else if (this.zoomEnabled) {

                    this.resetOverlayedCanvas();

                    alpha = this.overlaidCanvasCtx.globalAlpha;


                    this.overlaidCanvasCtx.fillStyle = "#A89896";

                    var rect = {
                        x1: zoomPX ? this.dragStartPoint.x : this.plotArea.x1,
                        y1: zoomPY ? this.dragStartPoint.y : this.plotArea.y1,
                        x2: zoomPX ? x - this.dragStartPoint.x : this.plotArea.x2 - this.plotArea.x1,
                        y2: zoomPY ? y - this.dragStartPoint.y : this.plotArea.y2 - this.plotArea.y1
                    };

                    if (this.validateRegion(rect.x1, rect.y1, zoomPX ? x : this.plotArea.x2 - this.plotArea.x1, zoomPY ? y : this.plotArea.y2 - this.plotArea.y1, this.zoomType !== "xy").isValid) {
                        this.resetOverlayedCanvas();
                        this.overlaidCanvasCtx.fillStyle = "#99B2B5"; //"#A0ABB8";
                    }

                    this.overlaidCanvasCtx.globalAlpha = .7;
                    this.overlaidCanvasCtx.fillRect(rect.x1, rect.y1, rect.x2, rect.y2);

                    this.overlaidCanvasCtx.globalAlpha = alpha;
                }
            }

        } else
            this.toolTip.mouseMoveHandler(x, y);
    }

    //#endregion Events

    //Sets the viewport range of Axis based on the given rect bounds (pixels). Also limits the zooming/panning based on axis bounds. Returns a boolean to indicate whether it was succesful or not based on the selected region.
    Chart.prototype._zoomPanToSelectedRegion = function (px1, py1, px2, py2, keepAxisIndependent) {

        var validateRegion = this.validateRegion(px1, py1, px2, py2, keepAxisIndependent);
        var axesWithValidRange = validateRegion.axesWithValidRange,
            axesRanges = validateRegion.axesRanges;


        if (validateRegion.isValid) {
            for (var i = 0; i < axesWithValidRange.length; i++) {
                var axis = axesWithValidRange[i];
                var param = axesRanges[i];

                axis.setViewPortRange(param.val1, param.val2);
            }
        }
        //else console.log(px1,px2, val2, "-", val1, "=", Math.abs(val2 - val1));

        return validateRegion.isValid;
    }

    Chart.prototype.validateRegion = function (px1, py1, px2, py2, keepAxisIndependent) {

        keepAxisIndependent = keepAxisIndependent || false;

        var zoomPX = this.zoomType.indexOf("x") >= 0, //Whether to zoom horizontally
            zoomPY = this.zoomType.indexOf("y") >= 0, //Whether to zoom vertically
            isValid = false,
            axesWithValidRange = [],
            axes = [],
            axesRanges = [];

        for (var k = 0; k < this.axisX.length; k++)
            if (this.axisX[k] && zoomPX)
                axes.push(this.axisX[k]);

        for (var k = 0; k < this.axisX2.length; k++)
            if (this.axisX2[k] && zoomPX)
                axes.push(this.axisX2[k]);

        for (var k = 0; k < this.axisY.length; k++)
            if (this.axisY[k] && zoomPY)
                axes.push(this.axisY[k]);

        for (var k = 0; k < this.axisY2.length; k++)
            if (this.axisY2[k] && zoomPY)
                axes.push(this.axisY2[k]);


        for (var i = 0; i < axes.length; i++) {
            var axis = axes[i];
            //var range = Math.abs(axis.viewportMaximum - axis.viewportMinimum);

            var val1 = axis.convertPixelToValue({ x: px1, y: py1 });
            var val2 = axis.convertPixelToValue({ x: px2, y: py2 });

            if (val1 > val2) {
                var temp = val2;
                val2 = val1;
                val1 = temp;
            }

            if (isFinite(axis.dataInfo.minDiff)) {
                if (!(axis.logarithmic && val2 / val1 < Math.pow(axis.dataInfo.minDiff, 3) || !axis.logarithmic && Math.abs(val2 - val1) < 3 * Math.abs(axis.dataInfo.minDiff)
                    || (val1 < axis.minimum) || (val2 > axis.maximum))) {
                    axesWithValidRange.push(axis);
                    axesRanges.push({ val1: val1, val2: val2 });

                    isValid = true;
                } else if (!keepAxisIndependent) {
                    isValid = false;
                    break;
                }
            }
        }

        return {
            isValid: isValid, axesWithValidRange: axesWithValidRange, axesRanges: axesRanges
        };
    }

    Chart.prototype.preparePlotArea = function () {

        var plotArea = this.plotArea;

        if (!isCanvasSupported && (plotArea.x1 > 0 || plotArea.y1 > 0)) {
            plotArea.ctx.translate(plotArea.x1, plotArea.y1);
        }

        if ((this.axisX[0] || this.axisX2[0]) && (this.axisY[0] || this.axisY2[0])) {
            var lineCoordinates = this.axisX[0] ? this.axisX[0].lineCoordinates : this.axisX2[0].lineCoordinates;

            if (this.axisY && this.axisY.length > 0) {
                if (this.axisY[0]) {
                    var yAxis = this.axisY[0];
                    plotArea.x1 = lineCoordinates.x1 < lineCoordinates.x2 ? lineCoordinates.x1 : yAxis.lineCoordinates.x1;
                    plotArea.y1 = (lineCoordinates.y1 < yAxis.lineCoordinates.y1 ? lineCoordinates.y1 : yAxis.lineCoordinates.y1);

                    plotArea.x2 = (lineCoordinates.x2 > yAxis.lineCoordinates.x2 ? lineCoordinates.x2 : yAxis.lineCoordinates.x2);
                    plotArea.y2 = lineCoordinates.y2 > lineCoordinates.y1 ? lineCoordinates.y2 : yAxis.lineCoordinates.y2;

                    plotArea.width = plotArea.x2 - plotArea.x1;
                    plotArea.height = plotArea.y2 - plotArea.y1;
                    //plotArea = { x1: x1, y1: y1, x2: x2, y2: y2, width: x2 - x1, height: y2 - y1 };
                }
            }
            if (this.axisY2 && this.axisY2.length > 0) {
                if (this.axisY2[0]) {
                    var yAxis = this.axisY2[0];
                    plotArea.x1 = lineCoordinates.x1 < lineCoordinates.x2 ? lineCoordinates.x1 : yAxis.lineCoordinates.x1;
                    plotArea.y1 = (lineCoordinates.y1 < yAxis.lineCoordinates.y1 ? lineCoordinates.y1 : yAxis.lineCoordinates.y1);

                    plotArea.x2 = (lineCoordinates.x2 > yAxis.lineCoordinates.x2 ? lineCoordinates.x2 : yAxis.lineCoordinates.x2);
                    plotArea.y2 = lineCoordinates.y2 > lineCoordinates.y1 ? lineCoordinates.y2 : yAxis.lineCoordinates.y2;

                    plotArea.width = plotArea.x2 - plotArea.x1;
                    plotArea.height = plotArea.y2 - plotArea.y1;
                    //plotArea = { x1: x1, y1: y1, x2: x2, y2: y2, width: x2 - x1, height: y2 - y1 };
                }
            }
        } else {
            //ToDo: @sunil
            var freeSpace = this.layoutManager.getFreeSpace();
            plotArea.x1 = freeSpace.x1;
            plotArea.x2 = freeSpace.x2;
            plotArea.y1 = freeSpace.y1;
            plotArea.y2 = freeSpace.y2;

            plotArea.width = freeSpace.width;
            plotArea.height = freeSpace.height;
        }

        if (!isCanvasSupported) {

            plotArea.canvas.width = plotArea.width;
            plotArea.canvas.height = plotArea.height;

            plotArea.canvas.style.left = plotArea.x1 + "px";
            plotArea.canvas.style.top = plotArea.y1 + "px";

            if (plotArea.x1 > 0 || plotArea.y1 > 0) {
                plotArea.ctx.translate(-plotArea.x1, -plotArea.y1);
            }
        }

        plotArea.layoutManager = new LayoutManager(plotArea.x1, plotArea.y1, plotArea.x2, plotArea.y2, 2);
    }

    //#region Render Methods

    Chart.prototype.renderIndexLabels = function (targetCtx) {
        var ctx = targetCtx || this.plotArea.ctx;

        var plotArea = this.plotArea;

        var mid = 0;
        var yMinLimit = 0;
        var yMaxLimit = 0;
        var xMinLimit = 0;
        var xMaxLimit = 0;
        var marginX = 0, marginY = 0; // Margin between label and dataPoint / PlotArea
        var offSetX = 0, offSetY = 0; // Distance to offSet textBlock (top) from dataPoint inorder to position it
        var offset = 0;
        var visibleWidth = 0;
        var visibleHeight = 0;

        for (var i = 0; i < this._indexLabels.length; i++) {

            var indexLabel = this._indexLabels[i];
            var chartTypeLower = indexLabel.chartType.toLowerCase();

            var x, y, angle;

            var fontColor = getProperty("indexLabelFontColor", indexLabel.dataPoint, indexLabel.dataSeries);
            var fontSize = getProperty("indexLabelFontSize", indexLabel.dataPoint, indexLabel.dataSeries);
            var fontFamily = getProperty("indexLabelFontFamily", indexLabel.dataPoint, indexLabel.dataSeries);
            var fontStyle = getProperty("indexLabelFontStyle", indexLabel.dataPoint, indexLabel.dataSeries);
            var fontWeight = getProperty("indexLabelFontWeight", indexLabel.dataPoint, indexLabel.dataSeries);
            var backgroundColor = getProperty("indexLabelBackgroundColor", indexLabel.dataPoint, indexLabel.dataSeries);
            var maxWidth = getProperty("indexLabelMaxWidth", indexLabel.dataPoint, indexLabel.dataSeries);
            var indexLabelWrap = getProperty("indexLabelWrap", indexLabel.dataPoint, indexLabel.dataSeries);
            var indexLabelLineDashType = getProperty("indexLabelLineDashType", indexLabel.dataPoint, indexLabel.dataSeries);
            var indexLabelLineColor = getProperty("indexLabelLineColor", indexLabel.dataPoint, indexLabel.dataSeries);
            var indexLabelLineThickness = isNullOrUndefined(indexLabel.dataPoint.indexLabelLineThickness) ?
                isNullOrUndefined(indexLabel.dataSeries.options.indexLabelLineThickness) ? 0 : indexLabel.dataSeries.options.indexLabelLineThickness
                : indexLabel.dataPoint.indexLabelLineThickness;
            offset = indexLabelLineThickness > 0 ? Math.min(10, (this.plotInfo.axisPlacement === "normal" ? this.plotArea.height : this.plotArea.width) << 0) : 0;

            var percentAndTotal = {
                percent: null, total: null
            };
            var formatterParameter = null;

            if (indexLabel.dataSeries.type.indexOf("stacked") >= 0 || indexLabel.dataSeries.type === "pie" || indexLabel.dataSeries.type === "doughnut")
                percentAndTotal = this.getPercentAndTotal(indexLabel.dataSeries, indexLabel.dataPoint);

            if (indexLabel.dataSeries.indexLabelFormatter || indexLabel.dataPoint.indexLabelFormatter)
                formatterParameter = {
                    chart: this, dataSeries: indexLabel.dataSeries, dataPoint: indexLabel.dataPoint, index: indexLabel.indexKeyword, total: percentAndTotal.total, percent: percentAndTotal.percent
                };


            var indexLabelText = indexLabel.dataPoint.indexLabelFormatter ? indexLabel.dataPoint.indexLabelFormatter(formatterParameter)
                : indexLabel.dataPoint.indexLabel ? this.replaceKeywordsWithValue(indexLabel.dataPoint.indexLabel, indexLabel.dataPoint, indexLabel.dataSeries, null, indexLabel.indexKeyword)
                    : indexLabel.dataSeries.indexLabelFormatter ? indexLabel.dataSeries.indexLabelFormatter(formatterParameter)
                        : indexLabel.dataSeries.indexLabel ? this.replaceKeywordsWithValue(indexLabel.dataSeries.indexLabel, indexLabel.dataPoint, indexLabel.dataSeries, null, indexLabel.indexKeyword) : null;

            if (indexLabelText === null || indexLabelText === "")
                continue;

            var placement = getProperty("indexLabelPlacement", indexLabel.dataPoint, indexLabel.dataSeries);
            var orientation = getProperty("indexLabelOrientation", indexLabel.dataPoint, indexLabel.dataSeries);
            var angle = 0;

            var direction = indexLabel.direction; // +1 for above the point and -1 for below the point

            var axisX = indexLabel.dataSeries.axisX;
            var axisY = indexLabel.dataSeries.axisY;
            var isInside = false;


            var textBlock = new TextBlock(ctx, {
                x: 0,
                y: 0,
                maxWidth: maxWidth ? maxWidth : this.width * .5,
                maxHeight: indexLabelWrap ? fontSize * 5 : fontSize * 1.5,
                angle: orientation === "horizontal" ? 0 : -90,
                text: indexLabelText,
                padding: 0,
                backgroundColor: backgroundColor,
                horizontalAlign: "left",//left, center, right
                fontSize: fontSize,//in pixels
                fontFamily: fontFamily,
                fontWeight: fontWeight, //normal, bold, bolder, lighter,
                fontColor: fontColor,
                fontStyle: fontStyle, // normal, italic, oblique
                textBaseline: "top"
            });

            var textSize = textBlock.measureText();

            indexLabel.dataSeries.indexLabelMaxWidth = textBlock.maxWidth;
            //if (indexLabel.dataPoint.x < axisX.viewportMinimum || indexLabel.dataPoint.x > axisX.viewportMaximum || indexLabel.dataPoint.y < axisY.viewportMinimum || indexLabel.dataPoint.y > axisY.viewportMaximum)
            //	continue;

            if (chartTypeLower === "stackedarea100") {
                if (indexLabel.point.x < plotArea.x1 || indexLabel.point.x > plotArea.x2 || indexLabel.point.y < plotArea.y1 - 1 || indexLabel.point.y > plotArea.y2 + 1)
                    continue;
            }
            else if (chartTypeLower === "rangearea" || chartTypeLower === "rangesplinearea") {
                if (indexLabel.dataPoint.x < axisX.viewportMinimum || indexLabel.dataPoint.x > axisX.viewportMaximum || Math.max.apply(null, indexLabel.dataPoint.y) < axisY.viewportMinimum || Math.min.apply(null, indexLabel.dataPoint.y) > axisY.viewportMaximum)
                    continue;
            }
            else if (chartTypeLower.indexOf("line") >= 0 || chartTypeLower.indexOf("area") >= 0
                || chartTypeLower.indexOf("bubble") >= 0 || chartTypeLower.indexOf("scatter") >= 0) {

                if (indexLabel.dataPoint.x < axisX.viewportMinimum || indexLabel.dataPoint.x > axisX.viewportMaximum || indexLabel.dataPoint.y < axisY.viewportMinimum || indexLabel.dataPoint.y > axisY.viewportMaximum)
                    continue;
            }
            else if (chartTypeLower.indexOf("column") >= 0) {
                if (indexLabel.dataPoint.x < axisX.viewportMinimum || indexLabel.dataPoint.x > axisX.viewportMaximum || indexLabel.bounds.y1 > plotArea.y2 || indexLabel.bounds.y2 < plotArea.y1)
                    continue;
            }
            else if (chartTypeLower.indexOf("bar") >= 0) {
                if (indexLabel.dataPoint.x < axisX.viewportMinimum || indexLabel.dataPoint.x > axisX.viewportMaximum || indexLabel.bounds.x1 > plotArea.x2 || indexLabel.bounds.x2 < plotArea.x1)
                    continue;
            }
            else if (chartTypeLower === "candlestick" || chartTypeLower === "ohlc") {
                if (indexLabel.dataPoint.x < axisX.viewportMinimum || indexLabel.dataPoint.x > axisX.viewportMaximum || Math.max.apply(null, indexLabel.dataPoint.y) < axisY.viewportMinimum || Math.min.apply(null, indexLabel.dataPoint.y) > axisY.viewportMaximum)
                    continue;
            }
            else {
                if (indexLabel.dataPoint.x < axisX.viewportMinimum || indexLabel.dataPoint.x > axisX.viewportMaximum)
                    continue;
            }

            marginY = 2;
            marginX = 2;

            if (orientation === "horizontal") {
                visibleWidth = textBlock.width;
                visibleHeight = textBlock.height;
            } else {
                visibleHeight = textBlock.width;
                visibleWidth = textBlock.height;
            }

            if (this.plotInfo.axisPlacement === "normal") {

                if (chartTypeLower.indexOf("line") >= 0 || chartTypeLower.indexOf("area") >= 0) {

                    placement = "auto";
                    marginY = 4;

                } else if (chartTypeLower.indexOf("stacked") >= 0) {

                    if (placement === "auto")
                        placement = "inside";

                } else if (chartTypeLower === "bubble" || chartTypeLower === "scatter") {

                    placement = "inside";

                }

                x = indexLabel.point.x - visibleWidth / 2;

                if (placement !== "inside") {	//outside or auto

                    yMinLimit = plotArea.y1;
                    yMaxLimit = plotArea.y2;

                    if (direction > 0) {
                        y = indexLabel.point.y - visibleHeight - marginY - offset;

                        if (y < yMinLimit) {
                            if (placement === "auto") {
                                y = Math.max(indexLabel.point.y, yMinLimit) + marginY + offset;
                            }
                            else {
                                y = yMinLimit + marginY + offset;
                            }
                            isInside = y + visibleHeight > indexLabel.point.y;
                        }
                    }
                    else {
                        y = indexLabel.point.y + marginY + offset;

                        if (y > yMaxLimit - visibleHeight - marginY - offset) {
                            if (placement === "auto") {
                                y = Math.min(indexLabel.point.y, yMaxLimit) - visibleHeight - marginY - offset;
                            }
                            else {
                                y = yMaxLimit - visibleHeight - marginY - offset;
                            }
                            isInside = y < indexLabel.point.y;
                        }
                    }

                } else {


                    yMinLimit = Math.max(indexLabel.bounds.y1, plotArea.y1);
                    yMaxLimit = Math.min(indexLabel.bounds.y2, plotArea.y2);


                    if (chartTypeLower.indexOf("range") >= 0) {
                        if (direction > 0)
                            mid = Math.max(indexLabel.bounds.y1, plotArea.y1) + visibleHeight / 2 + marginY;
                        else
                            mid = Math.min(indexLabel.bounds.y2, plotArea.y2) - visibleHeight / 2 - marginY;
                    }
                    else
                        mid = (Math.max(indexLabel.bounds.y1, plotArea.y1) + Math.min(indexLabel.bounds.y2, plotArea.y2)) / 2

                    if (direction > 0) {
                        y = Math.max(indexLabel.point.y, mid) - visibleHeight / 2;

                        if (y < yMinLimit && (chartTypeLower === "bubble" || chartTypeLower === "scatter")) {
                            y = Math.max(indexLabel.point.y - visibleHeight - marginY, plotArea.y1 + marginY);
                        }
                    }
                    else {
                        y = Math.min(indexLabel.point.y, mid) - visibleHeight / 2;

                        if (y > yMaxLimit - visibleHeight - marginY && (chartTypeLower === "bubble" || chartTypeLower === "scatter")) {
                            y = Math.min(indexLabel.point.y + marginY, plotArea.y2 - visibleHeight - marginY);
                        }
                    }

                    // Make Sure that it does not overlap the axis line
                    y = Math.min(y, yMaxLimit - visibleHeight);
                }
            }
            else {

                if (chartTypeLower.indexOf("line") >= 0 || chartTypeLower.indexOf("area") >= 0
                    || chartTypeLower.indexOf("scatter") >= 0) {

                    placement = "auto";
                    marginX = 4;

                } else if (chartTypeLower.indexOf("stacked") >= 0) {

                    if (placement === "auto")
                        placement = "inside";

                } else if (chartTypeLower === "bubble") {

                    placement = "inside";

                }

                y = indexLabel.point.y - visibleHeight / 2;

                if (placement !== "inside") {	//outside or auto

                    xMinLimit = plotArea.x1;
                    xMaxLimit = plotArea.x2;

                    if (direction < 0) {
                        x = indexLabel.point.x - visibleWidth - marginX - offset;

                        if (x < xMinLimit) {
                            if (placement === "auto") {
                                x = Math.max(indexLabel.point.x, xMinLimit) + marginX + offset;
                            }
                            else {
                                x = xMinLimit + marginX + offset;
                            }
                            isInside = x + visibleWidth > indexLabel.point.x;
                        }
                    }
                    else {
                        x = indexLabel.point.x + marginX + offset;

                        if (x > xMaxLimit - visibleWidth - marginX - offset) {
                            if (placement === "auto") {
                                x = Math.min(indexLabel.point.x, xMaxLimit) - visibleWidth - marginX - offset;
                            }
                            else {
                                x = xMaxLimit - visibleWidth - marginX - offset;
                            }
                            isInside = x < indexLabel.point.x;
                        }
                    }

                } else {

                    xMinLimit = Math.max(indexLabel.bounds.x1, plotArea.x1);
                    xMaxLimit = Math.min(indexLabel.bounds.x2, plotArea.x2);

                    if (chartTypeLower.indexOf("range") >= 0) {
                        if (direction < 0)
                            mid = Math.max(indexLabel.bounds.x1, plotArea.x1) + visibleWidth / 2 + marginX;
                        else
                            mid = Math.min(indexLabel.bounds.x2, plotArea.x2) - visibleWidth / 2 - marginX;
                    }
                    else
                        var mid = (Math.max(indexLabel.bounds.x1, plotArea.x1) + Math.min(indexLabel.bounds.x2, plotArea.x2)) / 2;

                    if (direction < 0) {
                        x = Math.max(indexLabel.point.x, mid) - visibleWidth / 2;

                        //if (y < xMinLimit) {
                        //	y = Math.max(indexLabel.point.y - visibleHeight - marginY, plotArea.y1 + marginY);
                        //}
                    }
                    else {
                        x = Math.min(indexLabel.point.x, mid) - visibleWidth / 2;

                        //if (y > xMaxLimit - visibleHeight - marginY) {
                        //	y = Math.min(indexLabel.point.y + marginY, plotArea.y2 - visibleHeight - marginY);
                        //}
                    }

                    // Make Sure that it does not overlap the axis line
                    x = Math.max(x, xMinLimit);
                }
            }

            if (orientation === "vertical") {
                y += visibleHeight;
            }

            //y -= 5;
            textBlock.x = x;
            textBlock.y = y;

            //console.log(textBlock.text + ": " + textBlock.x + "; " + textBlock.y);

            textBlock.render(true);

            //indexLabel connection line rendering logic not for pie and doughnut, use textSize later on
            if (indexLabelLineThickness && placement !== "inside" &&
                (chartTypeLower.indexOf("bar") < 0 && indexLabel.point.x > plotArea.x1 && indexLabel.point.x < plotArea.x2 || !isInside) &&
                (chartTypeLower.indexOf("column") < 0 && indexLabel.point.y > plotArea.y1 && indexLabel.point.y < plotArea.y2 || !isInside)) {

                ctx.lineWidth = indexLabelLineThickness;
                ctx.strokeStyle = indexLabelLineColor ? indexLabelLineColor : "gray";
                if (ctx.setLineDash) {
                    ctx.setLineDash(getLineDashArray(indexLabelLineDashType, indexLabelLineThickness));
                }
                ctx.beginPath();
                ctx.moveTo(indexLabel.point.x, indexLabel.point.y);

                if (chartTypeLower.indexOf("bar") >= 0)
                    ctx.lineTo(x + (indexLabel.direction > 0 ? 0 : visibleWidth), y + (orientation === "horizontal" ? visibleHeight : -visibleHeight) / 2);
                else if (chartTypeLower.indexOf("column") >= 0)
                    ctx.lineTo(x + visibleWidth / 2, y + ((indexLabel.direction > 0 ? visibleHeight : -visibleHeight) + (orientation === "horizontal" ? visibleHeight : -visibleHeight)) / 2);
                else
                    ctx.lineTo(x + visibleWidth / 2, y + ((y < indexLabel.point.y ? visibleHeight : -visibleHeight) + (orientation === "horizontal" ? visibleHeight : -visibleHeight)) / 2);
                ctx.stroke();
            }
        }

        //source and dest would be same when animation is not enabled
        var animationInfo = {
            source: ctx, dest: this.plotArea.ctx, animationCallback: AnimationHelper.fadeInAnimation, easingFunction: AnimationHelper.easing.easeInQuad, animationBase: 0, startTimePercent: .7
        };

        for (var i = 0; i < this._indexLabels.length; i++) {
            var indexLabel = this._indexLabels[i];
            var backgroundColor = getProperty("indexLabelBackgroundColor", indexLabel.dataPoint, indexLabel.dataSeries);
            indexLabel.dataSeries.indexLabelBackgroundColor = !isNullOrUndefined(backgroundColor) ? backgroundColor : (isCanvasSupported ? "transparent" : null);
        }
        return animationInfo;
    }

    Chart.prototype.renderLine = function (plotUnit) {

        var ctx = plotUnit.targetCanvasCtx || this.plotArea.ctx;

        var totalDataSeries = plotUnit.dataSeriesIndexes.length;
        if (totalDataSeries <= 0)
            return;

        var ghostCtx = this._eventManager.ghostCtx;
        //var ghostCtx = this.overlaidCanvasCtx;

        ctx.save();

        var plotArea = this.plotArea;

        ctx.beginPath();
        ctx.rect(plotArea.x1, plotArea.y1, plotArea.width, plotArea.height);
        ctx.clip();

        var markers = [];
        var markerPropsColor = null;
        var previousNotNullDataPoint;
        //var defaultLineJoinType = ctx.lineJoin;
        //ctx.lineJoin = "round";

        for (var j = 0; j < plotUnit.dataSeriesIndexes.length; j++) {

            var dataSeriesIndex = plotUnit.dataSeriesIndexes[j];

            var dataSeries = this.data[dataSeriesIndex];
            ctx.lineWidth = dataSeries.lineThickness;
            var dataPoints = dataSeries.dataPoints;
            var currentLineDashType = "solid";

            if (ctx.setLineDash) {
                var nullDataLineDashType = getLineDashArray(dataSeries.nullDataLineDashType, dataSeries.lineThickness);
                currentLineDashType = dataSeries.lineDashType;
                var lineDashType = getLineDashArray(currentLineDashType, dataSeries.lineThickness);
                ctx.setLineDash(lineDashType);
            }

            var seriesId = dataSeries.id;
            this._eventManager.objectMap[seriesId] = {
                objectType: "dataSeries", dataSeriesIndex: dataSeriesIndex
            };
            var hexColor = intToHexColorString(seriesId);
            ghostCtx.strokeStyle = hexColor;
            //ghostCtx.lineWidth = dataSeries.lineThickness;
            ghostCtx.lineWidth = dataSeries.lineThickness > 0 ? Math.max(dataSeries.lineThickness, 4) : 0;

            var colorSet = dataSeries._colorSet;
            var color = dataSeries.lineColor = dataSeries.options.lineColor ? dataSeries.options.lineColor : colorSet[0];
            var currentStrokeStyle = color;
            ctx.strokeStyle = color;

            var isFirstDataPointInPlotArea = true;
            var i = 0, x, y;
            var dataPointX; //Used so that when dataPoint.x is a DateTime value, it doesn't get converted to number back and forth.

            //if (!dataSeries.options.markerSize && dataSeries.dataPoints.length < 1000)
            //    dataSeries.markerSize = 8;
            ctx.beginPath();
            if (dataPoints.length > 0) {
                //dataSeries.noDataPointsInPlotArea = 0
                var prevDataNull = false;
                for (i = 0; i < dataPoints.length; i++) {

                    dataPointX = dataPoints[i].x.getTime ? dataPoints[i].x.getTime() : dataPoints[i].x;

                    if (dataPointX < plotUnit.axisX.dataInfo.viewPortMin || dataPointX > plotUnit.axisX.dataInfo.viewPortMax && !(dataSeries.connectNullData && prevDataNull))
                        continue;

                    //if (!isFinite(dataPoints[i].y))
                    //    continue;

                    if (typeof (dataPoints[i].y) !== "number") {
                        if (i > 0 && !(dataSeries.connectNullData || prevDataNull || isFirstDataPointInPlotArea)) {// if first dataPoint is null then no need to call stroke method
                            ctx.stroke();
                            if (isCanvasSupported) {
                                ghostCtx.stroke();
                            }
                        }


                        prevDataNull = true;
                        continue;
                    }

                    x = plotUnit.axisX.convertValueToPixel(dataPointX);
                    y = plotUnit.axisY.convertValueToPixel(dataPoints[i].y);

                    var id = dataSeries.dataPointIds[i];
                    this._eventManager.objectMap[id] = {
                        id: id, objectType: "dataPoint", dataSeriesIndex: dataSeriesIndex, dataPointIndex: i, x1: x, y1: y
                    };


                    //dataSeries.noDataPointsInPlotArea++;

                    if (isFirstDataPointInPlotArea || prevDataNull) {

                        //For drawing line over nonNull dataPoints
                        if (!isFirstDataPointInPlotArea && dataSeries.connectNullData) {
                            //Applying nullLineDshType If lineDashType at dataPoints not mentoioned in prevuous dataPoints
                            if (ctx.setLineDash && (dataSeries.options.nullDataLineDashType || (currentLineDashType === dataSeries.lineDashType && dataSeries.lineDashType !== dataSeries.nullDataLineDashType))) {
                                ctx.stroke();
                                //if (isCanvasSupported) {
                                //	ghostCtx.stroke();
                                //}
                                ctx.beginPath();
                                ctx.moveTo(previousNotNullDataPoint.x, previousNotNullDataPoint.y);
                                currentLineDashType = dataSeries.nullDataLineDashType;
                                ctx.setLineDash(nullDataLineDashType);
                            }

                            ctx.lineTo(x, y);
                            if (isCanvasSupported)
                                ghostCtx.lineTo(x, y);

                        } else { //If connectNullData = false
                            ctx.beginPath();
                            ctx.moveTo(x, y);
                            if (isCanvasSupported) {
                                ghostCtx.beginPath();
                                ghostCtx.moveTo(x, y);
                            }
                        }

                        isFirstDataPointInPlotArea = false;
                        prevDataNull = false;
                    } else {

                        ctx.lineTo(x, y);

                        if (isCanvasSupported)
                            ghostCtx.lineTo(x, y);

                        if (i % 500 == 0) {
                            ctx.stroke();
                            ctx.beginPath();
                            ctx.moveTo(x, y);

                            if (isCanvasSupported) {
                                ghostCtx.stroke();
                                ghostCtx.beginPath();
                                ghostCtx.moveTo(x, y);
                            }
                        }
                    }

                    previousNotNullDataPoint = { x: x, y: y };

                    if (i < dataPoints.length - 1 && (currentStrokeStyle !== (dataPoints[i].lineColor || color) || currentLineDashType !== (dataPoints[i].lineDashType || dataSeries.lineDashType))) { //Applieng new ctx on DataPoint

                        ctx.stroke();
                        ctx.beginPath();
                        ctx.moveTo(x, y);
                        //if (isCanvasSupported) {
                        //	ghostCtx.stroke();
                        //	ghostCtx.beginPath();
                        //	ghostCtx.moveTo(x, y);
                        //}

                        currentStrokeStyle = dataPoints[i].lineColor || color;
                        ctx.strokeStyle = currentStrokeStyle;
                        if (ctx.setLineDash)
                            if (dataPoints[i].lineDashType) {
                                currentLineDashType = dataPoints[i].lineDashType;
                                ctx.setLineDash(getLineDashArray(currentLineDashType, dataSeries.lineThickness));
                            }
                            else {
                                currentLineDashType = dataSeries.lineDashType;
                                ctx.setLineDash(lineDashType);
                            }
                    }


                    //Render Marker
                    if (dataPoints[i].markerSize > 0 || dataSeries.markerSize > 0) {

                        var markerProps = dataSeries.getMarkerProperties(i, x, y, ctx);
                        markerPropsColor = markerProps.color;
                        markers.push(markerProps);

                        //if (!dataSeries.maxWidthInX || markerProps.size > dataSeries.maxWidthInX) {
                        //	dataSeries.maxWidthInX = markerProps.size / (plotUnit.axisX.conversionParameters.pixelPerUnit > 1 ? plotUnit.axisX.conversionParameters.pixelPerUnit - 1 : plotUnit.axisX.conversionParameters.pixelPerUnit);
                        //}

                        var markerColor = intToHexColorString(id);

                        //window.console.log("index: " + i + "; id: " + id + "; hex: " + markerColor);

                        if (isCanvasSupported) {
                            markers.push({
                                x: x, y: y, ctx: ghostCtx,
                                type: markerProps.type,
                                size: markerProps.size,
                                color: markerColor,
                                borderColor: markerColor,
                                borderThickness: markerProps.borderThickness
                            });
                        }
                    }

                    if (dataPoints[i].indexLabel || dataSeries.indexLabel || dataPoints[i].indexLabelFormatter || dataSeries.indexLabelFormatter) {

                        this._indexLabels.push({
                            chartType: "line",
                            dataPoint: dataPoints[i],
                            dataSeries: dataSeries,
                            point: {
                                x: x, y: y
                            },
                            direction: dataPoints[i].y < 0 === plotUnit.axisY.reversed ? 1 : -1,
                            color: color
                        });

                    }

                }

                ctx.stroke();

                if (isCanvasSupported)
                    ghostCtx.stroke();
            }

        }


        RenderHelper.drawMarkers(markers);
        //dataSeries.markerColor = markerPropsColor;
        ctx.restore();
        //ctx.lineJoin = defaultLineJoinType;

        ctx.beginPath();

        if (isCanvasSupported)
            ghostCtx.beginPath();

        //source and dest would be same when animation is not enabled
        var animationInfo = {
            source: ctx, dest: this.plotArea.ctx, animationCallback: AnimationHelper.xClipAnimation, easingFunction: AnimationHelper.easing.linear, animationBase: 0
        };
        return animationInfo;
    }

    Chart.prototype.renderStepLine = function (plotUnit) {
        var ctx = plotUnit.targetCanvasCtx || this.plotArea.ctx;

        var totalDataSeries = plotUnit.dataSeriesIndexes.length;
        if (totalDataSeries <= 0)
            return;

        var ghostCtx = this._eventManager.ghostCtx;
        //var ghostCtx = this.overlaidCanvasCtx;

        ctx.save();

        var plotArea = this.plotArea;

        ctx.beginPath();
        ctx.rect(plotArea.x1, plotArea.y1, plotArea.width, plotArea.height);
        ctx.clip();

        var markers = [];
        var markerPropsColor = null;
        var previousNotNullDataPoint;

        for (var j = 0; j < plotUnit.dataSeriesIndexes.length; j++) {

            var dataSeriesIndex = plotUnit.dataSeriesIndexes[j];

            var dataSeries = this.data[dataSeriesIndex];
            ctx.lineWidth = dataSeries.lineThickness;
            var dataPoints = dataSeries.dataPoints;
            var currentLineDashType = "solid";

            if (ctx.setLineDash) {
                var nullDataLineDashType = getLineDashArray(dataSeries.nullDataLineDashType, dataSeries.lineThickness);
                currentLineDashType = dataSeries.lineDashType;
                var lineDashType = getLineDashArray(currentLineDashType, dataSeries.lineThickness);
                ctx.setLineDash(lineDashType);
            }

            var seriesId = dataSeries.id;
            this._eventManager.objectMap[seriesId] = {
                objectType: "dataSeries", dataSeriesIndex: dataSeriesIndex
            };
            var hexColor = intToHexColorString(seriesId);
            ghostCtx.strokeStyle = hexColor;
            //ghostCtx.lineWidth = dataSeries.lineThickness;
            ghostCtx.lineWidth = dataSeries.lineThickness > 0 ? Math.max(dataSeries.lineThickness, 4) : 0;

            var colorSet = dataSeries._colorSet;
            var color = dataSeries.lineColor = dataSeries.options.lineColor ? dataSeries.options.lineColor : colorSet[0];
            var currentStrokeStyle = color;
            ctx.strokeStyle = color;

            var isFirstDataPointInPlotArea = true;
            var i = 0, x, y;
            var dataPointX; //Used so that when dataPoint.x is a DateTime value, it doesn't get converted to number back and forth.

            //if (!dataSeries.options.markerSize && dataSeries.dataPoints.length < 1000)
            //    dataSeries.markerSize = 8;
            ctx.beginPath();
            if (dataPoints.length > 0) {
                //dataSeries.noDataPointsInPlotArea = 0
                var prevDataNull = false;
                for (i = 0; i < dataPoints.length; i++) {

                    dataPointX = dataPoints[i].getTime ? dataPoints[i].x.getTime() : dataPoints[i].x;

                    if (dataPointX < plotUnit.axisX.dataInfo.viewPortMin || dataPointX > plotUnit.axisX.dataInfo.viewPortMax && !(dataSeries.connectNullData && prevDataNull))
                        continue;

                    //if (!isFinite(dataPoints[i].y))
                    //    continue;

                    if (typeof (dataPoints[i].y) !== "number") {
                        if (i > 0 && !(dataSeries.connectNullData || prevDataNull || isFirstDataPointInPlotArea)) {// if first dataPoint is null then no need to call stroke method
                            ctx.stroke();

                            if (isCanvasSupported) {
                                ghostCtx.stroke();
                            }
                        }

                        prevDataNull = true;
                        continue;
                    }

                    var prevY = y;

                    x = plotUnit.axisX.convertValueToPixel(dataPointX);
                    y = plotUnit.axisY.convertValueToPixel(dataPoints[i].y);

                    var id = dataSeries.dataPointIds[i];
                    this._eventManager.objectMap[id] = {
                        id: id, objectType: "dataPoint", dataSeriesIndex: dataSeriesIndex, dataPointIndex: i, x1: x, y1: y
                    };


                    //dataSeries.noDataPointsInPlotArea++;

                    if (isFirstDataPointInPlotArea || prevDataNull) {

                        if (!isFirstDataPointInPlotArea && dataSeries.connectNullData) {

                            if (ctx.setLineDash && (dataSeries.options.nullDataLineDashType || (currentLineDashType === dataSeries.lineDashType && dataSeries.lineDashType !== dataSeries.nullDataLineDashType))) {
                                ctx.stroke();
                                ctx.beginPath();
                                ctx.moveTo(previousNotNullDataPoint.x, previousNotNullDataPoint.y);
                                //if(!dataPoints[prevNonNullDataPointIndex].lineDashType)
                                currentLineDashType = dataSeries.nullDataLineDashType;
                                ctx.setLineDash(nullDataLineDashType);
                            }
                            ctx.lineTo(x, prevY);
                            ctx.lineTo(x, y);
                            if (isCanvasSupported) {
                                ghostCtx.lineTo(x, prevY);
                                ghostCtx.lineTo(x, y);
                            }
                        }
                        else { //connectNullData = false
                            ctx.beginPath();
                            ctx.moveTo(x, y);
                            if (isCanvasSupported) {
                                ghostCtx.beginPath();
                                ghostCtx.moveTo(x, y);
                            }
                        }

                        isFirstDataPointInPlotArea = false;
                        prevDataNull = false;
                    } else {

                        ctx.lineTo(x, prevY);
                        if (isCanvasSupported)
                            ghostCtx.lineTo(x, prevY);

                        ctx.lineTo(x, y);
                        if (isCanvasSupported)
                            ghostCtx.lineTo(x, y);

                        if (i % 500 == 0) {
                            ctx.stroke();
                            ctx.beginPath();
                            ctx.moveTo(x, y);

                            if (isCanvasSupported) {
                                ghostCtx.stroke();
                                ghostCtx.beginPath();
                                ghostCtx.moveTo(x, y);
                            }
                        }

                    }

                    previousNotNullDataPoint = { x: x, y: y };

                    if (i < dataPoints.length - 1 && (currentStrokeStyle !== (dataPoints[i].lineColor || color) || currentLineDashType !== (dataPoints[i].lineDashType || dataSeries.lineDashType))) { //Applieng new ctx on DataPoint
                        ctx.stroke();
                        ctx.beginPath();
                        ctx.moveTo(x, y);
                        currentStrokeStyle = dataPoints[i].lineColor || color;
                        ctx.strokeStyle = currentStrokeStyle;
                        if (ctx.setLineDash)
                            if (dataPoints[i].lineDashType) {
                                currentLineDashType = dataPoints[i].lineDashType;
                                ctx.setLineDash(getLineDashArray(currentLineDashType, dataSeries.lineThickness));
                            }
                            else {
                                currentLineDashType = dataSeries.lineDashType;
                                ctx.setLineDash(lineDashType);
                            }
                    }

                    //Render Marker
                    if (dataPoints[i].markerSize > 0 || dataSeries.markerSize > 0) {

                        var markerProps = dataSeries.getMarkerProperties(i, x, y, ctx);
                        markerPropsColor = markerProps.color;
                        markers.push(markerProps);

                        //if (!dataSeries.maxWidthInX || markerProps.size > dataSeries.maxWidthInX) {
                        //	dataSeries.maxWidthInX = markerProps.size / (plotUnit.axisX.conversionParameters.pixelPerUnit > 1 ? plotUnit.axisX.conversionParameters.pixelPerUnit - 1 : plotUnit.axisX.conversionParameters.pixelPerUnit);
                        //}

                        var markerColor = intToHexColorString(id);

                        //window.console.log("index: " + i + "; id: " + id + "; hex: " + markerColor);
                        if (isCanvasSupported) {
                            markers.push({
                                x: x, y: y, ctx: ghostCtx,
                                type: markerProps.type,
                                size: markerProps.size,
                                color: markerColor,
                                borderColor: markerColor,
                                borderThickness: markerProps.borderThickness
                            });
                        }
                    }

                    if (dataPoints[i].indexLabel || dataSeries.indexLabel || dataPoints[i].indexLabelFormatter || dataSeries.indexLabelFormatter) {

                        this._indexLabels.push({
                            chartType: "stepLine",
                            dataPoint: dataPoints[i],
                            dataSeries: dataSeries,
                            point: {
                                x: x, y: y
                            },
                            direction: dataPoints[i].y < 0 === plotUnit.axisY.reversed ? 1 : -1,
                            color: color
                        });

                    }

                }

                ctx.stroke();
                if (isCanvasSupported)
                    ghostCtx.stroke();
            }
        }


        RenderHelper.drawMarkers(markers);
        //dataSeries.markerColor = markerPropsColor;
        ctx.restore();

        ctx.beginPath();

        if (isCanvasSupported)
            ghostCtx.beginPath();

        //source and dest would be same when animation is not enabled
        var animationInfo = {
            source: ctx, dest: this.plotArea.ctx, animationCallback: AnimationHelper.xClipAnimation, easingFunction: AnimationHelper.easing.linear, animationBase: 0
        };
        return animationInfo;
    }

    function getBezierPoints(points, defaultTension) {
        var bezierPoints = [],
            tension;

        for (var i = 0; i < points.length; i++) {

            if (i == 0) {
                bezierPoints.push(points[0]);
                continue;
            }

            var i1, i2, pointIndex;

            pointIndex = i - 1;
            i1 = pointIndex === 0 ? 0 : pointIndex - 1;
            i2 = pointIndex === points.length - 1 ? pointIndex : pointIndex + 1;
            tension = Math.abs((points[i2].x - points[i1].x) / ((points[i2].x - points[pointIndex].x) === 0 ? 0.01 : (points[i2].x - points[pointIndex].x))) * (defaultTension - 1) / 2 + 1;

            var drv1 = {
                x: (points[i2].x - points[i1].x) / tension, y: (points[i2].y - points[i1].y) / tension
            }

            if (points[pointIndex].x > points[i1].x && drv1.x > 0 || points[pointIndex].x < points[i1].x && drv1.x < 0)
                var cp1 = {
                    x: points[pointIndex].x + drv1.x / 3, y: points[pointIndex].y + drv1.y / 3
                }
            else
                var cp1 = {
                    x: points[pointIndex].x, y: points[pointIndex].y + drv1.y / 9
                }

            bezierPoints[bezierPoints.length] = cp1;


            pointIndex = i;
            i1 = pointIndex === 0 ? 0 : pointIndex - 1;
            i2 = pointIndex === points.length - 1 ? pointIndex : pointIndex + 1;
            tension = Math.abs((points[i2].x - points[i1].x) / ((points[pointIndex].x - points[i1].x) === 0 ? 0.01 : (points[pointIndex].x - points[i1].x))) * (defaultTension - 1) / 2 + 1;
            var drv2 = {
                x: (points[i2].x - points[i1].x) / tension, y: (points[i2].y - points[i1].y) / tension
            }

            if (points[pointIndex].x > points[i1].x && drv2.x > 0 || points[pointIndex].x < points[i1].x && drv2.x < 0)
                var cp2 = {
                    x: points[pointIndex].x - drv2.x / 3, y: points[pointIndex].y - drv2.y / 3
                }
            else
                var cp2 = {
                    x: points[pointIndex].x, y: points[pointIndex].y - drv2.y / 9
                }

            bezierPoints[bezierPoints.length] = cp2;

            bezierPoints[bezierPoints.length] = points[i];
        }

        return bezierPoints;
    }

    Chart.prototype.renderSpline = function (plotUnit) {
        var ctx = plotUnit.targetCanvasCtx || this.plotArea.ctx;

        var totalDataSeries = plotUnit.dataSeriesIndexes.length;
        if (totalDataSeries <= 0)
            return;

        var ghostCtx = this._eventManager.ghostCtx;

        ctx.save();

        var plotArea = this.plotArea;

        ctx.beginPath();
        ctx.rect(plotArea.x1, plotArea.y1, plotArea.width, plotArea.height);
        ctx.clip();

        var markers = [];
        var markerPropsColor = null;

        for (var j = 0; j < plotUnit.dataSeriesIndexes.length; j++) {

            var dataSeriesIndex = plotUnit.dataSeriesIndexes[j];

            var dataSeries = this.data[dataSeriesIndex];
            ctx.lineWidth = dataSeries.lineThickness;
            var dataPoints = dataSeries.dataPoints;
            var currentLineDashType = "solid";

            if (ctx.setLineDash) {
                var nullDataLineDashType = getLineDashArray(dataSeries.nullDataLineDashType, dataSeries.lineThickness);
                currentLineDashType = dataSeries.lineDashType;
                var lineDashType = getLineDashArray(currentLineDashType, dataSeries.lineThickness);
                ctx.setLineDash(lineDashType);
            }

            var seriesId = dataSeries.id;
            this._eventManager.objectMap[seriesId] = {
                objectType: "dataSeries", dataSeriesIndex: dataSeriesIndex
            };
            var hexColor = intToHexColorString(seriesId);
            ghostCtx.strokeStyle = hexColor;
            //ghostCtx.lineWidth = dataSeries.lineThickness;
            ghostCtx.lineWidth = dataSeries.lineThickness > 0 ? Math.max(dataSeries.lineThickness, 4) : 0;

            var colorSet = dataSeries._colorSet;
            var color = dataSeries.lineColor = dataSeries.options.lineColor ? dataSeries.options.lineColor : colorSet[0];
            var currentStrokeStyle = color;
            ctx.strokeStyle = color;

            var isFirstDataPointInPlotArea = true;
            var i = 0, x, y;
            var dataPointX; //Used so that when dataPoint.x is a DateTime value, it doesn't get converted to number back and forth.

            //if (!dataSeries.options.markerSize && dataSeries.dataPoints.length < 1000)
            //    dataSeries.markerSize = 8;

            var pixels = [];

            ctx.beginPath();
            if (dataPoints.length > 0) {

                var prevDataNull = false;
                for (i = 0; i < dataPoints.length; i++) {

                    dataPointX = dataPoints[i].getTime ? dataPoints[i].x.getTime() : dataPoints[i].x;

                    if (dataPointX < plotUnit.axisX.dataInfo.viewPortMin || dataPointX > plotUnit.axisX.dataInfo.viewPortMax && !(dataSeries.connectNullData && prevDataNull))
                        continue;

                    //if (!isFinite(dataPoints[i].y))
                    //    continue;

                    if (typeof (dataPoints[i].y) !== "number") {
                        if (i > 0 && !prevDataNull) {// if first dataPoint is null then no need to call stroke method
                            if (dataSeries.connectNullData) {
                                if (ctx.setLineDash && pixels.length > 0 && (dataSeries.options.nullDataLineDashType || !dataPoints[i - 1].lineDashType)) {
                                    pixels[pixels.length - 1].newLineDashArray = nullDataLineDashType;
                                    currentLineDashType = dataSeries.nullDataLineDashType;
                                }
                            }
                            else {
                                renderBezier(pixels);
                                pixels = [];
                            }

                        }

                        prevDataNull = true;
                        continue;
                    }

                    x = plotUnit.axisX.convertValueToPixel(dataPointX);
                    y = plotUnit.axisY.convertValueToPixel(dataPoints[i].y);

                    var id = dataSeries.dataPointIds[i];
                    this._eventManager.objectMap[id] = {
                        id: id, objectType: "dataPoint", dataSeriesIndex: dataSeriesIndex, dataPointIndex: i, x1: x, y1: y
                    };

                    pixels[pixels.length] = {
                        x: x, y: y
                    };

                    //Drawing cunnectNullData
                    /*if (prevDataNull && dataSeries.connectNullData && ctx.setLineDash && !isFirstDataPointInPlotArea && (currentLineDashType === dataSeries.nullDataLineDashType && dataSeries.nullDataLineDashType !== dataSeries.lineDashType )) {
						newLineDashArray = lineDashType;
							currentLineDashType = dataSeries.lineDashType;
					}*/

                    if (i < dataPoints.length - 1 && (currentStrokeStyle !== (dataPoints[i].lineColor || color) || currentLineDashType !== (dataPoints[i].lineDashType || dataSeries.lineDashType))) { //Applieng new ctx on DataPoint

                        currentStrokeStyle = dataPoints[i].lineColor || color;
                        pixels[pixels.length - 1].newStrokeStyle = currentStrokeStyle;
                        if (ctx.setLineDash)
                            if (dataPoints[i].lineDashType) {
                                currentLineDashType = dataPoints[i].lineDashType;
                                pixels[pixels.length - 1].newLineDashArray = getLineDashArray(currentLineDashType, dataSeries.lineThickness);
                            }
                            else {
                                currentLineDashType = dataSeries.lineDashType;
                                pixels[pixels.length - 1].newLineDashArray = lineDashType;
                            }
                    }


                    //Add Markers
                    if (dataPoints[i].markerSize > 0 || dataSeries.markerSize > 0) {

                        var markerProps = dataSeries.getMarkerProperties(i, x, y, ctx);
                        markerPropsColor = markerProps.color;
                        markers.push(markerProps);

                        //if (!dataSeries.maxWidthInX || markerProps.size > dataSeries.maxWidthInX) {
                        //	dataSeries.maxWidthInX = markerProps.size / (plotUnit.axisX.conversionParameters.pixelPerUnit > 1 ? plotUnit.axisX.conversionParameters.pixelPerUnit - 1 : plotUnit.axisX.conversionParameters.pixelPerUnit);
                        //}

                        var markerColor = intToHexColorString(id);

                        //window.console.log("index: " + i + "; id: " + id + "; hex: " + markerColor);
                        if (isCanvasSupported) {
                            markers.push({
                                x: x, y: y, ctx: ghostCtx,
                                type: markerProps.type,
                                size: markerProps.size,
                                color: markerColor,
                                borderColor: markerColor,
                                borderThickness: markerProps.borderThickness
                            });
                        }
                    }

                    //Add Labels
                    if (dataPoints[i].indexLabel || dataSeries.indexLabel || dataPoints[i].indexLabelFormatter || dataSeries.indexLabelFormatter) {

                        this._indexLabels.push({
                            chartType: "spline",
                            dataPoint: dataPoints[i],
                            dataSeries: dataSeries,
                            point: {
                                x: x, y: y
                            },
                            direction: dataPoints[i].y < 0 === plotUnit.axisY.reversed ? 1 : -1,
                            color: color
                        });

                    }

                    isFirstDataPointInPlotArea = false;
                    prevDataNull = false;

                }
            }

            renderBezier(pixels);
        }

        RenderHelper.drawMarkers(markers);
        //dataSeries.markerColor = markerPropsColor;
        ctx.restore();

        ctx.beginPath();

        if (isCanvasSupported)
            ghostCtx.beginPath();

        function renderBezier(pixels) {

            var bp = getBezierPoints(pixels, 2);

            if (bp.length > 0) {
                ctx.beginPath();
                if (isCanvasSupported)
                    ghostCtx.beginPath();

                ctx.moveTo(bp[0].x, bp[0].y);
                if (bp[0].newStrokeStyle)
                    ctx.strokeStyle = bp[0].newStrokeStyle;
                if (bp[0].newLineDashArray)
                    ctx.setLineDash(bp[0].newLineDashArray);

                if (isCanvasSupported)
                    ghostCtx.moveTo(bp[0].x, bp[0].y);

                for (var i = 0; i < bp.length - 3; i += 3) {

                    ctx.bezierCurveTo(bp[i + 1].x, bp[i + 1].y, bp[i + 2].x, bp[i + 2].y, bp[i + 3].x, bp[i + 3].y);

                    if (isCanvasSupported)
                        ghostCtx.bezierCurveTo(bp[i + 1].x, bp[i + 1].y, bp[i + 2].x, bp[i + 2].y, bp[i + 3].x, bp[i + 3].y);

                    if (i > 0 && i % 3000 === 0 || bp[i + 3].newStrokeStyle || bp[i + 3].newLineDashArray) {
                        ctx.stroke();
                        ctx.beginPath();
                        ctx.moveTo(bp[i + 3].x, bp[i + 3].y);
                        if (bp[i + 3].newStrokeStyle)
                            ctx.strokeStyle = bp[i + 3].newStrokeStyle;
                        if (bp[i + 3].newLineDashArray)
                            ctx.setLineDash(bp[i + 3].newLineDashArray);

                        if (isCanvasSupported) {
                            ghostCtx.stroke();
                            ghostCtx.beginPath();
                            ghostCtx.moveTo(bp[i + 3].x, bp[i + 3].y);
                        }
                    }
                }

                ctx.stroke();

                if (isCanvasSupported)
                    ghostCtx.stroke();
            }
        }

        //source and dest would be same when animation is not enabled
        var animationInfo = {
            source: ctx, dest: this.plotArea.ctx, animationCallback: AnimationHelper.xClipAnimation, easingFunction: AnimationHelper.easing.linear, animationBase: 0
        };
        return animationInfo;
    }

    var drawRect = function (ctx, x1, y1, x2, y2, color, borderThickness, borderColor, top, bottom, left, right, fillOpacity) {
        if (typeof (fillOpacity) === "undefined")
            fillOpacity = 1;

        borderThickness = borderThickness || 0;
        borderColor = borderColor || "black";

        var a1 = x1, a2 = x2, b1 = y1, b2 = y2, edgeY, edgeX;
        if (x2 - x1 > 15 && y2 - y1 > 15)
            var bevelDepth = 8;
        else
            var bevelDepth = 0.35 * Math.min((x2 - x1), (y2 - y1));

        var color2 = "rgba(255, 255, 255, .4)";
        var color3 = "rgba(255, 255, 255, 0.1)";
        //color1 = "rgba(" + r + "," + g + ", " + b + ",1)";
        var color1 = color;

        ctx.beginPath();
        ctx.moveTo(x1, y1);
        ctx.save();
        ctx.fillStyle = color1;

        ctx.globalAlpha = fillOpacity;
        ctx.fillRect(x1, y1, x2 - x1, y2 - y1);
        ctx.globalAlpha = 1;

        if (borderThickness > 0) {
            var offset = borderThickness % 2 === 0 ? 0 : .5;
            ctx.beginPath();
            ctx.lineWidth = borderThickness;
            ctx.strokeStyle = borderColor;
            ctx.moveTo(x1, y1);
            ctx.rect(x1 - offset, y1 - offset, x2 - x1 + 2 * offset, y2 - y1 + 2 * offset);
            ctx.stroke();
        }

        ctx.restore();
        //   ctx.beginPath();
        if (top === true) {
            ctx.save();
            ctx.beginPath();
            ctx.moveTo(x1, y1);
            ctx.lineTo(x1 + bevelDepth, y1 + bevelDepth);
            ctx.lineTo(x2 - bevelDepth, y1 + bevelDepth);
            ctx.lineTo(x2, y1);
            ctx.closePath();
            var grd = ctx.createLinearGradient((x2 + x1) / 2, b1 + bevelDepth, (x2 + x1) / 2, b1);
            grd.addColorStop(0, color1);
            grd.addColorStop(1, color2);
            ctx.fillStyle = grd;
            ctx.fill();
            //              ctx.stroke();
            ctx.restore();
        }


        if (bottom === true) {
            ctx.save();
            ctx.beginPath();
            ctx.moveTo(x1, y2);
            ctx.lineTo(x1 + bevelDepth, y2 - bevelDepth);
            ctx.lineTo(x2 - bevelDepth, y2 - bevelDepth);
            ctx.lineTo(x2, y2);
            ctx.closePath();
            var grd = ctx.createLinearGradient((x2 + x1) / 2, b2 - bevelDepth, (x2 + x1) / 2, b2);
            grd.addColorStop(0, color1);
            grd.addColorStop(1, color2);
            ctx.fillStyle = grd;
            //       ctx.stroke();
            ctx.fill();
            ctx.restore();
        }

        if (left === true) {
            ctx.save();
            ctx.beginPath();
            ctx.moveTo(x1, y1)
            ctx.lineTo(x1 + bevelDepth, y1 + bevelDepth);
            ctx.lineTo(x1 + bevelDepth, y2 - bevelDepth);
            ctx.lineTo(x1, y2);
            ctx.closePath();
            var grd = ctx.createLinearGradient(a1 + bevelDepth, (y2 + y1) / 2, a1, (y2 + y1) / 2);
            grd.addColorStop(0, color1);
            grd.addColorStop(1, color3);
            ctx.fillStyle = grd;
            ctx.fill();
            //     ctx.stroke();
            ctx.restore();
        }


        if (right === true) {
            ctx.save();
            ctx.beginPath();
            ctx.moveTo(x2, y1)
            ctx.lineTo(x2 - bevelDepth, y1 + bevelDepth);
            ctx.lineTo(x2 - bevelDepth, y2 - bevelDepth);
            ctx.lineTo(x2, y2);
            var grd = ctx.createLinearGradient(a2 - bevelDepth, (y2 + y1) / 2, a2, (y2 + y1) / 2);
            grd.addColorStop(0, color1);
            grd.addColorStop(1, color3);
            ctx.fillStyle = grd;
            grd.addColorStop(0, color1);
            grd.addColorStop(1, color3);
            ctx.fillStyle = grd;
            ctx.fill();
            ctx.closePath();
            //          ctx.stroke();
            ctx.restore();
        }
        //

    }

    Chart.prototype.renderColumn = function (plotUnit) {

        var ctx = plotUnit.targetCanvasCtx || this.plotArea.ctx;

        var totalDataSeries = plotUnit.dataSeriesIndexes.length;

        if (totalDataSeries <= 0)
            return;

        var color = null;

        var plotArea = this.plotArea;

        var i = 0, x, y;
        var dataPointX; //Used so that when dataPoint.x is a DateTime value, it doesn't get converted to number from dataTime everytime it is used.

        var yZeroToPixel = plotUnit.axisY.convertValueToPixel(plotUnit.axisY.logarithmic ? plotUnit.axisY.viewportMinimum : 0);

        var minBarWidth = this.dataPointMinWidth = this.dataPointMinWidth ? this.dataPointMinWidth : this.dataPointWidth ? this.dataPointWidth : 1;
        var maxBarWidth = this.dataPointMaxWidth = this.dataPointMaxWidth ? this.dataPointMaxWidth : this.dataPointWidth ? this.dataPointWidth : Math.min((this.width * .15), this.plotArea.width / plotUnit.plotType.totalDataSeries * .9) << 0;

        var xMinDiff = plotUnit.axisX.dataInfo.minDiff;

        if (!isFinite(xMinDiff))
            xMinDiff = Math.abs(plotUnit.axisX.range) * .3;

        var barWidth = this.dataPointWidth = this.dataPointWidth ? this.dataPointWidth : (plotArea.width * (plotUnit.axisX.logarithmic ? Math.log(xMinDiff) / Math.log(plotUnit.axisX.range) : Math.abs(xMinDiff) / Math.abs(plotUnit.axisX.range)) / plotUnit.plotType.totalDataSeries * .9) << 0;

        if (this.dataPointMaxWidth && minBarWidth > maxBarWidth)
            minBarWidth = Math.min(this.dataPointWidth ? this.dataPointWidth : Infinity, maxBarWidth);

        if (!this.dataPointMaxWidth && this.dataPointMinWidth && maxBarWidth < minBarWidth)
            maxBarWidth = Math.max(this.dataPointWidth ? this.dataPointWidth : -Infinity, minBarWidth);

        if (barWidth < minBarWidth)
            barWidth = minBarWidth;

        if (barWidth > maxBarWidth)
            barWidth = maxBarWidth;


        ctx.save();
        if (isCanvasSupported)
            this._eventManager.ghostCtx.save();

        ctx.beginPath();
        ctx.rect(plotArea.x1, plotArea.y1, plotArea.width, plotArea.height);
        ctx.clip();

        if (isCanvasSupported) {
            this._eventManager.ghostCtx.beginPath();
            this._eventManager.ghostCtx.rect(plotArea.x1, plotArea.y1, plotArea.width, plotArea.height);
            this._eventManager.ghostCtx.clip();
        }
        //ctx.beginPath();

        for (var j = 0; j < plotUnit.dataSeriesIndexes.length; j++) {

            var dataSeriesIndex = plotUnit.dataSeriesIndexes[j];

            var dataSeries = this.data[dataSeriesIndex];
            var dataPoints = dataSeries.dataPoints;
            var isFirstDataPointInPlotArea = true;


            // Reducing pixelPerUnit by 1 just to overcome any problems due to rounding off of pixels.
            //dataSeries.maxWidthInX = barWidth / (plotUnit.axisX.conversionParameters.pixelPerUnit > 1 ? plotUnit.axisX.conversionParameters.pixelPerUnit - 1 : plotUnit.axisX.conversionParameters.pixelPerUnit);

            //var offsetX = barWidth * plotUnit.index << 0;


            if (dataPoints.length > 0) {
                var bevelEnabled = (barWidth > 5) && dataSeries.bevelEnabled ? true : false;

                for (i = 0; i < dataPoints.length; i++) {

                    dataPoints[i].getTime ? dataPointX = dataPoints[i].x.getTime() : dataPointX = dataPoints[i].x;

                    if (dataPointX < plotUnit.axisX.dataInfo.viewPortMin || dataPointX > plotUnit.axisX.dataInfo.viewPortMax) {
                        continue;
                    }

                    if (typeof (dataPoints[i].y) !== "number")
                        continue;

                    x = plotUnit.axisX.convertValueToPixel(dataPointX);
                    y = plotUnit.axisY.convertValueToPixel(dataPoints[i].y);

                    var x1 = plotUnit.axisX.reversed ? x + (plotUnit.plotType.totalDataSeries * barWidth / 2) - ((plotUnit.previousDataSeriesCount + j) * barWidth) << 0 : x - (plotUnit.plotType.totalDataSeries * barWidth / 2) + ((plotUnit.previousDataSeriesCount + j) * barWidth) << 0;
                    var x2 = plotUnit.axisX.reversed ? x1 - barWidth << 0 : x1 + barWidth << 0;
                    var y1;
                    var y2;

                    if (dataPoints[i].y >= 0) {
                        y1 = y;

                        y2 = yZeroToPixel;

                        if (y1 > y2) {
                            var temp = y1;
                            y1 = y2;
                            y2 = temp;
                        }

                    } else {
                        y2 = y;

                        y1 = yZeroToPixel;

                        if (y1 > y2) {
                            var temp = y1;
                            y1 = y2;
                            y2 = temp;
                        }
                    }

                    color = dataPoints[i].color ? dataPoints[i].color : dataSeries._colorSet[i % dataSeries._colorSet.length];
                    drawRect(ctx, x1, y1, x2, y2, color, 0, null, bevelEnabled && (dataPoints[i].y >= 0), (dataPoints[i].y < 0) && bevelEnabled, false, false, dataSeries.fillOpacity);

                    //if (dataSeries.markerType && dataSeries.markerSize > 0) {
                    //    RenderHelper.drawMarker(x1 + (x2 - x1) / 2, y, ctx, dataSeries.markerType, dataSeries.markerSize, color, dataSeries.markerBorderColor, dataSeries.markerBorderThickness ? dataSeries.markerBorderThickness : 1);
                    //}

                    var id = dataSeries.dataPointIds[i];
                    this._eventManager.objectMap[id] = {
                        id: id, objectType: "dataPoint", dataSeriesIndex: dataSeriesIndex, dataPointIndex: i, x1: x1, y1: y1, x2: x2, y2: y2
                    };

                    color = intToHexColorString(id);
                    if (isCanvasSupported)
                        drawRect(this._eventManager.ghostCtx, x1, y1, x2, y2, color, 0, null, false, false, false, false);

                    if (dataPoints[i].indexLabel || dataSeries.indexLabel || dataPoints[i].indexLabelFormatter || dataSeries.indexLabelFormatter) {

                        this._indexLabels.push({
                            chartType: "column",
                            dataPoint: dataPoints[i],
                            dataSeries: dataSeries,
                            point: {
                                x: x1 + (x2 - x1) / 2, y: dataPoints[i].y < 0 === plotUnit.axisY.reversed ? y1 : y2
                            },
                            direction: dataPoints[i].y < 0 === plotUnit.axisY.reversed ? 1 : -1,
                            bounds: {
                                x1: x1, y1: Math.min(y1, y2), x2: x2, y2: Math.max(y1, y2)
                            },
                            color: color
                        });

                    }
                }
            }
        }

        ctx.restore();

        if (isCanvasSupported)
            this._eventManager.ghostCtx.restore();

        //source and dest would be same when animation is not enabled
        var animationBase = yZeroToPixel < plotUnit.axisY.bounds.y1 ? plotUnit.axisY.bounds.y1 : yZeroToPixel > plotUnit.axisY.bounds.y2 ? plotUnit.axisY.bounds.y2 : yZeroToPixel;

        var animationInfo = {
            source: ctx, dest: this.plotArea.ctx, animationCallback: AnimationHelper.yScaleAnimation, easingFunction: AnimationHelper.easing.easeOutQuart, animationBase: animationBase
        };
        return animationInfo;
    }

    Chart.prototype.renderStackedColumn = function (plotUnit) {
        var ctx = plotUnit.targetCanvasCtx || this.plotArea.ctx;
        var totalDataSeries = plotUnit.dataSeriesIndexes.length;

        if (totalDataSeries <= 0)
            return;

        var color = null;

        var plotArea = this.plotArea;

        var offsetPositiveY = [];
        var offsetNegativeY = [];
        var stackedY = [];

        var i = 0, x, y;
        var dataPointX; //Used so that when dataPoint.x is a DateTime value, it doesn't get converted to number everytime it is accessed.

        //var yZeroToPixel = (axisYProps.y2 - axisYProps.height / rangeY * Math.abs(0 - plotUnit.axisY.viewportMinimum) + .5) << 0;
        var yZeroToPixel = plotUnit.axisY.convertValueToPixel(plotUnit.axisY.logarithmic ? plotUnit.axisY.viewportMinimum : 0);

        var minBarWidth = this.dataPointMinWidth ? this.dataPointMinWidth : this.dataPointWidth ? this.dataPointWidth : 1;
        var maxBarWidth = this.dataPointMaxWidth ? this.dataPointMaxWidth : this.dataPointWidth ? this.dataPointWidth : this.width * .15 << 0;

        var xMinDiff = plotUnit.axisX.dataInfo.minDiff;

        if (!isFinite(xMinDiff))
            xMinDiff = Math.abs(plotUnit.axisX.range) * .3;

        var barWidth = this.dataPointWidth ? this.dataPointWidth : (plotArea.width * (plotUnit.axisX.logarithmic ? Math.log(xMinDiff) / Math.log(plotUnit.axisX.range) : Math.abs(xMinDiff) / Math.abs(plotUnit.axisX.range)) / plotUnit.plotType.plotUnits.length * .9) << 0;

        if (this.dataPointMaxWidth && minBarWidth > maxBarWidth)
            minBarWidth = Math.min(this.dataPointWidth ? this.dataPointWidth : Infinity, maxBarWidth);

        if (!this.dataPointMaxWidth && this.dataPointMinWidth && maxBarWidth < minBarWidth)
            maxBarWidth = Math.max(this.dataPointWidth ? this.dataPointWidth : -Infinity, minBarWidth);

        if (barWidth < minBarWidth)
            barWidth = minBarWidth;

        if (barWidth > maxBarWidth)
            barWidth = maxBarWidth;


        ctx.save();
        if (isCanvasSupported)
            this._eventManager.ghostCtx.save();

        ctx.beginPath();
        ctx.rect(plotArea.x1, plotArea.y1, plotArea.width, plotArea.height);
        ctx.clip();

        if (isCanvasSupported) {
            this._eventManager.ghostCtx.beginPath();
            this._eventManager.ghostCtx.rect(plotArea.x1, plotArea.y1, plotArea.width, plotArea.height);
            this._eventManager.ghostCtx.clip();
        }

        for (var j = 0; j < plotUnit.dataSeriesIndexes.length; j++) {

            var dataSeriesIndex = plotUnit.dataSeriesIndexes[j];
            var dataSeries = this.data[dataSeriesIndex];
            var dataPoints = dataSeries.dataPoints;
            var isFirstDataPointInPlotArea = true;

            // Reducing pixelPerUnit by 1 just to overcome any problems due to rounding off of pixels.
            //dataSeries.maxWidthInX = barWidth / (plotUnit.axisX.conversionParameters.pixelPerUnit > 1 ? plotUnit.axisX.conversionParameters.pixelPerUnit - 1 : plotUnit.axisX.conversionParameters.pixelPerUnit);


            if (dataPoints.length > 0) {
                var bevelEnabled = (barWidth > 5) && dataSeries.bevelEnabled ? true : false;

                ctx.strokeStyle = "#4572A7 ";

                for (i = 0; i < dataPoints.length; i++) {

                    dataPointX = dataPoints[i].x.getTime ? dataPoints[i].x.getTime() : dataPoints[i].x;


                    if (dataPointX < plotUnit.axisX.dataInfo.viewPortMin || dataPointX > plotUnit.axisX.dataInfo.viewPortMax) {
                        continue;
                    }

                    if (typeof (dataPoints[i].y) !== "number")
                        continue;

                    x = plotUnit.axisX.convertValueToPixel(dataPointX);

                    var x1 = x - (plotUnit.plotType.plotUnits.length * barWidth / 2) + (plotUnit.index * barWidth) << 0;
                    var x2 = x1 + barWidth << 0;
                    var y1;
                    var y2;

                    if (plotUnit.axisY.logarithmic) {
                        stackedY[dataPointX] = dataPoints[i].y + (stackedY[dataPointX] ? stackedY[dataPointX] : 0);
                        if (stackedY[dataPointX] > 0) {
                            y1 = plotUnit.axisY.convertValueToPixel(stackedY[dataPointX]);
                            y2 = offsetPositiveY[dataPointX] ? offsetPositiveY[dataPointX] : yZeroToPixel;

                            offsetPositiveY[dataPointX] = y1;
                        }

                    } else {

                        y = plotUnit.axisY.convertValueToPixel(dataPoints[i].y);

                        if (dataPoints[i].y >= 0) {
                            var offset = offsetPositiveY[dataPointX] ? offsetPositiveY[dataPointX] : 0;

                            y1 = y - offset;
                            y2 = yZeroToPixel - offset;

                            offsetPositiveY[dataPointX] = offset + (y2 - y1);

                        } else {
                            var offset = offsetNegativeY[dataPointX] ? offsetNegativeY[dataPointX] : 0;

                            y2 = y + offset;
                            y1 = yZeroToPixel + offset;

                            offsetNegativeY[dataPointX] = offset + (y2 - y1);
                        }

                    }

                    color = dataPoints[i].color ? dataPoints[i].color : dataSeries._colorSet[i % dataSeries._colorSet.length];

                    drawRect(ctx, x1, y1, x2, y2, color, 0, null, bevelEnabled && (dataPoints[i].y >= 0), (dataPoints[i].y < 0) && bevelEnabled, false, false, dataSeries.fillOpacity);

                    //if (dataSeries.markerType && dataSeries.markerSize > 0) {
                    //    RenderHelper.drawMarker(x1 + (x2 - x1)/2, y1, ctx, dataSeries.markerType, dataSeries.markerSize, color, dataSeries.markerBorderColor, dataSeries.markerBorderThickness ? dataSeries.markerBorderThickness : 1);
                    //}

                    var id = dataSeries.dataPointIds[i];
                    this._eventManager.objectMap[id] = {
                        id: id, objectType: "dataPoint", dataSeriesIndex: dataSeriesIndex, dataPointIndex: i, x1: x1, y1: y1, x2: x2, y2: y2
                    };
                    color = intToHexColorString(id);

                    if (isCanvasSupported)
                        drawRect(this._eventManager.ghostCtx, x1, y1, x2, y2, color, 0, null, false, false, false, false);


                    if (dataPoints[i].indexLabel || dataSeries.indexLabel || dataPoints[i].indexLabelFormatter || dataSeries.indexLabelFormatter) {

                        this._indexLabels.push({
                            chartType: "stackedColumn",
                            dataPoint: dataPoints[i],
                            dataSeries: dataSeries,
                            point: {
                                x: x, y: dataPoints[i].y >= 0 ? y1 : y2
                            },
                            direction: dataPoints[i].y < 0 === plotUnit.axisY.reversed ? 1 : -1,
                            bounds: {
                                x1: x1, y1: Math.min(y1, y2), x2: x2, y2: Math.max(y1, y2)
                            },
                            color: color
                        });

                    }
                }
            }
        }

        ctx.restore();

        if (isCanvasSupported)
            this._eventManager.ghostCtx.restore();

        //source and dest would be same when animation is not enabled
        var animationBase = yZeroToPixel < plotUnit.axisY.bounds.y1 ? plotUnit.axisY.bounds.y1 : yZeroToPixel > plotUnit.axisY.bounds.y2 ? plotUnit.axisY.bounds.y2 : yZeroToPixel;

        var animationInfo = {
            source: ctx, dest: this.plotArea.ctx, animationCallback: AnimationHelper.yScaleAnimation, easingFunction: AnimationHelper.easing.easeOutQuart, animationBase: animationBase
        };
        return animationInfo;
    }

    Chart.prototype.renderStackedColumn100 = function (plotUnit) {
        var ctx = plotUnit.targetCanvasCtx || this.plotArea.ctx;
        var totalDataSeries = plotUnit.dataSeriesIndexes.length;

        if (totalDataSeries <= 0)
            return;

        var color = null;

        var plotArea = this.plotArea;

        var offsetPositiveY = [];
        var offsetNegativeY = [];
        var stackedY = [];

        var i = 0, x, y;
        var dataPointX; //Used so that when dataPoint.x is a DateTime value, it doesn't get converted to number everytime it is accessed.

        //var yZeroToPixel = (axisYProps.y2 - axisYProps.height / rangeY * Math.abs(0 - plotUnit.axisY.viewportMinimum) + .5) << 0;
        var yZeroToPixel = plotUnit.axisY.convertValueToPixel(plotUnit.axisY.logarithmic ? plotUnit.axisY.viewportMinimum : 0);

        var minBarWidth = this.dataPointMinWidth ? this.dataPointMinWidth : this.dataPointWidth ? this.dataPointWidth : 1;
        var maxBarWidth = this.dataPointMaxWidth ? this.dataPointMaxWidth : this.dataPointWidth ? this.dataPointWidth : this.width * .15 << 0;
        var xMinDiff = plotUnit.axisX.dataInfo.minDiff;

        if (!isFinite(xMinDiff))
            xMinDiff = Math.abs(plotUnit.axisX.range) * .3;

        var barWidth = this.dataPointWidth ? this.dataPointWidth : (plotArea.width * (plotUnit.axisX.logarithmic ? Math.log(xMinDiff) / Math.log(plotUnit.axisX.range) : Math.abs(xMinDiff) / Math.abs(plotUnit.axisX.range)) / plotUnit.plotType.plotUnits.length * .9) << 0;

        if (this.dataPointMaxWidth && minBarWidth > maxBarWidth)
            minBarWidth = Math.min(this.dataPointWidth ? this.dataPointWidth : Infinity, maxBarWidth);

        if (!this.dataPointMaxWidth && this.dataPointMinWidth && maxBarWidth < minBarWidth)
            maxBarWidth = Math.max(this.dataPointWidth ? this.dataPointWidth : -Infinity, minBarWidth);

        if (barWidth < minBarWidth)
            barWidth = minBarWidth;

        if (barWidth > maxBarWidth)
            barWidth = maxBarWidth;

        ctx.save();
        if (isCanvasSupported)
            this._eventManager.ghostCtx.save();

        ctx.beginPath();
        ctx.rect(plotArea.x1, plotArea.y1, plotArea.width, plotArea.height);
        ctx.clip();

        if (isCanvasSupported) {
            this._eventManager.ghostCtx.beginPath();
            this._eventManager.ghostCtx.rect(plotArea.x1, plotArea.y1, plotArea.width, plotArea.height);
            this._eventManager.ghostCtx.clip();
        }

        for (var j = 0; j < plotUnit.dataSeriesIndexes.length; j++) {

            var dataSeriesIndex = plotUnit.dataSeriesIndexes[j];

            var dataSeries = this.data[dataSeriesIndex];
            var dataPoints = dataSeries.dataPoints;
            var isFirstDataPointInPlotArea = true;


            //dataSeries.maxWidthInX = barWidth / (plotUnit.axisX.conversionParameters.pixelPerUnit > 1 ? plotUnit.axisX.conversionParameters.pixelPerUnit - 1 : plotUnit.axisX.conversionParameters.pixelPerUnit);


            if (dataPoints.length > 0) {
                var bevelEnabled = (barWidth > 5) && dataSeries.bevelEnabled ? true : false;

                //ctx.strokeStyle = "#4572A7 ";

                for (i = 0; i < dataPoints.length; i++) {

                    dataPointX = dataPoints[i].x.getTime ? dataPoints[i].x.getTime() : dataPoints[i].x;


                    if (dataPointX < plotUnit.axisX.dataInfo.viewPortMin || dataPointX > plotUnit.axisX.dataInfo.viewPortMax) {
                        continue;
                    }

                    if (typeof (dataPoints[i].y) !== "number")
                        continue;

                    x = plotUnit.axisX.convertValueToPixel(dataPointX);

                    var yPercent;
                    if (plotUnit.dataPointYSums[dataPointX] !== 0)
                        yPercent = dataPoints[i].y / plotUnit.dataPointYSums[dataPointX] * 100;
                    else
                        yPercent = 0;

                    //y = (plotUnit.axisY.conversionParameters.reference + plotUnit.axisY.conversionParameters.pixelPerUnit * (yPercent - plotUnit.axisY.conversionParameters.minimum) + .5) << 0;

                    var x1 = x - (plotUnit.plotType.plotUnits.length * barWidth / 2) + (plotUnit.index * barWidth) << 0;
                    var x2 = x1 + barWidth << 0;
                    var y1;
                    var y2;

                    if (plotUnit.axisY.logarithmic) {
                        stackedY[dataPointX] = yPercent + (stackedY[dataPointX] ? stackedY[dataPointX] : 0);
                        if (stackedY[dataPointX] <= 0)
                            continue;

                        y1 = plotUnit.axisY.convertValueToPixel(stackedY[dataPointX]);
                        y2 = offsetPositiveY[dataPointX] ? offsetPositiveY[dataPointX] : yZeroToPixel;

                        offsetPositiveY[dataPointX] = y1;
                    }
                    else {
                        y = plotUnit.axisY.convertValueToPixel(yPercent);
                        if (dataPoints[i].y >= 0) {
                            var offset = offsetPositiveY[dataPointX] ? offsetPositiveY[dataPointX] : 0;

                            y1 = y - offset;
                            y2 = yZeroToPixel - offset;

                            offsetPositiveY[dataPointX] = offset + (y2 - y1);

                        } else {
                            var offset = offsetNegativeY[dataPointX] ? offsetNegativeY[dataPointX] : 0;

                            y2 = y + offset;
                            y1 = yZeroToPixel + offset;

                            offsetNegativeY[dataPointX] = offset + (y2 - y1);
                        }
                    }


                    color = dataPoints[i].color ? dataPoints[i].color : dataSeries._colorSet[i % dataSeries._colorSet.length];
                    drawRect(ctx, x1, y1, x2, y2, color, 0, null, bevelEnabled && (dataPoints[i].y >= 0), (dataPoints[i].y < 0) && bevelEnabled, false, false, dataSeries.fillOpacity);

                    var id = dataSeries.dataPointIds[i];
                    this._eventManager.objectMap[id] = {
                        id: id, objectType: "dataPoint", dataSeriesIndex: dataSeriesIndex, dataPointIndex: i, x1: x1, y1: y1, x2: x2, y2: y2
                    };
                    color = intToHexColorString(id);

                    if (isCanvasSupported)
                        drawRect(this._eventManager.ghostCtx, x1, y1, x2, y2, color, 0, null, false, false, false, false);


                    if (dataPoints[i].indexLabel || dataSeries.indexLabel || dataPoints[i].indexLabelFormatter || dataSeries.indexLabelFormatter) {

                        this._indexLabels.push({
                            chartType: "stackedColumn100",
                            dataPoint: dataPoints[i],
                            dataSeries: dataSeries,
                            point: {
                                x: x, y: dataPoints[i].y >= 0 ? y1 : y2
                            },
                            direction: dataPoints[i].y < 0 === plotUnit.axisY.reversed ? 1 : -1,
                            bounds: {
                                x1: x1, y1: Math.min(y1, y2), x2: x2, y2: Math.max(y1, y2)
                            },
                            color: color
                        });

                    }
                }
            }
        }

        ctx.restore();

        if (isCanvasSupported)
            this._eventManager.ghostCtx.restore();

        //source and dest would be same when animation is not enabled
        var animationBase = yZeroToPixel < plotUnit.axisY.bounds.y1 ? plotUnit.axisY.bounds.y1 : yZeroToPixel > plotUnit.axisY.bounds.y2 ? plotUnit.axisY.bounds.y2 : yZeroToPixel;

        var animationInfo = {
            source: ctx, dest: this.plotArea.ctx, animationCallback: AnimationHelper.yScaleAnimation, easingFunction: AnimationHelper.easing.easeOutQuart, animationBase: animationBase
        };
        return animationInfo;
    }

    Chart.prototype.renderBar = function (plotUnit) {
        var ctx = plotUnit.targetCanvasCtx || this.plotArea.ctx;
        var totalDataSeries = plotUnit.dataSeriesIndexes.length;

        if (totalDataSeries <= 0)
            return;

        var color = null;

        var plotArea = this.plotArea;

        var i = 0, x, y;
        var dataPointX; //Used so that when dataPoint.x is a DateTime value, it doesn't get converted to number from dataTime everytime it is used.

        //In case of Bar Chart, yZeroToPixel is x co-ordinate!
        var yZeroToPixel = plotUnit.axisY.convertValueToPixel(plotUnit.axisY.logarithmic ? plotUnit.axisY.viewportMinimum : 0);

        var minBarWidth = this.dataPointMinWidth ? this.dataPointMinWidth : this.dataPointWidth ? this.dataPointWidth : 1;
        var maxBarWidth = this.dataPointMaxWidth ? this.dataPointMaxWidth : this.dataPointWidth ? this.dataPointWidth : Math.min((this.height * .15), this.plotArea.height / plotUnit.plotType.totalDataSeries * .9) << 0;
        var xMinDiff = plotUnit.axisX.dataInfo.minDiff;

        if (!isFinite(xMinDiff))
            xMinDiff = Math.abs(plotUnit.axisX.range) * .3;

        var barWidth = this.dataPointWidth ? this.dataPointWidth : (plotArea.height * (plotUnit.axisX.logarithmic ? Math.log(xMinDiff) / Math.log(plotUnit.axisX.range) : Math.abs(xMinDiff) / Math.abs(plotUnit.axisX.range)) / plotUnit.plotType.totalDataSeries * .9) << 0;

        if (this.dataPointMaxWidth && minBarWidth > maxBarWidth)
            minBarWidth = Math.min(this.dataPointWidth ? this.dataPointWidth : Infinity, maxBarWidth);

        if (!this.dataPointMaxWidth && this.dataPointMinWidth && maxBarWidth < minBarWidth)
            maxBarWidth = Math.max(this.dataPointWidth ? this.dataPointWidth : -Infinity, minBarWidth);

        if (barWidth < minBarWidth)
            barWidth = minBarWidth;

        if (barWidth > maxBarWidth)
            barWidth = maxBarWidth;

        ctx.save();

        if (isCanvasSupported)
            this._eventManager.ghostCtx.save();

        ctx.beginPath();
        ctx.rect(plotArea.x1, plotArea.y1, plotArea.width, plotArea.height);
        ctx.clip();

        if (isCanvasSupported) {
            this._eventManager.ghostCtx.beginPath();
            this._eventManager.ghostCtx.rect(plotArea.x1, plotArea.y1, plotArea.width, plotArea.height);
            this._eventManager.ghostCtx.clip();
        }

        for (var j = 0; j < plotUnit.dataSeriesIndexes.length; j++) {

            var dataSeriesIndex = plotUnit.dataSeriesIndexes[j];

            var dataSeries = this.data[dataSeriesIndex];
            var dataPoints = dataSeries.dataPoints;
            var isFirstDataPointInPlotArea = true;


            //dataSeries.maxWidthInX = barWidth / (plotUnit.axisX.conversionParameters.pixelPerUnit > 1 ? plotUnit.axisX.conversionParameters.pixelPerUnit - 1 : plotUnit.axisX.conversionParameters.pixelPerUnit);


            if (dataPoints.length > 0) {
                var bevelEnabled = (barWidth > 5) && dataSeries.bevelEnabled ? true : false;

                ctx.strokeStyle = "#4572A7 ";

                for (i = 0; i < dataPoints.length; i++) {

                    dataPoints[i].getTime ? dataPointX = dataPoints[i].x.getTime() : dataPointX = dataPoints[i].x;

                    if (dataPointX < plotUnit.axisX.dataInfo.viewPortMin || dataPointX > plotUnit.axisX.dataInfo.viewPortMax) {
                        continue;
                    }

                    if (typeof (dataPoints[i].y) !== "number")
                        continue;

                    //x and y are pixel co-ordinates of point and should not be confused with X and Y values
                    y = plotUnit.axisX.convertValueToPixel(dataPointX);
                    x = plotUnit.axisY.convertValueToPixel(dataPoints[i].y);


                    var y1 = plotUnit.axisX.reversed ? (y + (plotUnit.plotType.totalDataSeries * barWidth / 2) - ((plotUnit.previousDataSeriesCount + j) * barWidth)) << 0 : (y - (plotUnit.plotType.totalDataSeries * barWidth / 2) + ((plotUnit.previousDataSeriesCount + j) * barWidth)) << 0;
                    var y2 = plotUnit.axisX.reversed ? y1 - barWidth << 0 : y1 + barWidth << 0;
                    var x1;
                    var x2;

                    if (dataPoints[i].y >= 0) {
                        x1 = yZeroToPixel;
                        x2 = x;
                    } else {
                        x1 = x;
                        x2 = yZeroToPixel;
                    }

                    //drawRect(ctx, x1, y1, plotArea.x2, y2, "#EEEEEE", 0, null, false, false, false, false);
                    //drawRect(ctx, x1, y1, plotArea.x2, y2, "#BDCED3", 0, null, false, false, false, false);

                    color = dataPoints[i].color ? dataPoints[i].color : dataSeries._colorSet[i % dataSeries._colorSet.length];
                    //color = "#1B4962";
                    drawRect(ctx, x1, y1, x2, y2, color, 0, null, bevelEnabled, false, false, false, dataSeries.fillOpacity);


                    var id = dataSeries.dataPointIds[i];
                    this._eventManager.objectMap[id] = {
                        id: id, objectType: "dataPoint", dataSeriesIndex: dataSeriesIndex, dataPointIndex: i, x1: x1, y1: y1, x2: x2, y2: y2
                    };
                    color = intToHexColorString(id);

                    if (isCanvasSupported)
                        drawRect(this._eventManager.ghostCtx, x1, y1, x2, y2, color, 0, null, false, false, false, false);

                    if (dataPoints[i].indexLabel || dataSeries.indexLabel || dataPoints[i].indexLabelFormatter || dataSeries.indexLabelFormatter)
                        this._indexLabels.push({
                            chartType: "bar",
                            dataPoint: dataPoints[i],
                            dataSeries: dataSeries,
                            point: {
                                x: dataPoints[i].y >= 0 ? x2 : x1, y: y1 + (y2 - y1) / 2
                            },
                            direction: dataPoints[i].y < 0 === plotUnit.axisY.reversed ? 1 : -1,
                            bounds: {
                                x1: Math.min(x1, x2), y1: y1, x2: Math.max(x1, x2), y2: y2
                            },
                            color: color
                        });
                }
            }
        }

        ctx.restore();

        if (isCanvasSupported)
            this._eventManager.ghostCtx.restore();

        //source and dest would be same when animation is not enabled
        var animationBase = yZeroToPixel < plotUnit.axisY.bounds.x1 ? plotUnit.axisY.bounds.x1 : yZeroToPixel > plotUnit.axisY.bounds.x2 ? plotUnit.axisY.bounds.x2 : yZeroToPixel;

        var animationInfo = {
            source: ctx, dest: this.plotArea.ctx, animationCallback: AnimationHelper.xScaleAnimation, easingFunction: AnimationHelper.easing.easeOutQuart, animationBase: animationBase
        };
        return animationInfo;
    }

    Chart.prototype.renderStackedBar = function (plotUnit) {
        var ctx = plotUnit.targetCanvasCtx || this.plotArea.ctx;
        var totalDataSeries = plotUnit.dataSeriesIndexes.length;

        if (totalDataSeries <= 0)
            return;

        var color = null;

        var plotArea = this.plotArea;

        var offsetPositiveY = [];
        var offsetNegativeY = [];
        var stackedY = [];

        var i = 0, x, y;
        var dataPointX; //Used so that when dataPoint.x is a DateTime value, it doesn't get converted to number everytime it is accessed.

        //var yZeroToPixel = (axisYProps.y2 - axisYProps.height / rangeY * Math.abs(0 - plotUnit.axisY.viewportMinimum) + .5) << 0;
        var yZeroToPixel = plotUnit.axisY.convertValueToPixel(plotUnit.axisY.logarithmic ? plotUnit.axisY.viewportMinimum : 0);

        var minBarWidth = this.dataPointMinWidth ? this.dataPointMinWidth : this.dataPointWidth ? this.dataPointWidth : 1;
        var maxBarWidth = this.dataPointMaxWidth ? this.dataPointMaxWidth : this.dataPointWidth ? this.dataPointWidth : this.height * .15 << 0;
        var xMinDiff = plotUnit.axisX.dataInfo.minDiff;

        if (!isFinite(xMinDiff))
            xMinDiff = Math.abs(plotUnit.axisX.range) * .3;

        var barWidth = this.dataPointWidth ? this.dataPointWidth : (plotArea.height * (plotUnit.axisX.logarithmic ? Math.log(xMinDiff) / Math.log(plotUnit.axisX.range) : Math.abs(xMinDiff) / Math.abs(plotUnit.axisX.range)) / plotUnit.plotType.plotUnits.length * .9) << 0;

        if (this.dataPointMaxWidth && minBarWidth > maxBarWidth)
            minBarWidth = Math.min(this.dataPointWidth ? this.dataPointWidth : Infinity, maxBarWidth);

        if (!this.dataPointMaxWidth && this.dataPointMinWidth && maxBarWidth < minBarWidth)
            maxBarWidth = Math.max(this.dataPointWidth ? this.dataPointWidth : -Infinity, minBarWidth);

        if (barWidth < minBarWidth)
            barWidth = minBarWidth;

        if (barWidth > maxBarWidth)
            barWidth = maxBarWidth;

        ctx.save();

        if (isCanvasSupported)
            this._eventManager.ghostCtx.save();

        ctx.beginPath();
        ctx.rect(plotArea.x1, plotArea.y1, plotArea.width, plotArea.height);
        ctx.clip();

        if (isCanvasSupported) {
            this._eventManager.ghostCtx.beginPath();
            this._eventManager.ghostCtx.rect(plotArea.x1, plotArea.y1, plotArea.width, plotArea.height);
            this._eventManager.ghostCtx.clip();
        }

        for (var j = 0; j < plotUnit.dataSeriesIndexes.length; j++) {

            var dataSeriesIndex = plotUnit.dataSeriesIndexes[j];

            var dataSeries = this.data[dataSeriesIndex];
            var dataPoints = dataSeries.dataPoints;
            var isFirstDataPointInPlotArea = true;

            //dataSeries.maxWidthInX = barWidth / (plotUnit.axisX.conversionParameters.pixelPerUnit > 1 ? plotUnit.axisX.conversionParameters.pixelPerUnit - 1 : plotUnit.axisX.conversionParameters.pixelPerUnit);

            if (dataPoints.length > 0) {
                var bevelEnabled = (barWidth > 5) && dataSeries.bevelEnabled ? true : false;

                ctx.strokeStyle = "#4572A7 ";

                for (i = 0; i < dataPoints.length; i++) {

                    dataPointX = dataPoints[i].x.getTime ? dataPoints[i].x.getTime() : dataPoints[i].x;


                    if (dataPointX < plotUnit.axisX.dataInfo.viewPortMin || dataPointX > plotUnit.axisX.dataInfo.viewPortMax) {
                        continue;
                    }

                    if (typeof (dataPoints[i].y) !== "number")
                        continue;

                    y = plotUnit.axisX.convertValueToPixel(dataPointX);
                    //x = (plotUnit.axisY.conversionParameters.reference + plotUnit.axisY.conversionParameters.pixelPerUnit * (dataPoints[i].y - plotUnit.axisY.conversionParameters.minimum) + .5) << 0;

                    //var x1 = x - (plotUnit.plotType.plotUnits.length * barWidth / 2) + (plotUnit.index * barWidth) << 0;

                    var y1 = y - (plotUnit.plotType.plotUnits.length * barWidth / 2) + (plotUnit.index * barWidth) << 0;
                    var y2 = y1 + barWidth << 0;
                    var x1;
                    var x2;

                    if (plotUnit.axisY.logarithmic) {
                        stackedY[dataPointX] = dataPoints[i].y + (stackedY[dataPointX] ? stackedY[dataPointX] : 0);
                        if (stackedY[dataPointX] > 0) {
                            x1 = offsetPositiveY[dataPointX] ? offsetPositiveY[dataPointX] : yZeroToPixel;
                            offsetPositiveY[dataPointX] = x2 = plotUnit.axisY.convertValueToPixel(stackedY[dataPointX]);
                        }
                    }
                    else {
                        x = plotUnit.axisY.convertValueToPixel(dataPoints[i].y);
                        if (dataPoints[i].y >= 0) {
                            var offset = offsetPositiveY[dataPointX] ? offsetPositiveY[dataPointX] : 0;

                            x1 = yZeroToPixel + offset;
                            x2 = x + offset;

                            offsetPositiveY[dataPointX] = offset + (x2 - x1);

                        } else {
                            var offset = offsetNegativeY[dataPointX] ? offsetNegativeY[dataPointX] : 0;

                            x1 = x - offset;
                            x2 = yZeroToPixel - offset;

                            offsetNegativeY[dataPointX] = offset + (x2 - x1);
                        }
                    }


                    color = dataPoints[i].color ? dataPoints[i].color : dataSeries._colorSet[i % dataSeries._colorSet.length];
                    drawRect(ctx, x1, y1, x2, y2, color, 0, null, bevelEnabled, false, false, false, dataSeries.fillOpacity);

                    var id = dataSeries.dataPointIds[i];
                    this._eventManager.objectMap[id] = {
                        id: id, objectType: "dataPoint", dataSeriesIndex: dataSeriesIndex, dataPointIndex: i, x1: x1, y1: y1, x2: x2, y2: y2
                    };
                    color = intToHexColorString(id);

                    if (isCanvasSupported)
                        drawRect(this._eventManager.ghostCtx, x1, y1, x2, y2, color, 0, null, false, false, false, false);

                    if (dataPoints[i].indexLabel || dataSeries.indexLabel || dataPoints[i].indexLabelFormatter || dataSeries.indexLabelFormatter)
                        this._indexLabels.push({
                            chartType: "stackedBar",
                            dataPoint: dataPoints[i],
                            dataSeries: dataSeries,
                            point: {
                                x: dataPoints[i].y >= 0 ? x2 : x1, y: y
                            },
                            direction: dataPoints[i].y < 0 === plotUnit.axisY.reversed ? 1 : -1,
                            bounds: {
                                x1: Math.min(x1, x2), y1: y1, x2: Math.max(x1, x2), y2: y2
                            },
                            color: color
                        });
                }
            }
        }

        ctx.restore();

        if (isCanvasSupported)
            this._eventManager.ghostCtx.restore();

        //source and dest would be same when animation is not enabled
        var animationBase = yZeroToPixel < plotUnit.axisY.bounds.x1 ? plotUnit.axisY.bounds.x1 : yZeroToPixel > plotUnit.axisY.bounds.x2 ? plotUnit.axisY.bounds.x2 : yZeroToPixel;

        var animationInfo = {
            source: ctx, dest: this.plotArea.ctx, animationCallback: AnimationHelper.xScaleAnimation, easingFunction: AnimationHelper.easing.easeOutQuart, animationBase: animationBase
        };
        return animationInfo;
    }

    Chart.prototype.renderStackedBar100 = function (plotUnit) {
        var ctx = plotUnit.targetCanvasCtx || this.plotArea.ctx;
        var totalDataSeries = plotUnit.dataSeriesIndexes.length;

        if (totalDataSeries <= 0)
            return;

        var color = null;

        var plotArea = this.plotArea;

        var offsetPositiveY = [];
        var offsetNegativeY = [];
        var stackedY = [];

        var i = 0, x, y;
        var dataPointX; //Used so that when dataPoint.x is a DateTime value, it doesn't get converted to number everytime it is accessed.

        //var yZeroToPixel = (axisYProps.y2 - axisYProps.height / rangeY * Math.abs(0 - plotUnit.axisY.viewportMinimum) + .5) << 0;
        var yZeroToPixel = plotUnit.axisY.convertValueToPixel(plotUnit.axisY.logarithmic ? plotUnit.axisY.viewportMinimum : 0);

        var minBarWidth = this.dataPointMinWidth ? this.dataPointMinWidth : this.dataPointWidth ? this.dataPointWidth : 1;
        var maxBarWidth = this.dataPointMaxWidth ? this.dataPointMaxWidth : this.dataPointWidth ? this.dataPointWidth : this.height * .15 << 0;
        var xMinDiff = plotUnit.axisX.dataInfo.minDiff;

        if (!isFinite(xMinDiff))
            xMinDiff = Math.abs(plotUnit.axisX.range) * .3;

        var barWidth = this.dataPointWidth ? this.dataPointWidth : (plotArea.height * (plotUnit.axisX.logarithmic ? Math.log(xMinDiff) / Math.log(plotUnit.axisX.range) : Math.abs(xMinDiff) / Math.abs(plotUnit.axisX.range)) / plotUnit.plotType.plotUnits.length * .9) << 0;

        if (this.dataPointMaxWidth && minBarWidth > maxBarWidth)
            minBarWidth = Math.min(this.dataPointWidth ? this.dataPointWidth : Infinity, maxBarWidth);

        if (!this.dataPointMaxWidth && this.dataPointMinWidth && maxBarWidth < minBarWidth)
            maxBarWidth = Math.max(this.dataPointWidth ? this.dataPointWidth : -Infinity, minBarWidth);

        if (barWidth < minBarWidth)
            barWidth = minBarWidth;

        if (barWidth > maxBarWidth)
            barWidth = maxBarWidth;

        ctx.save();

        if (isCanvasSupported)
            this._eventManager.ghostCtx.save();

        ctx.beginPath();
        ctx.rect(plotArea.x1, plotArea.y1, plotArea.width, plotArea.height);
        ctx.clip();

        if (isCanvasSupported) {
            this._eventManager.ghostCtx.beginPath();
            this._eventManager.ghostCtx.rect(plotArea.x1, plotArea.y1, plotArea.width, plotArea.height);
            this._eventManager.ghostCtx.clip();
        }

        for (var j = 0; j < plotUnit.dataSeriesIndexes.length; j++) {

            var dataSeriesIndex = plotUnit.dataSeriesIndexes[j];

            var dataSeries = this.data[dataSeriesIndex];
            var dataPoints = dataSeries.dataPoints;
            var isFirstDataPointInPlotArea = true;

            //dataSeries.maxWidthInX = barWidth / (plotUnit.axisX.conversionParameters.pixelPerUnit > 1 ? plotUnit.axisX.conversionParameters.pixelPerUnit - 1 : plotUnit.axisX.conversionParameters.pixelPerUnit);

            if (dataPoints.length > 0) {
                var bevelEnabled = (barWidth > 5) && dataSeries.bevelEnabled ? true : false;

                ctx.strokeStyle = "#4572A7 ";

                for (i = 0; i < dataPoints.length; i++) {

                    dataPointX = dataPoints[i].x.getTime ? dataPoints[i].x.getTime() : dataPoints[i].x;


                    if (dataPointX < plotUnit.axisX.dataInfo.viewPortMin || dataPointX > plotUnit.axisX.dataInfo.viewPortMax) {
                        continue;
                    }

                    if (typeof (dataPoints[i].y) !== "number")
                        continue;

                    y = plotUnit.axisX.convertValueToPixel(dataPointX);

                    var yPercent;
                    if (plotUnit.dataPointYSums[dataPointX] !== 0)
                        yPercent = dataPoints[i].y / plotUnit.dataPointYSums[dataPointX] * 100;
                    else
                        yPercent = 0;

                    //x = (plotUnit.axisY.conversionParameters.reference + plotUnit.axisY.conversionParameters.pixelPerUnit * (yPercent - plotUnit.axisY.conversionParameters.minimum) + .5) << 0;

                    var y1 = y - (plotUnit.plotType.plotUnits.length * barWidth / 2) + (plotUnit.index * barWidth) << 0;
                    var y2 = y1 + barWidth << 0;
                    var x1;
                    var x2;

                    if (plotUnit.axisY.logarithmic) {
                        stackedY[dataPointX] = yPercent + (stackedY[dataPointX] ? stackedY[dataPointX] : 0);
                        if (stackedY[dataPointX] <= 0)
                            continue;

                        x1 = offsetPositiveY[dataPointX] ? offsetPositiveY[dataPointX] : yZeroToPixel;
                        offsetPositiveY[dataPointX] = x2 = plotUnit.axisY.convertValueToPixel(stackedY[dataPointX]);

                    }
                    else {
                        x = plotUnit.axisY.convertValueToPixel(yPercent);
                        if (dataPoints[i].y >= 0) {
                            var offset = offsetPositiveY[dataPointX] ? offsetPositiveY[dataPointX] : 0;

                            x1 = yZeroToPixel + offset;
                            x2 = x + offset;

                            offsetPositiveY[dataPointX] = offset + (x2 - x1);

                        } else {
                            var offset = offsetNegativeY[dataPointX] ? offsetNegativeY[dataPointX] : 0;

                            x1 = x - offset;
                            x2 = yZeroToPixel - offset;

                            offsetNegativeY[dataPointX] = offset + (x2 - x1);
                        }
                    }


                    color = dataPoints[i].color ? dataPoints[i].color : dataSeries._colorSet[i % dataSeries._colorSet.length];
                    drawRect(ctx, x1, y1, x2, y2, color, 0, null, bevelEnabled, false, false, false, dataSeries.fillOpacity);

                    var id = dataSeries.dataPointIds[i];
                    this._eventManager.objectMap[id] = {
                        id: id, objectType: "dataPoint", dataSeriesIndex: dataSeriesIndex, dataPointIndex: i, x1: x1, y1: y1, x2: x2, y2: y2
                    };
                    color = intToHexColorString(id);

                    if (isCanvasSupported)
                        drawRect(this._eventManager.ghostCtx, x1, y1, x2, y2, color, 0, null, false, false, false, false);

                    if (dataPoints[i].indexLabel || dataSeries.indexLabel || dataPoints[i].indexLabelFormatter || dataSeries.indexLabelFormatter)
                        this._indexLabels.push({
                            chartType: "stackedBar100",
                            dataPoint: dataPoints[i],
                            dataSeries: dataSeries,
                            point: {
                                x: dataPoints[i].y >= 0 ? x2 : x1, y: y
                            },
                            direction: dataPoints[i].y < 0 === plotUnit.axisY.reversed ? 1 : -1,
                            bounds: {
                                x1: Math.min(x1, x2), y1: y1, x2: Math.max(x1, x2), y2: y2
                            },
                            color: color
                        });
                }
            }
        }

        ctx.restore();

        if (isCanvasSupported)
            this._eventManager.ghostCtx.restore();

        //source and dest would be same when animation is not enabled
        var animationBase = yZeroToPixel < plotUnit.axisY.bounds.x1 ? plotUnit.axisY.bounds.x1 : yZeroToPixel > plotUnit.axisY.bounds.x2 ? plotUnit.axisY.bounds.x2 : yZeroToPixel;

        var animationInfo = {
            source: ctx, dest: this.plotArea.ctx, animationCallback: AnimationHelper.xScaleAnimation, easingFunction: AnimationHelper.easing.easeOutQuart, animationBase: animationBase
        };
        return animationInfo;
    }

    Chart.prototype.renderArea = function (plotUnit) {
        var ctx = plotUnit.targetCanvasCtx || this.plotArea.ctx;

        var totalDataSeries = plotUnit.dataSeriesIndexes.length;

        if (totalDataSeries <= 0)
            return;

        var ghostCtx = this._eventManager.ghostCtx;

        var axisXProps = plotUnit.axisX.lineCoordinates;
        var axisYProps = plotUnit.axisY.lineCoordinates;
        var markers = [];
        var markerPropsColor = null;

        var plotArea = this.plotArea;
        var previousNotNullDataPoint, currentDataPoint;
        ctx.save();

        if (isCanvasSupported)
            ghostCtx.save();

        ctx.beginPath();
        ctx.rect(plotArea.x1, plotArea.y1, plotArea.width, plotArea.height);
        ctx.clip();

        //var defaultLineJoinType = ctx.lineJoin;
        //ctx.lineJoin = "round";

        if (isCanvasSupported) {
            ghostCtx.beginPath();
            ghostCtx.rect(plotArea.x1, plotArea.y1, plotArea.width, plotArea.height);
            ghostCtx.clip();
        }

        for (var j = 0; j < plotUnit.dataSeriesIndexes.length; j++) {

            var dataSeriesIndex = plotUnit.dataSeriesIndexes[j];

            var dataSeries = this.data[dataSeriesIndex];

            var dataPoints = dataSeries.dataPoints;

            var seriesId = dataSeries.id;
            this._eventManager.objectMap[seriesId] = {
                objectType: "dataSeries", dataSeriesIndex: dataSeriesIndex
            };

            var hexColor = intToHexColorString(seriesId);
            ghostCtx.fillStyle = hexColor;
            //ghostCtx.lineWidth = dataSeries.lineThickness;
            //ghostCtx.lineWidth = 20;

            markers = [];

            var isFirstDataPointInPlotArea = true;
            var i = 0, x, y;
            var dataPointX; //Used so that when dataPoint.x is a DateTime value, it doesn't get converted to number back and forth.

            var yZeroToPixel = plotUnit.axisY.convertValueToPixel(plotUnit.axisY.logarithmic ? plotUnit.axisY.viewportMinimum : 0);
            var baseY;

            var startPoint = null;

            if (dataPoints.length > 0) {
                //ctx.strokeStyle = "#4572A7 ";
                var color = dataSeries._colorSet[i % dataSeries._colorSet.length];
                var lineColor = dataSeries.lineColor = dataSeries.options.lineColor || color;
                var currentStrokeStyle = lineColor;
                //ctx.strokeStyle = "red";
                ctx.fillStyle = color;
                ctx.strokeStyle = lineColor;
                ctx.lineWidth = dataSeries.lineThickness;
                var currentLineDashType = "solid";

                if (ctx.setLineDash) {
                    var nullDataLineDashType = getLineDashArray(dataSeries.nullDataLineDashType, dataSeries.lineThickness);
                    currentLineDashType = dataSeries.lineDashType;
                    var lineDashType = getLineDashArray(currentLineDashType, dataSeries.lineThickness);
                    ctx.setLineDash(lineDashType);
                }

                var prevDataNull = true;
                for (; i < dataPoints.length; i++) {

                    dataPointX = dataPoints[i].x.getTime ? dataPoints[i].x.getTime() : dataPoints[i].x;

                    if (dataPointX < plotUnit.axisX.dataInfo.viewPortMin || dataPointX > plotUnit.axisX.dataInfo.viewPortMax && !(dataSeries.connectNullData && prevDataNull)) {
                        continue;
                    }

                    if (typeof (dataPoints[i].y) !== "number") {
                        if (!(dataSeries.connectNullData || prevDataNull || isFirstDataPointInPlotArea))
                            closeArea();

                        prevDataNull = true;
                        continue;
                    }

                    x = plotUnit.axisX.convertValueToPixel(dataPointX);
                    y = plotUnit.axisY.convertValueToPixel(dataPoints[i].y);

                    if (isFirstDataPointInPlotArea || prevDataNull) {

                        if (!isFirstDataPointInPlotArea && dataSeries.connectNullData) {
                            //Applying nullLineDshType If lineDashType at dataPoints not mentoioned in prevuous dataPoints
                            if (ctx.setLineDash && (dataSeries.options.nullDataLineDashType || (currentLineDashType === dataSeries.lineDashType && dataSeries.lineDashType !== dataSeries.nullDataLineDashType))) {
                                currentDataPoint = { x: x, y: y };
                                x = previousNotNullDataPoint.x;
                                y = previousNotNullDataPoint.y;
                                //ctx.stroke();
                                closeArea();
                                //ctx.beginPath();
                                ctx.moveTo(previousNotNullDataPoint.x, previousNotNullDataPoint.y);
                                x = currentDataPoint.x;
                                y = currentDataPoint.y;
                                startPoint = previousNotNullDataPoint;
                                currentLineDashType = dataSeries.nullDataLineDashType;
                                ctx.setLineDash(nullDataLineDashType);
                            }

                            ctx.lineTo(x, y);
                            if (isCanvasSupported)
                                ghostCtx.lineTo(x, y);

                        } else { //If connectNullData = false
                            ctx.beginPath();
                            ctx.moveTo(x, y);
                            if (isCanvasSupported) {
                                ghostCtx.beginPath();
                                ghostCtx.moveTo(x, y);
                            }
                            startPoint = {
                                x: x, y: y
                            };
                        }

                        isFirstDataPointInPlotArea = false;
                        prevDataNull = false;
                    }
                    else {

                        ctx.lineTo(x, y);

                        if (isCanvasSupported)
                            ghostCtx.lineTo(x, y);

                        if (i % 250 == 0) {
                            closeArea();
                        }
                    }

                    previousNotNullDataPoint = { x: x, y: y };

                    if (i < dataPoints.length - 1 && (currentStrokeStyle !== (dataPoints[i].lineColor || lineColor) || currentLineDashType !== (dataPoints[i].lineDashType || dataSeries.lineDashType))) { //Applieng new ctx on DataPoint

                        closeArea();
                        //ctx.stroke();
                        //ctx.beginPath();
                        //ctx.moveTo(x, y);

                        currentStrokeStyle = dataPoints[i].lineColor || lineColor;
                        ctx.strokeStyle = currentStrokeStyle;
                        if (ctx.setLineDash)
                            if (dataPoints[i].lineDashType) {
                                currentLineDashType = dataPoints[i].lineDashType;
                                ctx.setLineDash(getLineDashArray(currentLineDashType, dataSeries.lineThickness));
                            }
                            else {
                                currentLineDashType = dataSeries.lineDashType;
                                ctx.setLineDash(lineDashType);
                            }
                    }

                    var id = dataSeries.dataPointIds[i];
                    this._eventManager.objectMap[id] = {
                        id: id, objectType: "dataPoint", dataSeriesIndex: dataSeriesIndex, dataPointIndex: i, x1: x, y1: y
                    };

                    //Render Marker
                    if (dataPoints[i].markerSize !== 0) {
                        if (dataPoints[i].markerSize > 0 || dataSeries.markerSize > 0) {
                            var markerProps = dataSeries.getMarkerProperties(i, x, y, ctx);
                            markerPropsColor = markerProps.color;
                            markers.push(markerProps);

                            //if (!dataSeries.maxWidthInX || markerProps.size > dataSeries.maxWidthInX) {
                            //	dataSeries.maxWidthInX = markerProps.size / (plotUnit.axisX.conversionParameters.pixelPerUnit > 1 ? plotUnit.axisX.conversionParameters.pixelPerUnit - 1 : plotUnit.axisX.conversionParameters.pixelPerUnit);
                            //}

                            var markerColor = intToHexColorString(id);

                            if (isCanvasSupported) {
                                markers.push({
                                    x: x, y: y, ctx: ghostCtx,
                                    type: markerProps.type,
                                    size: markerProps.size,
                                    color: markerColor,
                                    borderColor: markerColor,
                                    borderThickness: markerProps.borderThickness
                                });
                            }
                        }
                    }

                    if (dataPoints[i].indexLabel || dataSeries.indexLabel || dataPoints[i].indexLabelFormatter || dataSeries.indexLabelFormatter) {

                        this._indexLabels.push({
                            chartType: "area",
                            dataPoint: dataPoints[i],
                            dataSeries: dataSeries,
                            point: {
                                x: x, y: y
                            },
                            direction: dataPoints[i].y < 0 === plotUnit.axisY.reversed ? 1 : -1,
                            color: color
                        });

                    }
                }

                closeArea();

                //startPoint = { x: x, y: y };
                RenderHelper.drawMarkers(markers);
                //dataSeries.markerColor = markerPropsColor;
            }
        }

        ctx.restore();
        //ctx.lineJoin = defaultLineJoinType;

        if (isCanvasSupported)
            this._eventManager.ghostCtx.restore();

        function closeArea() {

            if (!startPoint)
                return;

            if (dataSeries.lineThickness > 0)
                ctx.stroke();

            if (plotUnit.axisY.logarithmic || plotUnit.axisY.viewportMinimum <= 0 && plotUnit.axisY.viewportMaximum >= 0) {
                baseY = yZeroToPixel;
            }
            else if (plotUnit.axisY.viewportMaximum < 0)
                baseY = axisYProps.y1;
            else if (plotUnit.axisY.viewportMinimum > 0)
                baseY = axisXProps.y2;

            ctx.lineTo(x, baseY);
            ctx.lineTo(startPoint.x, baseY);
            ctx.closePath();

            ctx.globalAlpha = dataSeries.fillOpacity;
            ctx.fill();
            ctx.globalAlpha = 1;

            if (isCanvasSupported) {
                ghostCtx.lineTo(x, baseY);
                ghostCtx.lineTo(startPoint.x, baseY);
                ghostCtx.closePath();
                ghostCtx.fill();
            }

            ctx.beginPath();
            ctx.moveTo(x, y);
            ghostCtx.beginPath();
            ghostCtx.moveTo(x, y);

            startPoint = {
                x: x, y: y
            };
        }

        //source and dest would be same when animation is not enabled
        var animationInfo = {
            source: ctx, dest: this.plotArea.ctx, animationCallback: AnimationHelper.xClipAnimation, easingFunction: AnimationHelper.easing.linear, animationBase: 0
        };
        return animationInfo;
    }

    Chart.prototype.renderSplineArea = function (plotUnit) {
        var ctx = plotUnit.targetCanvasCtx || this.plotArea.ctx;

        var totalDataSeries = plotUnit.dataSeriesIndexes.length;

        if (totalDataSeries <= 0)
            return;

        var ghostCtx = this._eventManager.ghostCtx;

        var axisXProps = plotUnit.axisX.lineCoordinates;
        var axisYProps = plotUnit.axisY.lineCoordinates;
        var markers = [];
        var markerPropsColor = null;

        var plotArea = this.plotArea;
        ctx.save();

        if (isCanvasSupported)
            ghostCtx.save();

        ctx.beginPath();
        ctx.rect(plotArea.x1, plotArea.y1, plotArea.width, plotArea.height);
        ctx.clip();

        if (isCanvasSupported) {
            ghostCtx.beginPath();
            ghostCtx.rect(plotArea.x1, plotArea.y1, plotArea.width, plotArea.height);
            ghostCtx.clip();
        }

        for (var j = 0; j < plotUnit.dataSeriesIndexes.length; j++) {

            var dataSeriesIndex = plotUnit.dataSeriesIndexes[j];

            var dataSeries = this.data[dataSeriesIndex];

            var dataPoints = dataSeries.dataPoints;

            var seriesId = dataSeries.id;
            this._eventManager.objectMap[seriesId] = {
                objectType: "dataSeries", dataSeriesIndex: dataSeriesIndex
            };

            var hexColor = intToHexColorString(seriesId);
            ghostCtx.fillStyle = hexColor;
            //ghostCtx.lineWidth = dataSeries.lineThickness;
            //ghostCtx.lineWidth = 20;

            markers = [];

            var isFirstDataPointInPlotArea = true;
            var i = 0, x, y;
            var dataPointX; //Used so that when dataPoint.x is a DateTime value, it doesn't get converted to number back and forth.

            var yZeroToPixel = plotUnit.axisY.convertValueToPixel(plotUnit.axisY.logarithmic ? plotUnit.axisY.viewportMinimum : 0);
            var baseY;

            var startPoint = null;

            var pixels = [];

            if (dataPoints.length > 0) {
                //ctx.strokeStyle = "#4572A7 ";
                var color = dataSeries._colorSet[i % dataSeries._colorSet.length];
                var lineColor = dataSeries.lineColor = dataSeries.options.lineColor || color;
                var currentStrokeStyle = lineColor;
                ctx.fillStyle = color;
                ctx.strokeStyle = lineColor;
                ctx.lineWidth = dataSeries.lineThickness;
                var currentLineDashType = "solid";

                if (ctx.setLineDash) {
                    var nullDataLineDashType = getLineDashArray(dataSeries.nullDataLineDashType, dataSeries.lineThickness);
                    currentLineDashType = dataSeries.lineDashType;
                    var lineDashType = getLineDashArray(currentLineDashType, dataSeries.lineThickness);
                    ctx.setLineDash(lineDashType);
                }

                var prevDataNull = false;
                for (; i < dataPoints.length; i++) {

                    dataPointX = dataPoints[i].x.getTime ? dataPoints[i].x.getTime() : dataPoints[i].x;

                    if (dataPointX < plotUnit.axisX.dataInfo.viewPortMin || dataPointX > plotUnit.axisX.dataInfo.viewPortMax && !(dataSeries.connectNullData && prevDataNull)) {
                        continue;
                    }

                    if (typeof (dataPoints[i].y) !== "number") {
                        if (i > 0 && !prevDataNull) {
                            if (dataSeries.connectNullData) {
                                if (ctx.setLineDash && pixels.length > 0 && (dataSeries.options.nullDataLineDashType || !dataPoints[i - 1].lineDashType)) {
                                    pixels[pixels.length - 1].newLineDashArray = nullDataLineDashType;
                                    currentLineDashType = dataSeries.nullDataLineDashType;
                                }
                            }
                            else {
                                renderBezierArea();
                                pixels = [];
                            }
                        }

                        prevDataNull = true;
                        continue;
                    }

                    x = plotUnit.axisX.convertValueToPixel(dataPointX);
                    y = plotUnit.axisY.convertValueToPixel(dataPoints[i].y);


                    var id = dataSeries.dataPointIds[i];
                    this._eventManager.objectMap[id] = {
                        id: id, objectType: "dataPoint", dataSeriesIndex: dataSeriesIndex, dataPointIndex: i, x1: x, y1: y
                    };

                    pixels[pixels.length] = {
                        x: x, y: y
                    };

                    if (i < dataPoints.length - 1 && (currentStrokeStyle !== (dataPoints[i].lineColor || lineColor) || currentLineDashType !== (dataPoints[i].lineDashType || dataSeries.lineDashType))) { //Applieng new ctx on DataPoint

                        currentStrokeStyle = dataPoints[i].lineColor || lineColor;
                        pixels[pixels.length - 1].newStrokeStyle = currentStrokeStyle;
                        if (ctx.setLineDash)
                            if (dataPoints[i].lineDashType) {
                                currentLineDashType = dataPoints[i].lineDashType;
                                pixels[pixels.length - 1].newLineDashArray = getLineDashArray(currentLineDashType, dataSeries.lineThickness);
                            }
                            else {
                                currentLineDashType = dataSeries.lineDashType;
                                pixels[pixels.length - 1].newLineDashArray = lineDashType;
                            }
                    }

                    //Render Marker
                    if (dataPoints[i].markerSize !== 0) {
                        if (dataPoints[i].markerSize > 0 || dataSeries.markerSize > 0) {
                            var markerProps = dataSeries.getMarkerProperties(i, x, y, ctx);
                            markerPropsColor = markerProps.color;
                            markers.push(markerProps);

                            //if (!dataSeries.maxWidthInX || markerProps.size > dataSeries.maxWidthInX) {
                            //	dataSeries.maxWidthInX = markerProps.size / (plotUnit.axisX.conversionParameters.pixelPerUnit > 1 ? plotUnit.axisX.conversionParameters.pixelPerUnit - 1 : plotUnit.axisX.conversionParameters.pixelPerUnit);
                            //}

                            var markerColor = intToHexColorString(id);

                            if (isCanvasSupported) {
                                markers.push({
                                    x: x, y: y, ctx: ghostCtx,
                                    type: markerProps.type,
                                    size: markerProps.size,
                                    color: markerColor,
                                    borderColor: markerColor,
                                    borderThickness: markerProps.borderThickness
                                });
                            }
                        }
                    }


                    //Render Index Labels
                    if (dataPoints[i].indexLabel || dataSeries.indexLabel || dataPoints[i].indexLabelFormatter || dataSeries.indexLabelFormatter) {

                        this._indexLabels.push({
                            chartType: "splineArea",
                            dataPoint: dataPoints[i],
                            dataSeries: dataSeries,
                            point: {
                                x: x, y: y
                            },
                            direction: dataPoints[i].y < 0 === plotUnit.axisY.reversed ? 1 : -1,
                            color: color
                        });

                    }

                    isFirstDataPointInPlotArea = false;
                    prevDataNull = false;
                }

                renderBezierArea();

                RenderHelper.drawMarkers(markers);
                //dataSeries.markerColor = markerPropsColor;
            }
        }

        ctx.restore();

        if (isCanvasSupported)
            this._eventManager.ghostCtx.restore();

        function renderBezierArea() {
            var bp = getBezierPoints(pixels, 2);

            if (bp.length > 0) {

                if (dataSeries.lineThickness > 0) {
                    ctx.beginPath();
                    ctx.moveTo(bp[0].x, bp[0].y);
                    if (bp[0].newStrokeStyle)
                        ctx.strokeStyle = bp[0].newStrokeStyle;
                    if (bp[0].newLineDashArray)
                        ctx.setLineDash(bp[0].newLineDashArray);

                    for (var i = 0; i < bp.length - 3; i += 3) {

                        ctx.bezierCurveTo(bp[i + 1].x, bp[i + 1].y, bp[i + 2].x, bp[i + 2].y, bp[i + 3].x, bp[i + 3].y);

                        if (isCanvasSupported)
                            ghostCtx.bezierCurveTo(bp[i + 1].x, bp[i + 1].y, bp[i + 2].x, bp[i + 2].y, bp[i + 3].x, bp[i + 3].y);

                        if (bp[i + 3].newStrokeStyle || bp[i + 3].newLineDashArray) {
                            ctx.stroke();
                            ctx.beginPath();
                            ctx.moveTo(bp[i + 3].x, bp[i + 3].y);
                            if (bp[i + 3].newStrokeStyle)
                                ctx.strokeStyle = bp[i + 3].newStrokeStyle;
                            if (bp[i + 3].newLineDashArray)
                                ctx.setLineDash(bp[i + 3].newLineDashArray);
                        }

                    }

                    ctx.stroke();
                }

                ctx.beginPath();
                ctx.moveTo(bp[0].x, bp[0].y);
                if (isCanvasSupported) {
                    ghostCtx.beginPath();
                    ghostCtx.moveTo(bp[0].x, bp[0].y);
                }

                for (var i = 0; i < bp.length - 3; i += 3) {

                    ctx.bezierCurveTo(bp[i + 1].x, bp[i + 1].y, bp[i + 2].x, bp[i + 2].y, bp[i + 3].x, bp[i + 3].y);

                    if (isCanvasSupported)
                        ghostCtx.bezierCurveTo(bp[i + 1].x, bp[i + 1].y, bp[i + 2].x, bp[i + 2].y, bp[i + 3].x, bp[i + 3].y);

                }

                if (plotUnit.axisY.logarithmic || plotUnit.axisY.viewportMinimum <= 0 && plotUnit.axisY.viewportMaximum >= 0) {
                    baseY = yZeroToPixel;
                }
                else if (plotUnit.axisY.viewportMaximum < 0)
                    baseY = axisYProps.y1;
                else if (plotUnit.axisY.viewportMinimum > 0)
                    baseY = axisXProps.y2;

                startPoint = {
                    x: bp[0].x, y: bp[0].y
                };

                ctx.lineTo(bp[bp.length - 1].x, baseY);
                ctx.lineTo(startPoint.x, baseY);
                ctx.closePath();

                ctx.globalAlpha = dataSeries.fillOpacity;
                ctx.fill();
                ctx.globalAlpha = 1;

                if (isCanvasSupported) {
                    ghostCtx.lineTo(bp[bp.length - 1].x, baseY);
                    ghostCtx.lineTo(startPoint.x, baseY);
                    ghostCtx.closePath();
                    ghostCtx.fill();
                }
            }
        }

        //source and dest would be same when animation is not enabled
        var animationInfo = {
            source: ctx, dest: this.plotArea.ctx, animationCallback: AnimationHelper.xClipAnimation, easingFunction: AnimationHelper.easing.linear, animationBase: 0
        };
        return animationInfo;
    }

    Chart.prototype.renderStepArea = function (plotUnit) {
        var ctx = plotUnit.targetCanvasCtx || this.plotArea.ctx;

        var totalDataSeries = plotUnit.dataSeriesIndexes.length;

        if (totalDataSeries <= 0)
            return;

        var ghostCtx = this._eventManager.ghostCtx;

        var axisXProps = plotUnit.axisX.lineCoordinates;
        var axisYProps = plotUnit.axisY.lineCoordinates;
        var markers = [];
        var markerPropsColor = null;

        var plotArea = this.plotArea;
        var previousNotNullDataPoint, currentDataPoint;
        ctx.save();

        if (isCanvasSupported)
            ghostCtx.save();

        ctx.beginPath();
        ctx.rect(plotArea.x1, plotArea.y1, plotArea.width, plotArea.height);
        ctx.clip();

        if (isCanvasSupported) {
            ghostCtx.beginPath();
            ghostCtx.rect(plotArea.x1, plotArea.y1, plotArea.width, plotArea.height);
            ghostCtx.clip();
        }

        for (var j = 0; j < plotUnit.dataSeriesIndexes.length; j++) {

            var dataSeriesIndex = plotUnit.dataSeriesIndexes[j];

            var dataSeries = this.data[dataSeriesIndex];

            var dataPoints = dataSeries.dataPoints;

            var seriesId = dataSeries.id;
            this._eventManager.objectMap[seriesId] = {
                objectType: "dataSeries", dataSeriesIndex: dataSeriesIndex
            };

            var hexColor = intToHexColorString(seriesId);
            ghostCtx.fillStyle = hexColor;
            //ghostCtx.lineWidth = dataSeries.lineThickness;
            //ghostCtx.lineWidth = 20;

            markers = [];

            var isFirstDataPointInPlotArea = true;
            var i = 0, x, y;
            var dataPointX; //Used so that when dataPoint.x is a DateTime value, it doesn't get converted to number back and forth.

            var yZeroToPixel = plotUnit.axisY.convertValueToPixel(plotUnit.axisY.logarithmic ? plotUnit.axisY.viewportMinimum : 0);
            var baseY;

            var startPoint = null;

            var prevDataNull = false;
            if (dataPoints.length > 0) {
                //ctx.strokeStyle = "#4572A7 ";
                var color = dataSeries._colorSet[i % dataSeries._colorSet.length];
                var lineColor = dataSeries.lineColor = dataSeries.options.lineColor || color;
                var currentStrokeStyle = lineColor;
                //ctx.strokeStyle = "red";
                ctx.fillStyle = color;
                ctx.strokeStyle = lineColor;
                ctx.lineWidth = dataSeries.lineThickness;
                var currentLineDashType = "solid";

                if (ctx.setLineDash) {
                    var nullDataLineDashType = getLineDashArray(dataSeries.nullDataLineDashType, dataSeries.lineThickness);
                    currentLineDashType = dataSeries.lineDashType;
                    var lineDashType = getLineDashArray(currentLineDashType, dataSeries.lineThickness);
                    ctx.setLineDash(lineDashType);
                }

                for (; i < dataPoints.length; i++) {

                    dataPointX = dataPoints[i].x.getTime ? dataPoints[i].x.getTime() : dataPoints[i].x;

                    if (dataPointX < plotUnit.axisX.dataInfo.viewPortMin || dataPointX > plotUnit.axisX.dataInfo.viewPortMax && !(dataSeries.connectNullData && prevDataNull)) {
                        continue;
                    }

                    var prevY = y;

                    if (typeof (dataPoints[i].y) !== "number") {
                        if (!(dataSeries.connectNullData || prevDataNull || isFirstDataPointInPlotArea))
                            closeArea();

                        prevDataNull = true;
                        continue;
                    }

                    x = plotUnit.axisX.convertValueToPixel(dataPointX);
                    y = plotUnit.axisY.convertValueToPixel(dataPoints[i].y);



                    if (isFirstDataPointInPlotArea || prevDataNull) {
                        if (!isFirstDataPointInPlotArea && dataSeries.connectNullData) {
                            //Applying nullLineDshType If lineDashType at dataPoints not mentoioned in prevuous dataPoints
                            if (ctx.setLineDash && (dataSeries.options.nullDataLineDashType || (currentLineDashType === dataSeries.lineDashType && dataSeries.lineDashType !== dataSeries.nullDataLineDashType))) {
                                currentDataPoint = { x: x, y: y };
                                x = previousNotNullDataPoint.x;
                                y = previousNotNullDataPoint.y;
                                closeArea();
                                ctx.moveTo(previousNotNullDataPoint.x, previousNotNullDataPoint.y);
                                x = currentDataPoint.x;
                                y = currentDataPoint.y;
                                startPoint = previousNotNullDataPoint;
                                currentLineDashType = dataSeries.nullDataLineDashType;
                                ctx.setLineDash(nullDataLineDashType);
                            }
                            ctx.lineTo(x, prevY);
                            ctx.lineTo(x, y);
                            if (isCanvasSupported) {
                                ghostCtx.lineTo(x, prevY);
                                ghostCtx.lineTo(x, y);
                            }

                        } else { //If connectNullData = false
                            ctx.beginPath();
                            ctx.moveTo(x, y);
                            if (isCanvasSupported) {
                                ghostCtx.beginPath();
                                ghostCtx.moveTo(x, y);
                            }
                            startPoint = {
                                x: x, y: y
                            };
                        }

                        isFirstDataPointInPlotArea = false;
                        prevDataNull = false;
                    }
                    else {

                        ctx.lineTo(x, prevY);
                        if (isCanvasSupported)
                            ghostCtx.lineTo(x, prevY);

                        ctx.lineTo(x, y);

                        if (isCanvasSupported)
                            ghostCtx.lineTo(x, y);

                        if (i % 250 == 0) {
                            closeArea();
                        }
                    }

                    previousNotNullDataPoint = { x: x, y: y };

                    if (i < dataPoints.length - 1 && (currentStrokeStyle !== (dataPoints[i].lineColor || lineColor) || currentLineDashType !== (dataPoints[i].lineDashType || dataSeries.lineDashType))) { //Applieng new ctx on DataPoint

                        closeArea();

                        currentStrokeStyle = dataPoints[i].lineColor || lineColor;
                        ctx.strokeStyle = currentStrokeStyle;
                        if (ctx.setLineDash)
                            if (dataPoints[i].lineDashType) {
                                currentLineDashType = dataPoints[i].lineDashType;
                                ctx.setLineDash(getLineDashArray(currentLineDashType, dataSeries.lineThickness));
                            }
                            else {
                                currentLineDashType = dataSeries.lineDashType;
                                ctx.setLineDash(lineDashType);
                            }
                    }

                    var id = dataSeries.dataPointIds[i];
                    this._eventManager.objectMap[id] = {
                        id: id, objectType: "dataPoint", dataSeriesIndex: dataSeriesIndex, dataPointIndex: i, x1: x, y1: y
                    };

                    //Render Marker
                    if (dataPoints[i].markerSize !== 0) {
                        if (dataPoints[i].markerSize > 0 || dataSeries.markerSize > 0) {
                            var markerProps = dataSeries.getMarkerProperties(i, x, y, ctx);
                            markerPropsColor = markerProps.color;
                            markers.push(markerProps);

                            //if (!dataSeries.maxWidthInX || markerProps.size > dataSeries.maxWidthInX) {
                            //	dataSeries.maxWidthInX = markerProps.size / (plotUnit.axisX.conversionParameters.pixelPerUnit > 1 ? plotUnit.axisX.conversionParameters.pixelPerUnit - 1 : plotUnit.axisX.conversionParameters.pixelPerUnit);
                            //}

                            var markerColor = intToHexColorString(id);

                            if (isCanvasSupported) {
                                markers.push({
                                    x: x, y: y, ctx: ghostCtx,
                                    type: markerProps.type,
                                    size: markerProps.size,
                                    color: markerColor,
                                    borderColor: markerColor,
                                    borderThickness: markerProps.borderThickness
                                });
                            }
                        }
                    }

                    if (dataPoints[i].indexLabel || dataSeries.indexLabel || dataPoints[i].indexLabelFormatter || dataSeries.indexLabelFormatter) {

                        this._indexLabels.push({
                            chartType: "stepArea",
                            dataPoint: dataPoints[i],
                            dataSeries: dataSeries,
                            point: {
                                x: x, y: y
                            },
                            direction: dataPoints[i].y < 0 === plotUnit.axisY.reversed ? 1 : -1,
                            color: color
                        });

                    }
                }

                closeArea();

                RenderHelper.drawMarkers(markers);
                //dataSeries.markerColor = markerPropsColor;
            }
        }

        ctx.restore();
        if (isCanvasSupported)
            this._eventManager.ghostCtx.restore();

        function closeArea() {

            if (!startPoint)
                return;

            if (dataSeries.lineThickness > 0)
                ctx.stroke();

            if (plotUnit.axisY.logarithmic || plotUnit.axisY.viewportMinimum <= 0 && plotUnit.axisY.viewportMaximum >= 0) {
                baseY = yZeroToPixel;
            }
            else if (plotUnit.axisY.viewportMaximum < 0)
                baseY = axisYProps.y1;
            else if (plotUnit.axisY.viewportMinimum > 0)
                baseY = axisXProps.y2;

            ctx.lineTo(x, baseY);
            ctx.lineTo(startPoint.x, baseY);
            ctx.closePath();

            ctx.globalAlpha = dataSeries.fillOpacity;
            ctx.fill();
            ctx.globalAlpha = 1;

            if (isCanvasSupported) {
                ghostCtx.lineTo(x, baseY);
                ghostCtx.lineTo(startPoint.x, baseY);
                ghostCtx.closePath();
                ghostCtx.fill();
            }

            ctx.beginPath();
            ctx.moveTo(x, y);
            ghostCtx.beginPath();
            ghostCtx.moveTo(x, y);

            startPoint = {
                x: x, y: y
            };
        }

        //source and dest would be same when animation is not enabled
        var animationInfo = {
            source: ctx, dest: this.plotArea.ctx, animationCallback: AnimationHelper.xClipAnimation, easingFunction: AnimationHelper.easing.linear, animationBase: 0
        };
        return animationInfo;
    }

    Chart.prototype.renderStackedArea = function (plotUnit) {
        var ctx = plotUnit.targetCanvasCtx || this.plotArea.ctx;

        var totalDataSeries = plotUnit.dataSeriesIndexes.length;

        if (totalDataSeries <= 0)
            return;

        var color = null;
        var markers = [];
        var markerPropsColor = null;

        var plotArea = this.plotArea;

        var offsetY = [];
        var currentBaseValues = [];

        var allXValues = [];
        //var offsetNegativeY = [];
        var stackedY = [];

        var i = 0, x, y;
        var dataPointX; //Used so that when dataPoint.x is a DateTime value, it doesn't get converted to number everytime it is accessed.

        //var yZeroToPixel = (axisYProps.y2 - axisYProps.height / rangeY * Math.abs(0 - plotUnit.axisY.viewportMinimum) + .5) << 0;
        var yZeroToPixel = plotUnit.axisY.convertValueToPixel(plotUnit.axisY.logarithmic ? plotUnit.axisY.viewportMinimum : 0);

        var xMinDiff = plotUnit.axisX.dataInfo.minDiff;

        var ghostCtx = this._eventManager.ghostCtx;
        var previousNotNullDataPoint, temp1, temp2;

        if (isCanvasSupported)
            ghostCtx.beginPath();

        ctx.save();

        if (isCanvasSupported)
            ghostCtx.save();

        ctx.beginPath();
        ctx.rect(plotArea.x1, plotArea.y1, plotArea.width, plotArea.height);
        ctx.clip();
        //var defaultLineJoinType = ctx.lineJoin;
        //ctx.lineJoin = "round";

        if (isCanvasSupported) {
            ghostCtx.beginPath();
            ghostCtx.rect(plotArea.x1, plotArea.y1, plotArea.width, plotArea.height);
            ghostCtx.clip();
        }

        var xValuePresent = [];
        for (var j = 0; j < plotUnit.dataSeriesIndexes.length; j++) {

            var dataSeriesIndex = plotUnit.dataSeriesIndexes[j];
            var dataSeries = this.data[dataSeriesIndex];
            var dataPoints = dataSeries.dataPoints;
            var xValue;

            dataSeries.dataPointIndexes = [];

            for (i = 0; i < dataPoints.length; i++) {
                xValue = dataPoints[i].x.getTime ? dataPoints[i].x.getTime() : dataPoints[i].x;
                dataSeries.dataPointIndexes[xValue] = i;

                if (!xValuePresent[xValue]) {
                    allXValues.push(xValue);
                    xValuePresent[xValue] = true;
                }
            }

            allXValues.sort(compareNumbers);
        }

        for (var j = 0; j < plotUnit.dataSeriesIndexes.length; j++) {

            var dataSeriesIndex = plotUnit.dataSeriesIndexes[j];

            var dataSeries = this.data[dataSeriesIndex];
            var dataPoints = dataSeries.dataPoints;
            var isFirstDataPointInPlotArea = true;

            currentBaseValues = [];


            var seriesId = dataSeries.id;
            this._eventManager.objectMap[seriesId] = {
                objectType: "dataSeries", dataSeriesIndex: dataSeriesIndex
            };
            var hexColor = intToHexColorString(seriesId);
            ghostCtx.fillStyle = hexColor;



            if (allXValues.length > 0) {

                color = dataSeries._colorSet[0];
                //ctx.strokeStyle = "red";
                var lineColor = dataSeries.lineColor = dataSeries.options.lineColor || color;
                var currentStrokeStyle = lineColor;
                ctx.fillStyle = color;
                ctx.strokeStyle = lineColor;
                ctx.lineWidth = dataSeries.lineThickness;
                var currentLineDashType = "solid";

                if (ctx.setLineDash) {
                    var nullDataLineDashType = getLineDashArray(dataSeries.nullDataLineDashType, dataSeries.lineThickness);
                    currentLineDashType = dataSeries.lineDashType;
                    var lineDashType = getLineDashArray(currentLineDashType, dataSeries.lineThickness);
                    ctx.setLineDash(lineDashType);
                }

                var prevDataNull = true;
                for (i = 0; i < allXValues.length; i++) {

                    dataPointX = allXValues[i];
                    var dataPoint = null;

                    if (dataSeries.dataPointIndexes[dataPointX] >= 0)
                        dataPoint = dataPoints[dataSeries.dataPointIndexes[dataPointX]];
                    else
                        dataPoint = {
                            x: dataPointX, y: null
                        };

                    if (dataPointX < plotUnit.axisX.dataInfo.viewPortMin || dataPointX > plotUnit.axisX.dataInfo.viewPortMax && !(dataSeries.connectNullData && prevDataNull)) {
                        continue;
                    }

                    if (typeof (dataPoint.y) !== "number") {
                        if (!(dataSeries.connectNullData || prevDataNull || isFirstDataPointInPlotArea))
                            closeArea();

                        prevDataNull = true;
                        continue;
                    }

                    var x = plotUnit.axisX.convertValueToPixel(dataPointX);
                    //var y = (plotUnit.axisY.conversionParameters.reference + plotUnit.axisY.conversionParameters.pixelPerUnit * (dataPoint.y - plotUnit.axisY.conversionParameters.minimum) + .5) << 0;
                    var offset = offsetY[dataPointX] ? offsetY[dataPointX] : 0;


                    if (plotUnit.axisY.logarithmic) {

                        stackedY[dataPointX] = dataPoint.y + (stackedY[dataPointX] ? stackedY[dataPointX] : 0);
                        if (stackedY[dataPointX] <= 0)
                            continue;
                        var y = plotUnit.axisY.convertValueToPixel(stackedY[dataPointX]);

                    } else {
                        var y = plotUnit.axisY.convertValueToPixel(dataPoint.y);
                        y = y - offset;
                    }

                    currentBaseValues.push({ x: x, y: yZeroToPixel - offset });
                    offsetY[dataPointX] = yZeroToPixel - y;

                    if (isFirstDataPointInPlotArea || prevDataNull) {

                        if (!isFirstDataPointInPlotArea && dataSeries.connectNullData) {
                            //Applying nullLineDshType If lineDashType at dataPoints not mentoioned in prevuous dataPoints
                            if (ctx.setLineDash && (dataSeries.options.nullDataLineDashType || (currentLineDashType === dataSeries.lineDashType && dataSeries.lineDashType !== dataSeries.nullDataLineDashType))) {
                                temp1 = currentBaseValues.pop();
                                temp2 = currentBaseValues[currentBaseValues.length - 1];
                                closeArea();
                                ctx.moveTo(previousNotNullDataPoint.x, previousNotNullDataPoint.y);
                                currentBaseValues.push(temp2);
                                currentBaseValues.push(temp1);
                                currentLineDashType = dataSeries.nullDataLineDashType;
                                ctx.setLineDash(nullDataLineDashType);
                            }

                            ctx.lineTo(x, y);
                            if (isCanvasSupported)
                                ghostCtx.lineTo(x, y);

                        } else {
                            ctx.beginPath();
                            ctx.moveTo(x, y);

                            if (isCanvasSupported) {
                                ghostCtx.beginPath();
                                ghostCtx.moveTo(x, y);
                            }
                        }
                        //currentBaseValues.push({ x: x, y: yZeroToPixel - offset });
                        isFirstDataPointInPlotArea = false;
                        prevDataNull = false;
                    }
                    else {

                        ctx.lineTo(x, y);

                        if (isCanvasSupported)
                            ghostCtx.lineTo(x, y);

                        if (i % 250 == 0) {

                            closeArea();
                            ctx.moveTo(x, y);

                            if (isCanvasSupported) {
                                ghostCtx.moveTo(x, y);
                            }

                            currentBaseValues.push({ x: x, y: yZeroToPixel - offset });
                        }

                    }

                    previousNotNullDataPoint = { x: x, y: y };

                    if (i < dataPoints.length - 1 && (currentStrokeStyle !== (dataPoints[i].lineColor || lineColor) || currentLineDashType !== (dataPoints[i].lineDashType || dataSeries.lineDashType))) { //Applieng new ctx on DataPoint

                        closeArea();
                        //ctx.stroke();
                        ctx.beginPath();
                        ctx.moveTo(x, y);
                        currentBaseValues.push({ x: x, y: yZeroToPixel - offset });

                        currentStrokeStyle = dataPoints[i].lineColor || lineColor;
                        ctx.strokeStyle = currentStrokeStyle;
                        if (ctx.setLineDash)
                            if (dataPoints[i].lineDashType) {
                                currentLineDashType = dataPoints[i].lineDashType;
                                ctx.setLineDash(getLineDashArray(currentLineDashType, dataSeries.lineThickness));
                            }
                            else {
                                currentLineDashType = dataSeries.lineDashType;
                                ctx.setLineDash(lineDashType);
                            }
                    }

                    if (dataSeries.dataPointIndexes[dataPointX] >= 0) {
                        var id = dataSeries.dataPointIds[dataSeries.dataPointIndexes[dataPointX]];
                        this._eventManager.objectMap[id] = {
                            id: id, objectType: "dataPoint", dataSeriesIndex: dataSeriesIndex, dataPointIndex: dataSeries.dataPointIndexes[dataPointX], x1: x, y1: y
                        };
                    }

                    //Render Marker
                    if (dataSeries.dataPointIndexes[dataPointX] >= 0 && dataPoint.markerSize !== 0) {
                        if (dataPoint.markerSize > 0 || dataSeries.markerSize > 0) {

                            var markerProps = dataSeries.getMarkerProperties(dataSeries.dataPointIndexes[dataPointX], x, y, ctx);
                            markerPropsColor = markerProps.color;
                            markers.push(markerProps);

                            //if (!dataSeries.maxWidthInX || markerProps.size > dataSeries.maxWidthInX) {
                            //	dataSeries.maxWidthInX = markerProps.size / (plotUnit.axisX.conversionParameters.pixelPerUnit > 1 ? plotUnit.axisX.conversionParameters.pixelPerUnit - 1 : plotUnit.axisX.conversionParameters.pixelPerUnit);
                            //}

                            markerColor = intToHexColorString(id);

                            if (isCanvasSupported) {
                                markers.push({
                                    x: x, y: y, ctx: ghostCtx,
                                    type: markerProps.type,
                                    size: markerProps.size,
                                    color: markerColor,
                                    borderColor: markerColor,
                                    borderThickness: markerProps.borderThickness
                                });
                            }
                        }
                    }

                    if (dataPoint.indexLabel || dataSeries.indexLabel || dataPoint.indexLabelFormatter || dataSeries.indexLabelFormatter) {

                        this._indexLabels.push({
                            chartType: "stackedArea",
                            dataPoint: dataPoint,
                            dataSeries: dataSeries,
                            point: {
                                x: x, y: y
                            },
                            direction: dataPoints[i].y < 0 === plotUnit.axisY.reversed ? 1 : -1,
                            color: color
                        });

                    }
                }

                closeArea();
                ctx.moveTo(x, y);

                if (isCanvasSupported) {
                    ghostCtx.moveTo(x, y);
                }
            }

            delete (dataSeries.dataPointIndexes);
            //dataSeries.markerColor = markerPropsColor;
        }

        RenderHelper.drawMarkers(markers);


        ctx.restore();
        //ctx.lineJoin = defaultLineJoinType;

        if (isCanvasSupported)
            ghostCtx.restore();

        //source and dest would be same when animation is not enabled
        var animationInfo = {
            source: ctx, dest: this.plotArea.ctx, animationCallback: AnimationHelper.xClipAnimation, easingFunction: AnimationHelper.easing.linear, animationBase: 0
        };
        return animationInfo;

        function closeArea() {

            if (currentBaseValues.length < 1)
                return;

            if (dataSeries.lineThickness > 0)
                ctx.stroke();

            while (currentBaseValues.length > 0) {
                var point = currentBaseValues.pop();
                ctx.lineTo(point.x, point.y);

                if (isCanvasSupported)
                    ghostCtx.lineTo(point.x, point.y);

            }

            ctx.closePath();

            ctx.globalAlpha = dataSeries.fillOpacity;
            ctx.fill();
            ctx.globalAlpha = 1;

            ctx.beginPath();

            if (isCanvasSupported) {
                ghostCtx.closePath();
                ghostCtx.fill();

                ghostCtx.beginPath();
            }
            currentBaseValues = [];
        }
    }

    Chart.prototype.renderStackedArea100 = function (plotUnit) {
        var ctx = plotUnit.targetCanvasCtx || this.plotArea.ctx;

        var totalDataSeries = plotUnit.dataSeriesIndexes.length;

        if (totalDataSeries <= 0)
            return;

        var color = null;

        var plotArea = this.plotArea;
        var markers = [];
        var markerPropsColor = null;

        var offsetY = [];
        var currentBaseValues = [];
        var allXValues = [];
        //var offsetNegativeY = [];
        var stackedY = [];

        var i = 0, x, y;
        var dataPointX; //Used so that when dataPoint.x is a DateTime value, it doesn't get converted to number everytime it is accessed.
        var previousNotNullDataPoint, temp1, temp2;


        //var yZeroToPixel = (axisYProps.y2 - axisYProps.height / rangeY * Math.abs(0 - plotUnit.axisY.viewportMinimum) + .5) << 0;
        var yZeroToPixel = plotUnit.axisY.convertValueToPixel(plotUnit.axisY.logarithmic ? plotUnit.axisY.viewportMinimum : 0);


        var ghostCtx = this._eventManager.ghostCtx;

        ctx.save();

        if (isCanvasSupported)
            ghostCtx.save();


        ctx.beginPath();
        ctx.rect(plotArea.x1, plotArea.y1, plotArea.width, plotArea.height);
        ctx.clip();
        //var defaultLineJoinType = ctx.lineJoin;
        //ctx.lineJoin = "round";

        if (isCanvasSupported) {
            ghostCtx.beginPath();
            ghostCtx.rect(plotArea.x1, plotArea.y1, plotArea.width, plotArea.height);
            ghostCtx.clip();
        }

        var xValuePresent = [];
        for (var j = 0; j < plotUnit.dataSeriesIndexes.length; j++) {

            var dataSeriesIndex = plotUnit.dataSeriesIndexes[j];
            var dataSeries = this.data[dataSeriesIndex];
            var dataPoints = dataSeries.dataPoints;
            var xValue;

            dataSeries.dataPointIndexes = [];

            for (i = 0; i < dataPoints.length; i++) {
                xValue = dataPoints[i].x.getTime ? dataPoints[i].x.getTime() : dataPoints[i].x;
                dataSeries.dataPointIndexes[xValue] = i;

                if (!xValuePresent[xValue]) {
                    allXValues.push(xValue);
                    xValuePresent[xValue] = true;
                }
            }

            allXValues.sort(compareNumbers);
        }

        for (var j = 0; j < plotUnit.dataSeriesIndexes.length; j++) {

            var dataSeriesIndex = plotUnit.dataSeriesIndexes[j];

            var dataSeries = this.data[dataSeriesIndex];
            var dataPoints = dataSeries.dataPoints;
            var isFirstDataPointInPlotArea = true;


            var seriesId = dataSeries.id;
            this._eventManager.objectMap[seriesId] = {
                objectType: "dataSeries", dataSeriesIndex: dataSeriesIndex
            };
            var hexColor = intToHexColorString(seriesId);
            ghostCtx.fillStyle = hexColor;


            currentBaseValues = [];

            if (allXValues.length > 0) {

                color = dataSeries._colorSet[i % dataSeries._colorSet.length];
                //ctx.strokeStyle = "red";
                var lineColor = dataSeries.lineColor = dataSeries.options.lineColor || color;
                var currentStrokeStyle = lineColor;
                ctx.fillStyle = color;
                ctx.strokeStyle = lineColor;
                ctx.lineWidth = dataSeries.lineThickness;
                var currentLineDashType = "solid";

                if (ctx.setLineDash) {
                    var nullDataLineDashType = getLineDashArray(dataSeries.nullDataLineDashType, dataSeries.lineThickness);
                    currentLineDashType = dataSeries.lineDashType;
                    var lineDashType = getLineDashArray(currentLineDashType, dataSeries.lineThickness);
                    ctx.setLineDash(lineDashType);
                }


                //ctx.strokeStyle = "#4572A7 ";
                var prevDataNull = true;
                for (i = 0; i < allXValues.length; i++) {

                    dataPointX = allXValues[i];
                    var dataPoint = null;

                    if (dataSeries.dataPointIndexes[dataPointX] >= 0)
                        dataPoint = dataPoints[dataSeries.dataPointIndexes[dataPointX]];
                    else
                        dataPoint = {
                            x: dataPointX, y: null
                        };

                    if (dataPointX < plotUnit.axisX.dataInfo.viewPortMin || dataPointX > plotUnit.axisX.dataInfo.viewPortMax && !(dataSeries.connectNullData && prevDataNull)) {
                        continue;
                    }

                    if (typeof (dataPoint.y) !== "number") {
                        if (!(dataSeries.connectNullData || prevDataNull || isFirstDataPointInPlotArea))
                            closeArea();

                        prevDataNull = true;
                        continue;
                    }

                    var yPercent;
                    if (plotUnit.dataPointYSums[dataPointX] !== 0)
                        yPercent = dataPoint.y / plotUnit.dataPointYSums[dataPointX] * 100;
                    else
                        yPercent = 0;

                    var x = plotUnit.axisX.convertValueToPixel(dataPointX);

                    var offset = offsetY[dataPointX] ? offsetY[dataPointX] : 0;

                    if (plotUnit.axisY.logarithmic) {

                        stackedY[dataPointX] = yPercent + (stackedY[dataPointX] ? stackedY[dataPointX] : 0);
                        if (stackedY[dataPointX] <= 0)
                            continue;
                        var y = plotUnit.axisY.convertValueToPixel(stackedY[dataPointX]);

                    } else {
                        var y = plotUnit.axisY.convertValueToPixel(yPercent);
                        y = y - offset;
                    }
                    currentBaseValues.push({ x: x, y: yZeroToPixel - offset });
                    offsetY[dataPointX] = yZeroToPixel - y;

                    if (isFirstDataPointInPlotArea || prevDataNull) {

                        if (!isFirstDataPointInPlotArea && dataSeries.connectNullData) {
                            //Applying nullLineDshType If lineDashType at dataPoints not mentoioned in prevuous dataPoints
                            if (ctx.setLineDash && (dataSeries.options.nullDataLineDashType || (currentLineDashType === dataSeries.lineDashType && dataSeries.lineDashType !== dataSeries.nullDataLineDashType))) {
                                temp1 = currentBaseValues.pop();
                                temp2 = currentBaseValues[currentBaseValues.length - 1];
                                closeArea();
                                ctx.moveTo(previousNotNullDataPoint.x, previousNotNullDataPoint.y);
                                currentBaseValues.push(temp2);
                                currentBaseValues.push(temp1);
                                currentLineDashType = dataSeries.nullDataLineDashType;
                                ctx.setLineDash(nullDataLineDashType);
                            }

                            ctx.lineTo(x, y);
                            if (isCanvasSupported)
                                ghostCtx.lineTo(x, y);

                        } else {
                            ctx.beginPath();
                            ctx.moveTo(x, y);

                            if (isCanvasSupported) {
                                ghostCtx.beginPath();
                                ghostCtx.moveTo(x, y);
                            }
                        }
                        isFirstDataPointInPlotArea = false;
                        prevDataNull = false;
                    }
                    else {

                        ctx.lineTo(x, y);

                        if (isCanvasSupported)
                            ghostCtx.lineTo(x, y);

                        if (i % 250 == 0) {

                            closeArea();
                            ctx.moveTo(x, y);

                            if (isCanvasSupported) {
                                ghostCtx.moveTo(x, y);
                            }

                            currentBaseValues.push({ x: x, y: yZeroToPixel - offset });
                        }
                    }

                    previousNotNullDataPoint = { x: x, y: y };

                    if (i < dataPoints.length - 1 && (currentStrokeStyle !== (dataPoints[i].lineColor || lineColor) || currentLineDashType !== (dataPoints[i].lineDashType || dataSeries.lineDashType))) { //Applieng new ctx on DataPoint

                        closeArea();
                        //ctx.stroke();
                        ctx.beginPath();
                        ctx.moveTo(x, y);
                        currentBaseValues.push({ x: x, y: yZeroToPixel - offset });

                        currentStrokeStyle = dataPoints[i].lineColor || lineColor;
                        ctx.strokeStyle = currentStrokeStyle;
                        if (ctx.setLineDash)
                            if (dataPoints[i].lineDashType) {
                                currentLineDashType = dataPoints[i].lineDashType;
                                ctx.setLineDash(getLineDashArray(currentLineDashType, dataSeries.lineThickness));
                            }
                            else {
                                currentLineDashType = dataSeries.lineDashType;
                                ctx.setLineDash(lineDashType);
                            }
                    }


                    if (dataSeries.dataPointIndexes[dataPointX] >= 0) {
                        var id = dataSeries.dataPointIds[dataSeries.dataPointIndexes[dataPointX]];
                        this._eventManager.objectMap[id] = {
                            id: id, objectType: "dataPoint", dataSeriesIndex: dataSeriesIndex, dataPointIndex: dataSeries.dataPointIndexes[dataPointX], x1: x, y1: y
                        };
                    }

                    //Render Marker
                    if (dataSeries.dataPointIndexes[dataPointX] >= 0 && dataPoint.markerSize !== 0) {
                        if (dataPoint.markerSize > 0 || dataSeries.markerSize > 0) {
                            var markerProps = dataSeries.getMarkerProperties(i, x, y, ctx);
                            markerPropsColor = markerProps.color;
                            markers.push(markerProps);

                            //if (!dataSeries.maxWidthInX || markerProps.size > dataSeries.maxWidthInX) {
                            //	dataSeries.maxWidthInX = markerProps.size / (plotUnit.axisX.conversionParameters.pixelPerUnit > 1 ? plotUnit.axisX.conversionParameters.pixelPerUnit - 1 : plotUnit.axisX.conversionParameters.pixelPerUnit);
                            //}

                            markerColor = intToHexColorString(id);

                            if (isCanvasSupported) {
                                markers.push({
                                    x: x, y: y, ctx: ghostCtx,
                                    type: markerProps.type,
                                    size: markerProps.size,
                                    color: markerColor,
                                    borderColor: markerColor,
                                    borderThickness: markerProps.borderThickness
                                });
                            }
                        }
                    }

                    if (dataPoint.indexLabel || dataSeries.indexLabel || dataPoint.indexLabelFormatter || dataSeries.indexLabelFormatter) {

                        this._indexLabels.push({
                            chartType: "stackedArea100",
                            dataPoint: dataPoint,
                            dataSeries: dataSeries,
                            point: {
                                x: x, y: y
                            },
                            direction: dataPoints[i].y < 0 === plotUnit.axisY.reversed ? 1 : -1,
                            color: color
                        });

                    }
                }

                closeArea();
                ctx.moveTo(x, y);
                if (isCanvasSupported) {
                    ghostCtx.moveTo(x, y);
                }
            }

            delete (dataSeries.dataPointIndexes);
            //dataSeries.markerColor = markerPropsColor;
        }

        RenderHelper.drawMarkers(markers);

        ctx.restore();
        //ctx.lineJoin = defaultLineJoinType;


        if (isCanvasSupported)
            ghostCtx.restore();

        //source and dest would be same when animation is not enabled
        var animationInfo = {
            source: ctx, dest: this.plotArea.ctx, animationCallback: AnimationHelper.xClipAnimation, easingFunction: AnimationHelper.easing.linear, animationBase: 0
        };
        return animationInfo;

        function closeArea() {
            if (dataSeries.lineThickness > 0)
                ctx.stroke();

            while (currentBaseValues.length > 0) {
                var point = currentBaseValues.pop();
                ctx.lineTo(point.x, point.y);

                if (isCanvasSupported)
                    ghostCtx.lineTo(point.x, point.y);
            }

            ctx.closePath();

            ctx.globalAlpha = dataSeries.fillOpacity;
            ctx.fill();
            ctx.globalAlpha = 1;

            ctx.beginPath();

            if (isCanvasSupported) {
                ghostCtx.closePath();
                ghostCtx.fill();
                ghostCtx.beginPath();
            }

            currentBaseValues = [];
        }
    }

    Chart.prototype.renderBubble = function (plotUnit) {

        var ctx = plotUnit.targetCanvasCtx || this.plotArea.ctx;

        var totalDataSeries = plotUnit.dataSeriesIndexes.length;

        if (totalDataSeries <= 0)
            return;

        var color = null;

        var plotArea = this.plotArea;

        var i = 0, x, y;
        var dataPointX; //Used so that when dataPoint.x is a DateTime value, it doesn't get converted to number from dataTime everytime it is used.


        ctx.save();

        if (isCanvasSupported)
            this._eventManager.ghostCtx.save();

        ctx.beginPath();
        ctx.rect(plotArea.x1, plotArea.y1, plotArea.width, plotArea.height);
        ctx.clip();

        if (isCanvasSupported) {
            this._eventManager.ghostCtx.beginPath();
            this._eventManager.ghostCtx.rect(plotArea.x1, plotArea.y1, plotArea.width, plotArea.height);
            this._eventManager.ghostCtx.clip();
        }

        var maxZ = -Infinity;
        var minZ = Infinity;

        for (var j = 0; j < plotUnit.dataSeriesIndexes.length; j++) {

            var dataSeriesIndex = plotUnit.dataSeriesIndexes[j];
            var dataSeries = this.data[dataSeriesIndex];
            var dataPoints = dataSeries.dataPoints;
            var z = 0;

            for (var i = 0; i < dataPoints.length; i++) {

                dataPointX = dataPoints[i].getTime ? dataPointX = dataPoints[i].x.getTime() : dataPointX = dataPoints[i].x;

                if (dataPointX < plotUnit.axisX.dataInfo.viewPortMin || dataPointX > plotUnit.axisX.dataInfo.viewPortMax) {
                    continue;
                }

                if (typeof (dataPoints[i].z) !== "undefined") {

                    z = dataPoints[i].z;

                    if (z > maxZ)
                        maxZ = z;

                    if (z < minZ)
                        minZ = z;
                }
            }
        }

        var minArea = Math.PI * 5 * 5;
        var maxArea = Math.max(Math.pow(Math.min(plotArea.height, plotArea.width) * .25 / 2, 2) * Math.PI, minArea);

        for (var j = 0; j < plotUnit.dataSeriesIndexes.length; j++) {

            var dataSeriesIndex = plotUnit.dataSeriesIndexes[j];

            var dataSeries = this.data[dataSeriesIndex];
            var dataPoints = dataSeries.dataPoints;
            var isFirstDataPointInPlotArea = true;


            if (dataPoints.length > 0) {

                ctx.strokeStyle = "#4572A7 ";



                for (var i = 0; i < dataPoints.length; i++) {

                    dataPointX = dataPoints[i].getTime ? dataPointX = dataPoints[i].x.getTime() : dataPointX = dataPoints[i].x;

                    if (dataPointX < plotUnit.axisX.dataInfo.viewPortMin || dataPointX > plotUnit.axisX.dataInfo.viewPortMax) {
                        continue;
                    }

                    if (typeof (dataPoints[i].y) !== "number")
                        continue;

                    x = plotUnit.axisX.convertValueToPixel(dataPointX);
                    y = plotUnit.axisY.convertValueToPixel(dataPoints[i].y);

                    var z = dataPoints[i].z;

                    var area = (maxZ === minZ) ? maxArea / 2 : minArea + (maxArea - minArea) / (maxZ - minZ) * (z - minZ);
                    var radius = Math.max(Math.sqrt(area / Math.PI) << 0, 1);

                    var markerSize = radius * 2;
                    var markerProps = dataSeries.getMarkerProperties(i, ctx);
                    markerProps.size = markerSize;


                    ctx.globalAlpha = dataSeries.fillOpacity;
                    RenderHelper.drawMarker(x, y, ctx, markerProps.type, markerProps.size, markerProps.color, markerProps.borderColor, markerProps.borderThickness);
                    ctx.globalAlpha = 1;

                    var id = dataSeries.dataPointIds[i];
                    this._eventManager.objectMap[id] = {
                        id: id, objectType: "dataPoint", dataSeriesIndex: dataSeriesIndex, dataPointIndex: i, x1: x, y1: y, size: markerSize
                    };
                    var markerColor = intToHexColorString(id);
                    //RenderHelper.drawMarker(x, y, this._eventManager.ghostCtx, markerType, markerSize, markerColor, markerColor, dataSeries.markerBorderThickness);
                    if (isCanvasSupported)
                        RenderHelper.drawMarker(x, y, this._eventManager.ghostCtx, markerProps.type, markerProps.size, markerColor, markerColor, markerProps.borderThickness);


                    if (dataPoints[i].indexLabel || dataSeries.indexLabel || dataPoints[i].indexLabelFormatter || dataSeries.indexLabelFormatter) {

                        this._indexLabels.push({
                            chartType: "bubble",
                            dataPoint: dataPoints[i],
                            dataSeries: dataSeries,
                            point: {
                                x: x, y: y
                            },
                            direction: 1,
                            bounds: {
                                x1: x - markerProps.size / 2, y1: y - markerProps.size / 2, x2: x + markerProps.size / 2, y2: y + markerProps.size / 2
                            },
                            color: color
                        });
                    }
                }
            }
        }

        ctx.restore();

        if (isCanvasSupported)
            this._eventManager.ghostCtx.restore();

        //source and dest would be same when animation is not enabled
        var animationInfo = {
            source: ctx, dest: this.plotArea.ctx, animationCallback: AnimationHelper.fadeInAnimation, easingFunction: AnimationHelper.easing.easeInQuad, animationBase: 0
        };
        return animationInfo;
    }

    Chart.prototype.renderScatter = function (plotUnit) {
        var ctx = plotUnit.targetCanvasCtx || this.plotArea.ctx;
        var totalDataSeries = plotUnit.dataSeriesIndexes.length;

        if (totalDataSeries <= 0)
            return;

        var color = null;

        var plotArea = this.plotArea;

        var i = 0, x, y;
        var dataPointX; //Used so that when dataPoint.x is a DateTime value, it doesn't get converted to number from dataTime everytime it is used.


        ctx.save();
        if (isCanvasSupported)
            this._eventManager.ghostCtx.save();

        ctx.beginPath();
        ctx.rect(plotArea.x1, plotArea.y1, plotArea.width, plotArea.height);
        ctx.clip();

        if (isCanvasSupported) {
            this._eventManager.ghostCtx.beginPath();
            this._eventManager.ghostCtx.rect(plotArea.x1, plotArea.y1, plotArea.width, plotArea.height);
            this._eventManager.ghostCtx.clip();
        }

        for (var j = 0; j < plotUnit.dataSeriesIndexes.length; j++) {

            var dataSeriesIndex = plotUnit.dataSeriesIndexes[j];

            var dataSeries = this.data[dataSeriesIndex];
            var dataPoints = dataSeries.dataPoints;
            var isFirstDataPointInPlotArea = true;


            if (dataPoints.length > 0) {

                ctx.strokeStyle = "#4572A7 ";

                var maxArea = Math.pow(Math.min(plotArea.height, plotArea.width) * .3 / 2, 2) * Math.PI;

                var prevDataPointX = 0;
                var prevDataPointY = 0;

                for (var i = 0; i < dataPoints.length; i++) {

                    dataPointX = dataPoints[i].getTime ? dataPointX = dataPoints[i].x.getTime() : dataPointX = dataPoints[i].x;

                    if (dataPointX < plotUnit.axisX.dataInfo.viewPortMin || dataPointX > plotUnit.axisX.dataInfo.viewPortMax) {
                        continue;
                    }

                    if (typeof (dataPoints[i].y) !== "number")
                        continue;

                    x = plotUnit.axisX.convertValueToPixel(dataPointX);
                    y = plotUnit.axisY.convertValueToPixel(dataPoints[i].y);

                    var markerProps = dataSeries.getMarkerProperties(i, x, y, ctx);

                    ctx.globalAlpha = dataSeries.fillOpacity;
                    RenderHelper.drawMarker(markerProps.x, markerProps.y, markerProps.ctx, markerProps.type, markerProps.size, markerProps.color, markerProps.borderColor, markerProps.borderThickness);
                    ctx.globalAlpha = 1;


                    //if (Math.abs(prevDataPointX - x) < markerProps.size / 2 && Math.abs(prevDataPointY - y) < markerProps.size / 2) {
                    //    continue;
                    //}

                    //if (!dataSeries.maxWidthInX || markerProps.size > dataSeries.maxWidthInX) {
                    //	dataSeries.maxWidthInX = markerProps.size / (plotUnit.axisX.conversionParameters.pixelPerUnit > 1 ? plotUnit.axisX.conversionParameters.pixelPerUnit - 1 : plotUnit.axisX.conversionParameters.pixelPerUnit);
                    //}

                    if ((Math.sqrt((prevDataPointX - x) * (prevDataPointX - x) + (prevDataPointY - y) * (prevDataPointY - y)) < Math.min(markerProps.size, 5))
                        && dataPoints.length > (Math.min(this.plotArea.width, this.plotArea.height))) {
                        continue;
                    }

                    //Render ID on Ghost Canvas - for event handling
                    var id = dataSeries.dataPointIds[i];
                    this._eventManager.objectMap[id] = {
                        id: id, objectType: "dataPoint", dataSeriesIndex: dataSeriesIndex, dataPointIndex: i, x1: x, y1: y
                    };
                    var markerColor = intToHexColorString(id);

                    if (isCanvasSupported) {
                        RenderHelper.drawMarker(
                            markerProps.x, markerProps.y, this._eventManager.ghostCtx,
                            markerProps.type,
                            markerProps.size,
                            markerColor,
                            markerColor,
                            markerProps.borderThickness
                        );
                    }
                    //markers.push();

                    if (dataPoints[i].indexLabel || dataSeries.indexLabel || dataPoints[i].indexLabelFormatter || dataSeries.indexLabelFormatter) {

                        this._indexLabels.push({
                            chartType: "scatter",
                            dataPoint: dataPoints[i],
                            dataSeries: dataSeries,
                            point: {
                                x: x, y: y
                            },
                            direction: 1,
                            bounds: {
                                x1: x - markerProps.size / 2, y1: y - markerProps.size / 2, x2: x + markerProps.size / 2, y2: y + markerProps.size / 2
                            },
                            color: color
                        });
                    }

                    prevDataPointX = x;
                    prevDataPointY = y;
                }
            }
        }

        ctx.restore();

        if (isCanvasSupported)
            this._eventManager.ghostCtx.restore();

        //source and dest would be same when animation is not enabled
        var animationInfo = {
            source: ctx, dest: this.plotArea.ctx, animationCallback: AnimationHelper.fadeInAnimation, easingFunction: AnimationHelper.easing.easeInQuad, animationBase: 0
        };
        return animationInfo;
    }

    Chart.prototype.renderCandlestick = function (plotUnit) {
        var ctx = plotUnit.targetCanvasCtx || this.plotArea.ctx;
        var ghostCtx = this._eventManager.ghostCtx;

        var totalDataSeries = plotUnit.dataSeriesIndexes.length;
        if (totalDataSeries <= 0)
            return;

        var color = null;

        var plotArea = this.plotArea;

        var i = 0, x, y1, y2, y3, y4;
        var dataPointX; //Used so that when dataPoint.x is a DateTime value, it doesn't get converted to number from dataTime everytime it is used.

        //var yZeroToPixel = plotUnit.axisY.convertValueToPixel(0);

        var minBarWidth = this.dataPointMinWidth ? this.dataPointMinWidth : this.dataPointWidth ? this.dataPointWidth : 1;
        var maxBarWidth = this.dataPointMaxWidth ? this.dataPointMaxWidth : this.dataPointWidth ? this.dataPointWidth : (this.width * .015);

        var xMinDiff = plotUnit.axisX.dataInfo.minDiff;

        if (!isFinite(xMinDiff))
            xMinDiff = Math.abs(plotUnit.axisX.range) * .3;

        var barWidth = this.dataPointWidth ? this.dataPointWidth : (plotArea.width * (plotUnit.axisX.logarithmic ? Math.log(xMinDiff) / Math.log(plotUnit.axisX.range) : Math.abs(xMinDiff) / Math.abs(plotUnit.axisX.range)) * .7) << 0;

        if (this.dataPointMaxWidth && minBarWidth > maxBarWidth)
            minBarWidth = Math.min(this.dataPointWidth ? this.dataPointWidth : Infinity, maxBarWidth);

        if (!this.dataPointMaxWidth && this.dataPointMinWidth && maxBarWidth < minBarWidth)
            maxBarWidth = Math.max(this.dataPointWidth ? this.dataPointWidth : -Infinity, minBarWidth);

        if (barWidth < minBarWidth)
            barWidth = minBarWidth;

        if (barWidth > maxBarWidth)
            barWidth = maxBarWidth;

        ctx.save();
        if (isCanvasSupported)
            ghostCtx.save();

        ctx.beginPath();
        ctx.rect(plotArea.x1, plotArea.y1, plotArea.width, plotArea.height);
        ctx.clip();

        if (isCanvasSupported) {
            ghostCtx.beginPath();
            ghostCtx.rect(plotArea.x1, plotArea.y1, plotArea.width, plotArea.height);
            ghostCtx.clip();
        }
        //ctx.beginPath();

        for (var j = 0; j < plotUnit.dataSeriesIndexes.length; j++) {

            var dataSeriesIndex = plotUnit.dataSeriesIndexes[j];

            var dataSeries = this.data[dataSeriesIndex];
            var dataPoints = dataSeries.dataPoints;
            var isFirstDataPointInPlotArea = true;


            // Reducing pixelPerUnit by 1 just to overcome any problems due to rounding off of pixels.
            //dataSeries.maxWidthInX = barWidth / (plotUnit.axisX.conversionParameters.pixelPerUnit > 1 ? plotUnit.axisX.conversionParameters.pixelPerUnit - 1 : plotUnit.axisX.conversionParameters.pixelPerUnit);

            //var offsetX = barWidth * plotUnit.index << 0;


            if (dataPoints.length > 0) {
                var bevelEnabled = (barWidth > 5) && dataSeries.bevelEnabled ? true : false;

                for (i = 0; i < dataPoints.length; i++) {

                    dataPoints[i].getTime ? dataPointX = dataPoints[i].x.getTime() : dataPointX = dataPoints[i].x;

                    if (dataPointX < plotUnit.axisX.dataInfo.viewPortMin || dataPointX > plotUnit.axisX.dataInfo.viewPortMax) {
                        continue;
                    }

                    if (dataPoints[i].y === null || !dataPoints[i].y.length
                        || typeof (dataPoints[i].y[0]) !== "number" || typeof (dataPoints[i].y[1]) !== "number"
                        || typeof (dataPoints[i].y[2]) !== "number" || typeof (dataPoints[i].y[3]) !== "number")
                        continue;

                    x = plotUnit.axisX.convertValueToPixel(dataPointX);
                    y1 = plotUnit.axisY.convertValueToPixel(dataPoints[i].y[0]);
                    y2 = plotUnit.axisY.convertValueToPixel(dataPoints[i].y[1]);

                    y3 = plotUnit.axisY.convertValueToPixel(dataPoints[i].y[2]);
                    y4 = plotUnit.axisY.convertValueToPixel(dataPoints[i].y[3]);

                    var x1 = (x - barWidth / 2) << 0;
                    var x2 = (x1 + barWidth) << 0;


                    color = dataPoints[i].color ? dataPoints[i].color : dataSeries._colorSet[0];


                    //var borderThickness = Math.max(2, ((barWidth * .1) / 2 << 0) * 2); // Set only even numbers for border
                    var borderThickness = Math.round(Math.max(1, (barWidth * .15)));
                    //borderThickness = (borderThickness / 2 << 0) * 2;
                    //borderThickness = 2;
                    var offset = borderThickness % 2 === 0 ? 0 : .5;


                    var id = dataSeries.dataPointIds[i];
                    this._eventManager.objectMap[id] = {
                        id: id, objectType: "dataPoint", dataSeriesIndex: dataSeriesIndex, dataPointIndex: i, x1: x1, y1: y1, x2: x2, y2: y2,
                        x3: x, y3: y3, x4: x, y4: y4, borderThickness: borderThickness, color: color
                    };

                    ctx.strokeStyle = color;
                    ctx.beginPath();
                    ctx.lineWidth = borderThickness;
                    ghostCtx.lineWidth = Math.max(borderThickness, 4);

                    if (dataSeries.type === "candlestick") {

                        ctx.moveTo(x - offset, y2);
                        ctx.lineTo(x - offset, Math.min(y1, y4));
                        ctx.stroke();
                        ctx.moveTo(x - offset, Math.max(y1, y4));
                        ctx.lineTo(x - offset, y3);
                        ctx.stroke();

                        drawRect(ctx, x1, Math.min(y1, y4), x2, Math.max(y1, y4), dataPoints[i].y[0] <= dataPoints[i].y[3] ? dataSeries.risingColor : color, borderThickness, color, bevelEnabled, bevelEnabled, false, false, dataSeries.fillOpacity);


                        if (isCanvasSupported) {
                            color = intToHexColorString(id);
                            ghostCtx.strokeStyle = color;

                            ghostCtx.moveTo(x - offset, y2);
                            ghostCtx.lineTo(x - offset, Math.min(y1, y4));
                            ghostCtx.stroke();
                            ghostCtx.moveTo(x - offset, Math.max(y1, y4));
                            ghostCtx.lineTo(x - offset, y3);
                            ghostCtx.stroke();
                            drawRect(ghostCtx, x1, Math.min(y1, y4), x2, Math.max(y1, y4), color, 0, null, false, false, false, false);
                        }
                    }
                    else if (dataSeries.type === "ohlc") {

                        ctx.moveTo(x - offset, y2);
                        ctx.lineTo(x - offset, y3);
                        ctx.stroke();

                        ctx.beginPath();
                        ctx.moveTo(x, y1);
                        ctx.lineTo(x1, y1);
                        ctx.stroke();

                        ctx.beginPath();
                        ctx.moveTo(x, y4);
                        ctx.lineTo(x2, y4);
                        ctx.stroke();

                        if (isCanvasSupported) {

                            color = intToHexColorString(id);
                            ghostCtx.strokeStyle = color;

                            ghostCtx.moveTo(x - offset, y2);
                            ghostCtx.lineTo(x - offset, y3);
                            ghostCtx.stroke();

                            ghostCtx.beginPath();
                            ghostCtx.moveTo(x, y1);
                            ghostCtx.lineTo(x1, y1);
                            ghostCtx.stroke();

                            ghostCtx.beginPath();
                            ghostCtx.moveTo(x, y4);
                            ghostCtx.lineTo(x2, y4);
                            ghostCtx.stroke();
                        }
                    }

                    if (dataPoints[i].indexLabel || dataSeries.indexLabel || dataPoints[i].indexLabelFormatter || dataSeries.indexLabelFormatter) {

                        this._indexLabels.push({
                            chartType: dataSeries.type,
                            dataPoint: dataPoints[i],
                            dataSeries: dataSeries,
                            point: {
                                x: x1 + (x2 - x1) / 2, y: plotUnit.axisY.reversed ? y3 : y2
                            },
                            direction: 1,
                            bounds: {
                                x1: x1, y1: Math.min(y2, y3), x2: x2, y2: Math.max(y2, y3)
                            },
                            color: color
                        });

                    }
                }
            }
        }

        ctx.restore();

        if (isCanvasSupported)
            ghostCtx.restore();

        //source and dest would be same when animation is not enabled
        var animationInfo = {
            source: ctx, dest: this.plotArea.ctx, animationCallback: AnimationHelper.fadeInAnimation, easingFunction: AnimationHelper.easing.easeInQuad, animationBase: 0
        };
        return animationInfo;
    }

    Chart.prototype.renderRangeColumn = function (plotUnit) {
        var ctx = plotUnit.targetCanvasCtx || this.plotArea.ctx;
        var totalDataSeries = plotUnit.dataSeriesIndexes.length;

        if (totalDataSeries <= 0)
            return;

        var color = null;

        var plotArea = this.plotArea;

        var i = 0, x, y1, y2;
        var dataPointX; //Used so that when dataPoint.x is a DateTime value, it doesn't get converted to number from dataTime everytime it is used.

        //var yZeroToPixel = plotUnit.axisY.convertValueToPixel(0);

        var minBarWidth = this.dataPointMinWidth ? this.dataPointMinWidth : this.dataPointWidth ? this.dataPointWidth : 1;
        var maxBarWidth = this.dataPointMaxWidth ? this.dataPointMaxWidth : this.dataPointWidth ? this.dataPointWidth : (this.width * .03);
        //var maxBarWidth = (this.width * .015);
        var xMinDiff = plotUnit.axisX.dataInfo.minDiff;

        if (!isFinite(xMinDiff))
            xMinDiff = Math.abs(plotUnit.axisX.range) * .3;

        var barWidth = this.dataPointWidth ? this.dataPointWidth : (plotArea.width * (plotUnit.axisX.logarithmic ? Math.log(xMinDiff) / Math.log(plotUnit.axisX.range) : Math.abs(xMinDiff) / Math.abs(plotUnit.axisX.range)) / plotUnit.plotType.totalDataSeries * .9) << 0;

        if (this.dataPointMaxWidth && minBarWidth > maxBarWidth)
            minBarWidth = Math.min(this.dataPointWidth ? this.dataPointWidth : Infinity, maxBarWidth);

        if (!this.dataPointMaxWidth && this.dataPointMinWidth && maxBarWidth < minBarWidth)
            maxBarWidth = Math.max(this.dataPointWidth ? this.dataPointWidth : -Infinity, minBarWidth);

        if (barWidth < minBarWidth)
            barWidth = minBarWidth;

        if (barWidth > maxBarWidth)
            barWidth = maxBarWidth;

        ctx.save();
        if (isCanvasSupported)
            this._eventManager.ghostCtx.save();

        ctx.beginPath();
        ctx.rect(plotArea.x1, plotArea.y1, plotArea.width, plotArea.height);
        ctx.clip();

        if (isCanvasSupported) {
            this._eventManager.ghostCtx.beginPath();
            this._eventManager.ghostCtx.rect(plotArea.x1, plotArea.y1, plotArea.width, plotArea.height);
            this._eventManager.ghostCtx.clip();
        }
        //ctx.beginPath();

        for (var j = 0; j < plotUnit.dataSeriesIndexes.length; j++) {

            var dataSeriesIndex = plotUnit.dataSeriesIndexes[j];

            var dataSeries = this.data[dataSeriesIndex];
            var dataPoints = dataSeries.dataPoints;
            var isFirstDataPointInPlotArea = true;


            // Reducing pixelPerUnit by 1 just to overcome any problems due to rounding off of pixels.
            //dataSeries.maxWidthInX = barWidth / (plotUnit.axisX.conversionParameters.pixelPerUnit > 1 ? plotUnit.axisX.conversionParameters.pixelPerUnit - 1 : plotUnit.axisX.conversionParameters.pixelPerUnit);

            //var offsetX = barWidth * plotUnit.index << 0;


            if (dataPoints.length > 0) {
                var bevelEnabled = (barWidth > 5) && dataSeries.bevelEnabled ? true : false;

                for (i = 0; i < dataPoints.length; i++) {

                    dataPoints[i].getTime ? dataPointX = dataPoints[i].x.getTime() : dataPointX = dataPoints[i].x;

                    if (dataPointX < plotUnit.axisX.dataInfo.viewPortMin || dataPointX > plotUnit.axisX.dataInfo.viewPortMax) {
                        continue;
                    }

                    if (dataPoints[i].y === null || !dataPoints[i].y.length
                        || typeof (dataPoints[i].y[0]) !== "number" || typeof (dataPoints[i].y[1]) !== "number")
                        continue;

                    x = plotUnit.axisX.convertValueToPixel(dataPointX);
                    y1 = plotUnit.axisY.convertValueToPixel(dataPoints[i].y[0]);
                    y2 = plotUnit.axisY.convertValueToPixel(dataPoints[i].y[1]);

                    //var x1 = x - barWidth / 2 << 0;
                    var x1 = plotUnit.axisX.reversed ? x + (plotUnit.plotType.totalDataSeries * barWidth / 2) - ((plotUnit.previousDataSeriesCount + j) * barWidth) << 0 : x - (plotUnit.plotType.totalDataSeries * barWidth / 2) + ((plotUnit.previousDataSeriesCount + j) * barWidth) << 0;
                    var x2 = plotUnit.axisX.reversed ? x1 - barWidth << 0 : x1 + barWidth << 0;
                    var y1;
                    var y2;


                    color = dataPoints[i].color ? dataPoints[i].color : dataSeries._colorSet[i % dataSeries._colorSet.length];

                    if (y1 > y2) {
                        var temp = y1;
                        y1 = y2;
                        y2 = temp;
                    }

                    var id = dataSeries.dataPointIds[i];
                    this._eventManager.objectMap[id] = {
                        id: id, objectType: "dataPoint", dataSeriesIndex: dataSeriesIndex, dataPointIndex: i, x1: x1, y1: y1, x2: x2, y2: y2
                    };

                    //var borderThickness = Math.max(1, (barWidth * .1 << 0));
                    var borderThickness = 0;

                    drawRect(ctx, x1, y1, x2, y2, color, borderThickness, color, bevelEnabled, bevelEnabled, false, false, dataSeries.fillOpacity);
                    color = intToHexColorString(id);

                    if (isCanvasSupported)
                        drawRect(this._eventManager.ghostCtx, x1, y1, x2, y2, color, 0, null, false, false, false, false);


                    if (dataPoints[i].indexLabel || dataSeries.indexLabel || dataPoints[i].indexLabelFormatter || dataSeries.indexLabelFormatter) {

                        this._indexLabels.push({
                            chartType: "rangeColumn",
                            dataPoint: dataPoints[i],
                            dataSeries: dataSeries,
                            indexKeyword: 0,
                            point: {
                                x: x1 + (x2 - x1) / 2, y: dataPoints[i].y[1] >= dataPoints[i].y[0] ? y2 : y1
                            },
                            direction: dataPoints[i].y[1] >= dataPoints[i].y[0] ? -1 : 1,
                            bounds: {
                                x1: x1, y1: Math.min(y1, y2), x2: x2, y2: Math.max(y1, y2)
                            },
                            color: color
                        });

                        this._indexLabels.push({
                            chartType: "rangeColumn",
                            dataPoint: dataPoints[i],
                            dataSeries: dataSeries,
                            indexKeyword: 1,
                            point: {
                                x: x1 + (x2 - x1) / 2, y: dataPoints[i].y[1] >= dataPoints[i].y[0] ? y1 : y2
                            },
                            direction: dataPoints[i].y[1] >= dataPoints[i].y[0] ? 1 : -1,
                            bounds: {
                                x1: x1, y1: Math.min(y1, y2), x2: x2, y2: Math.max(y1, y2)
                            },
                            color: color
                        });

                    }
                }
            }
        }

        ctx.restore();

        if (isCanvasSupported)
            this._eventManager.ghostCtx.restore();


        //source and dest would be same when animation is not enabled
        var animationInfo = {
            source: ctx, dest: this.plotArea.ctx, animationCallback: AnimationHelper.fadeInAnimation, easingFunction: AnimationHelper.easing.easeInQuad, animationBase: 0
        };
        return animationInfo;
    }

    Chart.prototype.renderRangeBar = function (plotUnit) {
        var ctx = plotUnit.targetCanvasCtx || this.plotArea.ctx;
        var totalDataSeries = plotUnit.dataSeriesIndexes.length;

        if (totalDataSeries <= 0)
            return;

        var color = null;

        var plotArea = this.plotArea;

        var i = 0, x1, x2, y;
        var dataPointX; //Used so that when dataPoint.x is a DateTime value, it doesn't get converted to number from dataTime everytime it is used.

        //In case of Bar Chart, yZeroToPixel is x co-ordinate!
        //var yZeroToPixel = plotUnit.axisY.convertValueToPixel(0);

        var minBarWidth = this.dataPointMinWidth ? this.dataPointMinWidth : this.dataPointWidth ? this.dataPointWidth : 1;
        var maxBarWidth = this.dataPointMaxWidth ? this.dataPointMaxWidth : this.dataPointWidth ? this.dataPointWidth : Math.min((this.height * .15), this.plotArea.height / plotUnit.plotType.totalDataSeries * .9) << 0;
        var xMinDiff = plotUnit.axisX.dataInfo.minDiff;

        if (!isFinite(xMinDiff))
            xMinDiff = Math.abs(plotUnit.axisX.range) * .3;

        var barWidth = this.dataPointWidth ? this.dataPointWidth : (plotArea.height * (plotUnit.axisX.logarithmic ? Math.log(xMinDiff) / Math.log(plotUnit.axisX.range) : Math.abs(xMinDiff) / Math.abs(plotUnit.axisX.range)) / plotUnit.plotType.totalDataSeries * .9) << 0;

        if (this.dataPointMaxWidth && minBarWidth > maxBarWidth)
            minBarWidth = Math.min(this.dataPointWidth ? this.dataPointWidth : Infinity, maxBarWidth);

        if (!this.dataPointMaxWidth && this.dataPointMinWidth && maxBarWidth < minBarWidth)
            maxBarWidth = Math.max(this.dataPointWidth ? this.dataPointWidth : -Infinity, minBarWidth);

        if (barWidth < minBarWidth)
            barWidth = minBarWidth;

        if (barWidth > maxBarWidth)
            barWidth = maxBarWidth;

        ctx.save();

        if (isCanvasSupported)
            this._eventManager.ghostCtx.save();

        ctx.beginPath();
        ctx.rect(plotArea.x1, plotArea.y1, plotArea.width, plotArea.height);
        ctx.clip();

        if (isCanvasSupported) {
            this._eventManager.ghostCtx.beginPath();
            this._eventManager.ghostCtx.rect(plotArea.x1, plotArea.y1, plotArea.width, plotArea.height);
            this._eventManager.ghostCtx.clip();
        }

        for (var j = 0; j < plotUnit.dataSeriesIndexes.length; j++) {

            var dataSeriesIndex = plotUnit.dataSeriesIndexes[j];

            var dataSeries = this.data[dataSeriesIndex];
            var dataPoints = dataSeries.dataPoints;
            var isFirstDataPointInPlotArea = true;


            //dataSeries.maxWidthInX = barWidth / (plotUnit.axisX.conversionParameters.pixelPerUnit > 1 ? plotUnit.axisX.conversionParameters.pixelPerUnit - 1 : plotUnit.axisX.conversionParameters.pixelPerUnit);


            if (dataPoints.length > 0) {
                var bevelEnabled = (barWidth > 5) && dataSeries.bevelEnabled ? true : false;

                ctx.strokeStyle = "#4572A7 ";

                for (i = 0; i < dataPoints.length; i++) {

                    dataPoints[i].getTime ? dataPointX = dataPoints[i].x.getTime() : dataPointX = dataPoints[i].x;

                    if (dataPointX < plotUnit.axisX.dataInfo.viewPortMin || dataPointX > plotUnit.axisX.dataInfo.viewPortMax) {
                        continue;
                    }

                    if (dataPoints[i].y === null || !dataPoints[i].y.length
                        || typeof (dataPoints[i].y[0]) !== "number" || typeof (dataPoints[i].y[1]) !== "number")
                        continue;

                    //x and y are pixel co-ordinates of point and should not be confused with X and Y values
                    x1 = plotUnit.axisY.convertValueToPixel(dataPoints[i].y[0]);
                    x2 = plotUnit.axisY.convertValueToPixel(dataPoints[i].y[1]);

                    y = plotUnit.axisX.convertValueToPixel(dataPointX);


                    var y1 = plotUnit.axisX.reversed ? (y + (plotUnit.plotType.totalDataSeries * barWidth / 2) - ((plotUnit.previousDataSeriesCount + j) * barWidth)) << 0 : (y - (plotUnit.plotType.totalDataSeries * barWidth / 2) + ((plotUnit.previousDataSeriesCount + j) * barWidth)) << 0;
                    var y2 = plotUnit.axisX.reversed ? y1 - barWidth << 0 : y1 + barWidth << 0;

                    if (x1 > x2) {
                        var temp = x1;
                        x1 = x2;
                        x2 = temp;
                    }

                    //drawRect(ctx, x1, y1, plotArea.x2, y2, "#EEEEEE", 0, null, false, false, false, false);
                    //drawRect(ctx, x1, y1, plotArea.x2, y2, "#BDCED3", 0, null, false, false, false, false);

                    color = dataPoints[i].color ? dataPoints[i].color : dataSeries._colorSet[i % dataSeries._colorSet.length];
                    //color = "#1B4962";
                    drawRect(ctx, x1, y1, x2, y2, color, 0, null, bevelEnabled, false, false, false, dataSeries.fillOpacity);


                    var id = dataSeries.dataPointIds[i];
                    this._eventManager.objectMap[id] = {
                        id: id, objectType: "dataPoint", dataSeriesIndex: dataSeriesIndex, dataPointIndex: i, x1: x1, y1: y1, x2: x2, y2: y2
                    };
                    color = intToHexColorString(id);

                    if (isCanvasSupported)
                        drawRect(this._eventManager.ghostCtx, x1, y1, x2, y2, color, 0, null, false, false, false, false);


                    if (dataPoints[i].indexLabel || dataSeries.indexLabel || dataPoints[i].indexLabelFormatter || dataSeries.indexLabelFormatter) {

                        this._indexLabels.push({
                            chartType: "rangeBar",
                            dataPoint: dataPoints[i],
                            dataSeries: dataSeries,
                            indexKeyword: 0,
                            point: {
                                x: dataPoints[i].y[1] >= dataPoints[i].y[0] ? x1 : x2, y: y1 + (y2 - y1) / 2
                            },
                            direction: dataPoints[i].y[1] >= dataPoints[i].y[0] ? -1 : 1,
                            bounds: {
                                x1: Math.min(x1, x2), y1: y1, x2: Math.max(x1, x2), y2: y2
                            },
                            color: color
                        });

                        this._indexLabels.push({
                            chartType: "rangeBar",
                            dataPoint: dataPoints[i],
                            dataSeries: dataSeries,
                            indexKeyword: 1,
                            point: {
                                x: dataPoints[i].y[1] >= dataPoints[i].y[0] ? x2 : x1, y: y1 + (y2 - y1) / 2
                            },
                            direction: dataPoints[i].y[1] >= dataPoints[i].y[0] ? 1 : -1,
                            bounds: {
                                x1: Math.min(x1, x2), y1: y1, x2: Math.max(x1, x2), y2: y2
                            },
                            color: color
                        });
                    }
                }
            }
        }

        ctx.restore();

        if (isCanvasSupported)
            this._eventManager.ghostCtx.restore();

        //source and dest would be same when animation is not enabled
        var animationInfo = {
            source: ctx, dest: this.plotArea.ctx, animationCallback: AnimationHelper.fadeInAnimation, easingFunction: AnimationHelper.easing.easeInQuad, animationBase: 0
        };
        return animationInfo;
    }

    Chart.prototype.renderRangeArea = function (plotUnit) {
        var ctx = plotUnit.targetCanvasCtx || this.plotArea.ctx;
        var totalDataSeries = plotUnit.dataSeriesIndexes.length;

        if (totalDataSeries <= 0)
            return;

        var ghostCtx = this._eventManager.ghostCtx;

        var axisXProps = plotUnit.axisX.lineCoordinates;
        var axisYProps = plotUnit.axisY.lineCoordinates;
        var markers = [];
        var markerPropsColor = null;

        var plotArea = this.plotArea;
        ctx.save();

        if (isCanvasSupported)
            ghostCtx.save();

        ctx.beginPath();
        ctx.rect(plotArea.x1, plotArea.y1, plotArea.width, plotArea.height);
        ctx.clip();
        //var defaultLineJoinType = ctx.lineJoin;
        //ctx.lineJoin = "round";

        if (isCanvasSupported) {
            ghostCtx.beginPath();
            ghostCtx.rect(plotArea.x1, plotArea.y1, plotArea.width, plotArea.height);
            ghostCtx.clip();
        }

        for (var j = 0; j < plotUnit.dataSeriesIndexes.length; j++) {

            var closingPath = [];

            var dataSeriesIndex = plotUnit.dataSeriesIndexes[j];

            var dataSeries = this.data[dataSeriesIndex];

            var dataPoints = dataSeries.dataPoints;

            var seriesId = dataSeries.id;
            this._eventManager.objectMap[seriesId] = {
                objectType: "dataSeries", dataSeriesIndex: dataSeriesIndex
            };

            var hexColor = intToHexColorString(seriesId);
            ghostCtx.fillStyle = hexColor;
            //ghostCtx.lineWidth = dataSeries.lineThickness;
            //ghostCtx.lineWidth = 20;

            markers = [];

            var isFirstDataPointInPlotArea = true;
            var i = 0, x, y1, y2;
            var dataPointX; //Used so that when dataPoint.x is a DateTime value, it doesn't get converted to number back and forth.

            //var yZeroToPixel = plotUnit.axisY.convertValueToPixel(0);
            //var baseY;

            var startPoint = null;

            if (dataPoints.length > 0) {
                //ctx.strokeStyle = "#4572A7 ";
                var color = dataSeries._colorSet[i % dataSeries._colorSet.length];
                //ctx.strokeStyle = "red";
                var lineColor = dataSeries.lineColor = dataSeries.options.lineColor || color;
                var currentStrokeStyle = lineColor;
                ctx.fillStyle = color;
                ctx.strokeStyle = lineColor;
                ctx.lineWidth = dataSeries.lineThickness;
                var currentLineDashType = "solid";

                if (ctx.setLineDash) {
                    var nullDataLineDashType = getLineDashArray(dataSeries.nullDataLineDashType, dataSeries.lineThickness);
                    currentLineDashType = dataSeries.lineDashType;
                    var lineDashType = getLineDashArray(currentLineDashType, dataSeries.lineThickness);
                    ctx.setLineDash(lineDashType);
                }

                var prevDataNull = true;
                for (; i < dataPoints.length; i++) {

                    dataPointX = dataPoints[i].x.getTime ? dataPoints[i].x.getTime() : dataPoints[i].x;

                    if (dataPointX < plotUnit.axisX.dataInfo.viewPortMin || dataPointX > plotUnit.axisX.dataInfo.viewPortMax && !(dataSeries.connectNullData && prevDataNull)) {
                        continue;
                    }

                    if (dataPoints[i].y === null || !dataPoints[i].y.length
                        || typeof (dataPoints[i].y[0]) !== "number" || typeof (dataPoints[i].y[1]) !== "number") {

                        if (!(prevDataNull || isFirstDataPointInPlotArea))
                            closeArea();

                        prevDataNull = true;
                        continue;
                    }

                    x = plotUnit.axisX.convertValueToPixel(dataPointX);

                    y1 = plotUnit.axisY.convertValueToPixel(dataPoints[i].y[0]);
                    y2 = plotUnit.axisY.convertValueToPixel(dataPoints[i].y[1]);

                    if (isFirstDataPointInPlotArea || prevDataNull) {

                        if (dataSeries.connectNullData && !isFirstDataPointInPlotArea) {
                            if (ctx.setLineDash && (dataSeries.options.nullDataLineDashType || (currentLineDashType === dataSeries.lineDashType && dataSeries.lineDashType !== dataSeries.nullDataLineDashType))) {
                                closingPath[closingPath.length - 1].newLineDashArray = lineDashType;
                                currentLineDashType = dataSeries.nullDataLineDashType;
                                ctx.setLineDash(nullDataLineDashType);
                            }

                            ctx.lineTo(x, y1);
                            if (isCanvasSupported)
                                ghostCtx.lineTo(x, y1);
                            closingPath.push({ x: x, y: y2 });

                        } else {

                            ctx.beginPath();
                            ctx.moveTo(x, y1);
                            startPoint = {
                                x: x, y: y1
                            };
                            closingPath = [];
                            closingPath.push({ x: x, y: y2 });

                            if (isCanvasSupported) {
                                ghostCtx.beginPath();
                                ghostCtx.moveTo(x, y1);
                            }
                        }

                        isFirstDataPointInPlotArea = false;
                        prevDataNull = false;

                    }
                    else {

                        ctx.lineTo(x, y1);
                        closingPath.push({ x: x, y: y2 });

                        if (isCanvasSupported)
                            ghostCtx.lineTo(x, y1);

                        if (i % 250 == 0) {
                            closeArea();
                        }
                    }


                    var id = dataSeries.dataPointIds[i];
                    this._eventManager.objectMap[id] = {
                        id: id, objectType: "dataPoint", dataSeriesIndex: dataSeriesIndex, dataPointIndex: i, x1: x, y1: y1, y2: y2
                    };

                    if (i < dataPoints.length - 1) {

                        if (currentStrokeStyle !== (dataPoints[i].lineColor || lineColor) || currentLineDashType !== (dataPoints[i].lineDashType || dataSeries.lineDashType)) { //Applieng new ctx on DataPoint

                            closeArea();

                            currentStrokeStyle = dataPoints[i].lineColor || lineColor;
                            closingPath[closingPath.length - 1].newStrokeStyle = currentStrokeStyle;
                            ctx.strokeStyle = currentStrokeStyle;

                            if (ctx.setLineDash)
                                if (dataPoints[i].lineDashType) {
                                    currentLineDashType = dataPoints[i].lineDashType;
                                    closingPath[closingPath.length - 1].newLineDashArray = getLineDashArray(currentLineDashType, dataSeries.lineThickness);
                                    ctx.setLineDash(closingPath[closingPath.length - 1].newLineDashArray);
                                }
                                else {
                                    currentLineDashType = dataSeries.lineDashType;
                                    closingPath[closingPath.length - 1].newLineDashArray = lineDashType;
                                    ctx.setLineDash(lineDashType);
                                }
                        }
                    }

                    //Render Marker
                    if (dataPoints[i].markerSize !== 0) {
                        if (dataPoints[i].markerSize > 0 || dataSeries.markerSize > 0) {
                            var markerProps = dataSeries.getMarkerProperties(i, x, y2, ctx);
                            markers.push(markerProps);

                            //if (!dataSeries.maxWidthInX || markerProps.size > dataSeries.maxWidthInX) {
                            //	dataSeries.maxWidthInX = markerProps.size / (plotUnit.axisX.conversionParameters.pixelPerUnit > 1 ? plotUnit.axisX.conversionParameters.pixelPerUnit - 1 : plotUnit.axisX.conversionParameters.pixelPerUnit);
                            //}

                            var markerColor = intToHexColorString(id);

                            if (isCanvasSupported) {
                                markers.push({
                                    x: x, y: y2, ctx: ghostCtx,
                                    type: markerProps.type,
                                    size: markerProps.size,
                                    color: markerColor,
                                    borderColor: markerColor,
                                    borderThickness: markerProps.borderThickness
                                });
                            }

                            markerProps = dataSeries.getMarkerProperties(i, x, y1, ctx);
                            markerPropsColor = markerProps.color;
                            markers.push(markerProps);



                            var markerColor = intToHexColorString(id);

                            if (isCanvasSupported) {
                                markers.push({
                                    x: x, y: y1, ctx: ghostCtx,
                                    type: markerProps.type,
                                    size: markerProps.size,
                                    color: markerColor,
                                    borderColor: markerColor,
                                    borderThickness: markerProps.borderThickness
                                });
                            }
                        }
                    }

                    if (dataPoints[i].indexLabel || dataSeries.indexLabel || dataPoints[i].indexLabelFormatter || dataSeries.indexLabelFormatter) {

                        this._indexLabels.push({
                            chartType: "rangeArea",
                            dataPoint: dataPoints[i],
                            dataSeries: dataSeries,
                            indexKeyword: 0,
                            point: {
                                x: x, y: y1
                            },
                            direction: dataPoints[i].y[0] > dataPoints[i].y[1] === plotUnit.axisY.reversed ? -1 : 1,
                            color: color
                        });

                        this._indexLabels.push({
                            chartType: "rangeArea",
                            dataPoint: dataPoints[i],
                            dataSeries: dataSeries,
                            indexKeyword: 1,
                            point: {
                                x: x, y: y2
                            },
                            direction: dataPoints[i].y[0] > dataPoints[i].y[1] === plotUnit.axisY.reversed ? 1 : -1,
                            color: color
                        });

                    }
                }

                closeArea();

                //startPoint = { x: x, y: y };
                RenderHelper.drawMarkers(markers);
                //dataSeries.markerColor = markerPropsColor;
            }
        }

        ctx.restore();
        //ctx.lineJoin = defaultLineJoinType;

        if (isCanvasSupported)
            this._eventManager.ghostCtx.restore();

        function closeArea() {

            if (!startPoint)
                return;

            var point = null;

            if (dataSeries.lineThickness > 0)
                ctx.stroke();

            for (var i = closingPath.length - 1; i >= 0; i--) {
                point = closingPath[i];
                ctx.lineTo(point.x, point.y);
                ghostCtx.lineTo(point.x, point.y);
            }



            ctx.closePath();
            //ctx.lineTo(startPoint.x, startPoint.y);

            ctx.globalAlpha = dataSeries.fillOpacity;
            ctx.fill();
            ctx.globalAlpha = 1;

            ghostCtx.fill();

            //if (isCanvasSupported) {
            //	ghostCtx.lineTo(x, baseY);
            //	ghostCtx.lineTo(startPoint.x, baseY);
            //	ghostCtx.closePath();
            //	ghostCtx.fill();
            //}

            if (dataSeries.lineThickness > 0) {
                ctx.beginPath();
                ctx.moveTo(point.x, point.y);
                for (var i = 0; i < closingPath.length; i++) {
                    point = closingPath[i];
                    ctx.lineTo(point.x, point.y);
                }

                ctx.stroke();
            }


            ctx.beginPath();
            ctx.moveTo(x, y1);
            ghostCtx.beginPath();
            ghostCtx.moveTo(x, y1);

            startPoint = {
                x: x, y: y1
            };
            closingPath = [];
            closingPath.push({ x: x, y: y2 });
        }

        //ctx.beginPath();
        //source and dest would be same when animation is not enabled
        var animationInfo = {
            source: ctx, dest: this.plotArea.ctx, animationCallback: AnimationHelper.xClipAnimation, easingFunction: AnimationHelper.easing.linear, animationBase: 0
        };
        return animationInfo;
    }


    Chart.prototype.renderRangeSplineArea = function (plotUnit) {
        var ctx = plotUnit.targetCanvasCtx || this.plotArea.ctx;
        var totalDataSeries = plotUnit.dataSeriesIndexes.length;

        if (totalDataSeries <= 0)
            return;

        var ghostCtx = this._eventManager.ghostCtx;

        var axisXProps = plotUnit.axisX.lineCoordinates;
        var axisYProps = plotUnit.axisY.lineCoordinates;
        var markers = [];
        var markerPropsColor = null;

        var plotArea = this.plotArea;
        ctx.save();

        if (isCanvasSupported)
            ghostCtx.save();

        ctx.beginPath();
        ctx.rect(plotArea.x1, plotArea.y1, plotArea.width, plotArea.height);
        ctx.clip();

        if (isCanvasSupported) {
            ghostCtx.beginPath();
            ghostCtx.rect(plotArea.x1, plotArea.y1, plotArea.width, plotArea.height);
            ghostCtx.clip();
        }

        for (var j = 0; j < plotUnit.dataSeriesIndexes.length; j++) {

            var dataSeriesIndex = plotUnit.dataSeriesIndexes[j];

            var dataSeries = this.data[dataSeriesIndex];

            var dataPoints = dataSeries.dataPoints;

            var seriesId = dataSeries.id;
            this._eventManager.objectMap[seriesId] = {
                objectType: "dataSeries", dataSeriesIndex: dataSeriesIndex
            };

            var hexColor = intToHexColorString(seriesId);
            ghostCtx.fillStyle = hexColor;
            //ghostCtx.lineWidth = dataSeries.lineThickness;
            //ghostCtx.lineWidth = 20;

            markers = [];

            var isFirstDataPointInPlotArea = true;
            var i = 0, x, y1, y2;
            var dataPointX; //Used so that when dataPoint.x is a DateTime value, it doesn't get converted to number back and forth.

            //var yZeroToPixel = plotUnit.axisY.convertValueToPixel(0);
            //var baseY;

            var startPoint = null;

            var pixelsY1 = [];
            var pixelsY2 = [];

            if (dataPoints.length > 0) {
                //ctx.strokeStyle = "#4572A7 ";
                var color = dataSeries._colorSet[i % dataSeries._colorSet.length];
                //ctx.strokeStyle = "red";
                var lineColor = dataSeries.lineColor = dataSeries.options.lineColor || color;
                var currentStrokeStyle = lineColor;
                ctx.fillStyle = color;
                //ctx.strokeStyle = lineColor;
                ctx.lineWidth = dataSeries.lineThickness;
                var currentLineDashType = "solid";
                var lineDashType;

                if (ctx.setLineDash) {
                    var nullDataLineDashType = getLineDashArray(dataSeries.nullDataLineDashType, dataSeries.lineThickness);
                    currentLineDashType = dataSeries.lineDashType;
                    lineDashType = getLineDashArray(currentLineDashType, dataSeries.lineThickness);
                    //ctx.setLineDash(lineDashType);
                }

                var prevDataNull = false;

                for (; i < dataPoints.length; i++) {

                    dataPointX = dataPoints[i].x.getTime ? dataPoints[i].x.getTime() : dataPoints[i].x;

                    if (dataPointX < plotUnit.axisX.dataInfo.viewPortMin || dataPointX > plotUnit.axisX.dataInfo.viewPortMax && !(dataSeries.connectNullData && prevDataNull)) {
                        continue;
                    }

                    if (dataPoints[i].y === null || !dataPoints[i].y.length || typeof (dataPoints[i].y[0]) !== "number" || typeof (dataPoints[i].y[1]) !== "number") {
                        if (i > 0 && !prevDataNull) {
                            if (dataSeries.connectNullData) {
                                if (ctx.setLineDash && pixelsY1.length > 0 && (dataSeries.options.nullDataLineDashType || !dataPoints[i - 1].lineDashType)) {
                                    pixelsY1[pixelsY1.length - 1].newLineDashArray = nullDataLineDashType;
                                    currentLineDashType = dataSeries.nullDataLineDashType;
                                }
                            }
                            else {
                                renderBezierArea(lineDashType, lineColor);
                                pixelsY1 = [];
                                pixelsY2 = [];
                            }
                        }
                        prevDataNull = true;
                        continue;
                    }

                    x = plotUnit.axisX.convertValueToPixel(dataPointX);
                    y1 = plotUnit.axisY.convertValueToPixel(dataPoints[i].y[0]);
                    y2 = plotUnit.axisY.convertValueToPixel(dataPoints[i].y[1]);


                    var id = dataSeries.dataPointIds[i];
                    this._eventManager.objectMap[id] = {
                        id: id, objectType: "dataPoint", dataSeriesIndex: dataSeriesIndex, dataPointIndex: i, x1: x, y1: y1, y2: y2
                    };

                    pixelsY1[pixelsY1.length] = {
                        x: x, y: y1
                    };
                    pixelsY2[pixelsY2.length] = {
                        x: x, y: y2
                    };

                    if (i < dataPoints.length - 1 && (currentStrokeStyle !== (dataPoints[i].lineColor || lineColor) || currentLineDashType !== (dataPoints[i].lineDashType || dataSeries.lineDashType))) { //Applieng new ctx on DataPoint

                        currentStrokeStyle = dataPoints[i].lineColor || lineColor;
                        pixelsY1[pixelsY1.length - 1].newStrokeStyle = currentStrokeStyle;
                        if (ctx.setLineDash)
                            if (dataPoints[i].lineDashType) {
                                currentLineDashType = dataPoints[i].lineDashType;
                                pixelsY1[pixelsY1.length - 1].newLineDashArray = getLineDashArray(currentLineDashType, dataSeries.lineThickness);
                            }
                            else {
                                currentLineDashType = dataSeries.lineDashType;
                                pixelsY1[pixelsY1.length - 1].newLineDashArray = lineDashType;
                            }
                    }

                    //Render Marker
                    if (dataPoints[i].markerSize !== 0) {
                        if (dataPoints[i].markerSize > 0 || dataSeries.markerSize > 0) {
                            var markerProps = dataSeries.getMarkerProperties(i, x, y1, ctx);
                            markerPropsColor = markerProps.color;
                            markers.push(markerProps);

                            //if (!dataSeries.maxWidthInX || markerProps.size > dataSeries.maxWidthInX) {
                            //	dataSeries.maxWidthInX = markerProps.size / (plotUnit.axisX.conversionParameters.pixelPerUnit > 1 ? plotUnit.axisX.conversionParameters.pixelPerUnit - 1 : plotUnit.axisX.conversionParameters.pixelPerUnit);
                            //}

                            var markerColor = intToHexColorString(id);

                            if (isCanvasSupported) {
                                markers.push({
                                    x: x, y: y1, ctx: ghostCtx,
                                    type: markerProps.type,
                                    size: markerProps.size,
                                    color: markerColor,
                                    borderColor: markerColor,
                                    borderThickness: markerProps.borderThickness
                                });
                            }

                            var markerProps = dataSeries.getMarkerProperties(i, x, y2, ctx);
                            markers.push(markerProps);

                            //if (!dataSeries.maxWidthInX || markerProps.size > dataSeries.maxWidthInX) {
                            //	dataSeries.maxWidthInX = markerProps.size / (plotUnit.axisX.conversionParameters.pixelPerUnit > 1 ? plotUnit.axisX.conversionParameters.pixelPerUnit - 1 : plotUnit.axisX.conversionParameters.pixelPerUnit);
                            //}

                            var markerColor = intToHexColorString(id);

                            if (isCanvasSupported) {
                                markers.push({
                                    x: x, y: y2, ctx: ghostCtx,
                                    type: markerProps.type,
                                    size: markerProps.size,
                                    color: markerColor,
                                    borderColor: markerColor,
                                    borderThickness: markerProps.borderThickness
                                });
                            }
                        }
                    }


                    //Render Index Labels
                    if (dataPoints[i].indexLabel || dataSeries.indexLabel || dataPoints[i].indexLabelFormatter || dataSeries.indexLabelFormatter) {

                        this._indexLabels.push({
                            chartType: "rangeSplineArea",
                            dataPoint: dataPoints[i],
                            dataSeries: dataSeries,
                            indexKeyword: 0,
                            point: {
                                x: x, y: y1
                            },
                            direction: dataPoints[i].y[0] <= dataPoints[i].y[1] ? -1 : 1,
                            color: color
                        });

                        this._indexLabels.push({
                            chartType: "rangeSplineArea",
                            dataPoint: dataPoints[i],
                            dataSeries: dataSeries,
                            indexKeyword: 1,
                            point: {
                                x: x, y: y2
                            },
                            direction: dataPoints[i].y[0] <= dataPoints[i].y[1] ? 1 : -1,
                            color: color
                        });

                    }

                    isFirstDataPointInPlotArea = false;
                    prevDataNull = false;
                }

                renderBezierArea(lineDashType, lineColor);

                RenderHelper.drawMarkers(markers);
                //dataSeries.markerColor = markerPropsColor;
            }
        }

        ctx.restore();

        if (isCanvasSupported)
            this._eventManager.ghostCtx.restore();

        function renderBezierArea(lineDashType, lineColor) {

            var bp = getBezierPoints(pixelsY1, 2);

            if (bp.length > 0) {

                if (dataSeries.lineThickness > 0) {
                    ctx.strokeStyle = lineColor;
                    if (ctx.setLineDash)
                        ctx.setLineDash(lineDashType);
                    ctx.beginPath();
                    ctx.moveTo(bp[0].x, bp[0].y);
                    for (var i = 0; i < bp.length - 3; i += 3) {

                        if (bp[i].newStrokeStyle || bp[i].newLineDashArray) {
                            ctx.stroke();
                            ctx.beginPath();
                            ctx.moveTo(bp[i].x, bp[i].y);
                            if (bp[i].newStrokeStyle)
                                ctx.strokeStyle = bp[i].newStrokeStyle;
                            if (bp[i].newLineDashArray)
                                ctx.setLineDash(bp[i].newLineDashArray);
                        }

                        ctx.bezierCurveTo(bp[i + 1].x, bp[i + 1].y, bp[i + 2].x, bp[i + 2].y, bp[i + 3].x, bp[i + 3].y);

                    }
                    ctx.stroke();
                }

                ctx.beginPath();
                ctx.moveTo(bp[0].x, bp[0].y);

                if (isCanvasSupported) {
                    ghostCtx.beginPath();
                    ghostCtx.moveTo(bp[0].x, bp[0].y);
                }

                for (var i = 0; i < bp.length - 3; i += 3) {

                    ctx.bezierCurveTo(bp[i + 1].x, bp[i + 1].y, bp[i + 2].x, bp[i + 2].y, bp[i + 3].x, bp[i + 3].y);

                    if (isCanvasSupported)
                        ghostCtx.bezierCurveTo(bp[i + 1].x, bp[i + 1].y, bp[i + 2].x, bp[i + 2].y, bp[i + 3].x, bp[i + 3].y);
                }




                bp = getBezierPoints(pixelsY2, 2);

                ctx.lineTo(pixelsY2[pixelsY2.length - 1].x, pixelsY2[pixelsY2.length - 1].y);

                for (var i = bp.length - 1; i > 2; i -= 3) {

                    ctx.bezierCurveTo(bp[i - 1].x, bp[i - 1].y, bp[i - 2].x, bp[i - 2].y, bp[i - 3].x, bp[i - 3].y);

                    if (isCanvasSupported)
                        ghostCtx.bezierCurveTo(bp[i - 1].x, bp[i - 1].y, bp[i - 2].x, bp[i - 2].y, bp[i - 3].x, bp[i - 3].y);
                }

                ctx.closePath();

                ctx.globalAlpha = dataSeries.fillOpacity;
                ctx.fill();
                if (isCanvasSupported) {
                    ghostCtx.closePath();
                    ghostCtx.fill();
                }

                ctx.globalAlpha = 1;


                if (dataSeries.lineThickness > 0) {
                    ctx.strokeStyle = lineColor;
                    if (ctx.setLineDash)
                        ctx.setLineDash(lineDashType);
                    ctx.beginPath();
                    ctx.moveTo(bp[0].x, bp[0].y);
                    for (var i = 0, j = 0; i < bp.length - 3; i += 3, j++) {

                        if (pixelsY1[j].newStrokeStyle || pixelsY1[j].newLineDashArray) {
                            ctx.stroke();
                            ctx.beginPath();
                            ctx.moveTo(bp[i].x, bp[i].y);
                            if (pixelsY1[j].newStrokeStyle)
                                ctx.strokeStyle = pixelsY1[j].newStrokeStyle;
                            if (pixelsY1[j].newLineDashArray)
                                ctx.setLineDash(pixelsY1[j].newLineDashArray);
                        }

                        ctx.bezierCurveTo(bp[i + 1].x, bp[i + 1].y, bp[i + 2].x, bp[i + 2].y, bp[i + 3].x, bp[i + 3].y);

                    }
                    ctx.stroke();
                }

                ctx.beginPath();



            }
        }

        //source and dest would be same when animation is not enabled
        var animationInfo = {
            source: ctx, dest: this.plotArea.ctx, animationCallback: AnimationHelper.xClipAnimation, easingFunction: AnimationHelper.easing.linear, animationBase: 0
        };
        return animationInfo;
    }
    //#region pieChart

    var drawSegment = function (ctx, center, radius, color, type, theta1, theta2, fillOpacity, percentInnerRadius) {
        if (radius < 0)
            return;
        if (typeof (fillOpacity) === "undefined")
            fillOpacity = 1;

        //IE8- FIX: In IE8- segment doesn't get draw if theta2 is equal to theta1 + 2*PI.
        if (!isCanvasSupported) {
            var theta2Mod = Number((theta2 % (2 * Math.PI)).toFixed(8));
            var theta1Mod = Number((theta1 % (2 * Math.PI)).toFixed(8));
            if (theta1Mod === theta2Mod)
                theta2 -= .0001;
        }

        ctx.save();
        ctx.globalAlpha = fillOpacity;

        if (type === "pie") {
            ctx.beginPath();
            ctx.moveTo(center.x, center.y);
            ctx.arc(center.x, center.y, radius, theta1, theta2, false);
            ctx.fillStyle = color;
            ctx.strokeStyle = "white";
            ctx.lineWidth = 2;
            //    ctx.shadowOffsetX = 2;
            //    ctx.shadowOffsetY = 1;
            //     ctx.shadowBlur = 2;
            //    ctx.shadowColor = '#BFBFBF';
            ctx.closePath();
            //ctx.stroke();
            ctx.fill();
        }
        else if (type === "doughnut") {
            ctx.beginPath();
            ctx.arc(center.x, center.y, radius, theta1, theta2, false);
            if (percentInnerRadius >= 0)
                ctx.arc(center.x, center.y, percentInnerRadius * radius, theta2, theta1, true);
            ctx.closePath();
            ctx.fillStyle = color;
            ctx.strokeStyle = "white";
            ctx.lineWidth = 2;
            // shadow properties
            //     ctx.shadowOffsetX = 1;
            //    ctx.shadowOffsetY = 1;
            //     ctx.shadowBlur = 1;
            //    ctx.shadowColor = '#BFBFBF';  //grey shadow
            //ctx.stroke();
            ctx.fill();
        }

        ctx.globalAlpha = 1;

        ctx.restore();
    };

    function convertPercentToValue(input, referenceValue) {
        //input can be a number or string
        if (input === null || typeof (input) === "undefined")
            return referenceValue;

        var result = parseFloat(input.toString()) * (input.toString().indexOf("%") >= 0 ? referenceValue / 100 : 1);

        // limit to plot area
        if (!isNaN(result) && result <= referenceValue && result >= 0)
            return result;

        return referenceValue;
    }

    Chart.prototype.renderPie = function (plotUnit) {
        var _this = this;
        var totalDataSeries = plotUnit.dataSeriesIndexes.length;

        if (totalDataSeries <= 0)
            return;

        var dataSeriesIndex = plotUnit.dataSeriesIndexes[0];
        var dataSeries = this.data[dataSeriesIndex];
        var dataPoints = dataSeries.dataPoints;
        var indexLabelLineEdgeLength = 10;
        var explodeDuration = 500;

        var plotArea = this.plotArea;

        //var maxFrame = isCanvasSupported ? 300 : 4;
        //var totalRecursions = 0;
        var dataPointEOs = []; //dataPoint Extension Objects Behaves like a storage place for all additional data relating to dataPoints. Requred because actual dataPoints should not be modified.

        var minDistanceBetweenLabels = 2;
        var indexLabelRadius;
        var indexLabelRadiusToRadiusRatio = 1.3;
        var poleAnglularDistance = (20 / 180) * Math.PI; //Anglular Distance from 90 & 270 to be considered pole
        var precision = 6;

        var center = {
            x: (plotArea.x2 + plotArea.x1) / 2, y: (plotArea.y2 + plotArea.y1) / 2
        };

        var sum = 0;
        var isIndexLabelPresent = false;
        for (var j = 0; j < dataPoints.length; j++) {
            sum += Math.abs(dataPoints[j].y);

            if (!isIndexLabelPresent && typeof (dataPoints[j].indexLabel) !== "undefined" && dataPoints[j].indexLabel !== null && dataPoints[j].indexLabel.toString().length > 0)
                isIndexLabelPresent = true;

            if (!isIndexLabelPresent && typeof (dataPoints[j].label) !== "undefined" && dataPoints[j].label !== null && dataPoints[j].label.toString().length > 0)
                isIndexLabelPresent = true;
        }

        if (sum === 0)
            return;

        isIndexLabelPresent = isIndexLabelPresent || (typeof (dataSeries.indexLabel) !== "undefined" && dataSeries.indexLabel !== null && dataSeries.indexLabel.toString().length > 0);

        var outerRadius = dataSeries.indexLabelPlacement !== "inside" && isIndexLabelPresent ? (Math.min(plotArea.width, plotArea.height) * 0.75) / 2 : (Math.min(plotArea.width, plotArea.height) * .92) / 2;

        if (dataSeries.radius)
            outerRadius = convertPercentToValue(dataSeries.radius, outerRadius);


        var innerRadius = (typeof dataSeries.innerRadius !== 'undefined' && dataSeries.innerRadius !== null) ? convertPercentToValue(dataSeries.innerRadius, outerRadius) : 0.7 * outerRadius;

        dataSeries.radius = outerRadius;

        if (dataSeries.type === "doughnut")
            dataSeries.innerRadius = innerRadius;

        var percentInnerRadius = Math.min(innerRadius / outerRadius, (outerRadius - 1) / outerRadius);

        function initLabels() {

            if (!dataSeries || !dataPoints)
                return;


            var noDPNearSouthPole = 0;
            var noDPNearNorthPole = 0;
            var firstDPCloseToSouth = 0;
            var firstDPCloseToNorth = 0;

            for (var j = 0; j < dataPoints.length; j++) {

                var dataPoint = dataPoints[j];
                var id = dataSeries.dataPointIds[j];

                var dataPointEO = {
                    id: id, objectType: "dataPoint", dataPointIndex: j, dataSeriesIndex: 0
                };
                dataPointEOs.push(dataPointEO);

                var percentAndTotal = {
                    percent: null, total: null
                };
                var formatterParameter = null;

                percentAndTotal = _this.getPercentAndTotal(dataSeries, dataPoint);

                if (dataSeries.indexLabelFormatter || dataPoint.indexLabelFormatter)
                    formatterParameter = {
                        chart: _this.options, dataSeries: dataSeries, dataPoint: dataPoint, total: percentAndTotal.total, percent: percentAndTotal.percent
                    };

                var indexLabelText = dataPoint.indexLabelFormatter ? dataPoint.indexLabelFormatter(formatterParameter)
                    : dataPoint.indexLabel ? _this.replaceKeywordsWithValue(dataPoint.indexLabel, dataPoint, dataSeries, j)
                        : dataSeries.indexLabelFormatter ? dataSeries.indexLabelFormatter(formatterParameter)
                            : dataSeries.indexLabel ? _this.replaceKeywordsWithValue(dataSeries.indexLabel, dataPoint, dataSeries, j) : dataPoint.label ? dataPoint.label : '';


                _this._eventManager.objectMap[id] = dataPointEO;

                //dataPointEO.indexLabelText = j.toString() + " " + "kingfisher: " + dataPoint.y.toString();;
                dataPointEO.center = {
                    x: center.x, y: center.y
                };
                dataPointEO.y = dataPoint.y;
                dataPointEO.radius = outerRadius;
                dataPointEO.percentInnerRadius = percentInnerRadius;
                dataPointEO.indexLabelText = indexLabelText;
                dataPointEO.indexLabelPlacement = dataSeries.indexLabelPlacement;
                dataPointEO.indexLabelLineColor = dataPoint.indexLabelLineColor ? dataPoint.indexLabelLineColor : dataSeries.options.indexLabelLineColor ? dataSeries.options.indexLabelLineColor : dataPoint.color ? dataPoint.color : dataSeries._colorSet[j % dataSeries._colorSet.length];
                dataPointEO.indexLabelLineThickness = (!isNullOrUndefined(dataPoint.indexLabelLineThickness)) ? dataPoint.indexLabelLineThickness : dataSeries.indexLabelLineThickness;
                dataPointEO.indexLabelLineDashType = dataPoint.indexLabelLineDashType ? dataPoint.indexLabelLineDashType : dataSeries.indexLabelLineDashType;
                dataPointEO.indexLabelFontColor = dataPoint.indexLabelFontColor ? dataPoint.indexLabelFontColor : dataSeries.indexLabelFontColor;
                dataPointEO.indexLabelFontStyle = dataPoint.indexLabelFontStyle ? dataPoint.indexLabelFontStyle : dataSeries.indexLabelFontStyle;
                dataPointEO.indexLabelFontWeight = dataPoint.indexLabelFontWeight ? dataPoint.indexLabelFontWeight : dataSeries.indexLabelFontWeight;
                dataPointEO.indexLabelFontSize = !isNullOrUndefined(dataPoint.indexLabelFontSize) ? dataPoint.indexLabelFontSize : dataSeries.indexLabelFontSize;
                dataPointEO.indexLabelFontFamily = dataPoint.indexLabelFontFamily ? dataPoint.indexLabelFontFamily : dataSeries.indexLabelFontFamily;
                dataPointEO.indexLabelBackgroundColor = dataPoint.indexLabelBackgroundColor ? dataPoint.indexLabelBackgroundColor : dataSeries.options.indexLabelBackgroundColor ? dataSeries.options.indexLabelBackgroundColor : dataSeries.indexLabelBackgroundColor;
                dataPointEO.indexLabelMaxWidth = dataPoint.indexLabelMaxWidth ? dataPoint.indexLabelMaxWidth : dataSeries.indexLabelMaxWidth ? dataSeries.indexLabelMaxWidth : plotArea.width * .33;
                dataPointEO.indexLabelWrap = typeof (dataPoint.indexLabelWrap) !== "undefined" ? dataPoint.indexLabelWrap : dataSeries.indexLabelWrap;

                dataPointEO.startAngle = j === 0 ? dataSeries.startAngle ? (dataSeries.startAngle / 180) * Math.PI : 0 : dataPointEOs[j - 1].endAngle;

                dataPointEO.startAngle = (dataPointEO.startAngle + (2 * Math.PI)) % (2 * Math.PI);

                dataPointEO.endAngle = dataPointEO.startAngle + ((2 * Math.PI / sum) * Math.abs(dataPoint.y));

                //var midAngle = dataPointEO.startAngle + Math.abs(dataPointEO.endAngle - dataPointEO.startAngle) / 2;
                var midAngle = (dataPointEO.endAngle + dataPointEO.startAngle) / 2;

                //var midAngle = (180 / Math.PI * midAngle);

                midAngle = (midAngle + (2 * Math.PI)) % (2 * Math.PI);

                dataPointEO.midAngle = midAngle;

                if (dataPointEO.midAngle > (Math.PI / 2) - poleAnglularDistance && dataPointEO.midAngle < (Math.PI / 2) + poleAnglularDistance) {
                    if (noDPNearSouthPole === 0 || dataPointEOs[firstDPCloseToSouth].midAngle > dataPointEO.midAngle)
                        firstDPCloseToSouth = j;

                    noDPNearSouthPole++;
                }
                else if (dataPointEO.midAngle > (3 * Math.PI / 2) - poleAnglularDistance && dataPointEO.midAngle < (3 * Math.PI / 2) + poleAnglularDistance) {
                    if (noDPNearNorthPole === 0 || dataPointEOs[firstDPCloseToNorth].midAngle > dataPointEO.midAngle)
                        firstDPCloseToNorth = j;

                    noDPNearNorthPole++;
                }


                if (midAngle > (Math.PI / 2) && midAngle <= (3 * Math.PI / 2))
                    dataPointEO.hemisphere = "left";
                else
                    dataPointEO.hemisphere = "right";

                //dataPointEO.indexLabelText = j.toString() + "; " + dataPoint.y.toString() + "; " + midAngle.toString() + "; junk";
                dataPointEO.indexLabelTextBlock = new TextBlock(_this.plotArea.ctx, {
                    fontSize: dataPointEO.indexLabelFontSize, fontFamily: dataPointEO.indexLabelFontFamily, fontColor: dataPointEO.indexLabelFontColor,
                    fontStyle: dataPointEO.indexLabelFontStyle, fontWeight: dataPointEO.indexLabelFontWeight,
                    horizontalAlign: "left",
                    backgroundColor: dataPointEO.indexLabelBackgroundColor,
                    maxWidth: dataPointEO.indexLabelMaxWidth, maxHeight: dataPointEO.indexLabelWrap ? dataPointEO.indexLabelFontSize * 5 : dataPointEO.indexLabelFontSize * 1.5,
                    text: dataPointEO.indexLabelText,
                    padding: 0,
                    //textBaseline: dataPointEO.indexLabelBackgroundColor ? "middle" : "top"
                    textBaseline: "top"
                });

                dataPointEO.indexLabelTextBlock.measureText();

                //dataPoint.labelWidth = ctx.measureText(j.toString() + "; " + dataPoint.label).width;

                //console.log(dataPoint.label);
            }

            var noOfDPToRightOfSouthPole = 0;
            var noOfDPToLeftOfNorthPole = 0;
            var keepSameDirection = false; // once a dataPoint's hemisphere is changed, others should follow the same so that there are no labes near pole pointing in opposite direction.

            for (var j = 0; j < dataPoints.length; j++) {

                var dataPointEO = dataPointEOs[(firstDPCloseToSouth + j) % dataPoints.length];

                if (noDPNearSouthPole > 1 && dataPointEO.midAngle > (Math.PI / 2) - poleAnglularDistance && dataPointEO.midAngle < (Math.PI / 2) + poleAnglularDistance) {

                    if (noOfDPToRightOfSouthPole <= noDPNearSouthPole / 2 && !keepSameDirection) {
                        dataPointEO.hemisphere = "right";
                        noOfDPToRightOfSouthPole++;
                    }
                    else {
                        dataPointEO.hemisphere = "left";
                        keepSameDirection = true;
                    }
                }
            }

            keepSameDirection = false;
            for (var j = 0; j < dataPoints.length; j++) {

                var dataPointEO = dataPointEOs[(firstDPCloseToNorth + j) % dataPoints.length];

                //if (dataPoint.hemisphere = "right")
                //	break;

                if (noDPNearNorthPole > 1 && dataPointEO.midAngle > (3 * Math.PI / 2) - poleAnglularDistance && dataPointEO.midAngle < (3 * Math.PI / 2) + poleAnglularDistance) {

                    if (noOfDPToLeftOfNorthPole <= noDPNearNorthPole / 2 && !keepSameDirection) {
                        dataPointEO.hemisphere = "left";
                        noOfDPToLeftOfNorthPole++;
                    }
                    else {
                        dataPointEO.hemisphere = "right";
                        keepSameDirection = true;
                    }
                }
            }
        }//End of initLabels()

        function renderLabels() {

            var ctx = _this.plotArea.ctx;
            ctx.save();

            ctx.fillStyle = "black";
            ctx.strokeStyle = "grey";
            var fontSize = 16;
            //ctx.font = fontSize + "px Arial";
            ctx.textBaseline = "middle";
            ctx.lineJoin = "round";
            var i = 0, j = 0;

            for (i = 0; i < dataPoints.length; i++) {
                var dataPointEO = dataPointEOs[i];

                if (!dataPointEO.indexLabelText)
                    continue;

                dataPointEO.indexLabelTextBlock.y -= dataPointEO.indexLabelTextBlock.height / 2;

                var xOffset = 0;

                if (dataPointEO.hemisphere === "left") {
                    var xOffset = dataSeries.indexLabelPlacement !== "inside" ? -(dataPointEO.indexLabelTextBlock.width + indexLabelLineEdgeLength) : -dataPointEO.indexLabelTextBlock.width / 2;
                }
                else {
                    var xOffset = dataSeries.indexLabelPlacement !== "inside" ? indexLabelLineEdgeLength : -dataPointEO.indexLabelTextBlock.width / 2;
                }

                dataPointEO.indexLabelTextBlock.x += xOffset;
                dataPointEO.indexLabelTextBlock.render(true);
                dataPointEO.indexLabelTextBlock.x -= xOffset;

                //if (i < 4)
                //	customPrompt(i + "; " + center.y + "; " + dataPointEO.indexLabelTextBlock.y.toFixed(2));

                dataPointEO.indexLabelTextBlock.y += dataPointEO.indexLabelTextBlock.height / 2;

                if (dataPointEO.indexLabelPlacement !== "inside" && dataPointEO.indexLabelLineThickness > 0) {
                    var indexLabelLineStartX = dataPointEO.center.x + outerRadius * Math.cos(dataPointEO.midAngle);
                    var indexLabelLineStartY = dataPointEO.center.y + outerRadius * Math.sin(dataPointEO.midAngle);

                    //ctx.strokeStyle = dataPoints[i].color ? dataPoints[i].color : dataSeries._colorSet[i % dataSeries._colorSet.length];
                    ctx.strokeStyle = dataPointEO.indexLabelLineColor;
                    ctx.lineWidth = dataPointEO.indexLabelLineThickness;

                    if (ctx.setLineDash) {
                        ctx.setLineDash(getLineDashArray(dataPointEO.indexLabelLineDashType, dataPointEO.indexLabelLineThickness));
                    }

                    //ctx.lineWidth = 4;
                    ctx.beginPath();
                    ctx.moveTo(indexLabelLineStartX, indexLabelLineStartY);
                    ctx.lineTo(dataPointEO.indexLabelTextBlock.x, dataPointEO.indexLabelTextBlock.y);
                    ctx.lineTo(dataPointEO.indexLabelTextBlock.x + (dataPointEO.hemisphere === "left" ? -indexLabelLineEdgeLength : indexLabelLineEdgeLength), dataPointEO.indexLabelTextBlock.y);
                    ctx.stroke();
                    //ctx.closePath();
                    //window.alert("contine??");
                    //animate();
                }

                ctx.lineJoin = "miter";
            }

            ctx.save();
        }

        function animate(fractionComplete) {

            var ctx = _this.plotArea.ctx;

            ctx.clearRect(plotArea.x1, plotArea.y1, plotArea.width, plotArea.height);
            ctx.fillStyle = _this.backgroundColor;
            ctx.fillRect(plotArea.x1, plotArea.y1, plotArea.width, plotArea.height);

            var maxAngle = dataPointEOs[0].startAngle + (2 * Math.PI * fractionComplete);

            for (var i = 0; i < dataPoints.length; i++) {

                var startAngle = i === 0 ? dataPointEOs[i].startAngle : endAngle;
                var endAngle = startAngle + (dataPointEOs[i].endAngle - dataPointEOs[i].startAngle);

                var shouldBreak = false;

                if (endAngle > maxAngle) {
                    endAngle = maxAngle;
                    shouldBreak = true;
                }

                var color = dataPoints[i].color ? dataPoints[i].color : dataSeries._colorSet[i % dataSeries._colorSet.length];

                if (endAngle > startAngle)
                    drawSegment(_this.plotArea.ctx, dataPointEOs[i].center, dataPointEOs[i].radius, color, dataSeries.type, startAngle, endAngle, dataSeries.fillOpacity, dataPointEOs[i].percentInnerRadius);

                if (shouldBreak)
                    break;
            }
        }

        function explodeToggle(fractionComplete) {

            var ctx = _this.plotArea.ctx;

            ctx.clearRect(plotArea.x1, plotArea.y1, plotArea.width, plotArea.height);
            ctx.fillStyle = _this.backgroundColor;
            ctx.fillRect(plotArea.x1, plotArea.y1, plotArea.width, plotArea.height);

            for (var i = 0; i < dataPoints.length; i++) {

                var startAngle = dataPointEOs[i].startAngle;
                var endAngle = dataPointEOs[i].endAngle;

                if (endAngle > startAngle) {


                    var offsetX = (outerRadius * .07 * Math.cos(dataPointEOs[i].midAngle));
                    var offsetY = (outerRadius * .07 * Math.sin(dataPointEOs[i].midAngle));
                    var isInTransition = false;

                    if (dataPoints[i].exploded) {
                        if (Math.abs(dataPointEOs[i].center.x - (center.x + offsetX)) > 0.000000001 || Math.abs(dataPointEOs[i].center.y - (center.y + offsetY)) > 0.000000001) {

                            dataPointEOs[i].center.x = center.x + offsetX * fractionComplete;
                            dataPointEOs[i].center.y = center.y + offsetY * fractionComplete;

                            isInTransition = true;
                        }
                    } else if (Math.abs(dataPointEOs[i].center.x - center.x) > 0 || Math.abs(dataPointEOs[i].center.y - center.y) > 0) {
                        dataPointEOs[i].center.x = center.x + offsetX * (1 - fractionComplete);
                        dataPointEOs[i].center.y = center.y + offsetY * (1 - fractionComplete);

                        isInTransition = true;
                    }

                    if (isInTransition) {
                        var entry = {
                        };
                        entry.dataSeries = dataSeries;
                        entry.dataPoint = dataSeries.dataPoints[i];
                        entry.index = i;
                        _this.toolTip.highlightObjects([entry]);
                    }

                    var color = dataPoints[i].color ? dataPoints[i].color : dataSeries._colorSet[i % dataSeries._colorSet.length];

                    drawSegment(_this.plotArea.ctx, dataPointEOs[i].center, dataPointEOs[i].radius, color, dataSeries.type, startAngle, endAngle, dataSeries.fillOpacity, dataPointEOs[i].percentInnerRadius);
                }
            }

            //window.alert("next??");
            renderLabels();
        }

        function areDataPointsTooClose(first, second) {

            var label1 = {
                x1: first.indexLabelTextBlock.x, y1: first.indexLabelTextBlock.y - first.indexLabelTextBlock.height / 2, x2: first.indexLabelTextBlock.x + first.indexLabelTextBlock.width, y2: first.indexLabelTextBlock.y + first.indexLabelTextBlock.height / 2
            };
            var label2 = {
                x1: second.indexLabelTextBlock.x, y1: second.indexLabelTextBlock.y - second.indexLabelTextBlock.height / 2, x2: second.indexLabelTextBlock.x + second.indexLabelTextBlock.width, y2: second.indexLabelTextBlock.y + second.indexLabelTextBlock.height / 2
            };

            if (label1.x2 < label2.x1 - indexLabelLineEdgeLength || label1.x1 > label2.x2 + indexLabelLineEdgeLength || label1.y1 > label2.y2 + indexLabelLineEdgeLength || label1.y2 < label2.y1 - indexLabelLineEdgeLength)
                return false;

            return true;
        }

        function getVerticalDistanceBetweenLabels(first, second) {

            var distance = 0;
            var label1 = {
                y: first.indexLabelTextBlock.y, y1: first.indexLabelTextBlock.y - first.indexLabelTextBlock.height / 2, y2: first.indexLabelTextBlock.y + first.indexLabelTextBlock.height / 2
            };
            var label2 = {
                y: second.indexLabelTextBlock.y, y1: second.indexLabelTextBlock.y - second.indexLabelTextBlock.height / 2, y2: second.indexLabelTextBlock.y + second.indexLabelTextBlock.height / 2
            };

            if (label2.y > label1.y) {
                distance = label2.y1 - label1.y2;
            }
            else {
                distance = label1.y1 - label2.y2;
            }

            return distance;
        }

        function getNextLabelIndex(currentLabelIndex) {
            var nextLabelIndex = null;

            for (var i = 1; i < dataPoints.length; i++) {

                nextLabelIndex = (currentLabelIndex + i + dataPointEOs.length) % dataPointEOs.length;

                if (dataPointEOs[nextLabelIndex].hemisphere !== dataPointEOs[currentLabelIndex].hemisphere) {
                    nextLabelIndex = null;
                    break;
                }
                else if ((dataPointEOs[nextLabelIndex].indexLabelText) && (nextLabelIndex !== currentLabelIndex)
                    && ((getVerticalDistanceBetweenLabels(dataPointEOs[nextLabelIndex], dataPointEOs[currentLabelIndex]) < 0) || (dataPointEOs[currentLabelIndex].hemisphere === "right" ? dataPointEOs[nextLabelIndex].indexLabelTextBlock.y >= dataPointEOs[currentLabelIndex].indexLabelTextBlock.y : dataPointEOs[nextLabelIndex].indexLabelTextBlock.y <= dataPointEOs[currentLabelIndex].indexLabelTextBlock.y)))
                    break;
                else {
                    nextLabelIndex = null;
                }
            }

            return nextLabelIndex;
        }

        function getPreviousLabelIndex(currentLabelIndex) {
            var prevLabelIndex = null;

            for (var i = 1; i < dataPoints.length; i++) {

                prevLabelIndex = (currentLabelIndex - i + dataPointEOs.length) % dataPointEOs.length;

                if (dataPointEOs[prevLabelIndex].hemisphere !== dataPointEOs[currentLabelIndex].hemisphere) {
                    prevLabelIndex = null;
                    break;
                }
                else if ((dataPointEOs[prevLabelIndex].indexLabelText) && (dataPointEOs[prevLabelIndex].hemisphere === dataPointEOs[currentLabelIndex].hemisphere) && (prevLabelIndex !== currentLabelIndex)
                    && ((getVerticalDistanceBetweenLabels(dataPointEOs[prevLabelIndex], dataPointEOs[currentLabelIndex]) < 0) || (dataPointEOs[currentLabelIndex].hemisphere === "right" ? dataPointEOs[prevLabelIndex].indexLabelTextBlock.y <= dataPointEOs[currentLabelIndex].indexLabelTextBlock.y : dataPointEOs[prevLabelIndex].indexLabelTextBlock.y >= dataPointEOs[currentLabelIndex].indexLabelTextBlock.y)))
                    break;
                else {
                    prevLabelIndex = null;
                }

            }

            return prevLabelIndex;
        }

        function rePositionLabels(dataPointIndex, offset, recursionCount) {
            recursionCount = (recursionCount || 0) + 1;

            if (recursionCount > 1000)
                return 0;

            offset = offset || 0;

            var actualOffset = 0;

            //var labelYMin = 2;
            //var labelYMax = ctx.canvas.height - 2;
            //var labelYMin = _this.plotArea.ctx.canvas.height / 2 - indexLabelRadius * 1;
            //var labelYMax = _this.plotArea.ctx.canvas.height / 2 + indexLabelRadius * 1;

            var labelYMin = center.y - indexLabelRadius * 1;
            var labelYMax = center.y + indexLabelRadius * 1;

            //console.log(totalRecursions);

            if (dataPointIndex >= 0 && dataPointIndex < dataPoints.length) {

                var dataPointEO = dataPointEOs[dataPointIndex];
                //if (dataPointIndex === 0)
                //	customPrompt(labelYMin.toFixed(2) + "; " + labelYMax.toFixed(2) + "; " + dataPointEO.indexLabelTextBlock.y.toFixed(2));

                // If label is already outside the bounds, return
                if ((offset < 0 && dataPointEO.indexLabelTextBlock.y < labelYMin) || (offset > 0 && dataPointEO.indexLabelTextBlock.y > labelYMax))
                    return 0;


                var validOffset = offset;


                //Check if the offset falls within the bounds (labelYMin, labelYMax, tangential bounds) without considering overlap. Else use the closest offset that is possible - validOffset.
                {
                    var distFromIndexLineStart = 0;
                    var indexLabelLineStartX = 0;
                    var indexLabelLineStartY = 0;
                    var indexLabelAngle = 0;
                    var indexLabelAngleWhenTangent = 0;

                    if (validOffset < 0) {
                        if (dataPointEO.indexLabelTextBlock.y - dataPointEO.indexLabelTextBlock.height / 2 > labelYMin && dataPointEO.indexLabelTextBlock.y - dataPointEO.indexLabelTextBlock.height / 2 + validOffset < labelYMin)
                            validOffset = -(labelYMin - (dataPointEO.indexLabelTextBlock.y - dataPointEO.indexLabelTextBlock.height / 2 + validOffset));
                    } else {
                        if (dataPointEO.indexLabelTextBlock.y + dataPointEO.indexLabelTextBlock.height / 2 < labelYMin && dataPointEO.indexLabelTextBlock.y + dataPointEO.indexLabelTextBlock.height / 2 + validOffset > labelYMax)
                            validOffset = (dataPointEO.indexLabelTextBlock.y + dataPointEO.indexLabelTextBlock.height / 2 + validOffset) - labelYMax;
                    }

                    var newlabelY = dataPointEO.indexLabelTextBlock.y + validOffset;
                    var newlabelX = 0;

                    if (dataPointEO.hemisphere === "right") {
                        newlabelX = center.x + Math.sqrt(Math.pow(indexLabelRadius, 2) - Math.pow(newlabelY - center.y, 2));
                    }
                    else
                        newlabelX = center.x - Math.sqrt(Math.pow(indexLabelRadius, 2) - Math.pow(newlabelY - center.y, 2));


                    indexLabelLineStartX = center.x + outerRadius * Math.cos(dataPointEO.midAngle);
                    indexLabelLineStartY = center.y + outerRadius * Math.sin(dataPointEO.midAngle);

                    distFromIndexLineStart = Math.sqrt(Math.pow(newlabelX - indexLabelLineStartX, 2) + Math.pow(newlabelY - indexLabelLineStartY, 2));

                    indexLabelAngleWhenTangent = Math.acos(outerRadius / indexLabelRadius);

                    //indexLabelAngle = Math.acos((outerRadius * outerRadius + distFromIndexLineStart * distFromIndexLineStart - indexLabelRadius * indexLabelRadius) / (2 * outerRadius * distFromIndexLineStart));
                    indexLabelAngle = Math.acos((indexLabelRadius * indexLabelRadius + outerRadius * outerRadius - distFromIndexLineStart * distFromIndexLineStart) / (2 * outerRadius * indexLabelRadius));

                    if (indexLabelAngle < indexLabelAngleWhenTangent) {
                        validOffset = newlabelY - dataPointEO.indexLabelTextBlock.y;
                        //dataPointEO.indexLabelTextBlock.x = newlabelX;
                    }
                    else {

                        validOffset = 0;

                        //dataPointEO.indexLabelTextBlock.x = newlabelX;

                        //Index Line is overlapping the pie. So lets find out the point where indexline becomes a tangent.

                        //distFromIndexLineStart = Math.sqrt(indexLabelRadius * indexLabelRadius - outerRadius * outerRadius);
                        ////distFromIndexLineStart *= offset < 0 ? -1 : 1;
                        ////indexLabelAngle = Math.acos((indexLabelRadius * indexLabelRadius + outerRadius * outerRadius - distFromIndexLineStart * distFromIndexLineStart) / (2 * outerRadius * indexLabelRadius));
                        //indexLabelAngle = Math.atan2(distFromIndexLineStart, outerRadius);

                        //newlabelX = center.x + indexLabelRadius * Math.cos(indexLabelAngle);
                        //newlabelY = center.y + indexLabelRadius * Math.sin(indexLabelAngle);

                        //actualOffset = newlabelY - dataPointEO.indexLabelTextBlock.y;

                        //dataPointEO.indexLabelTextBlock.y = newlabelY;
                        //dataPointEO.indexLabelTextBlock.x = newlabelX;

                    }

                }

                //var tempIndex = (dataPointIndex + dataPointEOs.length - 1) % dataPointEOs.length;

                //var prevDataPointIndex = dataPointEOs[tempIndex].hemisphere === dataPointEO.hemisphere ? tempIndex : null;

                var prevDataPointIndex = getPreviousLabelIndex(dataPointIndex);

                //tempIndex = (dataPointIndex + dataPointEOs.length + 1) % dataPointEOs.length;

                //var nextDataPointIndex = dataPointEOs[tempIndex].hemisphere === dataPointEO.hemisphere ? tempIndex : null;

                var nextDataPointIndex = getNextLabelIndex(dataPointIndex);

                var otherdataPointEO, otherDataPointIndex, distanceFromOtherLabel;
                var otherDataPointOffset = 0;
                var otherDataPointActualOffset = 0;


                if (validOffset < 0) {

                    otherDataPointIndex = dataPointEO.hemisphere === "right" ? prevDataPointIndex : nextDataPointIndex;

                    actualOffset = validOffset;

                    if (otherDataPointIndex !== null) {

                        //if (dataPointIndex < 4)
                        //	customPrompt("valid: " + validOffset);

                        var tempOffset = -validOffset;

                        var distanceFromOtherLabel = (dataPointEO.indexLabelTextBlock.y - dataPointEO.indexLabelTextBlock.height / 2) - (dataPointEOs[otherDataPointIndex].indexLabelTextBlock.y + dataPointEOs[otherDataPointIndex].indexLabelTextBlock.height / 2);

                        if (distanceFromOtherLabel - tempOffset < minDistanceBetweenLabels) {
                            otherDataPointOffset = -tempOffset;
                            //totalRecursions++;
                            otherDataPointActualOffset = rePositionLabels(otherDataPointIndex, otherDataPointOffset, recursionCount + 1);

                            //if (dataPointIndex < 4)
                            //	customPrompt(dataPointIndex + "; " + "offset: " + otherDataPointOffset);


                            if (+otherDataPointActualOffset.toFixed(precision) > +otherDataPointOffset.toFixed(precision)) {

                                if (distanceFromOtherLabel > minDistanceBetweenLabels)
                                    actualOffset = -(distanceFromOtherLabel - minDistanceBetweenLabels);
                                    //else
                                //	actualOffset = 0;
                                else
                                    actualOffset = -(tempOffset - (otherDataPointActualOffset - otherDataPointOffset));
                            }

                            //if (dataPointIndex < 4)
                            //	customPrompt("actual: " + actualOffset);
                        }

                    }

                } else if (validOffset > 0) {

                    otherDataPointIndex = dataPointEO.hemisphere === "right" ? nextDataPointIndex : prevDataPointIndex;

                    actualOffset = validOffset;

                    if (otherDataPointIndex !== null) {

                        var tempOffset = validOffset;

                        var distanceFromOtherLabel = (dataPointEOs[otherDataPointIndex].indexLabelTextBlock.y - dataPointEOs[otherDataPointIndex].indexLabelTextBlock.height / 2) - (dataPointEO.indexLabelTextBlock.y + dataPointEO.indexLabelTextBlock.height / 2);

                        if (distanceFromOtherLabel - tempOffset < minDistanceBetweenLabels) {
                            otherDataPointOffset = tempOffset;
                            //totalRecursions++;
                            otherDataPointActualOffset = rePositionLabels(otherDataPointIndex, otherDataPointOffset, recursionCount + 1);

                            if (+otherDataPointActualOffset.toFixed(precision) < +otherDataPointOffset.toFixed(precision)) {

                                if (distanceFromOtherLabel > minDistanceBetweenLabels)
                                    actualOffset = distanceFromOtherLabel - minDistanceBetweenLabels;
                                    //else
                                //	actualOffset = 0;
                                else
                                    actualOffset = tempOffset - (otherDataPointOffset - otherDataPointActualOffset);
                            }
                        }

                    }

                    //if (!(dataPointEO.indexLabelTextBlock.y + dataPointEO.indexLabelTextBlock.height / 2 + actualOffset < labelYMax)) {
                    //	if (dataPointEO.indexLabelTextBlock.y + dataPointEO.indexLabelTextBlock.height / 2 < labelYMax) {
                    //		actualOffset = labelYMax - (dataPointEO.indexLabelTextBlock.y + dataPointEO.indexLabelTextBlock.height / 2);
                    //	}
                    //	else {
                    //		actualOffset = 0;
                    //	}
                    //}

                }

                if (actualOffset) {

                    var newLabelY = dataPointEO.indexLabelTextBlock.y + actualOffset;




                    var newLabelX = 0;

                    if (dataPointEO.hemisphere === "right") {
                        newLabelX = center.x + Math.sqrt(Math.pow(indexLabelRadius, 2) - Math.pow(newLabelY - center.y, 2));
                    }
                    else
                        newLabelX = center.x - Math.sqrt(Math.pow(indexLabelRadius, 2) - Math.pow(newLabelY - center.y, 2));

                    if (dataPointEO.midAngle > (Math.PI / 2) - poleAnglularDistance && dataPointEO.midAngle < (Math.PI / 2) + poleAnglularDistance) {

                        var prevDPIndex = (dataPointIndex - 1 + dataPointEOs.length) % dataPointEOs.length;
                        var prevDP = dataPointEOs[prevDPIndex];
                        var nextDP = dataPointEOs[(dataPointIndex + 1 + dataPointEOs.length) % dataPointEOs.length];

                        if (dataPointEO.hemisphere === "left" && prevDP.hemisphere === "right" && newLabelX > prevDP.indexLabelTextBlock.x) {
                            newLabelX = prevDP.indexLabelTextBlock.x - 15;
                        } else if (dataPointEO.hemisphere === "right" && nextDP.hemisphere === "left" && newLabelX < nextDP.indexLabelTextBlock.x) {
                            newLabelX = nextDP.indexLabelTextBlock.x + 15;
                        }
                    } else if (dataPointEO.midAngle > (3 * Math.PI / 2) - poleAnglularDistance && dataPointEO.midAngle < (3 * Math.PI / 2) + poleAnglularDistance) {

                        var prevDPIndex = (dataPointIndex - 1 + dataPointEOs.length) % dataPointEOs.length;
                        var prevDP = dataPointEOs[prevDPIndex];
                        var nextDP = dataPointEOs[(dataPointIndex + 1 + dataPointEOs.length) % dataPointEOs.length];

                        if (dataPointEO.hemisphere === "right" && prevDP.hemisphere === "left" && newLabelX < prevDP.indexLabelTextBlock.x) {
                            newLabelX = prevDP.indexLabelTextBlock.x + 15;
                        } else if (dataPointEO.hemisphere === "left" && nextDP.hemisphere === "right" && newLabelX > nextDP.indexLabelTextBlock.x) {
                            newLabelX = nextDP.indexLabelTextBlock.x - 15;
                        }
                    }

                    //if (actualOffset < 0 && dataPointIndex < 4)
                    //	customPrompt(actualOffset.toFixed(2) + "; " + dataPointEO.indexLabelTextBlock.y.toFixed(2) + "; " + newLabelY.toFixed(2));

                    dataPointEO.indexLabelTextBlock.y = newLabelY;

                    dataPointEO.indexLabelTextBlock.x = newLabelX;

                    dataPointEO.indexLabelAngle = Math.atan2((dataPointEO.indexLabelTextBlock.y - center.y), (dataPointEO.indexLabelTextBlock.x - center.x));

                }


            }

            return actualOffset;
        }


        function positionLabels() {
            var ctx = _this.plotArea.ctx;

            ctx.fillStyle = "grey";
            ctx.strokeStyle = "grey";
            var fontSize = 16;
            ctx.font = fontSize + "px Arial";
            ctx.textBaseline = "middle";
            var i = 0, j = 0;
            var deltaR = 0;

            var resizeFlag = true;

            for (j = 0; j < 10 && (j < 1 || deltaR > 0) ; j++) {

                if (dataSeries.radius || (!dataSeries.radius && typeof dataSeries.innerRadius !== 'undefined' && dataSeries.innerRadius !== null && outerRadius - deltaR <= innerRadius))
                    resizeFlag = false;

                if (resizeFlag)
                    outerRadius -= deltaR;

                deltaR = 0;

                if (dataSeries.indexLabelPlacement !== "inside") {

                    indexLabelRadius = outerRadius * indexLabelRadiusToRadiusRatio;

                    for (i = 0; i < dataPoints.length; i++) {
                        var dataPointEO = dataPointEOs[i];

                        dataPointEO.indexLabelTextBlock.x = center.x + indexLabelRadius * Math.cos(dataPointEO.midAngle);
                        dataPointEO.indexLabelTextBlock.y = center.y + indexLabelRadius * Math.sin(dataPointEO.midAngle);

                        dataPointEO.indexLabelAngle = dataPointEO.midAngle;
                        dataPointEO.radius = outerRadius;
                        dataPointEO.percentInnerRadius = percentInnerRadius;
                        //dataPointEO.indexLabelFontSize = dataPoint.indexLabelFontSize ? dataPoint.indexLabelFontSize : dataSeries.indexLabelFontSize;
                    }

                    var currentDataPoint, nextDataPoint;
                    for (i = 0; i < dataPoints.length; i++) {

                        var dataPointEO = dataPointEOs[i];
                        //dataPointEO.lab
                        //resetAnimationFrame();
                        //animate();
                        //renderLabels();

                        //var prevDataPointIndex = (i - 1 + dataPointEOs.length) % dataPointEOs.length;

                        //var nextDataPointIndex = (i + 1 + dataPointEOs.length) % dataPointEOs.length;
                        //nextDataPointIndex = dataPointEOs[nextDataPointIndex].hemisphere === dataPointEO.hemisphere && nextDataPointIndex !== i ? nextDataPointIndex : null;

                        var nextDataPointIndex = getNextLabelIndex(i);

                        if (nextDataPointIndex === null)
                            continue;

                        currentDataPoint = dataPointEOs[i];
                        nextDataPoint = dataPointEOs[nextDataPointIndex];


                        var distanceFromNextLabel = 0;

                        //if (dataPointEO.hemisphere === "right")
                        //	distanceFromNextLabel = (nextDataPoint.indexLabelTextBlock.y - nextDataPoint.indexLabelTextBlock.height / 2) - (currentDataPoint.indexLabelTextBlock.y + currentDataPoint.indexLabelTextBlock.height / 2) - minDistanceBetweenLabels;
                        //else
                        //	distanceFromNextLabel = (currentDataPoint.indexLabelTextBlock.y - currentDataPoint.indexLabelTextBlock.height / 2) - (nextDataPoint.indexLabelTextBlock.y + nextDataPoint.indexLabelTextBlock.height / 2) - minDistanceBetweenLabels;

                        distanceFromNextLabel = getVerticalDistanceBetweenLabels(currentDataPoint, nextDataPoint) - minDistanceBetweenLabels;


                        if (distanceFromNextLabel < 0) {

                            var dataPointsAbove = 0;
                            var dataPointsBelow = 0;
                            //var indexLabelAngleWhenTangent = Math.acos(outerRadius / indexLabelRadius) / Math.PI * 180;


                            for (var k = 0; k < dataPoints.length; k++) {

                                if (k === i)
                                    continue;

                                //if (dataPointEOs[k].hemisphere !== dataPointEO.hemisphere || Math.abs(dataPointEOs[k].midAngle - dataPointEO.midAngle) > 30)
                                //	continue;
                                //if (dataPointEOs[k].hemisphere !== dataPointEO.hemisphere || Math.abs(dataPointEOs[k].labelAngle - dataPointEO.indexLabelAngle) > 30)
                                //	continue;
                                //if (dataPointEOs[k].hemisphere !== dataPointEO.hemisphere || Math.abs(dataPointEOs[k].midAngle - dataPointEO.midAngle) > indexLabelAngleWhenTangent)
                                //	continue;
                                if (dataPointEOs[k].hemisphere !== dataPointEO.hemisphere)
                                    continue;

                                if (dataPointEOs[k].indexLabelTextBlock.y < dataPointEO.indexLabelTextBlock.y)
                                    dataPointsAbove++;
                                else
                                    dataPointsBelow++;
                            }

                            //var upWardsOffset = (distanceFromNextLabel) / dataPoints.length * (dataPointsBelow);
                            var upWardsOffset = (distanceFromNextLabel) / (dataPointsAbove + dataPointsBelow || 1) * (dataPointsBelow);
                            var downWardsOffset = -1 * (distanceFromNextLabel - upWardsOffset);

                            var actualUpwardOffset = 0;
                            var actualDownwardOffset = 0;

                            if (dataPointEO.hemisphere === "right") {
                                actualUpwardOffset = rePositionLabels(i, upWardsOffset);

                                //if (i < 4 && actualDownwardOffset !== upWardsOffset)
                                //	customPrompt(i + "; " + upWardsOffset.toFixed(2) + "; " + actualUpwardOffset.toFixed(2));


                                downWardsOffset = -1 * (distanceFromNextLabel - actualUpwardOffset);

                                actualDownwardOffset = rePositionLabels(nextDataPointIndex, downWardsOffset);

                                //window.alert(typeof +downWardsOffset.toFixed(precision));
                                //Setting precision to make sure that they don't become not equal become of minor differences - like a difference of .000001
                                if (+actualDownwardOffset.toFixed(precision) < +downWardsOffset.toFixed(precision) && +actualUpwardOffset.toFixed(precision) <= +upWardsOffset.toFixed(precision))
                                    rePositionLabels(i, -(downWardsOffset - actualDownwardOffset));

                            } else {
                                actualUpwardOffset = rePositionLabels(nextDataPointIndex, upWardsOffset);

                                downWardsOffset = -1 * (distanceFromNextLabel - actualUpwardOffset);

                                actualDownwardOffset = rePositionLabels(i, downWardsOffset);

                                //Setting precision to make sure that they don't become not equal become of minor differences - like a difference of .000001
                                if (+actualDownwardOffset.toFixed(precision) < +downWardsOffset.toFixed(precision) && +actualUpwardOffset.toFixed(precision) <= +upWardsOffset.toFixed(precision))
                                    rePositionLabels(nextDataPointIndex, -(downWardsOffset - actualDownwardOffset));
                            }
                        }


                        //resetAnimationFrame();
                        //animate();
                        //renderLabels();
                        //window.alert("next??");
                    }
                } else {
                    for (i = 0; i < dataPoints.length; i++) {

                        var dataPointEO = dataPointEOs[i];
                        indexLabelRadius = dataSeries.type === "pie" ? outerRadius * .7 : outerRadius * .8;


                        var dx = center.x + indexLabelRadius * (Math.cos((dataPointEO.midAngle)));
                        var dy = center.y + indexLabelRadius * (Math.sin((dataPointEO.midAngle)));

                        dataPointEO.indexLabelTextBlock.x = dx;
                        dataPointEO.indexLabelTextBlock.y = dy;
                    }
                }

                // Resize Pie based on the label length.
                for (i = 0; i < dataPoints.length; i++) {

                    dataPointEO = dataPointEOs[i];

                    var size = dataPointEO.indexLabelTextBlock.measureText();
                    // To make sure that null text or empty strings don't affect the radius. Required when user is not showing any labels
                    if (size.height === 0 || size.width === 0)
                        continue;

                    var xOverflow = 0;
                    var xdr = 0;

                    if (dataPointEO.hemisphere === "right") {
                        xOverflow = plotArea.x2 - (dataPointEO.indexLabelTextBlock.x + dataPointEO.indexLabelTextBlock.width + indexLabelLineEdgeLength);
                        xOverflow *= -1;
                    } else {
                        xOverflow = plotArea.x1 - (dataPointEO.indexLabelTextBlock.x - dataPointEO.indexLabelTextBlock.width - indexLabelLineEdgeLength);
                    }
                    if (xOverflow > 0) {
                        if (!resizeFlag && dataPointEO.indexLabelText) {
                            var newIndexLabelMaxWidth = dataPointEO.hemisphere === "right" ? plotArea.x2 - dataPointEO.indexLabelTextBlock.x : dataPointEO.indexLabelTextBlock.x - plotArea.x1;
                            dataPointEO.indexLabelTextBlock.maxWidth * .3 > newIndexLabelMaxWidth ? dataPointEO.indexLabelText = "" : dataPointEO.indexLabelTextBlock.maxWidth = newIndexLabelMaxWidth * .85;
                            if (dataPointEO.indexLabelTextBlock.maxWidth * .3 < newIndexLabelMaxWidth) dataPointEO.indexLabelTextBlock.x -= dataPointEO.hemisphere === "right" ? 2 : -2;
                        }

                        if (Math.abs(dataPointEO.indexLabelTextBlock.y - dataPointEO.indexLabelTextBlock.height / 2 - center.y) < outerRadius
                            || Math.abs(dataPointEO.indexLabelTextBlock.y + dataPointEO.indexLabelTextBlock.height / 2 - center.y) < outerRadius) {

                            xdr = xOverflow / Math.abs(Math.cos(dataPointEO.indexLabelAngle));

                            if (xdr > 9)
                                xdr = xdr * .3;

                            if (xdr > deltaR)
                                deltaR = xdr;
                        }
                    }

                    var yOverflow = 0;
                    var ydr = 0;

                    if (dataPointEO.indexLabelAngle > 0 && dataPointEO.indexLabelAngle < Math.PI) {
                        yOverflow = plotArea.y2 - (dataPointEO.indexLabelTextBlock.y + dataPointEO.indexLabelTextBlock.height / 2 + 5);
                        yOverflow *= -1;
                    } else {
                        yOverflow = plotArea.y1 - (dataPointEO.indexLabelTextBlock.y - dataPointEO.indexLabelTextBlock.height / 2 - 5);
                    }

                    if (yOverflow > 0) {
                        if (!resizeFlag && dataPointEO.indexLabelText) {
                            var positionMultiplier = dataPointEO.indexLabelAngle > 0 && dataPointEO.indexLabelAngle < Math.PI ? -1 : 1;
                            if (rePositionLabels(i, yOverflow * positionMultiplier) === 0)
                                rePositionLabels(i, 2 * positionMultiplier);
                        }
                        if (Math.abs(dataPointEO.indexLabelTextBlock.x - center.x) < outerRadius) {

                            ydr = yOverflow / Math.abs(Math.sin(dataPointEO.indexLabelAngle));

                            if (ydr > 9)
                                ydr = ydr * .3;

                            if (ydr > deltaR)
                                deltaR = ydr;

                        }
                    }

                }

                function removeLabelsForSmallSegments(totalOverlap, startIndex, endIndex) {

                    var dpEOs = [];
                    var totalRemovedLabelHeight = 0;

                    for (var i = startIndex; true; i = (i + 1 + dataPoints.length) % dataPoints.length) {
                        dpEOs.push(dataPointEOs[i]);

                        if (i === endIndex)
                            break;
                    }

                    dpEOs.sort(function (entry1, entry2) {
                        return entry1.y - entry2.y;
                    });

                    for (var i = 0; i < dpEOs.length; i++) {
                        var dpEO = dpEOs[i];

                        if (totalRemovedLabelHeight < totalOverlap * .7) {
                            totalRemovedLabelHeight += dpEO.indexLabelTextBlock.height;
                            dpEO.indexLabelTextBlock.text = "";
                            dpEO.indexLabelText = "";
                            dpEO.indexLabelTextBlock.measureText();
                        } else
                            break;
                    }

                }

                //resetAnimationFrame(1);
                //animate();
                //window.alert("next??");
                function skipLabels() {
                    var overlapStartIndex = -1;
                    var overlapEndIndex = -1;
                    var totalOverlap = 0;
                    var removeLabels = false;

                    for (var k = 0; k < dataPoints.length; k++) {
                        removeLabels = false;
                        currentDataPoint = dataPointEOs[k];

                        if (!currentDataPoint.indexLabelText)
                            continue;

                        var nextLabelIndex = getNextLabelIndex(k);
                        if (nextLabelIndex === null)
                            continue;

                        var nextDataPoint = dataPointEOs[nextLabelIndex];

                        distanceFromNextLabel = 0;

                        //if (nextDataPoint.indexLabelTextBlock.y > currentDataPoint.indexLabelTextBlock.y)
                        //	distanceFromNextLabel = (nextDataPoint.indexLabelTextBlock.y - (nextDataPoint.indexLabelTextBlock.height / 2)) - (currentDataPoint.indexLabelTextBlock.y + (currentDataPoint.indexLabelTextBlock.height / 2));
                        //else
                        //	distanceFromNextLabel = (currentDataPoint.indexLabelTextBlock.y - (currentDataPoint.indexLabelTextBlock.height / 2)) - (nextDataPoint.indexLabelTextBlock.y + (nextDataPoint.indexLabelTextBlock.height / 2));

                        distanceFromNextLabel = getVerticalDistanceBetweenLabels(currentDataPoint, nextDataPoint);

                        if (distanceFromNextLabel < 0 && areDataPointsTooClose(currentDataPoint, nextDataPoint)) {
                            //if (distanceFromNextLabel < 0 && areDataPointsTooClose(currentDataPoint, nextDataPoint) ) {
                            if (overlapStartIndex < 0)
                                overlapStartIndex = k;

                            if (nextLabelIndex !== overlapStartIndex) {
                                overlapEndIndex = nextLabelIndex;

                                totalOverlap += -distanceFromNextLabel;
                            }

                            if (k % Math.max(dataPoints.length / 10, 3) === 0)
                                removeLabels = true;

                            //nextDataPoint.indexLabelText = "";
                            //nextDataPoint.indexLabelTextBlock.text = "";
                            //nextDataPoint.indexLabelTextBlock.measureText();
                        } else {

                            removeLabels = true;
                        }

                        if (removeLabels) {

                            if (totalOverlap > 0 && overlapStartIndex >= 0 && overlapEndIndex >= 0) {
                                removeLabelsForSmallSegments(totalOverlap, overlapStartIndex, overlapEndIndex);

                                overlapStartIndex = -1;
                                overlapEndIndex = -1;
                                totalOverlap = 0;
                            }
                        }
                    }

                    if (totalOverlap > 0)
                        removeLabelsForSmallSegments(totalOverlap, overlapStartIndex, overlapEndIndex);
                }

                skipLabels();


            }
            //window.alert("next??");


            //resetAnimationFrame(_this.animationEnabled && _this.renderCount === 0 ? isCanvasSupported ? 60 : 30 : 1);
            //animate();

            //console.log("totalRecursions: " + totalRecursions);
        }


        this.pieDoughnutClickHandler = function (e) {

            if (_this.isAnimating) {
                return;
            }

            //if explodeOnClick === true
            if ((isNullOrUndefined(e.dataSeries.explodeOnClick) || e.dataSeries.explodeOnClick)) {
                var i = e.dataPointIndex;
                var dataPoint = e.dataPoint;
                var dataSeries = this;


                var id = dataSeries.dataPointIds[i];

                //dataPointEO = _this._eventManager.objectMap[id];

                if (dataPoint.exploded)
                    dataPoint.exploded = false;
                else
                    dataPoint.exploded = true;


                // So that it doesn't try to explode when there is only one segment
                if (dataSeries.dataPoints.length > 1) {
                    _this._animator.animate(0, explodeDuration, function (fractionComplete) {

                        explodeToggle(fractionComplete);
                        renderChartElementsInPlotArea();
                        //console.log("Explode Start");

                    });
                }
            }
            return;
        }

        initLabels();

        positionLabels();
        positionLabels();
        positionLabels();
        positionLabels();

        this.disableToolTip = true;
        this._animator.animate(0, this.animatedRender ? this.animationDuration : 0, function (fractionComplete) {

            animate(fractionComplete);
            renderChartElementsInPlotArea();

        }, function () {

            _this.disableToolTip = false;
            _this._animator.animate(0, _this.animatedRender ? explodeDuration : 0, function (fractionComplete) {

                explodeToggle(fractionComplete);
                renderChartElementsInPlotArea();

            });

            //console.log("Animation Complete");
        });

        function renderChartElementsInPlotArea() {

            _this.plotArea.layoutManager.reset();

            if (_this.title) {
                if (_this.title.dockInsidePlotArea || (_this.title.horizontalAlign === "center" && _this.title.verticalAlign === "center"))
                    _this.title.render();

            }

            if (_this.subtitles)
                for (var i = 0; i < _this.subtitles.length; i++) {
                    var subtitle = _this.subtitles[i];
                    if (subtitle.dockInsidePlotArea || (subtitle.horizontalAlign === "center" && subtitle.verticalAlign === "center"))
                        subtitle.render();
                }

            if (_this.legend) {
                if (_this.legend.dockInsidePlotArea || (_this.legend.horizontalAlign === "center" && _this.legend.verticalAlign === "center"))
                    _this.legend.render();
            }

            if (global.fNg)
                global.fNg(_this);
        }

        //this.ctx.strokeRect(plotArea.x1 + 1, plotArea.y1, plotArea.width - 2, plotArea.height);
    }

    //#endregion pieChart


    //#endregion Render Methods
    Chart.prototype.animationRequestId = null;

    Chart.prototype.requestAnimFrame = (function () {
        return window.requestAnimationFrame ||
            window.webkitRequestAnimationFrame ||
            window.mozRequestAnimationFrame ||
            window.oRequestAnimationFrame ||
            window.msRequestAnimationFrame ||
            function (callback) {
                window.setTimeout(callback, 1000 / 60);
            };
    })();

    Chart.prototype.cancelRequestAnimFrame = (function () {
        return window.cancelAnimationFrame ||
            window.webkitCancelRequestAnimationFrame ||
            window.mozCancelRequestAnimationFrame ||
            window.oCancelRequestAnimationFrame ||
            window.msCancelRequestAnimationFrame ||
            clearTimeout
    })();

    //#region Public Methods

    Chart.prototype.set = function (name, value, updateChart) {
        updateChart = (typeof (updateChart) === "undefined") ? true : updateChart;

        if (name === "options") {
            this.options = value;

            if (updateChart)
                this.render();
        }
        else
            Chart.base.set.call(this, name, value, updateChart);
    }

    Chart.prototype.exportChart = function (options) {

        options = typeof (options) === "undefined" ? {} : options;
        var format = options.format ? options.format : "png";
        var fileName = options.fileName ? options.fileName : this.exportFileName;

        if (options.toDataURL) {
            return this.canvas.toDataURL("image/" + format);
        } else {
            exportCanvas(this.canvas, format, fileName);
        }
    }

    Chart.prototype.print = function () {
        var chartImageData = this.exportChart({ toDataURL: true });

        var printFrame = document.createElement("iframe");
        //printFrame.setAttribute("id", "canvasjs-print-frame");
        printFrame.setAttribute("class", "canvasjs-chart-print-frame");
        printFrame.setAttribute("style", "position:absolute; width:100%; border: 0px; margin: 0px 0px 0px 0px; padding 0px 0px 0px 0px;");
        printFrame.style.height = this.height + "px";
        this._canvasJSContainer.appendChild(printFrame);
        var _this = this;

        var printDoc = printFrame.contentWindow || printFrame.contentDocument.document || printFrame.contentDocument;

        printDoc.document.open();
        printDoc.document.write('<!DOCTYPE HTML>\n<html><body style="margin: 0px 0px 0px 0px; padding: 0px 0px 0px 0px;"><img src="' + chartImageData + '"/><body/></html>');
        printDoc.document.close();

        setTimeout(function () {
            printDoc.focus();
            printDoc.print();
            setTimeout(function () {
                _this._canvasJSContainer.removeChild(printFrame);
            }, 1000);
        }, 500);


    }


    //#endregion Public Methods

    //#endregion Class Chart

    //#region Class LayoutManager
    function LayoutManager(x1, y1, x2, y2, padding) {

        if (typeof (padding) === "undefined")
            padding = 0;

        this._padding = padding;

        this._x1 = x1;
        this._y1 = y1;
        this._x2 = x2;
        this._y2 = y2;

        this._topOccupied = this._padding;
        this._bottomOccupied = this._padding;
        this._leftOccupied = this._padding;
        this._rightOccupied = this._padding;
    }

    LayoutManager.prototype.registerSpace = function (position, size) {
        if (position === "top") {
            this._topOccupied += size.height;
        }
        else if (position === "bottom") {
            this._bottomOccupied += size.height;
        } else if (position === "left") {
            this._leftOccupied += size.width; // this is width when seen upright/vertically
        } else if (position === "right") {
            this._rightOccupied += size.width;// this is width when seen upright/vertically
        }
    }

    LayoutManager.prototype.unRegisterSpace = function (position, size) {
        if (position === "top") {
            this._topOccupied -= size.height;
        }
        else if (position === "bottom") {
            this._bottomOccupied -= size.height;
        } else if (position === "left") {
            this._leftOccupied -= size.width;// this is width when seen upright/vertically
        } else if (position === "right") {
            this._rightOccupied -= size.width;// this is width when seen upright/vertically
        }
    }

    LayoutManager.prototype.getFreeSpace = function () {
        ///<signature>
        ///<summary>Returns available free space {x1:number, y1:number, x2:number, y2:number}</summary>
        ///</signature>

        return {
            x1: this._x1 + this._leftOccupied,
            y1: this._y1 + this._topOccupied,
            x2: this._x2 - this._rightOccupied,
            y2: this._y2 - this._bottomOccupied,
            width: (this._x2 - this._x1) - this._rightOccupied - this._leftOccupied,
            height: (this._y2 - this._y1) - this._bottomOccupied - this._topOccupied
        };
    }

    LayoutManager.prototype.reset = function () {
        //so that there is enough padding.
        this._topOccupied = this._padding;
        this._bottomOccupied = this._padding;
        this._leftOccupied = this._padding;
        this._rightOccupied = this._padding;
    }
    //#endregion Class LayoutManager

    //#region Class TextBlock
    function TextBlock(ctx, options) {
        TextBlock.base.constructor.call(this, "TextBlock", options);

        this.ctx = ctx;
        this._isDirty = true;
        this._wrappedText = null;
    }
    extend(TextBlock, CanvasJSObject);
    TextBlock.prototype.render = function (preserveContext) {
        if (this.fontSize === 0)
            return;

        if (preserveContext)
            this.ctx.save();

        var font = this.ctx.font;
        this.ctx.textBaseline = this.textBaseline;

        var offsetY = 0;

        if (this._isDirty)
            this.measureText(this.ctx);

        this.ctx.translate(this.x, this.y + offsetY);

        if (this.textBaseline === "middle") {
            offsetY = -this._lineHeight / 2;
        }

        this.ctx.font = this._getFontString();

        this.ctx.rotate(Math.PI / 180 * this.angle);

        var textLeft = 0;
        var textTop = this.padding;
        //var textTop = this.padding;
        var line = null;

        if (!this.ctx.roundRect) extendCtx(this.ctx);

        if ((this.borderThickness > 0 && this.borderColor) || this.backgroundColor) {
            this.ctx.roundRect(0, offsetY, this.width, this.height, this.cornerRadius, this.borderThickness, this.backgroundColor, this.borderColor);

            //if (this.textBaseline === "middle") {
            //	//textTop += this.fontSize / 2;
            //	textTop += this._lineHeight / 2;
            //}
        }

        this.ctx.fillStyle = this.fontColor;

        for (var i = 0; i < this._wrappedText.lines.length; i++) {

            line = this._wrappedText.lines[i];
            if (this.horizontalAlign === "right")
                textLeft = this.width - line.width - this.padding;
            else if (this.horizontalAlign === "left")
                textLeft = this.padding;
            else if (this.horizontalAlign === "center")
                textLeft = (this.width - this.padding * 2) / 2 - line.width / 2 + this.padding;

            this.ctx.fillText(line.text, textLeft, textTop);

            textTop += line.height;
        }

        this.ctx.font = font;

        if (preserveContext)
            this.ctx.restore();
    }

    TextBlock.prototype.setText = function (text) {
        this.text = text;
        this._isDirty = true;
        this._wrappedText = null;
    }

    TextBlock.prototype.measureText = function () {
        this._lineHeight = getFontHeightInPixels(this.fontFamily, this.fontSize, this.fontWeight);

        if (this.maxWidth === null) {
            throw ("Please set maxWidth and height for TextBlock");
        }

        this._wrapText(this.ctx);
        this._isDirty = false;

        return {
            width: this.width, height: this.height
        }
    }

    TextBlock.prototype._getLineWithWidth = function (text, width, clipWord) {
        text = String(text);
        clipWord = clipWord || false;

        if (!text)
            return {
                text: "", width: 0
            };

        var textWidth = 0,
            min = 0,
            max = text.length - 1,
            mid = Infinity;

        this.ctx.font = this._getFontString();

        while (min <= max) {
            mid = Math.floor((min + max) / 2);
            var tempText = text.substr(0, mid + 1);

            textWidth = this.ctx.measureText(tempText).width;

            if (textWidth < width) {
                min = mid + 1;
            } else if (textWidth > width) {
                max = mid - 1;
            } else {
                break;
            }
        }

        //edge cases
        if (textWidth > width && tempText.length > 1) {
            tempText = tempText.substr(0, tempText.length - 1);
            textWidth = this.ctx.measureText(tempText).width;
        }

        var isClipped = true;

        if (tempText.length === text.length || text[tempText.length] === " ")
            isClipped = false;

        if (isClipped) {
            var resultWords = tempText.split(" ");
            if (resultWords.length > 1)
                resultWords.pop();

            tempText = resultWords.join(" ");
            textWidth = this.ctx.measureText(tempText).width;
        }

        return {
            text: tempText, width: textWidth
        };
    }

    TextBlock.prototype._wrapText = function wrapText() {
        //this.ctx.save();
        var text = new String(trimString(String(this.text)));
        var lines = [];
        var font = this.ctx.font; // Save the current Font
        var height = 0;
        var width = 0;

        this.ctx.font = this._getFontString();

        if (this.frontSize === 0)
            width = height = 0;
        else {
            while (text.length > 0) {

                var maxWidth = this.maxWidth - this.padding * 2;
                var maxHeight = this.maxHeight - this.padding * 2;

                var line = this._getLineWithWidth(text, maxWidth, false);
                line.height = this._lineHeight;

                lines.push(line);

                var prevWidth = width;
                width = Math.max(width, line.width);
                height += line.height;
                text = trimString(text.slice(line.text.length, text.length));

                if (maxHeight && height > maxHeight) {
                    var line = lines.pop();
                    height -= line.height;
                    width = prevWidth;
                }
            }
        }

        this._wrappedText = {
            lines: lines, width: width, height: height
        };
        this.width = width + this.padding * 2;
        this.height = height + this.padding * 2;

        this.ctx.font = font; // Restore the font
    }

    TextBlock.prototype._getFontString = function () {
        //return this.fontStyle + " " + this.fontWeight + " " + this.fontSize + "px " + this.fontFamily
        return getFontString("", this, null);
    }

    //#endregion Class TextBlock

    //#region Class Title

    function Title(chart, options) {
        Title.base.constructor.call(this, "Title", options, chart.theme, chart);

        this.chart = chart;
        this.canvas = chart.canvas;
        this.ctx = this.chart.ctx;

        this.optionsName = "title";

        //For assigning zero margin if title and subtitle situated at the same place
        if (isNullOrUndefined(this.options.margin) && chart.options.subtitles) {
            var subtitles = chart.options.subtitles;
            for (var i = 0; i < subtitles.length; i++) {
                if ((isNullOrUndefined(subtitles[i].horizontalAlign) && this.horizontalAlign === "center" || subtitles[i].horizontalAlign === this.horizontalAlign) && (isNullOrUndefined(subtitles[i].verticalAlign) && this.verticalAlign === "top" || subtitles[i].verticalAlign === this.verticalAlign) && (!subtitles[i].dockInsidePlotArea === !this.dockInsidePlotArea)) {
                    this.margin = 0;
                    break;
                }
            }
        }

        if (typeof (this.options.fontSize) === "undefined") {

            this.fontSize = this.chart.getAutoFontSize(this.fontSize);

            //window.console.log("Chart Title fontSize: " + this.fontSize);
        }

        this.width = null,//read only
            this.height = null//read only
        this.bounds = {
            x1: null, y1: null, x2: null, y2: null
        };
    }

    extend(Title, CanvasJSObject);
    Title.prototype.render = function () {

        if (!this.text)
            return;

        var container = (!this.dockInsidePlotArea ? this.chart : this.chart.plotArea);
        var freespace = container.layoutManager.getFreeSpace();
        var left = freespace.x1;
        var top = freespace.y1;
        var angle = 0;
        var maxHeight = 0;
        var containerMargin = 2; //Margin towards the container
        var rightOffset = this.chart._menuButton && this.chart.exportEnabled && this.verticalAlign === "top" ? 22 : 0; //So that Title doesn't overlap menu button.

        var textBlockHorizontalAlign;
        var position;

        if (this.verticalAlign === "top" || this.verticalAlign === "bottom") {
            if (this.maxWidth === null)
                this.maxWidth = freespace.width - containerMargin * 2 - rightOffset * (this.horizontalAlign === "center" ? 2 : 1);

            maxHeight = freespace.height * .5 - this.margin - containerMargin;
            angle = 0;
        }
        else if (this.verticalAlign === "center") {

            if (this.horizontalAlign === "left" || this.horizontalAlign === "right") {
                if (this.maxWidth === null)
                    this.maxWidth = freespace.height - containerMargin * 2;

                maxHeight = freespace.width * .5 - this.margin - containerMargin;
            } else if (this.horizontalAlign === "center") {
                if (this.maxWidth === null)
                    this.maxWidth = freespace.width - containerMargin * 2;

                maxHeight = freespace.height * .5 - containerMargin * 2;
            }
        }

        if (!this.wrap)
            maxHeight = Math.min(maxHeight, Math.max(this.fontSize * 1.5, this.fontSize + this.padding * 2.5));
        //console.log(this.maxWidth);

        var textBlock = new TextBlock(this.ctx, {
            fontSize: this.fontSize, fontFamily: this.fontFamily, fontColor: this.fontColor,
            fontStyle: this.fontStyle, fontWeight: this.fontWeight,
            horizontalAlign: this.horizontalAlign, verticalAlign: this.verticalAlign,
            borderColor: this.borderColor, borderThickness: this.borderThickness,
            backgroundColor: this.backgroundColor,
            maxWidth: this.maxWidth, maxHeight: maxHeight,
            cornerRadius: this.cornerRadius,
            text: this.text,
            padding: this.padding,
            textBaseline: "top"
        });

        var textBlockSize = textBlock.measureText();

        if (this.verticalAlign === "top" || this.verticalAlign === "bottom") {

            if (this.verticalAlign === "top") {
                top = freespace.y1 + containerMargin;
                position = "top";
            }
            else if (this.verticalAlign === "bottom") {
                top = freespace.y2 - containerMargin - textBlockSize.height;
                position = "bottom";
            }

            if (this.horizontalAlign === "left") {
                left = freespace.x1 + containerMargin;
            }
            else if (this.horizontalAlign === "center") {
                left = freespace.x1 + freespace.width / 2 - textBlockSize.width / 2;
            }
            else if (this.horizontalAlign === "right") {
                left = freespace.x2 - containerMargin - textBlockSize.width - rightOffset;
            }

            textBlockHorizontalAlign = this.horizontalAlign;

            this.width = textBlockSize.width;
            this.height = textBlockSize.height;
        }
        else if (this.verticalAlign === "center") {

            if (this.horizontalAlign === "left") {

                left = freespace.x1 + containerMargin;
                top = freespace.y2 - containerMargin - (this.maxWidth / 2 - textBlockSize.width / 2);
                angle = -90;

                position = "left";
                this.width = textBlockSize.height;
                this.height = textBlockSize.width;
            }
            else if (this.horizontalAlign === "right") {
                left = freespace.x2 - containerMargin;
                top = freespace.y1 + containerMargin + (this.maxWidth / 2 - textBlockSize.width / 2);
                angle = 90;

                position = "right";
                this.width = textBlockSize.height;
                this.height = textBlockSize.width;
            }
            else if (this.horizontalAlign === "center") {
                top = container.y1 + (container.height / 2 - textBlockSize.height / 2);
                left = container.x1 + (container.width / 2 - textBlockSize.width / 2);

                position = "center";
                this.width = textBlockSize.width;
                this.height = textBlockSize.height;
            }

            textBlockHorizontalAlign = "center";
        }

        textBlock.x = left;
        textBlock.y = top;
        textBlock.angle = angle;
        textBlock.horizontalAlign = textBlockHorizontalAlign;
        textBlock.render(true);

        container.layoutManager.registerSpace(position, {
            width: this.width + (position === "left" || position === "right" ? this.margin + containerMargin : 0),
            height: this.height + (position === "top" || position === "bottom" ? this.margin + containerMargin : 0)
        });

        this.bounds = {
            x1: left, y1: top, x2: left + this.width, y2: top + this.height
        };

        this.ctx.textBaseline = "top";
    }


    //#endregion Class Title

    //#region Class SubTitle

    function Subtitle(chart, options) {
        Subtitle.base.constructor.call(this, "Subtitle", options, chart.theme, chart);

        this.chart = chart;
        this.canvas = chart.canvas;
        this.ctx = this.chart.ctx;

        this.optionsName = "subtitles"
        this.isOptionsInArray = true;

        if (typeof (this.options.fontSize) === "undefined") {

            this.fontSize = this.chart.getAutoFontSize(this.fontSize);

            //window.console.log("Chart Title fontSize: " + this.fontSize);
        }

        this.width = null,//read only
            this.height = null//read only
        this.bounds = {
            x1: null, y1: null, x2: null, y2: null
        };
    }

    extend(Subtitle, CanvasJSObject);

    Subtitle.prototype.render = Title.prototype.render;

    //#endregion Class SubTitle

    //#region Legend

    //TBI: Implement Markes for Legend
    function Legend(chart, options) {
        Legend.base.constructor.call(this, "Legend", options, chart.theme, chart);

        this.chart = chart;
        this.canvas = chart.canvas;
        this.ctx = this.chart.ctx;
        this.ghostCtx = this.chart._eventManager.ghostCtx;
        this.items = [];

        this.optionsName = "legend";

        this.width = 0,
            //this.fontSize = 12,
            this.height = 0,
            this.orientation = null,
            this.dataSeries = [];
        this.bounds = {
            x1: null, y1: null, x2: null, y2: null
        };

        if (typeof (this.options.fontSize) === "undefined") {
            this.fontSize = this.chart.getAutoFontSize(this.fontSize);
            //window.console.log("fontSize: " + this.fontSize);
        }

        this.lineHeight = getFontHeightInPixels(this.fontFamily, this.fontSize, this.fontWeight);

        this.horizontalSpacing = this.fontSize;
    }
    extend(Legend, CanvasJSObject);

    Legend.prototype.render = function () {

        var container = (!this.dockInsidePlotArea ? this.chart : this.chart.plotArea);
        var freeSpace = container.layoutManager.getFreeSpace();
        var position = null;
        var top = 0;
        var left = 0;
        var maxWidth = 0;
        var maxHeight = 0;
        var markerMargin = this.markerMargin = this.chart.options.legend && !isNullOrUndefined(this.chart.options.legend.markerMargin) ? this.chart.options.legend.markerMargin : this.fontSize * 0.3;
        this.height = 0;

        var items = [];
        var rows = [];

        //this.ctx.font = getFontString("", this, null);
        //this.ctx.fontColor = this.fontColor;

        if (this.verticalAlign === "top" || this.verticalAlign === "bottom") {
            this.orientation = "horizontal";
            position = this.verticalAlign;

            maxWidth = this.maxWidth = this.maxWidth !== null ? this.maxWidth : freeSpace.width;
            maxHeight = this.maxHeight = this.maxHeight !== null ? this.maxHeight : freeSpace.height * .5;
        }
        else if (this.verticalAlign === "center") {
            this.orientation = "vertical";
            position = this.horizontalAlign;

            maxWidth = this.maxWidth = this.maxWidth !== null ? this.maxWidth : freeSpace.width * .5;
            maxHeight = this.maxHeight = this.maxHeight !== null ? this.maxHeight : freeSpace.height;
        }

        for (var i = 0; i < this.dataSeries.length; i++) {
            var dataSeries = this.dataSeries[i];
            //Added to avoid error generation because of absence of dataPoints array or elements
            if (!dataSeries.dataPoints || !dataSeries.dataPoints.length) continue;

            if (dataSeries.type !== "pie" && dataSeries.type !== "doughnut" && dataSeries.type !== "funnel") {

                var markerType = dataSeries.legendMarkerType = dataSeries.legendMarkerType ? dataSeries.legendMarkerType : (dataSeries.type === "line" || dataSeries.type === "stepLine" || dataSeries.type === "spline" || dataSeries.type === "scatter" || dataSeries.type === "bubble") && dataSeries.markerType ? dataSeries.markerType : DataSeries.getDefaultLegendMarker(dataSeries.type);
                var legendText = dataSeries.legendText ? dataSeries.legendText : this.itemTextFormatter ? this.itemTextFormatter({ chart: this.chart, legend: this.options, dataSeries: dataSeries, dataPoint: null })
                    : dataSeries.name;
                var markerColor = dataSeries.legendMarkerColor = dataSeries.legendMarkerColor ? dataSeries.legendMarkerColor : dataSeries.markerColor ? dataSeries.markerColor : dataSeries._colorSet[0];
                var markerSize = (!dataSeries.markerSize && (dataSeries.type === "line" || dataSeries.type === "stepLine" || dataSeries.type === "spline")) ? 0 : this.lineHeight * .75;
                var markerBorderColor = dataSeries.legendMarkerBorderColor ? dataSeries.legendMarkerBorderColor : dataSeries.markerBorderColor;
                var markerBorderThickness = dataSeries.legendMarkerBorderThickness ? dataSeries.legendMarkerBorderThickness : dataSeries.markerBorderThickness ? Math.max(1, Math.round(markerSize * .2)) : 0;
                var lineColor = dataSeries._colorSet[0];

                legendText = this.chart.replaceKeywordsWithValue(legendText, dataSeries.dataPoints[0], dataSeries, i);
                var item = {
                    markerType: markerType, markerColor: markerColor, text: legendText, textBlock: null, chartType: dataSeries.type, markerSize: markerSize, lineColor: dataSeries._colorSet[0],
                    dataSeriesIndex: dataSeries.index, dataPointIndex: null, markerBorderColor: markerBorderColor, markerBorderThickness: markerBorderThickness
                };

                items.push(item);
            } else {
                for (var dataPointIndex = 0; dataPointIndex < dataSeries.dataPoints.length; dataPointIndex++) {

                    var dataPoint = dataSeries.dataPoints[dataPointIndex];

                    var markerType = dataPoint.legendMarkerType ? dataPoint.legendMarkerType : dataSeries.legendMarkerType ? dataSeries.legendMarkerType : DataSeries.getDefaultLegendMarker(dataSeries.type);
                    var legendText = dataPoint.legendText ? dataPoint.legendText : dataSeries.legendText ? dataSeries.legendText : this.itemTextFormatter ? this.itemTextFormatter({ chart: this.chart, legend: this.options, dataSeries: dataSeries, dataPoint: dataPoint })
                        : dataPoint.name ? dataPoint.name : "DataPoint: " + (dataPointIndex + 1);
                    var markerColor = dataPoint.legendMarkerColor ? dataPoint.legendMarkerColor : dataSeries.legendMarkerColor ? dataSeries.legendMarkerColor : dataPoint.color ? dataPoint.color : dataSeries.color ? dataSeries.color : dataSeries._colorSet[dataPointIndex % dataSeries._colorSet.length];
                    var markerSize = this.lineHeight * .75;
                    var markerBorderColor = dataPoint.legendMarkerBorderColor ? dataPoint.legendMarkerBorderColor : dataSeries.legendMarkerBorderColor ? dataSeries.legendMarkerBorderColor : dataPoint.markerBorderColor ? dataPoint.markerBorderColor : dataSeries.markerBorderColor;
                    var markerBorderThickness = dataPoint.legendMarkerBorderThickness ? dataPoint.legendMarkerBorderThickness : dataSeries.legendMarkerBorderThickness ? dataSeries.legendMarkerBorderThickness : dataPoint.markerBorderThickness || dataSeries.markerBorderThickness ? Math.max(1, Math.round(markerSize * .2)) : 0;

                    legendText = this.chart.replaceKeywordsWithValue(legendText, dataPoint, dataSeries, dataPointIndex);

                    var item = {
                        markerType: markerType, markerColor: markerColor, text: legendText, textBlock: null, chartType: dataSeries.type, markerSize: markerSize,
                        dataSeriesIndex: i, dataPointIndex: dataPointIndex, markerBorderColor: markerBorderColor, markerBorderThickness: markerBorderThickness
                    };

                    if (dataPoint.showInLegend || (dataSeries.showInLegend && dataPoint.showInLegend !== false)) {
                        items.push(item);
                    }
                }
            }
            item = null;
        }
        if (this.reversed === true) {
            items.reverse();
        }

        // Find out the required width and height of Legend and position the items relative to the container
        if (items.length > 0) {
            var row = null;
            var rowIndex = 0; // required for vertical orientation
            var textMaxWidth = 0;
            var columnHeight = 0;
            var itemWidth = 0;

            if (this.itemWidth !== null) {
                if (this.itemMaxWidth !== null) {
                    textMaxWidth = Math.min(this.itemWidth, this.itemMaxWidth, maxWidth);
                } else {
                    textMaxWidth = this.itemMaxWidth = Math.min(this.itemWidth, maxWidth);
                }
            } else {
                if (this.itemMaxWidth !== null) {
                    textMaxWidth = Math.min(this.itemMaxWidth, maxWidth);
                } else {
                    textMaxWidth = this.itemMaxWidth = maxWidth;
                }
            }

            markerSize = (markerSize === 0 ? this.lineHeight * .75 : markerSize);
            textMaxWidth = textMaxWidth - (markerSize + markerMargin);

            for (var i = 0; i < items.length; i++) {
                var item = items[i];

                if (item.chartType === "line" || item.chartType === "spline" || item.chartType === "stepLine") {
                    textMaxWidth = textMaxWidth - 2 * (this.lineHeight * .1);
                }

                if (maxHeight <= 0 || typeof (maxHeight) === "undefined" || textMaxWidth <= 0 || typeof (textMaxWidth) === "undefined") {
                    continue;
                }

                if (this.orientation === "horizontal") {

                    item.textBlock = new TextBlock(this.ctx, {
                        x: 0,
                        y: 0,//TBI
                        maxWidth: textMaxWidth,
                        maxHeight: this.itemWrap ? maxHeight : this.lineHeight, //TBI: FontSize
                        angle: 0,
                        text: item.text,
                        horizontalAlign: "left",//left, center, right
                        fontSize: this.fontSize,//in pixels
                        fontFamily: this.fontFamily,
                        fontWeight: this.fontWeight, //normal, bold, bolder, lighter,
                        fontColor: this.fontColor,
                        fontStyle: this.fontStyle, // normal, italic, oblique
                        textBaseline: "middle"
                    });
                    item.textBlock.measureText();

                    if (this.itemWidth !== null) {
                        item.textBlock.width = this.itemWidth - (markerSize + markerMargin + ((item.chartType === "line" || item.chartType === "spline" || item.chartType === "stepLine") ? 2 * (this.lineHeight * .1) : 0));
                    }

                    if (!row || row.width + Math.round(item.textBlock.width + markerSize + markerMargin + (row.width === 0 ? 0 : (this.horizontalSpacing)) + ((item.chartType === "line" || item.chartType === "spline" || item.chartType === "stepLine") ? 2 * (this.lineHeight * .1) : 0)) > maxWidth) {
                        row = {
                            items: [], width: 0
                        };
                        rows.push(row);
                        this.height += columnHeight;
                        columnHeight = 0;
                    }

                    columnHeight = Math.max(columnHeight, item.textBlock.height);

                    item.textBlock.x = row.width;
                    item.textBlock.y = 0;

                    row.width += Math.round(item.textBlock.width + markerSize + markerMargin + (row.width === 0 ? 0 : this.horizontalSpacing) + ((item.chartType === "line" || item.chartType === "spline" || item.chartType === "stepLine") ? 2 * (this.lineHeight * .1) : 0));
                    row.items.push(item);

                    this.width = Math.max(row.width, this.width);
                } else {

                    item.textBlock = new TextBlock(this.ctx, {
                        x: 0,
                        y: 0,//TBI
                        maxWidth: textMaxWidth,
                        maxHeight: this.itemWrap === true ? maxHeight : this.fontSize * 1.5, //TBI: FontSize
                        angle: 0,
                        text: item.text,
                        horizontalAlign: "left",//left, center, right
                        fontSize: this.fontSize,//in pixels
                        fontFamily: this.fontFamily,
                        fontWeight: this.fontWeight, //normal, bold, bolder, lighter,
                        fontColor: this.fontColor,
                        fontStyle: this.fontStyle, // normal, italic, oblique
                        textBaseline: "middle"
                    });

                    item.textBlock.measureText();

                    if (this.itemWidth !== null) {
                        item.textBlock.width = this.itemWidth - (markerSize + markerMargin + ((item.chartType === "line" || item.chartType === "spline" || item.chartType === "stepLine") ? 2 * (this.lineHeight * .1) : 0));
                    }

                    if (this.height < maxHeight - this.lineHeight) {
                        row = {
                            items: [], width: 0
                        };
                        rows.push(row);
                    } else {
                        row = rows[rowIndex];
                        rowIndex = (rowIndex + 1) % rows.length;
                    }

                    this.height += item.textBlock.height;

                    item.textBlock.x = row.width; // relative to the row
                    item.textBlock.y = 0; // relative to the row

                    row.width += Math.round(item.textBlock.width + markerSize + markerMargin + (row.width === 0 ? 0 : this.horizontalSpacing) + ((item.chartType === "line" || item.chartType === "spline" || item.chartType === "stepLine") ? 2 * (this.lineHeight * .1) : 0));
                    row.items.push(item);

                    this.width = Math.max(row.width, this.width);
                }
                itemWidth = item.textBlock.width + (markerSize + markerMargin + ((item.chartType === "line" || item.chartType === "spline" || item.chartType === "stepLine") ? 2 * (this.lineHeight * .1) : 0));
            }
            this.itemWidth = itemWidth;

            if (this.itemWrap === false) {
                this.height = rows.length * (this.lineHeight);
            } else {
                this.height += columnHeight;
            }

            this.height = Math.min(maxHeight, this.height);
            this.width = Math.min(maxWidth, this.width);
        }

        if (this.verticalAlign === "top") {
            if (this.horizontalAlign === "left")
                left = freeSpace.x1;
            else if (this.horizontalAlign === "right")
                left = freeSpace.x2 - this.width;
            else
                left = freeSpace.x1 + freeSpace.width / 2 - this.width / 2;

            top = freeSpace.y1;
        } else if (this.verticalAlign === "center") {
            if (this.horizontalAlign === "left")
                left = freeSpace.x1;
            else if (this.horizontalAlign === "right")
                left = freeSpace.x2 - this.width;
            else
                left = freeSpace.x1 + freeSpace.width / 2 - this.width / 2;

            top = freeSpace.y1 + freeSpace.height / 2 - this.height / 2;
        } else if (this.verticalAlign === "bottom") {
            if (this.horizontalAlign === "left")
                left = freeSpace.x1;
            else if (this.horizontalAlign === "right")
                left = freeSpace.x2 - this.width;
            else
                left = freeSpace.x1 + freeSpace.width / 2 - this.width / 2;

            top = freeSpace.y2 - this.height;
        }

        this.items = items;

        //Assign ids to all legendItems
        for (var i = 0; i < this.items.length; i++) {

            var item = items[i];

            item.id = ++this.chart._eventManager.lastObjectId;
            this.chart._eventManager.objectMap[item.id] = {
                id: item.id, objectType: "legendItem", legendItemIndex: i, dataSeriesIndex: item.dataSeriesIndex, dataPointIndex: item.dataPointIndex
            };
            //delete item.textBlock;// Not Required anymore
        }

        if ((this.borderThickness > 0 && this.borderColor) || this.backgroundColor) {
            this.ctx.roundRect(left, top, this.width, this.height, this.cornerRadius, this.borderThickness, this.backgroundColor, this.borderColor);
        }

        var rowHeight = 0;
        for (var i = 0; i < rows.length; i++) {
            var row = rows[i];
            var columnHeight = 0;
            for (var itemIndex = 0; itemIndex < row.items.length; itemIndex++) {
                var item = row.items[itemIndex];

                var itemX = item.textBlock.x + left + (itemIndex === 0 ? markerSize * .2 : this.horizontalSpacing);
                var itemY = top + rowHeight;

                var ghostX = itemX;

                if (!this.chart.data[item.dataSeriesIndex].visible)
                    this.ctx.globalAlpha = .5;

                this.ctx.save();
                this.ctx.beginPath();
                this.ctx.rect(left, top, maxWidth, Math.max(maxHeight - (maxHeight % this.lineHeight), 0));
                this.ctx.clip();

                if (item.chartType === "line" || item.chartType === "stepLine" || item.chartType === "spline") {
                    this.ctx.strokeStyle = item.lineColor;
                    this.ctx.lineWidth = Math.ceil(this.lineHeight / 8);
                    this.ctx.beginPath();
                    this.ctx.moveTo(itemX - this.lineHeight * .1, itemY + this.lineHeight / 2);
                    this.ctx.lineTo(itemX + this.lineHeight * .85, itemY + this.lineHeight / 2);
                    this.ctx.stroke();

                    ghostX -= this.lineHeight * .1;
                }

                RenderHelper.drawMarker(itemX + markerSize / 2, itemY + (this.lineHeight / 2), this.ctx, item.markerType, item.markerSize, item.markerColor, item.markerBorderColor, item.markerBorderThickness);

                item.textBlock.x = itemX + markerMargin + markerSize;

                if (item.chartType === "line" || item.chartType === "stepLine" || item.chartType === "spline") {
                    item.textBlock.x = item.textBlock.x + this.lineHeight * .1;
                }

                item.textBlock.y = Math.round(itemY + this.lineHeight / 2);

                item.textBlock.render(true);

                this.ctx.restore();

                if (itemIndex > 0) {
                    columnHeight = Math.max(columnHeight, item.textBlock.height);
                } else {
                    columnHeight = item.textBlock.height;
                }

                if (!this.chart.data[item.dataSeriesIndex].visible)
                    this.ctx.globalAlpha = 1;

                var hexColor = intToHexColorString(item.id);
                this.ghostCtx.fillStyle = hexColor;
                this.ghostCtx.beginPath();
                this.ghostCtx.fillRect(ghostX, item.textBlock.y - this.lineHeight / 2, item.textBlock.x + item.textBlock.width - ghostX, item.textBlock.height);

                item.x1 = this.chart._eventManager.objectMap[item.id].x1 = ghostX;
                item.y1 = this.chart._eventManager.objectMap[item.id].y1 = item.textBlock.y - this.lineHeight / 2;
                item.x2 = this.chart._eventManager.objectMap[item.id].x2 = item.textBlock.x + item.textBlock.width;
                item.y2 = this.chart._eventManager.objectMap[item.id].y2 = item.textBlock.y + item.textBlock.height - this.lineHeight / 2;
            }
            rowHeight = rowHeight + columnHeight;
        }

        //this.ctx.beginPath();
        //this.ctx.lineWidth = 2;
        //this.ctx.strokeStyle = "red";
        //this.ctx.rect(left, top, this.width, this.height);
        //this.ctx.stroke();

        if (items.length > 0)
            container.layoutManager.registerSpace(position, { width: this.width + 2 + 2, height: this.height + 5 + 5 });

        this.bounds = {
            x1: left, y1: top, x2: left + this.width, y2: top + this.height
        };
    }

    //#endregion Legend

    //#region Class PlotArea
    function PlotArea(chart, options) {
        PlotArea.base.constructor.call(this, options);

        this.chart = chart;
        this.canvas = chart.canvas;
        this.ctx = this.chart.ctx;
    }
    extend(PlotArea, CanvasJSObject);

    PlotArea.prototype.render = function () {
        var freeSpace = this.chart.layoutManager.getFreeSpace();
        this.ctx.fillStyle = "red";
        this.ctx.fillRect(freeSpace.x1, freeSpace.y1, freeSpace.x2, freeSpace.y2);

    }
    //#endregion Class PlotArea

    //#region DataSeries

    function DataSeries(chart, options, index, id) {
        DataSeries.base.constructor.call(this, "DataSeries", options, chart.theme, chart);

        this.chart = chart;
        this.canvas = chart.canvas;
        this._ctx = chart.canvas.ctx;
        this.index = index;
        this.noDataPointsInPlotArea = 0;
        //this.maxWidthInX = 0;
        this.id = id;
        this.chart._eventManager.objectMap[id] = {
            id: id, objectType: "dataSeries", dataSeriesIndex: index
        }
        this.dataPointIds = [];
        this.plotUnit = [];

        this.axisX = null;
        this.axisY = null;

        this.optionsName = "data"
        this.isOptionsInArray = true;

        if (this.fillOpacity === null) {
            if (this.type.match(/area/i))
                this.fillOpacity = .7;
            else
                this.fillOpacity = 1;
        }


        this.axisPlacement = this.getDefaultAxisPlacement();

        if (typeof (this.options.indexLabelFontSize) === "undefined") {

            this.indexLabelFontSize = this.chart.getAutoFontSize(this.indexLabelFontSize);
        }
    }
    extend(DataSeries, CanvasJSObject);

    //Static Method that returns the axisPlacement for a given ChartType. Returns one of "normal", "xySwapped", "none"
    DataSeries.prototype.getDefaultAxisPlacement = function () {

        //if (!this.visible)
        //	return "none";

        //type = this.type.toLowerCase();
        var type = this.type;

        if (type === "column" || type === "line" || type === "stepLine" || type === "spline" || type === "area" || type === "stepArea" || type === "splineArea" || type === "stackedColumn" || type === "stackedLine" || type === "bubble" || type === "scatter"
            || type === "stackedArea" || type === "stackedColumn100" || type === "stackedLine100" || type === "stackedArea100"
            || type === "candlestick" || type === "ohlc" || type === "rangeColumn" || type === "rangeArea" || type === "rangeSplineArea") {
            return "normal";
        }
        else if (type === "bar" || type === "stackedBar" || type === "stackedBar100" || type === "rangeBar") {

            return "xySwapped";
        }
        else if (type === "pie" || type === "doughnut" || type === "funnel") {
            return "none";
        } else {
            window.console.log("Unknown Chart Type: " + type);
            return null;
        }
    }

    DataSeries.getDefaultLegendMarker = function (type) {

        //type = type.toLowerCase();

        if (type === "column" || type === "stackedColumn" || type === "stackedLine" || type === "bar" || type === "stackedBar" || type === "stackedBar100"
            || type === "bubble" || type === "scatter"
            || type === "stackedColumn100" || type === "stackedLine100" || type === "stepArea"
            || type === "candlestick" || type === "ohlc" || type === "rangeColumn" || type === "rangeBar" || type === "rangeArea" || type === "rangeSplineArea") {
            return "square";
        }
        else if (type === "line" || type === "stepLine" || type === "spline" || type === "pie" || type === "doughnut" || type === "funnel") {
            return "circle";
        } else if (type === "area" || type === "splineArea" || type === "stackedArea" || type === "stackedArea100") {
            return "triangle"
        } else {
            window.console.log("Unknown Chart Type: " + type);
            return null;
        }
    }

    //Finds dataPoint with the given x value. If findClosest is set, finds dataPoint with closest x value.
    //Returns searchResult object if found, else returns null
    DataSeries.prototype.getDataPointAtX = function (x, findClosest) {

        if (!this.dataPoints || this.dataPoints.length === 0) return null;

        var searchResult = {
            dataPoint: null, distance: Infinity, index: NaN
        };
        var dataPoint = null;

        var j = 0;
        var i = 0;
        var direction = 1; // +1 for foward and -1 for backward.

        var minimumXDistance = Infinity;
        var forwardMissCount = 0, backwardMissCount = 0;
        var maxMissCount = 1000;
        var searchStartIndex = 0;

        if (this.chart.plotInfo.axisPlacement !== "none") {

            //var xRange = (this.dataPoints[this.dataPoints.length - 1].x - this.dataPoints[0].x);

            //if (xRange > 0)
            //	searchStartIndex = ((this.dataPoints.length - 1) / xRange * (x - this.dataPoints[0].x)) >> 0;
            //else
            //	searchStartIndex = 0;
            if (this.axisX.logarithmic) {
                var xRange = Math.log(this.dataPoints[this.dataPoints.length - 1].x / this.dataPoints[0].x);
                if (xRange > 1)
                    searchStartIndex = Math.min(Math.max(((this.dataPoints.length - 1) / xRange * Math.log(x / this.dataPoints[0].x)) >> 0, 0), this.dataPoints.length);
                else
                    searchStartIndex = 0;
            } else {
                var xRange = (this.dataPoints[this.dataPoints.length - 1].x - this.dataPoints[0].x);

                if (xRange > 0)
                    searchStartIndex = Math.min(Math.max(((this.dataPoints.length - 1) / xRange * (x - this.dataPoints[0].x)) >> 0, 0), this.dataPoints.length);
                else
                    searchStartIndex = 0;
            }

            //searchStartIndex = ((this.dataPoints[this.dataPoints.length - 1].x - this.dataPoints[0].x) / this.dataPoints.length * (x - this.dataPoints[0].x)) >> 0;
        }

        while (true) {

            i = (direction > 0) ? searchStartIndex + j : searchStartIndex - j;

            if (i >= 0 && i < this.dataPoints.length) {

                dataPoint = this.dataPoints[i];

                var distance = this.axisX.logarithmic ? dataPoint.x > x ? dataPoint.x / x : x / dataPoint.x : Math.abs(dataPoint.x - x);

                if (distance < searchResult.distance) {
                    searchResult.dataPoint = dataPoint;
                    searchResult.distance = distance;
                    searchResult.index = i;
                }

                var xDistance = distance; //Math.abs(dataPoint.x - x);
                if (xDistance <= minimumXDistance)
                    minimumXDistance = xDistance;
                else {
                    if (direction > 0)
                        forwardMissCount++;
                    else
                        backwardMissCount++;
                }

                if (forwardMissCount > maxMissCount && backwardMissCount > maxMissCount)
                    break;


            } else if (searchStartIndex - j < 0 && searchStartIndex + j >= this.dataPoints.length)
                break;

            if (direction === -1) {
                j++;
                direction = 1;
            } else
                direction = -1;
        }


        if (!findClosest && searchResult.dataPoint.x === x)
            return searchResult;
        else if (findClosest && searchResult.dataPoint !== null)
            return searchResult;
        else
            return null;
    }

    // x & y should be in pixels. Can be used only after rendering the chart.
    DataSeries.prototype.getDataPointAtXY = function (x, y, getClosest) {

        if (!this.dataPoints || this.dataPoints.length === 0 || x < this.chart.plotArea.x1 || x > this.chart.plotArea.x2 || y < this.chart.plotArea.y1 || y > this.chart.plotArea.y2) return null;

        getClosest = getClosest || false;
        var results = [];
        var j = 0, i = 0;
        var direction = 1; // +1 for foward and -1 for backward.
        var foundDataPoint = false;
        var minimumXDistance = Infinity;
        var forwardMissCount = 0, backwardMissCount = 0;
        var maxMissCount = 1000;
        var searchStartIndex = 0;

        if (this.chart.plotInfo.axisPlacement !== "none") {
            var xAxis = this.chart.axisX[0] ? this.chart.axisX[0] : this.chart.axisX2[0];
            var xval = xAxis.getXValueAt({ x: x, y: y });

            if (this.axisX.logarithmic) {
                var xRange = Math.log(this.dataPoints[this.dataPoints.length - 1].x / this.dataPoints[0].x);
                if (xRange > 1)
                    searchStartIndex = Math.min(Math.max(((this.dataPoints.length - 1) / xRange * Math.log(xval / this.dataPoints[0].x)) >> 0, 0), this.dataPoints.length);
                else
                    searchStartIndex = 0;
            } else {
                var xRange = (this.dataPoints[this.dataPoints.length - 1].x - this.dataPoints[0].x);

                if (xRange > 0)
                    searchStartIndex = Math.min(Math.max(((this.dataPoints.length - 1) / xRange * (xval - this.dataPoints[0].x)) >> 0, 0), this.dataPoints.length);
                else
                    searchStartIndex = 0;

                //var xRange = (this.axisX._absoluteMaximum - this.axisX._absoluteMinimum);

                //if (xRange > 0)
                //	searchStartIndex = Math.min(Math.max(((this.dataPoints.length - 1) / xRange * (xval - this.axisX._absoluteMinimum)) >> 0, 0), this.dataPoints.length);
                //else
                //	searchStartIndex = 0;
            }
        }

        while (true) {

            //i = searchStartIndex + (j * direction);
            i = (direction > 0) ? searchStartIndex + j : searchStartIndex - j;

            if (i >= 0 && i < this.dataPoints.length) {

                var id = this.dataPointIds[i];
                var visualInfo = this.chart._eventManager.objectMap[id];
                var dataPoint = this.dataPoints[i];
                var distance = null;

                if (visualInfo) {

                    switch (this.type) {

                        case "column":
                        case "stackedColumn":
                        case "stackedColumn100":
                        case "bar":
                        case "stackedBar":
                        case "stackedBar100":
                        case "rangeColumn":
                        case "rangeBar":

                            if (x >= visualInfo.x1 && x <= visualInfo.x2 && y >= visualInfo.y1 && y <= visualInfo.y2) {
                                results.push({
                                    dataPoint: dataPoint,
                                    dataPointIndex: i,
                                    dataSeries: this,
                                    distance: Math.min(Math.abs(visualInfo.x1 - x), Math.abs(visualInfo.x2 - x), Math.abs(visualInfo.y1 - y), Math.abs(visualInfo.y2 - y))
                                    //distance:0
                                });

                                foundDataPoint = true;
                            }
                            break;

                        case "line":
                        case "stepLine":
                        case "spline":
                        case "area":
                        case "stepArea":
                        case "stackedArea":
                        case "stackedArea100":
                        case "splineArea":
                        case "scatter":
                            var markerSize = getProperty("markerSize", dataPoint, this) || 4;
                            var snapDistance = getClosest ? 20 : markerSize;

                            distance = Math.sqrt(Math.pow(visualInfo.x1 - x, 2) + Math.pow(visualInfo.y1 - y, 2));
                            if (distance <= snapDistance) {
                                results.push({
                                    dataPoint: dataPoint,
                                    dataPointIndex: i,
                                    dataSeries: this,
                                    distance: distance
                                });
                            }

                            var xDistance = Math.abs(visualInfo.x1 - x);
                            if (xDistance <= minimumXDistance)
                                minimumXDistance = xDistance;
                            else {
                                if (direction > 0)
                                    forwardMissCount++;
                                else
                                    backwardMissCount++;
                            }

                            if (distance <= markerSize / 2) {
                                foundDataPoint = true;
                            }

                            break;

                        case "rangeArea":
                        case "rangeSplineArea":

                            var markerSize = getProperty("markerSize", dataPoint, this) || 4;
                            var snapDistance = getClosest ? 20 : markerSize;

                            distance = Math.min(Math.sqrt(Math.pow(visualInfo.x1 - x, 2) + Math.pow(visualInfo.y1 - y, 2)), Math.sqrt(Math.pow(visualInfo.x1 - x, 2) + Math.pow(visualInfo.y2 - y, 2)));
                            if (distance <= snapDistance) {
                                results.push({
                                    dataPoint: dataPoint,
                                    dataPointIndex: i,
                                    dataSeries: this,
                                    distance: distance
                                });
                            }

                            var xDistance = Math.abs(visualInfo.x1 - x);
                            if (xDistance <= minimumXDistance)
                                minimumXDistance = xDistance;
                            else {
                                if (direction > 0)
                                    forwardMissCount++;
                                else
                                    backwardMissCount++;
                            }

                            if (distance <= markerSize / 2) {
                                foundDataPoint = true;
                            }

                            break;

                        case "bubble":
                            var markerSize = visualInfo.size;
                            distance = Math.sqrt(Math.pow(visualInfo.x1 - x, 2) + Math.pow(visualInfo.y1 - y, 2));
                            if (distance <= markerSize / 2) {
                                results.push({
                                    dataPoint: dataPoint,
                                    dataPointIndex: i,
                                    dataSeries: this,
                                    distance: distance
                                });

                                foundDataPoint = true;
                            }
                            break;

                        case "pie":
                        case "doughnut":
                            var center = visualInfo.center;
                            var innerRadius = this.type === "doughnut" ? visualInfo.percentInnerRadius * visualInfo.radius : 0;

                            distance = Math.sqrt(Math.pow(center.x - x, 2) + Math.pow(center.y - y, 2));
                            if (distance < visualInfo.radius && distance > innerRadius) {

                                var deltaY = y - center.y;
                                var deltaX = x - center.x;
                                var angle = Math.atan2(deltaY, deltaX);

                                if (angle < 0)
                                    angle += Math.PI * 2;

                                angle = Number((((angle / Math.PI * 180 % 360) + 360) % 360).toFixed(12));
                                //console.log(angle);


                                var startAngle = Number((((visualInfo.startAngle / Math.PI * 180 % 360) + 360) % 360).toFixed(12));
                                var endAngle = Number((((visualInfo.endAngle / Math.PI * 180 % 360) + 360) % 360).toFixed(12));

                                //So that data point is detected when there is only one dataPoint
                                if (endAngle === 0 && visualInfo.endAngle > 1) {
                                    endAngle = 360;
                                }

                                if (startAngle >= endAngle && dataPoint.y !== 0) {
                                    endAngle += 360;

                                    if (angle < startAngle)
                                        angle += 360;
                                }


                                if (angle > startAngle && angle < endAngle) {
                                    results.push({
                                        dataPoint: dataPoint,
                                        dataPointIndex: i,
                                        dataSeries: this,
                                        distance: 0
                                    });

                                    foundDataPoint = true;
                                }

                            }

                            break;

                        case "candlestick":
                            if (((x >= (visualInfo.x1 - visualInfo.borderThickness / 2)) && (x <= (visualInfo.x2 + visualInfo.borderThickness / 2))
                                && (y >= visualInfo.y2 - visualInfo.borderThickness / 2) && (y <= visualInfo.y3 + visualInfo.borderThickness / 2))
                                || (Math.abs(visualInfo.x2 - x + visualInfo.x1 - x) < visualInfo.borderThickness && (y >= visualInfo.y1 && y <= visualInfo.y4))) {
                                results.push({
                                    dataPoint: dataPoint,
                                    dataPointIndex: i,
                                    dataSeries: this,
                                    distance: Math.min(Math.abs(visualInfo.x1 - x), Math.abs(visualInfo.x2 - x), Math.abs(visualInfo.y2 - y), Math.abs(visualInfo.y3 - y))
                                    //distance:0
                                });

                                foundDataPoint = true;
                            }
                            break;

                        case "ohlc":

                            if ((Math.abs(visualInfo.x2 - x + visualInfo.x1 - x) < visualInfo.borderThickness && (y >= visualInfo.y2 && y <= visualInfo.y3))

                                || (x >= visualInfo.x1 && (x <= (visualInfo.x2 + visualInfo.x1) / 2)
                                    && (y >= visualInfo.y1 - visualInfo.borderThickness / 2) && (y <= visualInfo.y1 + visualInfo.borderThickness / 2))

                                || ((x >= (visualInfo.x1 + visualInfo.x2) / 2) && (x <= visualInfo.x2)
                                    && (y >= visualInfo.y4 - visualInfo.borderThickness / 2) && (y <= visualInfo.y4 + visualInfo.borderThickness / 2))) {

                                results.push({
                                    dataPoint: dataPoint,
                                    dataPointIndex: i,
                                    dataSeries: this,
                                    distance: Math.min(Math.abs(visualInfo.x1 - x), Math.abs(visualInfo.x2 - x), Math.abs(visualInfo.y2 - y), Math.abs(visualInfo.y3 - y))
                                    //distance:0
                                });

                                foundDataPoint = true;
                            }
                            break;

                    }

                    if (foundDataPoint || (forwardMissCount > maxMissCount && backwardMissCount > maxMissCount))
                        break;
                }

            } else if (searchStartIndex - j < 0 && searchStartIndex + j >= this.dataPoints.length)
                break;

            if (direction === -1) {
                j++;
                direction = 1;
            } else
                direction = -1;

        }



        var closestResult = null;

        for (var m = 0; m < results.length; m++) {
            if (!closestResult) {
                closestResult = results[m];
            } else if (results[m].distance <= closestResult.distance) {
                closestResult = results[m];
            }
        }

        //if (window.console)
        //	window.console.log("forwardMissCount: " + forwardMissCount + "; backwardMissCount: " + backwardMissCount + "; getClosest: " + getClosest);

        //if (window.console && closestResult)
        //    window.console.log(j + ": distance = " + closestResult.distance);

        return closestResult;
    }

    DataSeries.prototype.getMarkerProperties = function (index, x, y, ctx) {
        var dataPoints = this.dataPoints;
        var dataSeries = this;

        var markerColor = dataPoints[index].markerColor ? dataPoints[index].markerColor : dataSeries.markerColor ? dataSeries.markerColor : dataPoints[index].color ? dataPoints[index].color : dataSeries.color ? dataSeries.color : dataSeries._colorSet[index % dataSeries._colorSet.length];
        var markerBorderColor = dataPoints[index].markerBorderColor ? dataPoints[index].markerBorderColor : dataSeries.markerBorderColor ? dataSeries.markerBorderColor : null;
        var markerBorderThickness = dataPoints[index].markerBorderThickness ? dataPoints[index].markerBorderThickness : dataSeries.markerBorderThickness ? dataSeries.markerBorderThickness : null;
        var markerType = dataPoints[index].markerType ? dataPoints[index].markerType : dataSeries.markerType;
        var markerSize = dataPoints[index].markerSize ? dataPoints[index].markerSize : dataSeries.markerSize;


        return {
            x: x, y: y, ctx: ctx,
            type: markerType,
            size: markerSize,
            color: markerColor,
            borderColor: markerBorderColor,
            borderThickness: markerBorderThickness
        }
    }
    //#endregion DataSeries

    //#region Axis

    function Axis(chart, options, type, position, index) {
        Axis.base.constructor.call(this, "Axis", options, chart.theme, chart);

        this.chart = chart;
        this.canvas = chart.canvas;
        this.ctx = chart.ctx;
        this.maxWidth = 0;
        this.maxHeight = 0;
        this.intervalStartPosition = 0;
        this.labels = [];
        this.dataSeries = [];
        this._labels = null;
        this._ticks = null;
        this._stripLineLabels = null;

        //Processed information about the data that gets plotted against this axis
        this.dataInfo = {
            min: Infinity,
            max: -Infinity,
            viewPortMin: Infinity,
            viewPortMax: -Infinity,
            minDiff: Infinity // Used only in case of axisX
        };

        this.isOptionsInArray = true;

        if (type === "axisX") {
            if (position === "left" || position === "bottom") {
                this.optionsName = "axisX";
                if (isNullOrUndefined(this.chart.sessionVariables["axisX"][index]))
                    this.chart.sessionVariables["axisX"][index] = {};

                this.sessionVariables = this.chart.sessionVariables["axisX"][index];
            }
            else {
                this.optionsName = "axisX2";
                if (isNullOrUndefined(this.chart.sessionVariables["axisX2"][index]))
                    this.chart.sessionVariables["axisX2"][index] = {};

                this.sessionVariables = this.chart.sessionVariables["axisX2"][index];
            }

            if (!this.options.interval)
                this.intervalType = null;

            //Temporary Fix for axisX Line in theme2: In theme2 we need lineThickness of 0 only for Y axis.
            if (this.chart.theme === "theme2" && isNullOrUndefined(this.options.lineThickness)) {
                this.lineThickness = 2;
            }
        } else {
            if (position === "left" || position === "top") {
                this.optionsName = "axisY";
                if (isNullOrUndefined(this.chart.sessionVariables["axisY"][index]))
                    this.chart.sessionVariables["axisY"][index] = {};

                this.sessionVariables = this.chart.sessionVariables["axisY"][index];
            }
            else {
                this.optionsName = "axisY2";
                if (isNullOrUndefined(this.chart.sessionVariables["axisY2"][index]))
                    this.chart.sessionVariables["axisY2"][index] = {};

                this.sessionVariables = this.chart.sessionVariables["axisY2"][index];
            }
        }


        if (typeof (this.options.titleFontSize) === "undefined") {

            this.titleFontSize = this.chart.getAutoFontSize(this.titleFontSize);

            //window.console.log("titleFontSize: " + this.titleFontSize);
        }

        if (typeof (this.options.labelFontSize) === "undefined") {

            this.labelFontSize = this.chart.getAutoFontSize(this.labelFontSize);

            //window.console.log("labelFontSize: " + this.labelFontSize);

        }

        //Axis Type : axisX, axisY
        this.type = type;
        if (type === "axisX" && (!options || typeof (options.gridThickness) === "undefined"))
            this.gridThickness = 0;

        this._position = position;

        this.lineCoordinates = {
            x1: null, y1: null, x2: null, y2: null, width: null
        };//{x1:, y1:, x2:, y2:, width:}
        //
        {
            this.labelAngle = ((this.labelAngle % 360) + 360) % 360;

            if (this.labelAngle > 90 && this.labelAngle < 270)
                this.labelAngle -= 180;
            else if (this.labelAngle >= 270 && this.labelAngle <= 360)
                this.labelAngle -= 360
        }

        if (this.options.stripLines && this.options.stripLines.length > 0) {

            this.stripLines = [];

            for (var i = 0; i < this.options.stripLines.length; i++) {
                this.stripLines.push(new StripLine(this.chart, this.options.stripLines[i], chart.theme, ++this.chart._eventManager.lastObjectId, this));
            }
        }

        this._titleTextBlock = null;

        if (this.hasOptionChanged("viewportMinimum") && this.viewportMinimum === null) {
            this.options.viewportMinimum = undefined;
            this.sessionVariables.viewportMinimum = null;
        }

        if (!this.hasOptionChanged("viewportMinimum") && !isNaN(this.sessionVariables.newViewportMinimum) && this.sessionVariables.newViewportMinimum !== null)
            this.viewportMinimum = this.sessionVariables.newViewportMinimum;
        else
            this.sessionVariables.newViewportMinimum = null;


        if (this.hasOptionChanged("viewportMaximum") && this.viewportMaximum === null) {
            this.options.viewportMaximum = undefined;
            this.sessionVariables.viewportMaximum = null;
        }

        if (!this.hasOptionChanged("viewportMaximum") && !isNaN(this.sessionVariables.newViewportMaximum) && this.sessionVariables.newViewportMaximum !== null)
            this.viewportMaximum = this.sessionVariables.newViewportMaximum;
        else
            this.sessionVariables.newViewportMaximum = null;

        if (this.minimum !== null && this.viewportMinimum !== null)
            this.viewportMinimum = Math.max(this.viewportMinimum, this.minimum);

        if (this.maximum !== null && this.viewportMaximum !== null)
            this.viewportMaximum = Math.min(this.viewportMaximum, this.maximum);

        this.trackChanges("viewportMinimum");
        this.trackChanges("viewportMaximum");
    }

    extend(Axis, CanvasJSObject);

    Axis.prototype.createExtraLabelsForLog = function (recursionCount) {
        recursionCount = (recursionCount || 0) + 1;

        if (recursionCount > 5)
            return;
        var start = this.logLabelValues[0] || this.intervalStartPosition;

        if (Math.log(this.range) / Math.log(start / this.viewportMinimum) < this.noTicks - 1) {
            var interval = Axis.getNiceNumber((start - this.viewportMinimum) / Math.min(Math.max(2, this.noTicks - this.logLabelValues.length), 3), true);
            for (var i = Math.ceil(this.viewportMinimum / interval) * interval; i < start; i += interval) {
                if (i < this.viewportMinimum)
                    continue;
                this.logLabelValues.push(i);
            }
            this.logLabelValues.sort(compareNumbers);
            this.createExtraLabelsForLog(recursionCount);
        }
        return;
    }

    Axis.prototype.createLabels = function () {
        var textBlock, textBlockNext;
        var sizeNext;
        var i = 0;
        var k = 0;
        var endPoint;

        var labelMaxWidth = 0;
        var labelEffectiveMaxWidth = 0;
        var labelMaxHeight = 0;
        var labelEffectiveMaxHeight = 0;
        var labelInterval = this.interval;
        var intervalInPixels = 0;
        var labelSkipStep = 1; //this.labelStep;
        var textBlockHeight;
        var textBlockWidth = 0;
        var maxTextBlockWidth = 0;
        var labelRoatationAngle = -25;
        var labelMaxHeightLimit = this.chart.height * .6;
        var isDateTime = false;

        //var intervalInPixels = this.conversionParameters.pixelPerUnit * this.interval;

        if (this.dataSeries && this.dataSeries.length > 0) {
            for (var k = 0; k < this.dataSeries.length; k++) {
                if (this.dataSeries[k].xValueType === "dateTime")
                    isDateTime = true;
            }
        }
        if (this.type === "axisX" && isDateTime && !this.logarithmic) {
            this.intervalStartPosition = this.getLabelStartPoint(new Date(this.viewportMinimum), this.intervalType, this.interval);
            endPoint = addToDateTime(new Date(this.viewportMaximum), this.interval, this.intervalType)

            for (i = this.intervalStartPosition; i < endPoint; addToDateTime(i, labelInterval, this.intervalType)) {

                //var text = dateFormat(i, this.valueFormatString);
                var timeInMilliseconds = i.getTime();
                var text = this.labelFormatter ? this.labelFormatter({ chart: this.chart, axis: this.options, value: i, label: this.labels[i] ? this.labels[i] : null })
                    : this.type === "axisX" && this.labels[timeInMilliseconds] ? this.labels[timeInMilliseconds] : dateFormat(i, this.valueFormatString, this.chart._cultureInfo);

                textBlock = new TextBlock(this.ctx, {
                    x: 0,
                    y: 0,
                    //maxWidth: this.maxHeight,
                    //maxHeight: this.labelFontSize,
                    maxWidth: labelMaxWidth,
                    backgroundColor: this.labelBackgroundColor,
                    borderColor: this.labelBorderColor,
                    borderThickness: this.labelBorderThickness,
                    cornerRadius: this.labelCornerRadius,
                    maxHeight: labelMaxHeight,
                    angle: this.labelAngle,
                    text: this.prefix + text + this.suffix,
                    horizontalAlign: "left",//left, center, right
                    fontSize: this.labelFontSize,//in pixels
                    fontFamily: this.labelFontFamily,
                    fontWeight: this.labelFontWeight, //normal, bold, bolder, lighter,
                    fontColor: this.labelFontColor,
                    fontStyle: this.labelFontStyle, // normal, italic, oblique
                    textBaseline: "middle"
                });

                this._labels.push({ position: i.getTime(), textBlock: textBlock, effectiveHeight: null });
                //this._ticks.push({ position: i.getTime() });
            }

        }
        else {

            endPoint = this.viewportMaximum;

            //Check if it should be rendered as a category axis. If yes, then ceil the interval
            if (this.labels) {
                var tempInterval = Math.ceil(labelInterval);
                var tempStartPoint = Math.ceil(this.intervalStartPosition);
                var hasAllLabels = false;
                for (i = tempStartPoint; i < this.viewportMaximum; i += tempInterval) {
                    if (this.labels[i]) {
                        hasAllLabels = true;
                    } else {
                        hasAllLabels = false;
                        break;
                    }
                }

                if (hasAllLabels) {
                    labelInterval = this.interval = tempInterval;
                    this.intervalStartPosition = tempStartPoint;
                }
            }

            if (this.logarithmic && !this.equidistantInterval) {

                if (!this.logLabelValues) {
                    this.logLabelValues = [];
                    this.createExtraLabelsForLog();
                }

                for (var j = 0 ; j < this.logLabelValues.length; j++) {
                    i = this.logLabelValues[j];
                    if (i < this.viewportMinimum)
                        continue;

                    var text = this.labelFormatter ? this.labelFormatter({ chart: this.chart, axis: this.options, value: i, label: this.labels[i] ? this.labels[i] : null })
                        : this.type === "axisX" && this.labels[i] ? this.labels[i] : numberFormat(i, this.valueFormatString, this.chart._cultureInfo);
                    textBlock = new TextBlock(this.ctx, {
                        x: 0,
                        y: 0,
                        //maxWidth: this.maxHeight,
                        //maxHeight: this.labelFontSize,
                        maxWidth: labelMaxWidth,
                        maxHeight: labelMaxHeight,
                        angle: this.labelAngle,
                        text: this.prefix + text + this.suffix,
                        backgroundColor: this.labelBackgroundColor,
                        borderColor: this.labelBorderColor,
                        borderThickness: this.labelBorderThickness,
                        cornerRadius: this.labelCornerRadius,
                        horizontalAlign: "left",//left, center, right
                        fontSize: this.labelFontSize,//in pixels
                        fontFamily: this.labelFontFamily,
                        fontWeight: this.labelFontWeight, //normal, bold, bolder, lighter,
                        fontColor: this.labelFontColor,
                        fontStyle: this.labelFontStyle, // normal, italic, oblique
                        textBaseline: "middle",
                        borderThickness: 0
                    });
                    this._labels.push({ position: i, textBlock: textBlock, effectiveHeight: null });
                    //this._ticks.push({ position: i });
                }
            }

            //parseFloat & toPrecision are being used to avoid issues related to precision.
            for (i = this.intervalStartPosition; i <= endPoint; i = parseFloat((this.logarithmic && this.equidistantInterval ? i * Math.pow(this.logarithmBase, this.interval) : i + this.interval).toFixed(14))) {
                var text = this.labelFormatter ? this.labelFormatter({ chart: this.chart, axis: this.options, value: i, label: this.labels[i] ? this.labels[i] : null })
                    : this.type === "axisX" && this.labels[i] ? this.labels[i] : numberFormat(i, this.valueFormatString, this.chart._cultureInfo);

                textBlock = new TextBlock(this.ctx, {
                    x: 0,
                    y: 0,
                    //maxWidth: this.maxHeight,
                    //maxHeight: this.labelFontSize,
                    maxWidth: labelMaxWidth,
                    maxHeight: labelMaxHeight,
                    angle: this.labelAngle,
                    text: this.prefix + text + this.suffix,
                    horizontalAlign: "left",//left, center, right
                    backgroundColor: this.labelBackgroundColor,
                    borderColor: this.labelBorderColor,
                    borderThickness: this.labelBorderThickness,
                    cornerRadius: this.labelCornerRadius,
                    fontSize: this.labelFontSize,//in pixels
                    fontFamily: this.labelFontFamily,
                    fontWeight: this.labelFontWeight, //normal, bold, bolder, lighter,
                    fontColor: this.labelFontColor,
                    fontStyle: this.labelFontStyle, // normal, italic, oblique
                    textBaseline: "middle"
                });

                this._labels.push({ position: i, textBlock: textBlock, effectiveHeight: null });
                //this._ticks.push({ position: i });
            }
        }

        if (this._position === "bottom" || this._position === "top") {
            //intervalInPixels = this.lineCoordinates.width / Math.abs(this.viewportMaximum - this.viewportMinimum) * convertToNumber(this.interval, this.intervalType);
            if (this.logarithmic && !this.equidistantInterval && this._labels.length >= 2)
                intervalInPixels = this.lineCoordinates.width * Math.log(Math.min(this._labels[this._labels.length - 1].position / this._labels[this._labels.length - 2].position, this._labels[1].position / this._labels[0].position)) / Math.log(this.range);
            else
                intervalInPixels = this.lineCoordinates.width / (this.logarithmic && this.equidistantInterval ? Math.log(this.range) / Math.log(this.logarithmBase) : Math.abs(this.range)) * convertToNumber(this.interval, this.intervalType);

            labelMaxWidth = typeof (this.options.labelMaxWidth) === "undefined" ? this.chart.width * .5 >> 0 : this.options.labelMaxWidth;

            if (!(this.chart.panEnabled))
                labelMaxHeight = typeof (this.options.labelWrap) === "undefined" || this.labelWrap ? this.chart.height * .8 >> 0 : this.labelFontSize * 1.5;
        }
        else if (this._position === "left" || this._position === "right") {
            if (this.logarithmic && !this.equidistantInterval && this._labels.length >= 2)
                intervalInPixels = this.lineCoordinates.height * Math.log(Math.min(this._labels[this._labels.length - 1].position / this._labels[this._labels.length - 2].position, this._labels[1].position / this._labels[0].position)) / Math.log(this.range);
            else
                intervalInPixels = this.lineCoordinates.height / (this.logarithmic && this.equidistantInterval ? Math.log(this.range) / Math.log(this.logarithmBase) : Math.abs(this.range)) * convertToNumber(this.interval, this.intervalType);

            if (!(this.chart.panEnabled))
                labelMaxWidth = typeof (this.options.labelMaxWidth) === "undefined" ? this.chart.width * .3 >> 0 : this.options.labelMaxWidth;

            labelMaxHeight = typeof (this.options.labelWrap) === "undefined" || this.labelWrap ? this.chart.height * .3 >> 0 : this.labelFontSize * 1.5;
        }
        for (k = 0; k < this._labels.length; k++) {
            textBlock = this._labels[k].textBlock;
            textBlock.maxWidth = labelMaxWidth;
            textBlock.maxHeight = labelMaxHeight;
            var size = textBlock.measureText();
            textBlockHeight = size.height;
        }

        var effectiveLabelHeights = [];
        var effectiveLabelWidths = [];
        var labelOverlapWidth = 0;
        var labelOverLapHeight = 0;
        if (this.labelAutoFit || this.options.labelAutoFit) {
            if (!isNullOrUndefined(this.labelAngle)) {
                this.labelAngle = ((this.labelAngle % 360) + 360) % 360;

                if (this.labelAngle > 90 && this.labelAngle < 270)
                    this.labelAngle -= 180;
                else if (this.labelAngle >= 270 && this.labelAngle <= 360)
                    this.labelAngle -= 360
            }
            if (this._position === "bottom" || this._position === "top") {
                var j = 0;
                labelMaxWidth = intervalInPixels * .9 >> 0;
                var labelWordMaxWidth = 0;

                if (!(this.chart.panEnabled) && this._labels.length >= 1) {
                    this.sessionVariables.labelFontSize = this.labelFontSize;
                    this.sessionVariables.labelMaxWidth = labelMaxWidth;
                    this.sessionVariables.labelMaxHeight = labelMaxHeight;
                    this.sessionVariables.labelAngle = this.labelAngle;
                    this.sessionVariables.labelWrap = this.labelWrap;

                    for (i = 0; i < this._labels.length; i++) {
                        textBlock = this._labels[i].textBlock;
                        var labelIndex;
                        var words = textBlock.text.split(' ');
                        for (var k = 0; k < words.length; k++) {
                            var testLine = words[k];
                            this.ctx.font = textBlock.fontStyle + ' ' + textBlock.fontWeight + ' ' + textBlock.fontSize + 'px ' + textBlock.fontFamily;
                            var metrics = this.ctx.measureText(testLine);

                            if (metrics.width > labelWordMaxWidth) {
                                labelIndex = i;
                                labelWordMaxWidth = metrics.width;
                            }
                        }
                    }
                    var autoLabelStartValue = 0;
                    autoLabelStartValue = this.intervalStartPosition < this.viewportMinimum ? 1 : 0;
                    for (i = autoLabelStartValue; i < this._labels.length; i++) {
                        textBlock = this._labels[i].textBlock;
                        var size = textBlock.measureText();

                        if (i < this._labels.length - 1) {
                            j = (i + 1);
                            textBlockNext = this._labels[j].textBlock;
                            sizeNext = textBlockNext.measureText();
                        }
                        effectiveLabelHeights.push(textBlock.height);
                        this.sessionVariables.labelMaxHeight = Math.max.apply(Math, effectiveLabelHeights);

                        labelEffectiveMaxWidth = (labelMaxWidth * Math.cos(Math.PI / 180 * Math.abs(this.labelAngle))) + ((labelMaxHeight - textBlock.fontSize / 2) * Math.sin(Math.PI / 180 * Math.abs(this.labelAngle)));
                        labelEffectiveMaxHeight = (labelMaxWidth * Math.sin(Math.PI / 180 * Math.abs(this.labelAngle))) + ((labelMaxHeight - textBlock.fontSize / 2) * Math.cos(Math.PI / 180 * Math.abs(this.labelAngle)));
                        if (!(isNullOrUndefined(this.options.labelAngle) && isNaN(this.options.labelAngle)) || this.options.labelAngle === 0) {//User has set angle -->Rotate
                            this.sessionVariables.labelAngle = this.labelAngle;
                            this.sessionVariables.labelMaxHeight = (this.labelAngle === 0) ? labelMaxHeight : Math.min((labelEffectiveMaxHeight - labelMaxWidth * Math.cos(Math.PI / 180 * Math.abs(this.labelAngle))) / (Math.sin(Math.PI / 180 * Math.abs(this.labelAngle))), labelEffectiveMaxHeight);
                            var labelEffectiveMaxWidthLimit = this.labelAngle != 0 ? (labelMaxHeightLimit - (textBlockHeight + textBlock.fontSize / 2) * Math.cos(Math.PI / 180 * Math.abs(this.labelAngle))) / Math.sin(Math.PI / 180 * Math.abs(this.labelAngle)) : labelMaxWidth;
                            this.sessionVariables.labelMaxHeight = labelMaxHeight = this.labelWrap ? (labelMaxHeightLimit - (labelEffectiveMaxWidthLimit) * Math.sin(Math.PI / 180 * Math.abs(this.labelAngle))) / Math.cos(Math.PI / 180 * Math.abs(this.labelAngle)) : this.labelFontSize * 1.5;
                            if (!isNullOrUndefined(this.options.labelWrap)) {//User has set wrapping (true/false)
                                if (this.options.labelWrap) {//wrap is true -->Rotate+Wrap
                                    this.sessionVariables.labelWrap = this.labelWrap;
                                    this.sessionVariables.labelMaxWidth = this.options.labelMaxWidth ? this.options.labelMaxWidth : labelEffectiveMaxWidthLimit;
                                    this.sessionVariables.labelMaxHeight = labelMaxHeight;
                                }
                                else {//wrap is false
                                    if (!isNullOrUndefined(this.options.labelMaxWidth)) {//User has set labelMaxWidth -->Rotate+Clip after user set labelMaxWidth
                                        this.sessionVariables.labelMaxWidth = this.options.labelMaxWidth ? this.options.labelMaxWidth : labelEffectiveMaxWidthLimit;
                                        this.sessionVariables.labelWrap = this.labelWrap;
                                        this.sessionVariables.labelMaxHeight = labelMaxHeight;
                                    }
                                    else {//User has not set labelMaxWidth -->Rotate
                                        this.sessionVariables.labelMaxWidth = this.options.labelMaxWidth ? this.options.labelMaxWidth : labelEffectiveMaxWidthLimit;
                                        this.sessionVariables.labelWrap = this.labelWrap;
                                        this.sessionVariables.labelMaxHeight = labelMaxHeight;
                                    }
                                }
                            }
                            else if (isNullOrUndefined(this.options.labelWrap)) {//User has not set wrap
                                if (this.labelWrap && !isNullOrUndefined(this.options.labelMaxWidth)) {//labelwrap->true by default -->Rotate+Wrap
                                    this.sessionVariables.labelWrap = this.labelWrap;
                                    this.sessionVariables.labelMaxWidth = this.options.labelMaxWidth ? this.options.labelMaxWidth : labelEffectiveMaxWidthLimit;
                                    this.sessionVariables.labelMaxHeight = labelMaxHeight;
                                }
                                else {
                                    this.sessionVariables.labelAngle = this.labelAngle;
                                    this.sessionVariables.labelMaxWidth = labelEffectiveMaxWidthLimit;
                                    this.sessionVariables.labelMaxHeight = labelEffectiveMaxHeight < intervalInPixels * .9 ? intervalInPixels * .9 : labelEffectiveMaxHeight;
                                    this.sessionVariables.labelWrap = this.labelWrap;
                                }
                            }
                        }//if-angle is not set proceed to else part
                        else {
                            this.sessionVariables.labelMaxHeight = this.labelAngle === 0 ? labelMaxHeight : Math.min((labelEffectiveMaxHeight - labelMaxWidth * Math.cos(Math.PI / 180 * Math.abs(this.labelAngle))) / (Math.sin(Math.PI / 180 * Math.abs(this.labelAngle))), labelEffectiveMaxHeight);
                            var labelEffectiveMaxWidthLimit = (labelMaxHeightLimit - (textBlockHeight + textBlock.fontSize / 2) * Math.cos(Math.PI / 180 * Math.abs(labelRoatationAngle))) / Math.sin(Math.PI / 180 * Math.abs(labelRoatationAngle));
                            if (!isNullOrUndefined(this.options.labelWrap)) {//User has set Wrap (true/false)
                                if (this.labelWrap) {//wrap is true -->Wrap
                                    if (!isNullOrUndefined(this.options.labelMaxWidth)) {//User has set labelMaxWidth -->Wrap after user set labelMaxWidth
                                        this.sessionVariables.labelWrap = this.labelWrap;
                                        this.sessionVariables.labelMaxWidth = this.options.labelMaxWidth;
                                        this.sessionVariables.labelAngle = this.sessionVariables.labelMaxWidth > labelMaxWidth ? labelRoatationAngle : this.sessionVariables.labelAngle;
                                    }
                                    else {//User has not set labelMaxWidth --> Wrap after AutoCalculated labelMaxWidth
                                        this.sessionVariables.labelMaxWidth = Math.min(Math.max(labelMaxWidth, labelWordMaxWidth), labelEffectiveMaxWidthLimit);
                                        this.sessionVariables.labelWrap = this.labelWrap;
                                        if (((size.width + sizeNext.width) >> 0) > (2 * labelMaxWidth)) {
                                            this.sessionVariables.labelAngle = labelRoatationAngle;
                                        }
                                    }
                                }
                                else {//wrap is false
                                    if (!isNullOrUndefined(this.options.labelMaxWidth)) {//User has set labelMaxWidth -->Clip after user set labelMaxWidth
                                        this.sessionVariables.labelAngle = this.sessionVariables.labelMaxWidth > labelMaxWidth ? labelRoatationAngle : this.sessionVariables.labelAngle;
                                        this.sessionVariables.labelMaxWidth = this.options.labelMaxWidth;
                                        this.sessionVariables.labelMaxHeight = labelMaxHeight;
                                        this.sessionVariables.labelWrap = this.labelWrap;
                                    }
                                    else {//User has not set labelMaxWidth --> Rotate+Clip
                                        this.sessionVariables.labelWrap = this.labelWrap;
                                        this.sessionVariables.labelMaxHeight = labelMaxHeight;
                                        this.sessionVariables.labelMaxWidth = labelMaxWidth;
                                        if (((size.width + sizeNext.width) >> 0) > (2 * labelMaxWidth)) {
                                            this.sessionVariables.labelAngle = labelRoatationAngle;
                                            this.sessionVariables.labelMaxWidth = labelEffectiveMaxWidthLimit;

                                        }
                                    }
                                }
                            }
                            else if (isNullOrUndefined(this.options.labelWrap)) {//User has not set Wrap, labelWrap is true by default
                                if (!isNullOrUndefined(this.options.labelMaxWidth)) {//User has set labelMaxWidth -->Wrap if user set labelMaxWidth<labelMaxWidth else Rotate+Wrap
                                    if (this.options.labelMaxWidth < labelMaxWidth) {
                                        this.sessionVariables.labelMaxWidth = this.options.labelMaxWidth;
                                        this.sessionVariables.labelMaxHeight = labelEffectiveMaxHeight;
                                    }
                                    else {
                                        this.sessionVariables.labelAngle = labelRoatationAngle;
                                        this.sessionVariables.labelMaxWidth = this.options.labelMaxWidth;
                                        this.sessionVariables.labelMaxHeight = labelMaxHeight;
                                    }
                                }

                                else {//User has not set anything, handle auto-labelling (Rotate or Wrap or Decrease font size for the bestfit)
                                    //Decide Auto-Labelling based on overlapping
                                    if (!isNullOrUndefined(sizeNext)) {
                                        var adjacentLabelsWidth = (size.width + sizeNext.width) >> 0;
                                        var labelFontSize = this.labelFontSize;
                                        if (labelWordMaxWidth < labelMaxWidth) {
                                            if (adjacentLabelsWidth - (2 * labelMaxWidth) > labelOverlapWidth) {
                                                labelOverlapWidth = adjacentLabelsWidth - (2 * labelMaxWidth);
                                                if (adjacentLabelsWidth >= (2 * labelMaxWidth) && adjacentLabelsWidth < (2.2 * labelMaxWidth)) {//Reduce Font size
                                                    this.sessionVariables.labelMaxWidth = labelMaxWidth;
                                                    if (isNullOrUndefined(this.options.labelFontSize)) {
                                                        if (labelFontSize > 12) {
                                                            labelFontSize = Math.floor(12 / 13 * labelFontSize);
                                                            size = textBlock.measureText();
                                                        }
                                                    }
                                                    this.sessionVariables.labelFontSize = isNullOrUndefined(this.options.labelFontSize) ? labelFontSize : this.options.labelFontSize;
                                                    this.sessionVariables.labelAngle = this.labelAngle;
                                                }
                                                else if (adjacentLabelsWidth >= (2.2 * labelMaxWidth) && adjacentLabelsWidth < (2.8 * labelMaxWidth)) {//Slant
                                                    this.sessionVariables.labelAngle = labelRoatationAngle;
                                                    this.sessionVariables.labelMaxWidth = labelEffectiveMaxWidthLimit;
                                                    this.sessionVariables.labelFontSize = labelFontSize;
                                                }
                                                else if (adjacentLabelsWidth >= (2.8 * labelMaxWidth) && adjacentLabelsWidth < (3.2 * labelMaxWidth)) {//Wrap+Reduce font size
                                                    this.sessionVariables.labelMaxWidth = Math.max(labelMaxWidth, labelWordMaxWidth);
                                                    this.sessionVariables.labelWrap = true;
                                                    if (isNullOrUndefined(this.options.labelFontSize)) {
                                                        if (this.labelFontSize > 12) {
                                                            this.labelFontSize = Math.floor(12 / 13 * this.labelFontSize);//labelFontSize should not go beyond 12
                                                            size = textBlock.measureText();
                                                        }
                                                    }
                                                    this.sessionVariables.labelFontSize = isNullOrUndefined(this.options.labelFontSize) ? labelFontSize : this.options.labelFontSize;
                                                    this.sessionVariables.labelAngle = this.labelAngle;
                                                }
                                                else if (adjacentLabelsWidth >= (3.2 * labelMaxWidth) && adjacentLabelsWidth < (3.6 * labelMaxWidth)) {//Rotate+Wrap
                                                    this.sessionVariables.labelAngle = labelRoatationAngle;
                                                    this.sessionVariables.labelWrap = true;
                                                    this.sessionVariables.labelMaxWidth = labelEffectiveMaxWidthLimit;
                                                    this.sessionVariables.labelFontSize = this.labelFontSize;
                                                }
                                                else if (adjacentLabelsWidth > (3.6 * labelMaxWidth) && adjacentLabelsWidth < (5 * labelMaxWidth)) {
                                                    if (isNullOrUndefined(this.options.labelFontSize)) {
                                                        if (labelFontSize > 12) {
                                                            labelFontSize = Math.floor(12 / 13 * labelFontSize);//labelFontSize should not go beyond 12
                                                            size = textBlock.measureText();
                                                        }
                                                    }
                                                    this.sessionVariables.labelFontSize = isNullOrUndefined(this.options.labelFontSize) ? labelFontSize : this.options.labelFontSize;
                                                    this.sessionVariables.labelWrap = true;
                                                    this.sessionVariables.labelAngle = labelRoatationAngle;
                                                    this.sessionVariables.labelMaxWidth = labelEffectiveMaxWidthLimit;
                                                }
                                                else if (adjacentLabelsWidth > (5 * labelMaxWidth)) {
                                                    this.sessionVariables.labelWrap = true;
                                                    this.sessionVariables.labelMaxWidth = labelMaxWidth;
                                                    this.sessionVariables.labelFontSize = labelFontSize;
                                                    this.sessionVariables.labelMaxHeight = labelMaxHeight;
                                                    this.sessionVariables.labelAngle = this.labelAngle;
                                                }
                                            }
                                        }
                                        else {
                                            if (labelIndex === i && ((labelIndex === 0 && (labelWordMaxWidth + this._labels[labelIndex + 1].textBlock.measureText().width) - (2 * labelMaxWidth) > labelOverlapWidth) || (labelIndex === this._labels.length - 1 && (labelWordMaxWidth + this._labels[labelIndex - 1].textBlock.measureText().width) - (2 * labelMaxWidth) > labelOverlapWidth) || ((labelIndex > 0 && labelIndex < this._labels.length - 1) && ((labelWordMaxWidth + this._labels[labelIndex + 1].textBlock.measureText().width) - (2 * labelMaxWidth) > labelOverlapWidth) && ((labelWordMaxWidth + this._labels[labelIndex - 1].textBlock.measureText().width) - (2 * labelMaxWidth) > labelOverlapWidth)))) {
                                                labelOverlapWidth = labelIndex === 0 ? (labelWordMaxWidth + this._labels[labelIndex + 1].textBlock.measureText().width) - (2 * labelMaxWidth) : (labelWordMaxWidth + this._labels[labelIndex - 1].textBlock.measureText().width) - (2 * labelMaxWidth);
                                                this.sessionVariables.labelFontSize = isNullOrUndefined(this.options.labelFontSize) ? labelFontSize : this.options.labelFontSize;
                                                this.sessionVariables.labelWrap = true;
                                                this.sessionVariables.labelAngle = labelRoatationAngle;
                                                this.sessionVariables.labelMaxWidth = labelEffectiveMaxWidthLimit;//Math.max(labelMaxWidth, labelWordMaxWidth) > this.chart.height * .8 ? this.chart.height * .8 : Math.max(labelMaxWidth, labelWordMaxWidth);

                                            }
                                            else if (labelOverlapWidth === 0) {
                                                this.sessionVariables.labelFontSize = isNullOrUndefined(this.options.labelFontSize) ? labelFontSize : this.options.labelFontSize;
                                                this.sessionVariables.labelWrap = true;
                                                for (k = 0; k < this._labels.length; k++) {
                                                    textBlock = this._labels[k].textBlock;
                                                    textBlock.maxWidth = this.sessionVariables.labelMaxWidth = Math.min(Math.max(labelMaxWidth, labelWordMaxWidth), labelEffectiveMaxWidthLimit)
                                                    size = textBlock.measureText();
                                                    if (k < this._labels.length - 1) {
                                                        j = (k + 1);
                                                        textBlockNext = this._labels[j].textBlock;
                                                        textBlockNext.maxWidth = this.sessionVariables.labelMaxWidth = Math.min(Math.max(labelMaxWidth, labelWordMaxWidth), labelEffectiveMaxWidthLimit);
                                                        sizeNext = textBlockNext.measureText();
                                                        if (((size.width + sizeNext.width) >> 0) > (2 * labelMaxWidth))
                                                            this.sessionVariables.labelAngle = labelRoatationAngle;
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }

                    }
                    for (k = 0; k < this._labels.length; k++) {
                        textBlock = this._labels[k].textBlock;
                        textBlock.maxWidth = this.labelMaxWidth = this.sessionVariables.labelMaxWidth;
                        textBlock.fontSize = this.sessionVariables.labelFontSize;
                        textBlock.angle = this.labelAngle = this.sessionVariables.labelAngle;
                        textBlock.wrap = this.labelWrap = this.sessionVariables.labelWrap;
                        textBlock.maxHeight = this.sessionVariables.labelMaxHeight;
                        textBlock.measureText();
                    }
                }
                //Panning Mode
                else {
                    for (i = 0; i < this._labels.length; i++) {
                        textBlock = this._labels[i].textBlock;
                        textBlock.maxWidth = this.labelMaxWidth = isNullOrUndefined(this.options.labelMaxWidth) ? this.sessionVariables.labelMaxWidth : this.options.labelMaxWidth;
                        textBlock.fontSize = this.labelFontSize = isNullOrUndefined(this.options.labelFontSize) ? this.sessionVariables.labelFontSize : this.options.labelFontSize;
                        textBlock.angle = this.labelAngle = isNullOrUndefined(this.options.labelAngle) ? this.sessionVariables.labelAngle : this.labelAngle;
                        textBlock.wrap = this.labelWrap = isNullOrUndefined(this.options.labelWrap) ? this.sessionVariables.labelWrap : this.options.labelWrap;
                        textBlock.maxHeight = this.sessionVariables.labelMaxHeight;
                        textBlock.measureText();
                    }
                }
            }
            else if (this._position === "left" || this._position === "right") {
                var j = 0;
                labelMaxWidth = isNullOrUndefined(this.options.labelMaxWidth) ? this.chart.width * .3 >> 0 : this.options.labelMaxWidth;
                labelMaxHeight = typeof (this.options.labelWrap) === "undefined" || this.labelWrap ? this.chart.height * .3 >> 0 : this.labelFontSize * 1.5;
                if (!(this.chart.panEnabled) && this._labels.length >= 1) {
                    this.sessionVariables.labelFontSize = this.labelFontSize;
                    this.sessionVariables.labelMaxWidth = labelMaxWidth;
                    this.sessionVariables.labelMaxHeight = labelMaxHeight;
                    this.sessionVariables.labelAngle = isNullOrUndefined(this.sessionVariables.labelAngle) ? 0 : this.sessionVariables.labelAngle;
                    this.sessionVariables.labelWrap = this.labelWrap;

                    for (i = 0; i < this._labels.length; i++) {
                        textBlock = this._labels[i].textBlock;
                        var size = textBlock.measureText();

                        if (i < this._labels.length - 1) {
                            j = (i + 1);
                            textBlockNext = this._labels[j].textBlock;
                            sizeNext = textBlockNext.measureText();
                        }
                        effectiveLabelHeights.push(textBlock.height);
                        this.sessionVariables.labelMaxHeight = Math.max.apply(Math, effectiveLabelHeights);

                        labelEffectiveMaxHeight = (labelMaxWidth * Math.sin(Math.PI / 180 * Math.abs(this.labelAngle))) + ((labelMaxHeight - textBlock.fontSize / 2) * Math.cos(Math.PI / 180 * Math.abs(this.labelAngle)));
                        labelEffectiveMaxWidth = (labelMaxWidth * Math.cos(Math.PI / 180 * Math.abs(this.labelAngle))) + ((labelMaxHeight - textBlock.fontSize / 2) * Math.sin(Math.PI / 180 * Math.abs(this.labelAngle)));
                        if (!(isNullOrUndefined(this.options.labelAngle) && isNaN(this.options.labelAngle)) || this.options.labelAngle === 0) {//User has set angle -->Rotate
                            this.sessionVariables.labelAngle = this.labelAngle;
                            this.sessionVariables.labelMaxWidth = this.labelAngle === 0 ? labelMaxWidth : Math.min((labelEffectiveMaxHeight - labelMaxHeight * Math.sin(Math.PI / 180 * Math.abs(this.labelAngle))) / (Math.cos(Math.PI / 180 * Math.abs(this.labelAngle))), labelMaxHeight);
                            if (!isNullOrUndefined(this.options.labelWrap)) {//User has set wrapping (true/false)
                                if (this.options.labelWrap) {//wrap is true -->Rotate+Wrap
                                    this.sessionVariables.labelMaxHeight = this.labelAngle === 0 ? labelMaxHeight : labelEffectiveMaxHeight;
                                    this.sessionVariables.labelWrap = this.labelWrap;
                                    this.sessionVariables.labelMaxWidth = labelMaxWidth;
                                }
                                else {//wrap is false
                                    this.sessionVariables.labelMaxHeight = labelMaxHeight;
                                    if (!isNullOrUndefined(this.options.labelMaxWidth)) {//User has set labelMaxWidth -->Rotate+Clip after user set labelMaxWidth
                                        this.sessionVariables.labelMaxWidth = this.options.labelMaxWidth ? this.options.labelMaxWidth : this.sessionVariables.labelMaxWidth;
                                        this.sessionVariables.labelWrap = this.labelWrap;
                                    }
                                    else {//User has not set labelMaxWidth -->Rotate
                                        this.sessionVariables.labelMaxWidth = this.options.labelMaxWidth ? this.options.labelMaxWidth : this.sessionVariables.labelMaxWidth;
                                        this.sessionVariables.labelWrap = this.labelWrap;
                                    }
                                }
                            }
                            else if (isNullOrUndefined(this.options.labelWrap)) {//User has not set wrap
                                if (this.labelWrap && !isNullOrUndefined(this.options.labelMaxWidth)) {//labelwrap->true by default -->Rotate+Wrap
                                    this.sessionVariables.labelMaxWidth = this.options.labelMaxWidth ? this.options.labelMaxWidth > this.options.labelMaxWidth : this.sessionVariables.labelMaxWidth;
                                    this.sessionVariables.labelWrap = this.labelWrap;
                                    this.sessionVariables.labelMaxHeight = labelEffectiveMaxHeight;
                                }
                                else {
                                    this.sessionVariables.labelMaxWidth = this.options.labelMaxWidth ? this.options.labelMaxWidth : labelMaxWidth;
                                    this.sessionVariables.labelMaxHeight = this.labelAngle === 0 ? labelMaxHeight : labelEffectiveMaxHeight;
                                    if (isNullOrUndefined(this.options.labelMaxWidth)) {
                                        this.sessionVariables.labelAngle = this.labelAngle;
                                    }
                                }
                            }
                        }//if-angle is not set proceed to else part
                        else {
                            if (!isNullOrUndefined(this.options.labelWrap)) {//User has set Wrap (true/false)
                                if (this.labelWrap) {//wrap is true -->Wrap
                                    this.sessionVariables.labelMaxWidth = this.options.labelMaxWidth ? this.options.labelMaxWidth : this.sessionVariables.labelMaxWidth;
                                    this.sessionVariables.labelMaxHeight = labelMaxHeight;
                                }
                                else {//wrap is false
                                    if (this.labelMaxWidth) {//User has set labelMaxWidth -->Clip after user set labelMaxWidth
                                        this.sessionVariables.labelMaxWidth = this.options.labelMaxWidth ? this.options.labelMaxWidth : this.sessionVariables.labelMaxWidth;
                                        this.sessionVariables.labelMaxHeight = labelMaxHeight;
                                    }
                                    else {//User has not set labelMaxWidth --> Clip after first line
                                        this.sessionVariables.labelMaxWidth = labelMaxWidth;
                                        this.sessionVariables.labelMaxHeight = labelMaxHeight;
                                    }
                                }
                            }
                            else if (isNullOrUndefined(this.options.labelWrap)) {//User has not set Wrap, labelWrap is true by default
                                if (!isNullOrUndefined(this.options.labelMaxWidth)) {//User has set labelMaxWidth -->Wrap if user set labelMaxWidth<labelMaxWidth else Rotate+Wrap
                                    this.sessionVariables.labelMaxHeight = labelMaxHeight;
                                    this.sessionVariables.labelMaxWidth = this.options.labelMaxWidth ? this.options.labelMaxWidth : this.sessionVariables.labelMaxWidth;
                                }

                                else {//User has not set anything, handle auto-labelling (Rotate or Wrap or Decrease font size for the bestfit)
                                    //Decide Auto-Labelling based on overlapping
                                    if (!isNullOrUndefined(sizeNext)) {
                                        var adjacentLabelsHeight = (size.height + sizeNext.height) >> 0;
                                        if (adjacentLabelsHeight - (2 * labelMaxHeight) > labelOverLapHeight) {
                                            labelOverLapHeight = adjacentLabelsHeight - (2 * labelMaxHeight);
                                            if (adjacentLabelsHeight >= (2 * labelMaxHeight) && adjacentLabelsHeight < (2.4 * labelMaxHeight)) {//Reduce Font size
                                                if (isNullOrUndefined(this.options.labelFontSize)) {
                                                    if (this.labelFontSize > 12) {
                                                        this.labelFontSize = Math.floor(12 / 13 * this.labelFontSize);
                                                        size = textBlock.measureText();
                                                    }
                                                }
                                                this.sessionVariables.labelMaxHeight = labelMaxHeight;
                                                this.sessionVariables.labelFontSize = (isNullOrUndefined(this.options.labelFontSize)) ? this.labelFontSize : this.options.labelFontSize;
                                            }
                                            else if (adjacentLabelsHeight >= (2.4 * labelMaxHeight) && adjacentLabelsHeight < (2.8 * labelMaxHeight)) {//Slant
                                                //this.sessionVariables.labelAngle = labelRoatationAngle;
                                                this.sessionVariables.labelMaxHeight = labelEffectiveMaxHeight;
                                                this.sessionVariables.labelFontSize = this.labelFontSize;
                                                this.sessionVariables.labelWrap = true;
                                            }
                                            else if (adjacentLabelsHeight >= (2.8 * labelMaxHeight) && adjacentLabelsHeight < (3.2 * labelMaxHeight)) {//Wrap+Reduce font size
                                                this.sessionVariables.labelMaxHeight = labelMaxHeight;
                                                this.sessionVariables.labelWrap = true;
                                                if (isNullOrUndefined(this.options.labelFontSize)) {
                                                    if (this.labelFontSize > 12) {
                                                        this.labelFontSize = Math.floor(12 / 13 * this.labelFontSize);
                                                        size = textBlock.measureText();
                                                    }
                                                }
                                                this.sessionVariables.labelFontSize = isNullOrUndefined(this.options.labelFontSize) ? this.labelFontSize : this.options.labelFontSize;
                                                this.sessionVariables.labelAngle = isNullOrUndefined(this.sessionVariables.labelAngle) ? 0 : this.sessionVariables.labelAngle;
                                            }
                                            else if (adjacentLabelsHeight >= (3.2 * labelMaxHeight) && adjacentLabelsHeight < (3.6 * labelMaxHeight)) {//Rotate+Wrap
                                                //this.sessionVariables.labelAngle = labelRoatationAngle;
                                                this.sessionVariables.labelMaxHeight = labelEffectiveMaxHeight;
                                                this.sessionVariables.labelWrap = true;
                                                this.sessionVariables.labelFontSize = this.labelFontSize;
                                            }
                                            else if (adjacentLabelsHeight > (3.6 * labelMaxHeight) && adjacentLabelsHeight < (10 * labelMaxHeight)) {
                                                if (isNullOrUndefined(this.options.labelFontSize)) {
                                                    if (this.labelFontSize > 12) {
                                                        this.labelFontSize = Math.floor(12 / 13 * this.labelFontSize);
                                                        size = textBlock.measureText();
                                                    }
                                                }
                                                this.sessionVariables.labelFontSize = isNullOrUndefined(this.options.labelFontSize) ? this.labelFontSize : this.options.labelFontSize;
                                                this.sessionVariables.labelMaxWidth = labelMaxWidth;
                                                this.sessionVariables.labelMaxHeight = labelMaxHeight;
                                                this.sessionVariables.labelAngle = isNullOrUndefined(this.sessionVariables.labelAngle) ? 0 : this.sessionVariables.labelAngle;
                                            }
                                            else if (adjacentLabelsHeight > (10 * labelMaxHeight) && adjacentLabelsHeight < (50 * labelMaxHeight)) {
                                                if (isNullOrUndefined(this.options.labelFontSize)) {
                                                    if (this.labelFontSize > 12) {
                                                        this.labelFontSize = Math.floor(12 / 13 * this.labelFontSize);
                                                        size = textBlock.measureText();
                                                    }
                                                }
                                                this.sessionVariables.labelFontSize = isNullOrUndefined(this.options.labelFontSize) ? this.labelFontSize : this.options.labelFontSize;
                                                this.sessionVariables.labelMaxHeight = labelMaxHeight;
                                                this.sessionVariables.labelMaxWidth = labelMaxWidth;
                                                this.sessionVariables.labelAngle = isNullOrUndefined(this.sessionVariables.labelAngle) ? 0 : this.sessionVariables.labelAngle;
                                            }
                                        }
                                    }
                                }
                            }

                        }

                    }
                    for (k = 0; k < this._labels.length; k++) {
                        textBlock = this._labels[k].textBlock;
                        textBlock.maxWidth = this.labelMaxWidth = this.sessionVariables.labelMaxWidth;
                        textBlock.fontSize = this.labelFontSize = this.sessionVariables.labelFontSize;
                        textBlock.angle = this.labelAngle = this.sessionVariables.labelAngle;
                        textBlock.wrap = this.labelWrap = this.sessionVariables.labelWrap;
                        textBlock.maxHeight = this.sessionVariables.labelMaxHeight;
                        textBlock.measureText();
                    }
                }
                //Panning Mode
                else {
                    for (i = 0; i < this._labels.length; i++) {
                        textBlock = this._labels[i].textBlock;
                        textBlock.maxWidth = this.labelMaxWidth = isNullOrUndefined(this.options.labelMaxWidth) ? this.sessionVariables.labelMaxWidth : this.options.labelMaxWidth;
                        textBlock.fontSize = this.labelFontSize = isNullOrUndefined(this.options.labelFontSize) ? this.sessionVariables.labelFontSize : this.options.labelFontSize;
                        textBlock.angle = this.labelAngle = isNullOrUndefined(this.options.labelAngle) ? this.sessionVariables.labelAngle : this.labelAngle;
                        textBlock.wrap = this.labelWrap = isNullOrUndefined(this.options.labelWrap) ? this.sessionVariables.labelWrap : this.options.labelWrap;
                        textBlock.maxHeight = this.sessionVariables.labelMaxHeight;
                        textBlock.measureText();
                    }
                }
            }
        }//------------------LabelAutoFit-------------------//

        for (var i = 0; i < this.stripLines.length; i++) {
            var stripLine = this.stripLines[i];
            var stripLineLabelMaxWidth;
            var stripLineLabelMaxHeight;
            var backgroundColor;

            if (stripLine.labelPlacement === "outside") {
                stripLineLabelMaxWidth = this.sessionVariables.labelMaxWidth;
                if (this._position === "bottom" || this._position === "top") {
                    if (typeof (stripLine.options.labelWrap) === "undefined") {
                        stripLineLabelMaxHeight = this.sessionVariables.labelMaxHeight;
                    }
                    else {
                        stripLineLabelMaxHeight = stripLine.labelWrap ? this.chart.height * .8 >> 0 : this.labelFontSize * 1.5;
                    }
                }
                if (this._position === "left" || this._position === "right") {
                    if (typeof (stripLine.options.labelWrap) === "undefined") {
                        stripLineLabelMaxHeight = this.sessionVariables.labelMaxHeight;
                    }
                    else {
                        stripLineLabelMaxHeight = stripLine.labelWrap ? this.chart.width * .8 >> 0 : this.labelFontSize * 1.5;
                    }
                }

                if (!isNullOrUndefined(stripLine.options.labelBackgroundColor))
                    backgroundColor = stripLine.options.labelBackgroundColor;
                else
                    backgroundColor = "#EEEEEE";
            }
            else {
                stripLineLabelMaxWidth = (this._position === "bottom" || this._position === "top") ? this.chart.width * .9 >> 0 : this.chart.height * .9 >> 0;
                stripLineLabelMaxHeight = typeof (stripLine.options.labelWrap) === "undefined" || stripLine.labelWrap ? (this._position === "bottom" || this._position === "top") ? this.chart.width * .8 >> 0 : this.chart.height * .8 >> 0 : this.labelFontSize * 1.5;
                if (!isNullOrUndefined(stripLine.options.labelBackgroundColor))
                    backgroundColor = stripLine.options.labelBackgroundColor;
                else {
                    if (!isNullOrUndefined(stripLine.startValue) || stripLine.startValue === 0)
                        backgroundColor = "#EEEEEE";
                    else
                        backgroundColor = isCanvasSupported ? "transparent" : null;
                }
            }

            textBlock = new TextBlock(this.ctx, {
                x: 0,
                y: 0,
                //maxWidth: this.maxHeight,
                //maxHeight: this.labelFontSize,
                backgroundColor: backgroundColor,
                borderColor: stripLine.labelBorderColor,
                borderThickness: stripLine.labelBorderThickness,
                cornerRadius: stripLine.labelCornerRadius,
                maxWidth: stripLine.options.labelMaxWidth ? stripLine.options.labelMaxWidth : stripLineLabelMaxWidth,
                maxHeight: stripLineLabelMaxHeight,
                angle: this.labelAngle,
                text: stripLine.labelFormatter ? stripLine.labelFormatter({ chart: this.chart, axis: this, stripLine: stripLine }) : stripLine.label,
                horizontalAlign: "left",//left, center, right
                fontSize: stripLine.labelPlacement === "outside" ? stripLine.options.labelFontSize ? stripLine.options.labelFontSize : this.labelFontSize : stripLine.labelFontSize,//in pixels
                fontFamily: stripLine.labelPlacement === "outside" ? stripLine.options.labelFontFamily ? stripLine.options.labelFontFamily : this.labelFontFamily : stripLine.labelFontFamily,
                fontWeight: stripLine.labelPlacement === "outside" ? stripLine.options.fontWeight ? stripLine.options.fontWeight : this.fontWeight : stripLine.fontWeight, //normal, bold, bolder, lighter,
                fontColor: stripLine.options.labelFontColor || stripLine.color,
                fontStyle: stripLine.labelPlacement === "outside" ? stripLine.options.fontStyle ? stripLine.options.fontStyle : this.fontWeight : stripLine.fontStyle, // normal, italic, oblique
                textBaseline: "middle"
            });
            this._stripLineLabels.push({ position: stripLine.value, textBlock: textBlock, effectiveHeight: null, stripLine: stripLine });
        }

    }

    Axis.prototype.createLabelsAndCalculateWidth = function () {

        var maxLabelEffectiveWidth = 0;
        var i = 0;
        this._labels = [];
        //this._ticks = [];
        this._stripLineLabels = [];

        if (this._position === "left" || this._position === "right") {

            this.createLabels();

            for (i = 0; i < this._labels.length; i++) {

                var textBlock = this._labels[i].textBlock;

                var size = textBlock.measureText();

                //var hypotenuse = Math.sqrt(Math.pow(size.height / 2, 2) + Math.pow(size.width, 2));
                //labelEffectiveWidth = hypotenuse * Math.cos(Math.abs(Math.PI / 180 * this.labelAngle) - Math.abs(Math.acos(size.width / hypotenuse)));

                var labelEffectiveWidth = 0;

                if (this.labelAngle === 0)
                    labelEffectiveWidth = size.width;
                else
                    labelEffectiveWidth = (size.width * Math.cos(Math.PI / 180 * Math.abs(this.labelAngle))) + ((size.height - textBlock.fontSize / 2) * Math.sin(Math.PI / 180 * Math.abs(this.labelAngle)));


                if (maxLabelEffectiveWidth < labelEffectiveWidth)
                    maxLabelEffectiveWidth = labelEffectiveWidth;

                this._labels[i].effectiveWidth = labelEffectiveWidth;
            }
            for (i = 0; i < this._stripLineLabels.length; i++) {
                if (this._stripLineLabels[i].stripLine.labelPlacement === "outside") {
                    if (this._stripLineLabels[i].stripLine.value > this.viewportMinimum && this._stripLineLabels[i].stripLine.value < this.viewportMaximum) {
                        var textBlock = this._stripLineLabels[i].textBlock;

                        var size = textBlock.measureText();

                        //var hypotenuse = Math.sqrt(Math.pow(size.height / 2, 2) + Math.pow(size.width, 2));
                        //labelEffectiveWidth = hypotenuse * Math.cos(Math.abs(Math.PI / 180 * this.labelAngle) - Math.abs(Math.acos(size.width / hypotenuse)));

                        var labelEffectiveWidth = 0;

                        if (this.labelAngle === 0)
                            labelEffectiveWidth = size.width;
                        else
                            labelEffectiveWidth = (size.width * Math.cos(Math.PI / 180 * Math.abs(this.labelAngle))) + ((size.height - textBlock.fontSize / 2) * Math.sin(Math.PI / 180 * Math.abs(this.labelAngle)));


                        if (maxLabelEffectiveWidth < labelEffectiveWidth)
                            maxLabelEffectiveWidth = labelEffectiveWidth;

                        this._stripLineLabels[i].effectiveWidth = labelEffectiveWidth;
                    }
                }
            }
        }


        var titleHeight = this.title ? this._titleTextBlock.measureText().height + 2 : 0;

        var axisWidth = titleHeight + maxLabelEffectiveWidth + this.tickLength + 5;

        //if (isDebugMode && window.console) {
        //	window.console.log(this.type + "--- axisWidth: " + axisWidth);
        //}

        return axisWidth;
    }

    Axis.prototype.createLabelsAndCalculateHeight = function () {
        var maxLabelEffectiveHeight = 0;
        this._labels = [];
        //this._ticks = [];
        this._stripLineLabels = [];
        var textBlock;
        var i = 0;

        this.createLabels();

        if (this._position === "bottom" || this._position === "top") {

            for (i = 0; i < this._labels.length; i++) {

                textBlock = this._labels[i].textBlock;
                var size = textBlock.measureText();
                //var diagonal = Math.sqrt(Math.pow(size.height, 2) + Math.pow(size.width, 2));

                //var hypotenuse = Math.sqrt(Math.pow(size.height / 2, 2) + Math.pow(size.width, 2));
                //var labelEffectiveHeight = hypotenuse * Math.cos(Math.PI / 2 - (Math.abs(Math.PI / 180 * this.labelAngle) + Math.abs(Math.acos(size.width / hypotenuse))));

                var labelEffectiveHeight = 0;

                if (this.labelAngle === 0)
                    labelEffectiveHeight = size.height;
                else
                    labelEffectiveHeight = (size.width * Math.sin(Math.PI / 180 * Math.abs(this.labelAngle))) + ((size.height - textBlock.fontSize / 2) * Math.cos(Math.PI / 180 * Math.abs(this.labelAngle)));

                if (maxLabelEffectiveHeight < labelEffectiveHeight)
                    maxLabelEffectiveHeight = labelEffectiveHeight;

                this._labels[i].effectiveHeight = labelEffectiveHeight;
            }
            for (i = 0; i < this._stripLineLabels.length; i++) {
                if (this._stripLineLabels[i].stripLine.labelPlacement === "outside") {
                    textBlock = this._stripLineLabels[i].textBlock;
                    var size = textBlock.measureText();
                    var labelEffectiveHeight = 0;

                    if (this.labelAngle === 0)
                        labelEffectiveHeight = size.height;
                    else
                        labelEffectiveHeight = (size.width * Math.sin(Math.PI / 180 * Math.abs(this.labelAngle))) + ((size.height - textBlock.fontSize / 2) * Math.cos(Math.PI / 180 * Math.abs(this.labelAngle)));

                    if (maxLabelEffectiveHeight < labelEffectiveHeight)
                        maxLabelEffectiveHeight = labelEffectiveHeight;

                    this._stripLineLabels[i].effectiveHeight = labelEffectiveHeight;
                }
            }
        }


        //var titleHeight = this.title ? this.titleFontSize + 5 : 0;
        var titleHeight = this.title ? this._titleTextBlock.measureText().height + 2 : 0;

        return titleHeight + maxLabelEffectiveHeight + this.tickLength + 5;
    }

    //Static Method that co-ordinates between axisX, axisY and renders them
    Axis.setLayoutAndRender = function (axisX, axisX2, axisY, axisY2, axisPlacement, freeSpace) {
        var x1, y1, x2, y2;
        var chart = axisX[0] ? axisX[0].chart : axisX2[0].chart;
        var ctx = chart.ctx;

        if (axisX && axisX.length > 0) {
            for (var k = 0; k < axisX.length; k++) {
                if (axisX[k])
                    axisX[k].calculateAxisParameters();
            }
        }

        if (axisX2 && axisX2.length > 0) {
            for (var k = 0; k < axisX2.length; k++) {
                axisX2[k].calculateAxisParameters();
            }
        }

        if (axisY && axisY.length > 0)
            for (var k = 0; k < axisY.length; k++)
                axisY[k].calculateAxisParameters();

        if (axisY2 && axisY2.length > 0)
            for (var k = 0; k < axisY2.length; k++)
                axisY2[k].calculateAxisParameters();

        //if (axisY && axisY2 && typeof (axisY.options.viewportMaximum) === "undefined" && typeof (axisY.options.viewportMinimum) === "undefined" && typeof (axisY.options.interval) === "undefined"
        //		&& typeof (axisY2.options.viewportMaximum) === "undefined" && typeof (axisY2.options.viewportMinimum) === "undefined" && typeof (axisY2.options.interval) === "undefined") {

        //	var noTicksY = (axisY.viewportMaximum - axisY.viewportMinimum) / axisY.interval;

        //	var noTicksY2 = (axisY2.viewportMaximum - axisY2.viewportMinimum) / axisY2.interval;

        //	if (noTicksY > noTicksY2) {
        //		axisY2.viewportMaximum = axisY2.interval * noTicksY + axisY2.viewportMinimum;
        //	} else if (noTicksY2 > noTicksY) {
        //		axisY.viewportMaximum = axisY.interval * noTicksY2 + axisY.viewportMinimum;
        //	}
        //}


        var i = 0;
        var firstLabelWidthX = 0, lastLabelWidthX = 0, firstLabelWidthY = 0, lastLabelWidthY = 0, firstLabelWidthY2 = 0, lastLabelWidthY2 = 0, firstLabelPosition, lastLabelPosition, lastLabelWidthOutside = 0, firstLabelOutside = 0;
        var xFlag, x2Flag, yFlag, y2Flag;
        xFlag = x2Flag = yFlag = y2Flag = false;

        if (axisX && axisX.length > 0) {
            for (var k = 0; k < axisX.length; k++) {
                if (axisX[k] && axisX[k].title) {
                    axisX[k]._titleTextBlock = new TextBlock(axisX[k].ctx, {
                        text: axisX[k].title,
                        horizontalAlign: "center",//left, center, right
                        fontSize: axisX[k].titleFontSize,//in pixels
                        fontFamily: axisX[k].titleFontFamily,
                        fontWeight: axisX[k].titleFontWeight, //normal, bold, bolder, lighter,
                        fontColor: axisX[k].titleFontColor,
                        fontStyle: axisX[k].titleFontStyle, // normal, italic, oblique
                        borderColor: axisX[k].titleBorderColor,
                        borderThickness: axisX[k].titleBorderThickness,
                        backgroundColor: axisX[k].titleBackgroundColor,
                        cornerRadius: axisX[k].titleCornerRadius,
                        textBaseline: "top"
                    });
                }
            }
        }

        if (axisX2 && axisX2.length > 0) {
            for (var k = 0; k < axisX2.length; k++) {
                if (axisX2[k] && axisX2[k].title) {
                    axisX2[k]._titleTextBlock = new TextBlock(axisX2[k].ctx, {
                        text: axisX2[k].title,
                        horizontalAlign: "center",//left, center, right
                        fontSize: axisX2[k].titleFontSize,//in pixels
                        fontFamily: axisX2[k].titleFontFamily,
                        fontWeight: axisX2[k].titleFontWeight, //normal, bold, bolder, lighter,
                        fontColor: axisX2[k].titleFontColor,
                        fontStyle: axisX2[k].titleFontStyle, // normal, italic, oblique
                        borderColor: axisX2[k].titleBorderColor,
                        borderThickness: axisX2[k].titleBorderThickness,
                        backgroundColor: axisX2[k].titleBackgroundColor,
                        cornerRadius: axisX2[k].titleCornerRadius,
                        textBaseline: "top"
                    });
                }
            }
        }

        if (axisY && axisY.length > 0) {
            for (var k = 0; k < axisY.length; k++) {
                if (axisY[k] && axisY[k].title) {
                    axisY[k]._titleTextBlock = new TextBlock(axisY[k].ctx, {
                        text: axisY[k].title,
                        horizontalAlign: "center",//left, center, right
                        fontSize: axisY[k].titleFontSize,//in pixels
                        fontFamily: axisY[k].titleFontFamily,
                        fontWeight: axisY[k].titleFontWeight, //normal, bold, bolder, lighter,
                        fontColor: axisY[k].titleFontColor,
                        fontStyle: axisY[k].titleFontStyle, // normal, italic, oblique
                        borderColor: axisY[k].titleBorderColor,
                        borderThickness: axisY[k].titleBorderThickness,
                        backgroundColor: axisY[k].titleBackgroundColor,
                        cornerRadius: axisY[k].titleCornerRadius,
                        textBaseline: "top"
                    });
                }
            }
        }

        if (axisY2 && axisY2.length > 0) {
            for (var k = 0; k < axisY2.length; k++) {
                if (axisY2[k] && axisY2[k].title) {
                    axisY2[k]._titleTextBlock = new TextBlock(axisY2[k].ctx, {
                        text: axisY2[k].title,
                        horizontalAlign: "center",//left, center, right
                        fontSize: axisY2[k].titleFontSize,//in pixels
                        fontFamily: axisY2[k].titleFontFamily,
                        fontWeight: axisY2[k].titleFontWeight, //normal, bold, bolder, lighter,
                        fontColor: axisY2[k].titleFontColor,
                        fontStyle: axisY2[k].titleFontStyle, // normal, italic, oblique
                        borderColor: axisY2[k].titleBorderColor,
                        borderThickness: axisY2[k].titleBorderThickness,
                        backgroundColor: axisY2[k].titleBackgroundColor,
                        cornerRadius: axisY2[k].titleCornerRadius,
                        textBaseline: "top"
                    });
                }
            }
        }

        if (axisPlacement === "normal") {
            var axisXHeight = [], axisX2Height = [], axisYWidth = [], axisY2Width = [];
            var axisXHeights = [], axisX2Heights = [], axisYWidths = [], axisY2Widths = [];

            if (axisX && axisX.length > 0) {
                for (var k = 0; k < axisX.length; k++) {
                    if (axisX[k] && axisX[k].title) {
                        axisX[k]._titleTextBlock.maxWidth = axisX[k].titleMaxWidth || freeSpace.width;
                        axisX[k]._titleTextBlock.maxHeight = axisX[k].titleWrap ? freeSpace.height * 0.8 : axisX[k].titleFontSize * 1.5;
                        axisX[k]._titleTextBlock.angle = 0;
                    }
                }
            }

            if (axisX2 && axisX2.length > 0) {
                for (var k = 0; k < axisX2[k].length; k++) {
                    if (axisX2[k] && axisX2[k].title) {
                        axisX2[k]._titleTextBlock.maxWidth = axisX2[k].titleMaxWidth || freeSpace.width;
                        axisX2[k]._titleTextBlock.maxHeight = axisX2[k].titleWrap ? freeSpace.height * 0.8 : axisX2[k].titleFontSize * 1.5;
                        axisX2[k]._titleTextBlock.angle = 0;
                    }
                }
            }

            if (axisY && axisY.length > 0) {
                for (var k = 0; k < axisY.length; k++) {
                    if (axisY[k] && axisY[k].title) {
                        axisY[k]._titleTextBlock.maxWidth = axisY[k].titleMaxWidth || freeSpace.height;//this.lineCoordinates.height,
                        axisY[k]._titleTextBlock.maxHeight = axisY[k].titleWrap ? freeSpace.width * 0.8 : axisY[k].titleFontSize * 1.5;
                        axisY[k]._titleTextBlock.angle = -90;
                    }
                }
            }

            if (axisY2 && axisY2.length > 0) {
                for (var k = 0; k < axisY2.length; k++) {
                    if (axisY2[k] && axisY2[k].title) {
                        axisY2[k]._titleTextBlock.maxWidth = axisY2[k].titleMaxWidth || freeSpace.height;
                        axisY2[k]._titleTextBlock.maxHeight = axisY2[k].titleWrap ? freeSpace.width * 0.8 : axisY2[k].titleFontSize * 1.5;
                        axisY2[k]._titleTextBlock.angle = 90;
                    }
                }
            }

            while (i < 4) {

                var prevAxisXHeight = 0, prevAxisX2Height = 0, prevAxisYWidth = 0, prevAxisY2Width = 0;
                var axisXMargin = 0, axisX2Margin = 0, axisYMargin = 0, axisY2Margin = 0;
                var axisXTotalHeight = 0, axisX2TotalHeight = 0, axisYTotalWidth = 0, axisY2TotalWidth = 0;

                if (axisY && axisY.length > 0) {
                    axisYWidth = []; axisYTotalWidth = 0;
                    for (var k = 0; k < axisY.length; k++) {
                        axisYWidth.push(Math.ceil(axisY[k] ? axisY[k].createLabelsAndCalculateWidth() : 0));
                        axisYTotalWidth += axisYWidth[k];

                        axisYMargin += axisY[k] ? axisY[k].margin : 0;
                    }
                    axisYWidths.push(axisYWidth);
                } else {
                    axisYWidth.push(Math.ceil(axisY[0] ? axisY[0].createLabelsAndCalculateWidth() : 0));
                    axisYWidths.push(axisYWidth);
                }


                if (axisY2 && axisY2.length > 0) {
                    axisY2Width = []; axisY2TotalWidth = 0;
                    for (var k = 0; k < axisY2.length; k++) {
                        axisY2Width.push(Math.ceil(axisY2[k] ? axisY2[k].createLabelsAndCalculateWidth() : 0));
                        axisY2TotalWidth += axisY2Width[k];

                        axisY2Margin += axisY2[k] ? axisY2[k].margin : 0;
                    }
                    axisY2Widths.push(axisY2Width);
                } else {
                    axisY2Width.push(Math.ceil(axisY2[0] ? axisY2[0].createLabelsAndCalculateWidth() : 0));
                    axisY2Widths.push(axisY2Width);
                }


                x1 = Math.round(freeSpace.x1 + axisYTotalWidth + axisYMargin);

                x2 = Math.round(freeSpace.x2 - axisY2TotalWidth - axisY2Margin > chart.width - 10 ? chart.width - 10 : freeSpace.x2 - axisY2TotalWidth - axisY2Margin);

                if (axisX && axisX.length > 0) {
                    axisXHeight = []; axisXTotalHeight = 0;
                    for (var k = 0; k < axisX.length; k++) {
                        if (axisX[k])
                            axisX[k].lineCoordinates = {
                            };

                        axisX[k].lineCoordinates.width = Math.abs(x2 - x1);

                        if (axisX[k].title)
                            axisX[k]._titleTextBlock.maxWidth = axisX[k].titleMaxWidth > 0 && axisX[k].titleMaxWidth < axisX[k].lineCoordinates.width ? axisX[k].titleMaxWidth : axisX[k].lineCoordinates.width;


                        axisXHeight.push(Math.ceil(axisX[k] ? axisX[k].createLabelsAndCalculateHeight() : 0));
                        axisXTotalHeight += axisXHeight[k];

                        axisXMargin += axisX[k] ? axisX[k].margin : 0;
                    }
                    axisXHeights.push(axisXHeight);
                } else {
                    axisXHeight.push(Math.ceil(axisX[0] ? axisX[0].createLabelsAndCalculateHeight() : 0));
                    axisXHeights.push(axisXHeight);
                }

                if (axisX2 && axisX2.length > 0) {
                    axisX2Height = []; axisX2TotalHeight = 0;
                    for (var k = 0; k < axisX2.length; k++) {
                        if (axisX2[k])
                            axisX2[k].lineCoordinates = {
                            };

                        axisX2[k].lineCoordinates.width = Math.abs(x2 - x1);

                        if (axisX2[k].title)
                            axisX2[k]._titleTextBlock.maxWidth = axisX2[k].titleMaxWidth > 0 && axisX2[k].titleMaxWidth < axisX2[k].lineCoordinates.width ? axisX2[k].titleMaxWidth : axisX2[k].lineCoordinates.width;

                        axisX2Height.push(Math.ceil(axisX2[k] ? axisX2[k].createLabelsAndCalculateHeight() : 0));
                        axisX2TotalHeight += axisX2Height[k];

                        axisX2Margin += axisX2[k] ? axisX2[k].margin : 0;
                    }
                    axisX2Heights.push(axisX2Height);
                } else {
                    axisX2Height.push(Math.ceil(axisX2[0] ? axisX2[0].createLabelsAndCalculateHeight() : 0));
                    axisX2Heights.push(axisX2Height);
                }

                if (axisX && axisX.length > 0) {
                    for (var k = 0; k < axisX.length; k++) {
                        if (axisX[k]) {
                            axisX[k].lineCoordinates.x1 = x1;
                            x2 = Math.round(freeSpace.x2 - axisY2TotalWidth - axisY2Margin > chart.width - 10 ? chart.width - 10 : freeSpace.x2 - axisY2TotalWidth - axisY2Margin);

                            if (axisX[k]._labels && axisX[k]._labels.length > 1) {
                                var firstLabel = 0, lastLabel = 0;
                                firstLabel = axisX[k]._labels[1];
                                if (axisX[k].chart.plotInfo.axisXValueType === "dateTime") {
                                    lastLabel = axisX[k]._labels[axisX[k]._labels.length - 2];
                                }
                                else
                                    lastLabel = axisX[k]._labels[axisX[k]._labels.length - 1];
                                firstLabelWidthX = (firstLabel.textBlock.width * Math.cos(Math.PI / 180 * Math.abs(firstLabel.textBlock.angle))) + ((firstLabel.textBlock.height - lastLabel.textBlock.fontSize / 2) * Math.sin(Math.PI / 180 * Math.abs(firstLabel.textBlock.angle)));
                                lastLabelWidthX = (lastLabel.textBlock.width * Math.cos(Math.PI / 180 * Math.abs(lastLabel.textBlock.angle))) + ((lastLabel.textBlock.height - lastLabel.textBlock.fontSize / 2) * Math.sin(Math.PI / 180 * Math.abs(lastLabel.textBlock.angle)));
                            }

                            if (axisX[k] && axisX[k].labelAutoFit && !isNullOrUndefined(firstLabelPosition) && !isNullOrUndefined(lastLabelPosition)) {
                                lastLabelWidthOutside = 0;
                                if (axisX[k].labelAngle > 0) {
                                    if (lastLabelPosition + lastLabelWidthX > x2)
                                        lastLabelWidthOutside += ((axisX[k].labelAngle > 0) ? (lastLabelPosition + lastLabelWidthX) - x2 - axisY2TotalWidth : 0);
                                }
                                else if (axisX[k].labelAngle < 0) {
                                    if (firstLabelPosition - firstLabelWidthX < x1 && firstLabelPosition - firstLabelWidthX < axisX[k].viewportMinimum)
                                        firstLabelOutside = x1 - (axisYMargin + axisX[k].tickLength + axisYWidth + firstLabelPosition - firstLabelWidthX + axisX[k].labelFontSize / 2);

                                }
                                else if (axisX[k].labelAngle === 0) {
                                    if (lastLabelPosition + lastLabelWidthX > x2)
                                        lastLabelWidthOutside = (lastLabelPosition + lastLabelWidthX / 2) - x2 - axisY2TotalWidth;

                                    if (firstLabelPosition - firstLabelWidthX < x1 && firstLabelPosition - firstLabelWidthX < axisX[k].viewportMinimum)
                                        firstLabelOutside = x1 - axisYMargin - axisX[k].tickLength - axisYWidth - firstLabelPosition + (firstLabelWidthX / 2);

                                }
                                if ((axisX[k].viewportMaximum === axisX[k].maximum && axisX[k].viewportMinimum === axisX[k].minimum) && axisX[k].labelAngle > 0 && lastLabelWidthOutside > 0)
                                    x2 -= lastLabelWidthOutside;
                                else if ((axisX[k].viewportMaximum === axisX[k].maximum && axisX[k].viewportMinimum === axisX[k].minimum) && axisX[k].labelAngle < 0 && firstLabelOutside > 0)
                                    x1 += firstLabelOutside;
                                else if ((axisX[k].viewportMaximum === axisX[k].maximum && axisX[k].viewportMinimum === axisX[k].minimum) && axisX[k].labelAngle === 0) {
                                    if (firstLabelOutside > 0)
                                        x1 += firstLabelOutside;

                                    if (lastLabelWidthOutside > 0)
                                        x2 -= lastLabelWidthOutside;
                                }
                            }

                            if (!chart.panEnabled)
                                chart.sessionVariables.axisX.height = axisXTotalHeight;
                            else
                                axisXTotalHeight = chart.sessionVariables.axisX.height;

                            // Position axisX based on the available free space, Margin and its height
                            //x1 = freeSpace.x1 + axisYWidth + axisYMargin + axisYlineThickness / 2;
                            y1 = Math.round(freeSpace.y2 - axisXTotalHeight - axisXMargin + prevAxisXHeight);
                            y2 = Math.round(freeSpace.y2);

                            axisX[k].lineCoordinates.x2 = x2;
                            axisX[k].lineCoordinates.width = x2 - x1;
                            //axisX.lineCoordinates = { x1: x1, y1: y1, x2: x2, y2: y1, width: Math.abs(x2 - x1) }
                            axisX[k].lineCoordinates.y1 = y1;
                            axisX[k].lineCoordinates.y2 = y1;

                            axisX[k].bounds = {
                                x1: x1, y1: y1, x2: x2, y2: y2 - (axisXTotalHeight + axisXMargin - axisXHeight[k] - prevAxisXHeight), width: x2 - x1, height: y2 - y1
                            };
                        }
                        prevAxisXHeight += (axisXHeight[k] + axisX[k].margin);
                    }
                }

                if (axisX2 && axisX2.length > 0) {
                    for (var k = 0; k < axisX2.length; k++) {

                        axisX2[k].lineCoordinates.x1 = Math.round(freeSpace.x1 + axisYTotalWidth + axisYMargin);
                        axisX2[k].lineCoordinates.x2 = Math.round(freeSpace.x2 - axisY2TotalWidth - axisY2Margin > chart.width - 10 ? chart.width - 10 : freeSpace.x2 - axisY2TotalWidth - axisY2Margin);

                        axisX2[k].lineCoordinates.width = Math.abs(x2 - x1); // required early on inside createLabels of axisX

                        //if (axisX2.title)
                        //    axisX2._titleTextBlock.maxWidth = axisX2.titleMaxWidth > 0 && axisX2.titleMaxWidth < axisX2.lineCoordinates.width ? axisX2.titleMaxWidth : axisX2.lineCoordinates.width;

                        //var axisX2Height = Math.ceil(axisX2.createLabelsAndCalculateHeight());

                        if (axisX2[k]._labels && axisX2[k]._labels.length > 1) {
                            var firstLabel = 0, lastLabel = 0;
                            firstLabel = axisX2[k]._labels[1];
                            if (axisX2[k].chart.plotInfo.axisXValueType === "dateTime") {
                                lastLabel = axisX2[k]._labels[axisX2[k]._labels.length - 2];
                            }
                            else
                                lastLabel = axisX2[k]._labels[axisX2[k]._labels.length - 1];
                            firstLabelWidthX = (firstLabel.textBlock.width * Math.cos(Math.PI / 180 * Math.abs(firstLabel.textBlock.angle))) + ((firstLabel.textBlock.height - lastLabel.textBlock.fontSize / 2) * Math.sin(Math.PI / 180 * Math.abs(firstLabel.textBlock.angle)));
                            lastLabelWidthX = (lastLabel.textBlock.width * Math.cos(Math.PI / 180 * Math.abs(lastLabel.textBlock.angle))) + ((lastLabel.textBlock.height - lastLabel.textBlock.fontSize / 2) * Math.sin(Math.PI / 180 * Math.abs(lastLabel.textBlock.angle)));
                        }


                        if (!chart.panEnabled)
                            chart.sessionVariables.axisX2.height = axisX2TotalHeight;
                        else
                            axisX2TotalHeight = chart.sessionVariables.axisX2.height;

                        // Position axisX2 based on the available free space, Margin and its height
                        //x1 = freeSpace.x1 + axisYWidth + axisYMargin + axisYlineThickness / 2;
                        y1 = Math.round(freeSpace.y1);
                        y2 = Math.round(freeSpace.y2 + axisX2[k].margin);

                        //axisX.lineCoordinates = { x1: x1, y1: y1, x2: x2, y2: y1, width: Math.abs(x2 - x1) }
                        axisX2[k].lineCoordinates.y1 = y1 + axisX2TotalHeight + axisX2Margin - prevAxisX2Height;
                        axisX2[k].lineCoordinates.y2 = y1;

                        axisX2[k].bounds = {
                            x1: x1, y1: y1 + (axisX2TotalHeight + axisX2Margin - axisX2Height[k] - prevAxisX2Height), x2: x2, y2: y2, width: x2 - x1, height: y2 - y1
                        };

                        prevAxisX2Height += (axisX2Height[k] + axisX2[k].margin);
                    }
                }

                //if (isDebugMode) {
                //	axisX.ctx.rect(axisX.bounds.x1, axisX.bounds.y1, axisX.bounds.width, axisX.bounds.height);
                //	axisX.ctx.stroke();
                //}

                // Position axisY based on the available free space, Margin and its height
                if (axisY && axisY.length > 0) {
                    for (var k = 0; k < axisY.length; k++) {
                        var padding = 10;

                        if (axisY[k]) {
                            x1 = Math.round(axisX[0] ? axisX[0].lineCoordinates.x1 : axisX2[0].lineCoordinates.x1);
                            //x1 = Math.round(axisX.lineCoordinates.x1 - axisYWidth);

                            padding = axisY[k]._labels && axisY[k]._labels.length > 0 ? axisY[k]._labels[axisY[k]._labels.length - 1].textBlock.height / 2 : 10;
                            y1 = Math.round(freeSpace.y1 + axisX2TotalHeight + axisX2Margin < Math.max(padding, 10) ? Math.max(padding, 10) : freeSpace.y1 + axisX2TotalHeight + axisX2Margin);

                            //x2 = Math.round(freeSpace.x1 + axisYWidth + axisY.margin);
                            x2 = Math.round(axisX[0] ? axisX[0].lineCoordinates.x1 : axisX2[0].lineCoordinates.x1);
                            //y2 = freeSpace.y2 - axisXHeight - axisX.margin - axisX.lineThickness / 2;

                            if (!(axisX.length > 0)) {
                                padding = axisY[k]._labels && axisY[k]._labels.length > 0 ? axisY[k]._labels[0].textBlock.height / 2 : 10;
                            } else {
                                padding = 0;
                            }
                            y2 = Math.round(freeSpace.y2 - axisXTotalHeight - axisXMargin - padding);

                            axisY[k].lineCoordinates = {
                                x1: x2 - prevAxisYWidth, y1: y1, x2: x2 - prevAxisYWidth, y2: y2, height: Math.abs(y2 - y1)
                            }

                            axisY[k].bounds = {
                                x1: x1 - (axisYWidth[k] + prevAxisYWidth), y1: y1, x2: x2, y2: y2, width: x2 - x1, height: y2 - y1
                            };
                            if (axisY[k].title)
                                axisY[k]._titleTextBlock.maxWidth = axisY[k].titleMaxWidth > 0 && axisY[k].titleMaxWidth < axisY[k].lineCoordinates.height ? axisY[k].titleMaxWidth : axisY[k].lineCoordinates.height;
                            prevAxisYWidth += (axisYWidth[k] + axisY[k].margin);
                        }
                    }
                }

                // Position axisY2 based on the available free space, Margin and its height
                if (axisY2 && axisY2.length > 0) {
                    for (var k = 0; k < axisY2.length; k++) {
                        var padding = 0;
                        if (axisY2[k]) {
                            x1 = Math.round(axisX[0] ? axisX[0].lineCoordinates.x2 : axisX2[0].lineCoordinates.x2);
                            x2 = Math.round(x1);

                            padding = axisY2[k]._labels && axisY2[k]._labels.length > 0 ? axisY2[k]._labels[axisY2[k]._labels.length - 1].textBlock.height / 2 : 0;
                            y1 = Math.round(freeSpace.y1 + axisX2TotalHeight + axisX2Margin < Math.max(padding, 10) ? Math.max(padding, 10) : freeSpace.y1 + axisX2TotalHeight + axisX2Margin);

                            //y2 = freeSpace.y2 - axisXHeight - axisX.margin - axisX.lineThickness / 2;
                            if (!(axisX.length > 0)) {
                                padding = axisY2[k]._labels && axisY2[k]._labels.length > 0 ? axisY2[k]._labels[0].textBlock.height / 2 : 0;
                            } else {
                                padding = 0;
                            }
                            y2 = Math.round(freeSpace.y2 - (axisXTotalHeight + axisXMargin + padding));

                            axisY2[k].lineCoordinates = {
                                x1: x1 + prevAxisY2Width, y1: y1, x2: x1 + prevAxisY2Width, y2: y2, height: Math.abs(y2 - y1)
                            }

                            axisY2[k].bounds = {
                                x1: x1, y1: y1, x2: x2 + (axisY2Width[k] + prevAxisY2Width), y2: y2, width: x2 - x1, height: y2 - y1
                            };

                            if (axisY2[k].title)
                                axisY2[k]._titleTextBlock.maxWidth = axisY2[k].titleMaxWidth > 0 && axisY2[k].titleMaxWidth < axisY2[k].lineCoordinates.height ? axisY2[k].titleMaxWidth : axisY2[k].lineCoordinates.height;
                            prevAxisY2Width += (axisY2Width[k] + axisY2[k].margin);
                        }
                    }
                }

                if (axisX && axisX.length > 0) {
                    for (var k = 0; k < axisX.length; k++) {
                        if (axisX[k]) {
                            axisX[k].calculateValueToPixelConversionParameters();

                            if (axisX[k]._labels && axisX[k]._labels.length > 1) {
                                firstLabelPosition = (axisX[k].logarithmic ? Math.log(axisX[k]._labels[1].position / axisX[k].viewportMinimum) / axisX[k].conversionParameters.lnLogarithmBase : (axisX[k]._labels[1].position - axisX[k].viewportMinimum)) * Math.abs(axisX[k].conversionParameters.pixelPerUnit) + axisX[k].lineCoordinates.x1;
                                if (axisX[k].chart.plotInfo.axisXValueType === "dateTime")
                                    lastLabelPosition = (axisX[k].logarithmic ? Math.log(axisX[k]._labels[axisX[k]._labels.length - 2].position / axisX[k].viewportMinimum) / axisX[k].conversionParameters.lnLogarithmBase : (axisX[k]._labels[axisX[k]._labels.length - 2].position - axisX[k].viewportMinimum)) * Math.abs(axisX[k].conversionParameters.pixelPerUnit) + axisX[k].lineCoordinates.x1;
                                else
                                    lastLabelPosition = (axisX[k].logarithmic ? Math.log(axisX[k]._labels[axisX[k]._labels.length - 1].position / axisX[k].viewportMinimum) / axisX[k].conversionParameters.lnLogarithmBase : (axisX[k]._labels[axisX[k]._labels.length - 1].position - axisX[k].viewportMinimum)) * Math.abs(axisX[k].conversionParameters.pixelPerUnit) + axisX[k].lineCoordinates.x1;
                            }
                        }
                    }
                }

                if (axisX2 && axisX2.length > 0) {
                    for (var k = 0; k < axisX2.length; k++) {
                        axisX2[k].calculateValueToPixelConversionParameters();
                        if (axisX2[k]._labels && axisX2[k]._labels.length > 1) {
                            firstLabelPosition = (axisX2[k].logarithmic ? Math.log(axisX2[k]._labels[1].position / axisX2[k].viewportMinimum) / axisX2[k].conversionParameters.lnLogarithmBase : (axisX2[k]._labels[1].position - axisX2[k].viewportMinimum)) * Math.abs(axisX2[k].conversionParameters.pixelPerUnit) + axisX2[k].lineCoordinates.x1;
                            if (axisX2[k].chart.plotInfo.axisXValueType === "dateTime")
                                lastLabelPosition = (axisX2[k].logarithmic ? Math.log(axisX2[k]._labels[axisX2[k]._labels.length - 2].position / axisX2[k].viewportMinimum) / axisX2[k].conversionParameters.lnLogarithmBase : (axisX2[k]._labels[axisX2[k]._labels.length - 2].position - axisX2[k].viewportMinimum)) * Math.abs(axisX2[k].conversionParameters.pixelPerUnit) + axisX2[k].lineCoordinates.x1;
                            else
                                lastLabelPosition = (axisX2[k].logarithmic ? Math.log(axisX2[k]._labels[axisX2[k]._labels.length - 1].position / axisX2[k].viewportMinimum) / axisX2[k].conversionParameters.lnLogarithmBase : (axisX2[k]._labels[axisX2[k]._labels.length - 1].position - axisX2[k].viewportMinimum)) * Math.abs(axisX2[k].conversionParameters.pixelPerUnit) + axisX2[k].lineCoordinates.x1;
                        }
                    }
                }

                if (axisY && axisY.length > 0) {
                    for (var k = 0; k < axisY.length; k++) {
                        axisY[k].calculateValueToPixelConversionParameters();
                    }
                }

                if (axisY2 && axisY2.length > 0) {
                    for (var k = 0; k < axisY2.length; k++) {
                        axisY2[k].calculateValueToPixelConversionParameters();
                    }
                }

                if (i > 0) {
                    if (axisX && axisX.length > 0) {
                        for (var k = 0; k < axisX.length; k++) {
                            if (axisXHeights[i - 1][k] === axisXHeights[i][k])
                                xFlag = true;
                            else
                                xFlag = false
                        }
                    } else {
                        xFlag = true;
                    }
                    if (axisX2 && axisX2.length > 0) {
                        for (var k = 0; k < axisX2.length; k++) {
                            if (axisX2Heights[i - 1][k] === axisX2Heights[i][k])
                                x2Flag = true;
                            else
                                x2Flag = false;
                        }
                    } else {
                        x2Flag = true;
                    }
                    if (axisY && axisY.length > 0) {
                        for (var k = 0; k < axisY.length; k++) {
                            if (axisYWidths[i - 1][k] === axisYWidths[i][k])
                                yFlag = true;
                            else
                                yFlag = false;
                        }
                    } else {
                        yFlag = true;
                    }
                    if (axisY2 && axisY2.length > 0) {
                        for (var k = 0; k < axisY2.length; k++) {
                            if (axisY2Widths[i - 1][k] === axisY2Widths[i][k])
                                y2Flag = true;
                            else
                                y2Flag = false;
                        }
                    } else {
                        y2Flag = true;
                    }
                }

                if (xFlag && x2Flag && yFlag && y2Flag)
                    break;

                i++;
            }

            ctx.save();
            ctx.beginPath();

            if (axisX[0])
                ctx.rect(5, axisX[0].bounds.y1, axisX[0].chart.width - 10, axisX[0].bounds.height);

            if (axisX2[0])
                ctx.rect(5, axisX2[axisX2.length - 1].bounds.y1, axisX2[0].chart.width - 10, axisX2[0].bounds.height);

            ctx.clip();

            if (axisX && axisX.length > 0) {
                for (var k = 0; k < axisX.length; k++) {
                    axisX[k].renderLabelsTicksAndTitle();
                }
            }

            if (axisX2 && axisX2.length > 0) {
                for (var k = 0; k < axisX2.length; k++) {
                    axisX2[k].renderLabelsTicksAndTitle();
                }
            }

            ctx.restore();

            if (axisY && axisY.length > 0) {
                for (var k = 0; k < axisY.length; k++) {
                    axisY[k].renderLabelsTicksAndTitle();
                }
            }

            if (axisY2 && axisY2.length > 0) {
                for (var k = 0; k < axisY2.length; k++) {
                    axisY2[k].renderLabelsTicksAndTitle();
                }
            }

        }
        else {
            var axisYHeight = [], axisY2Height = [], axisXWidth = [], axisX2Width = [];
            var axisYHeights = [], axisY2Heights = [], axisXWidths = [], axisX2Widths = [];

            if (axisX && axisX.length > 0) {
                for (var k = 0; k < axisX.length; k++) {
                    if (axisX[k] && axisX[k].title) {
                        axisX[k]._titleTextBlock.maxWidth = axisX[k].titleMaxWidth || freeSpace.width;
                        axisX[k]._titleTextBlock.maxHeight = axisX[k].titleWrap ? freeSpace.height * 0.8 : axisX[k].titleFontSize * 1.5;
                        axisX[k]._titleTextBlock.angle = -90;
                    }
                }
            }

            if (axisX2 && axisX2.length > 0) {
                for (var k = 0; k < axisX2.length; k++) {
                    if (axisX2[k] && axisX2[k].title) {
                        axisX2[k]._titleTextBlock.maxWidth = axisX2[k].titleMaxWidth || freeSpace.width;
                        axisX2[k]._titleTextBlock.maxHeight = axisX2[k].titleWrap ? freeSpace.height * 0.8 : axisX2[k].titleFontSize * 1.5;
                        axisX2[k]._titleTextBlock.angle = 90;
                    }
                }
            }

            if (axisY && axisY.length > 0) {
                for (var k = 0; k < axisY.length; k++) {
                    if (axisY[k] && axisY[k].title) {
                        axisY[k]._titleTextBlock.maxWidth = axisY[k].titleMaxWidth || freeSpace.width;//axisX.lineCoordinates.width,
                        axisY[k]._titleTextBlock.maxHeight = axisY[k].titleWrap ? freeSpace.height * 0.8 : axisY[k].titleFontSize * 1.5;
                        axisY[k]._titleTextBlock.angle = 0;
                    }
                }
            }

            if (axisY2 && axisY2.length > 0) {
                for (var k = 0; k < axisY2.length; k++) {
                    if (axisY2[k] && axisY2[k].title) {
                        axisY2[k]._titleTextBlock.maxWidth = axisY2[k].titleMaxWidth || freeSpace.width;//this.lineCoordinates.width,
                        axisY2[k]._titleTextBlock.maxHeight = axisY2[k].titleWrap ? freeSpace.height * 0.8 : axisY2[k].titleFontSize * 1.5;
                        axisY2[k]._titleTextBlock.angle = 0;
                    }
                }
            }

            while (i < 4) {

                var prevAxisYHeight = 0, prevAxisY2Height = 0, prevAxisXWidth = 0, prevAxisX2Width = 0;
                var axisXMargin = 0, axisX2Margin = 0, axisYMargin = 0, axisY2Margin = 0;
                var axisYTotalHeight = 0, axisY2TotalHeight = 0, axisXTotalWidth = 0, axisX2TotalWidth = 0;

                if (axisX && axisX.length > 0) {
                    axisXWidth = []; axisXTotalWidth = 0;
                    for (var k = 0; k < axisX.length; k++) {
                        axisXWidth.push(Math.ceil(axisX[k] ? axisX[k].createLabelsAndCalculateWidth() : 0));
                        axisXTotalWidth += axisXWidth[k];

                        axisXMargin += axisX[k] ? axisX[k].margin : 0;
                    }
                    axisXWidths.push(axisXWidth);
                } else {
                    axisXWidth.push(Math.ceil(axisX[0] ? axisX[0].createLabelsAndCalculateWidth() : 0));
                    axisXWidths.push(axisXWidth);
                }

                if (axisX2 && axisX2.length > 0) {
                    axisX2Width = []; axisX2TotalWidth = 0;
                    for (var k = 0; k < axisX2.length; k++) {
                        axisX2Width.push(Math.ceil(axisX2[k] ? axisX2[k].createLabelsAndCalculateWidth() : 0));
                        axisX2TotalWidth += axisX2Width[k];

                        axisX2Margin += axisX2[k] ? axisX2[k].margin : 0;
                    }
                    axisX2Widths.push(axisX2Width);
                } else {
                    axisX2Width.push(Math.ceil(axisX2[0] ? axisX2[0].createLabelsAndCalculateWidth() : 0));
                    axisX2Widths.push(axisX2Width);
                }

                if (axisY && axisY.length > 0) {
                    for (var k = 0; k < axisY.length; k++) {
                        axisY[k].lineCoordinates = {
                        };

                        x1 = Math.round(freeSpace.x1 + axisXTotalWidth + axisXMargin);
                        x2 = Math.round(freeSpace.x2 - axisX2TotalWidth - axisX2Margin > chart.width - 10 ? chart.width - 10 : freeSpace.x2 - axisX2TotalWidth - axisX2Margin);
                        if (axisY[k].labelAutoFit) {
                            if (!isNullOrUndefined(firstLabelWidthY)) {
                                if (!axisX.length > 0)
                                    x1 = axisY[k].labelAngle < 0 ? Math.max(x1, firstLabelWidthY) : axisY[k].labelAngle === 0 ? Math.max(x1, firstLabelWidthY / 2) : x1;

                                if (!axisX2.length > 0)
                                    x2 = axisY[k].labelAngle > 0 ? x2 - lastLabelWidthY / 2 : axisY[k].labelAngle === 0 ? x2 - lastLabelWidthY / 2 : x2;
                            }
                        }
                        axisY[k].lineCoordinates.x1 = x1;
                        axisY[k].lineCoordinates.x2 = x2;
                        axisY[k].lineCoordinates.width = Math.abs(x2 - x1);
                        if (axisY[k].title)
                            axisY[k]._titleTextBlock.maxWidth = axisY[k].titleMaxWidth > 0 && axisY[k].titleMaxWidth < axisY[k].lineCoordinates.width ? axisY[k].titleMaxWidth : axisY[k].lineCoordinates.width;
                    }
                }

                if (axisY2 && axisY2.length > 0) {
                    for (var k = 0; k < axisY2.length; k++) {
                        axisY2[k].lineCoordinates = {
                        };
                        x1 = Math.round(freeSpace.x1 + axisXTotalWidth + axisXMargin);
                        x2 = Math.round(freeSpace.x2 - axisX2TotalWidth - axisX2Margin > axisY2[k].chart.width - 10 ? axisY2[k].chart.width - 10 : freeSpace.x2 - axisX2TotalWidth - axisX2Margin);
                        if (axisY2[k] && axisY2[k].labelAutoFit) {
                            if (!isNullOrUndefined(firstLabelWidthY2)) {
                                if (!axisX.length > 0)
                                    x1 = axisY2[k].labelAngle > 0 ? Math.max(x1, firstLabelWidthY2) : axisY2[k].labelAngle === 0 ? Math.max(x1, firstLabelWidthY2 / 2) : x1;

                                if (!axisX2.length > 0)
                                    x2 = axisY2[k].labelAngle < 0 ? x2 - lastLabelWidthY2 / 2 : axisY2[k].labelAngle === 0 ? x2 - lastLabelWidthY2 / 2 : x2 - (lastLabelWidthY2 / 2);
                            }
                        }
                        axisY2[k].lineCoordinates.x1 = x1;
                        axisY2[k].lineCoordinates.x2 = x2;

                        axisY2[k].lineCoordinates.width = Math.abs(x2 - x1);
                        if (axisY2[k].title)
                            axisY2[k]._titleTextBlock.maxWidth = axisY2[k].titleMaxWidth > 0 && axisY2[k].titleMaxWidth < axisY2[k].lineCoordinates.width ? axisY2[k].titleMaxWidth : axisY2[k].lineCoordinates.width;
                    }
                }

                if (axisY && axisY.length > 0) {
                    axisYHeight = []; axisYTotalHeight = 0;
                    for (var k = 0; k < axisY.length; k++) {
                        axisYHeight.push(Math.ceil(axisY[k] ? axisY[k].createLabelsAndCalculateHeight() : 0));
                        axisYTotalHeight += axisYHeight[k] + axisY[k].margin;

                        axisYMargin += axisY[k].margin;
                    }
                    axisYHeights.push(axisYHeight);
                } else {
                    axisYHeight.push(Math.ceil(axisY[0] ? axisY[0].createLabelsAndCalculateHeight() : 0));
                    axisYHeights.push(axisYHeight);
                }

                if (axisY2 && axisY2.length > 0) {
                    axisY2Height = []; axisY2TotalHeight = 0;
                    for (var k = 0; k < axisY2.length; k++) {
                        axisY2Height.push(Math.ceil(axisY2[k] ? axisY2[k].createLabelsAndCalculateHeight() : 0));
                        axisY2TotalHeight += axisY2Height[k];

                        axisY2Margin += axisY2[k].margin;
                    }
                    axisY2Heights.push(axisY2Height);
                } else {
                    axisY2Height.push(Math.ceil(axisY2[0] ? axisY2[0].createLabelsAndCalculateHeight() : 0));
                    axisY2Heights.push(axisY2Height);
                }

                if (axisY && axisY.length > 0)
                    for (var k = 0; k < axisY.length; k++) {
                        if (axisY[k]._labels.length > 0) {
                            var firstLabel = axisY[k]._labels[0];
                            var lastLabel = axisY[k]._labels[axisY[k]._labels.length - 1];
                            firstLabelWidthY = (firstLabel.textBlock.width * Math.cos(Math.PI / 180 * Math.abs(firstLabel.textBlock.angle))) + ((firstLabel.textBlock.height - lastLabel.textBlock.fontSize / 2) * Math.sin(Math.PI / 180 * Math.abs(firstLabel.textBlock.angle)));//(axisY2._labels[0].textBlock.width);
                            lastLabelWidthY = (lastLabel.textBlock.width * Math.cos(Math.PI / 180 * Math.abs(lastLabel.textBlock.angle))) + ((lastLabel.textBlock.height - lastLabel.textBlock.fontSize / 2) * Math.sin(Math.PI / 180 * Math.abs(lastLabel.textBlock.angle)));//axisY2._labels[axisY2._labels.length - 1].textBlock.width;
                        }
                    }

                if (axisY2 && axisY2.length > 0) {
                    for (var k = 0; k < axisY2.length; k++) {
                        if (axisY2[k] && axisY2[k]._labels.length > 0) {
                            var firstLabel = axisY2[k]._labels[0];
                            var lastLabel = axisY2[k]._labels[axisY2[k]._labels.length - 1];
                            firstLabelWidthY2 = (firstLabel.textBlock.width * Math.cos(Math.PI / 180 * Math.abs(firstLabel.textBlock.angle))) + ((firstLabel.textBlock.height - lastLabel.textBlock.fontSize / 2) * Math.sin(Math.PI / 180 * Math.abs(firstLabel.textBlock.angle)));//(axisY2._labels[0].textBlock.width);
                            lastLabelWidthY2 = (lastLabel.textBlock.width * Math.cos(Math.PI / 180 * Math.abs(lastLabel.textBlock.angle))) + ((lastLabel.textBlock.height - lastLabel.textBlock.fontSize / 2) * Math.sin(Math.PI / 180 * Math.abs(lastLabel.textBlock.angle)));//axisY2._labels[axisY2._labels.length - 1].textBlock.width;
                        }
                    }
                }

                if (!chart.panEnabled)
                    for (var k = 0; k < axisY.length; k++)
                        chart.sessionVariables.axisY.height = axisYHeight[k];
                else
                    for (var k = 0; k < axisY.length; k++)
                        axisYHeight[k] = chart.sessionVariables.axisY.height;

                // Position axisY based on the available free space, Margin and its height
                if (axisY && axisY.length > 0) {
                    for (var k = axisY.length - 1; k >= 0; k--) {
                        //x1 = freeSpace.x1 + axisXWidth + axisX.margin + axisX.lineThickness / 2;
                        //x2 = freeSpace.x2 > axisY.chart.width - 10 ? axisY.chart.width - 10 : freeSpace.x2;
                        y1 = Math.round(freeSpace.y2);
                        y2 = Math.round(freeSpace.y2 > axisY[k].chart.height - 10 ? axisY[k].chart.height - 10 : freeSpace.y2);

                        //axisY.lineCoordinates = { x1: x1, y1: y1, x2: x2, y2: y1, width: Math.abs(x2 - x1) }
                        axisY[k].lineCoordinates.y1 = y1 - (axisYHeight[k] + axisY[k].margin + prevAxisYHeight);
                        axisY[k].lineCoordinates.y2 = y1 - (axisYHeight[k] + axisY[k].margin + prevAxisYHeight);

                        axisY[k].bounds = {
                            x1: x1, y1: y1 - (axisYHeight[k] + prevAxisYHeight + axisY[k].margin), x2: x2, y2: y2 - (prevAxisYHeight + axisY[k].margin), width: x2 - x1, height: axisYHeight[k]
                        };

                        if (axisY[k].title)
                            axisY[k]._titleTextBlock.maxWidth = axisY[k].titleMaxWidth > 0 && axisY[k].titleMaxWidth < axisY[k].lineCoordinates.width ? axisY[k].titleMaxWidth : axisY[k].lineCoordinates.width;
                        prevAxisYHeight += (axisYHeight[k] + axisY[k].margin);
                    }
                }

                // Position axisY2 based on the available free space, Margin and its height
                if (axisY2 && axisY2.length > 0) {
                    for (var k = axisY2.length - 1; k >= 0; k--) {
                        if (axisY2[k]) {
                            //x1 = freeSpace.x1 + axisXWidth + axisX.margin + axisX.lineThickness / 2;
                            //x2 = freeSpace.x2 > axisY2.chart.width - 10 ? axisY2.chart.width - 10 : freeSpace.x2;

                            y1 = Math.round(freeSpace.y1);
                            y2 = Math.round(freeSpace.y1 + (axisY2Height[k] + axisY2[k].margin + prevAxisY2Height));

                            //axisY2.lineCoordinates = { x1: x1, y1: y2, x2: x2, y2: y2, width: Math.abs(x2 - x1) }
                            axisY2[k].lineCoordinates.y1 = y2;
                            axisY2[k].lineCoordinates.y2 = y2;

                            axisY2[k].bounds = {
                                x1: x1, y1: y1 + (axisY2[k].margin + prevAxisY2Height), x2: x2, y2: y2, width: x2 - x1, height: axisY2TotalHeight
                            };
                            if (axisY2[k].title)
                                axisY2[k]._titleTextBlock.maxWidth = axisY2[k].titleMaxWidth > 0 && axisY2[k].titleMaxWidth < axisY2[k].lineCoordinates.width ? axisY2[k].titleMaxWidth : axisY2[k].lineCoordinates.width;
                            prevAxisY2Height += (axisY2Height[k] + axisY2[k].margin);
                        }
                    }
                }

                //axisY.ctx.rect(axisY.bounds.x1, axisY.bounds.y1, axisY.bounds.width, axisY.bounds.height);
                //axisY.ctx.stroke();

                // Position axisX based on the available free space, Margin and its height
                if (axisX && axisX.length > 0) {
                    for (var k = 0; k < axisX.length; k++) {
                        var padding = 0;
                        padding = axisX[k]._labels && axisX[k]._labels.length > 0 ? axisX[k]._labels[0].textBlock.fontSize / 2 : 0;
                        x1 = Math.round(freeSpace.x1 + axisXMargin);

                        if (axisY2 && axisY2.length > 0) {
                            y1 = Math.round(axisY2[0] ? axisY2[0].lineCoordinates.y2 : (freeSpace.y1 < Math.max(padding, 10) ? Math.max(padding, 10) : freeSpace.y1));
                        } else {
                            y1 = freeSpace.y1 < Math.max(padding, 10) ? Math.max(padding, 10) : freeSpace.y1;
                        }

                        x2 = Math.round(freeSpace.x1 + axisXTotalWidth + axisXMargin);

                        if (axisY && axisY.length > 0) {
                            y2 = Math.round(axisY[0] ? axisY[0].lineCoordinates.y1 : (freeSpace.y2 - axisYTotalHeight > chart.height - Math.max(padding, 10) ? chart.height - Math.max(padding, 10) : freeSpace.y2 - axisYTotalHeight));
                        } else {
                            y2 = freeSpace.y2 > chart.height - Math.max(padding, 10) ? chart.height - Math.max(padding, 10) : freeSpace.y2;
                        }

                        if (axisY && axisY.length > 0) {
                            for (var l = 0; l < axisY.length; l++) {
                                if (axisY[l] && axisY[l].labelAutoFit) {
                                    x2 = axisY[l].labelAngle < 0 ? Math.max(x2, firstLabelWidthY) : axisY[l].labelAngle === 0 ? Math.max(x2, firstLabelWidthY / 2) : x2;
                                    x1 = axisY[l].labelAngle < 0 || axisY[l].labelAngle === 0 ? x2 - axisXTotalWidth : x1;
                                }
                            }
                        }

                        if (axisY2 && axisY2.length > 0) {
                            for (var l = 0; l < axisY2.length; l++) {
                                if (axisY2[l] && axisY2[l].labelAutoFit) {
                                    x2 = axisY2[l].lineCoordinates.x1;//Math.max(x2, firstLabelWidthY2 / 2);
                                    x1 = x2 - axisXTotalWidth;
                                }
                            }
                        }

                        axisX[k].lineCoordinates = {
                            x1: x2 - prevAxisXWidth, y1: y1, x2: x2 - prevAxisXWidth, y2: y2, height: Math.abs(y2 - y1)
                        };

                        axisX[k].bounds = {
                            x1: x2 - (axisXWidth[k] + prevAxisXWidth), y1: y1, x2: x2, y2: y2, width: x2 - x1, height: y2 - y1
                        };

                        if (axisX[k].title)
                            axisX[k]._titleTextBlock.maxWidth = axisX[k].titleMaxWidth > 0 && axisX[k].titleMaxWidth < axisX[k].lineCoordinates.height ? axisX[k].titleMaxWidth : axisX[k].lineCoordinates.height;

                        //axisX.ctx.rect(axisX.bounds.x1, axisX.bounds.y1, axisX.bounds.width, axisX.bounds.height);
                        //axisX.ctx.stroke();
                        axisX[k].calculateValueToPixelConversionParameters();

                        prevAxisXWidth += axisXWidth[k] + axisX[k].margin;
                    }
                }

                // Position axisX2 based on the available free space, Margin and its height
                if (axisX2 && axisX2.length > 0) {
                    for (var k = 0; k < axisX2.length; k++) {
                        var padding = 0;
                        padding = axisX2[k]._labels && axisX2[k]._labels.length > 0 ? axisX2[k]._labels[0].textBlock.fontSize / 2 : 0;
                        x1 = Math.round(freeSpace.x1 - axisXMargin);

                        if (axisY2 && axisY2.length > 0) {
                            y1 = Math.round(axisY2[0] ? axisY2[0].lineCoordinates.y2 : (freeSpace.y1 < Math.max(padding, 10) ? Math.max(padding, 10) : freeSpace.y1));
                        } else {
                            y1 = freeSpace.y1 < Math.max(padding, 10) ? Math.max(padding, 10) : freeSpace.y1;
                        }

                        x2 = Math.round(freeSpace.x2 - axisX2TotalWidth - axisX2Margin);

                        if (axisY && axisY.length > 0) {
                            y2 = Math.round(axisY[0] ? axisY[0].lineCoordinates.y1 : (freeSpace.y2 - axisYTotalHeight > chart.height - Math.max(padding, 10) ? chart.height - Math.max(padding, 10) : freeSpace.y2 - axisYTotalHeight));
                        } else {
                            y2 = freeSpace.y2 > chart.height - Math.max(padding, 10) ? chart.height - Math.max(padding, 10) : freeSpace.y2;
                        }

                        if (axisY && axisY.length > 0) {
                            for (var l = 0; l < axisY.length; l++) {
                                if (axisY[l] && axisY[l].labelAutoFit) {
                                    x2 = axisY[l].labelAngle < 0 ? Math.max(x2, firstLabelWidthY) : axisY[l].labelAngle === 0 ? Math.max(x2, firstLabelWidthY / 2) : x2;
                                    x1 = axisY[l].labelAngle < 0 || axisY[l].labelAngle === 0 ? x2 - axisX2TotalWidth : x1;
                                }
                            }
                        }

                        if (axisY2 && axisY2.length > 0) {
                            for (var l = 0; l < axisY2.length; l++) {
                                if (axisY2[l] && axisY2[l].labelAutoFit) {
                                    x2 = axisY2[l].lineCoordinates.x2;//Math.max(x2, firstLabelWidthY2 / 2);
                                    x1 = x2 - axisX2TotalWidth;
                                }
                            }
                        }


                        axisX2[k].lineCoordinates = {
                            x1: x2 + prevAxisX2Width, y1: y1, x2: x2 + prevAxisX2Width, y2: y2, height: Math.abs(y2 - y1)
                        };

                        axisX2[k].bounds = {
                            x1: x1, y1: y1, x2: x2 + axisX2Width[k] + prevAxisX2Width, y2: y2, width: x2 - x1, height: y2 - y1
                        };

                        if (axisX2[k].title)
                            axisX2[k]._titleTextBlock.maxWidth = axisX2[k].titleMaxWidth > 0 && axisX2[k].titleMaxWidth < axisX2[k].lineCoordinates.height ? axisX2[k].titleMaxWidth : axisX2[k].lineCoordinates.height;

                        //axisX.ctx.rect(axisX.bounds.x1, axisX.bounds.y1, axisX.bounds.width, axisX.bounds.height);
                        //axisX.ctx.stroke();
                        axisX2[k].calculateValueToPixelConversionParameters();

                        prevAxisX2Width += axisX2Width[k] + axisX2[k].margin;
                    }
                }


                if (axisY && axisY.length > 0) {
                    for (var k = 0; k < axisY.length; k++)
                        axisY[k].calculateValueToPixelConversionParameters();
                    //intervalInPixelsY = axisY.conversionParameters.pixelPerUnit * convertToNumber(axisY.interval, axisY.intervalType);
                }

                if (axisY2 && axisY2.length > 0) {
                    for (var k = 0; k < axisY2.length; k++) {
                        axisY2[k].calculateValueToPixelConversionParameters();
                        //intervalInPixelsY2 = axisY2.conversionParameters.pixelPerUnit * convertToNumber(axisY2.interval, axisY2.intervalType);
                    }
                }

                if (i > 0) {
                    if (axisX && axisX.length > 0) {
                        for (var k = 0; k < axisX.length; k++) {
                            if (axisXWidths[i - 1][k] === axisXWidths[i][k])
                                xFlag = true;
                            else
                                xFlag = false
                        }
                    } else {
                        xFlag = true;
                    }
                    if (axisX2 && axisX2.length > 0) {
                        for (var k = 0; k < axisX2.length; k++) {
                            if (axisX2Widths[i - 1][k] === axisX2Widths[i][k])
                                x2Flag = true;
                            else
                                x2Flag = false;
                        }
                    } else {
                        x2Flag = true;
                    }
                    if (axisY && axisY.length > 0) {
                        for (var k = 0; k < axisY.length; k++) {
                            if (axisYHeights[i - 1][k] === axisYHeights[i][k])
                                yFlag = true;
                            else
                                yFlag = false;
                        }
                    } else {
                        yFlag = true;
                    }
                    if (axisY2 && axisY2.length > 0) {
                        for (var k = 0; k < axisY2.length; k++) {
                            if (axisY2Heights[i - 1][k] === axisY2Heights[i][k])
                                y2Flag = true;
                            else
                                y2Flag = false;
                        }
                    } else {
                        y2Flag = true;
                    }
                }

                if (xFlag && x2Flag && yFlag && y2Flag)
                    break;

                i++;
            }

            //axisX.calculateValueToPixelConversionParameters();

            //if (axisY)
            //	axisY.calculateValueToPixelConversionParameters();
            //if (axisY2)
            //	axisY2.calculateValueToPixelConversionParameters();

            //console.log(chart.axisY.conversionParameters.pixelPerUnit * convertToNumber(chart.axisY.interval, chart.axisY.intervalType));
            //ctx.save();
            //ctx.rect(axisY.bounds.x1 - 30, axisY.bounds.y1, axisY.bounds.width + 60, axisY.bounds.height);
            //ctx.clip();

            if (axisY && axisY.length > 0)
                for (var k = 0; k < axisY.length; k++)
                    axisY[k].renderLabelsTicksAndTitle();

            if (axisY2 && axisY2.length > 0)
                for (var k = 0; k < axisY2.length; k++)
                    axisY2[k].renderLabelsTicksAndTitle();

            //ctx.restore();
            if (axisX && axisX.length > 0)
                for (var k = 0; k < axisX.length; k++)
                    axisX[k].renderLabelsTicksAndTitle();

            if (axisX2 && axisX2.length > 0)
                for (var k = 0; k < axisX2.length; k++)
                    axisX2[k].renderLabelsTicksAndTitle();
        }

        chart.preparePlotArea();

        var plotArea = chart.plotArea;

        ctx.save();
        ctx.beginPath();
        ctx.rect(plotArea.x1, plotArea.y1, Math.abs(plotArea.x2 - plotArea.x1), Math.abs(plotArea.y2 - plotArea.y1));

        ctx.clip();

        if (axisX && axisX.length > 0) {
            for (var k = 0; k < axisX.length; k++) {
                axisX[k].renderStripLinesOfThicknessType("value");
            }
        }

        if (axisX2 && axisX2.length > 0) {
            for (var k = 0; k < axisX2.length; k++) {
                axisX2[k].renderStripLinesOfThicknessType("value");
            }
        }

        if (axisY && axisY.length > 0) {
            for (var k = 0; k < axisY.length; k++) {
                axisY[k].renderStripLinesOfThicknessType("value");
            }
        }

        if (axisY2 && axisY2.length > 0) {
            for (var k = 0; k < axisY2.length; k++) {
                axisY2[k].renderStripLinesOfThicknessType("value");
            }
        }

        if (axisX && axisX.length > 0) {
            for (var k = 0; k < axisX.length; k++) {
                axisX[k].renderInterlacedColors();
            }
        }

        if (axisX2 && axisX2.length > 0) {
            for (var k = 0; k < axisX2.length; k++) {
                axisX2[k].renderInterlacedColors();
            }
        }

        if (axisY && axisY.length > 0) {
            for (var k = 0; k < axisY.length; k++) {
                axisY[k].renderInterlacedColors();
            }
        }

        if (axisY2 && axisY2.length > 0) {
            for (var k = 0; k < axisY2.length; k++) {
                axisY2[k].renderInterlacedColors();
            }
        }

        ctx.restore();

        if (axisX && axisX.length > 0) {
            for (var k = 0; k < axisX.length; k++) {
                axisX[k].renderGrid();
            }
        }

        if (axisX2 && axisX2.length > 0) {
            for (var k = 0; k < axisX2.length; k++) {
                axisX2[k].renderGrid();
            }
        }


        if (axisY && axisY.length > 0) {
            for (var k = 0; k < axisY.length; k++) {
                axisY[k].renderGrid();
            }
        }

        if (axisY2 && axisY2.length > 0) {
            for (var k = 0; k < axisY2.length; k++) {
                axisY2[k].renderGrid();
            }
        }

        if (axisX && axisX.length > 0) {
            for (var k = 0; k < axisX.length; k++) {
                axisX[k].renderAxisLine();
            }
        }

        if (axisX2 && axisX2.length > 0) {
            for (var k = 0; k < axisX2.length; k++) {
                axisX2[k].renderAxisLine();
            }
        }

        if (axisY && axisY.length > 0) {
            for (var k = 0; k < axisY.length; k++) {
                axisY[k].renderAxisLine();
            }
        }

        if (axisY2 && axisY2.length > 0) {
            for (var k = 0; k < axisY2.length; k++) {
                axisY2[k].renderAxisLine();
            }
        }

        if (axisX && axisX.length > 0) {
            for (var k = 0; k < axisX.length; k++) {
                axisX[k].renderStripLinesOfThicknessType("pixel");
            }
        }

        if (axisX2 && axisX2.length > 0) {
            for (var k = 0; k < axisX2.length; k++) {
                axisX2[k].renderStripLinesOfThicknessType("pixel");
            }
        }

        if (axisY && axisY.length > 0) {
            for (var k = 0; k < axisY.length; k++) {
                axisY[k].renderStripLinesOfThicknessType("pixel");
            }
        }

        if (axisY2 && axisY2.length > 0) {
            for (var k = 0; k < axisY2.length; k++) {
                axisY2[k].renderStripLinesOfThicknessType("pixel");
            }
        }

    }

    Axis.prototype.renderLabelsTicksAndTitle = function () {

        var skipLabels = false;
        var totalLabelWidth = 0;
        var totalLabelHeight = 0;
        var thresholdRatio = 1;
        var labelCount = 0;
        var skipStep = 2;
        var intervalInPixels = this.conversionParameters.pixelPerUnit * convertToNumber(this.interval, this.intervalType);

        if (this.labelAngle !== 0 && this.labelAngle !== 360)
            thresholdRatio = 1.2;

        //Don't skip labels when interval is explicitely set
        if (typeof (this.options.interval) === "undefined") {
            if (this._position === "bottom" || this._position === "top") {
                if (this.logarithmic && !this.equidistantInterval && this.labelAutoFit) {
                    var labels = [];
                    if (this.labelAngle !== 0 && this.labelAngle !== 360)
                        thresholdRatio = 1;
                    else
                        thresholdRatio = 1.2;
                    var nextWidth, nextPosition = this.viewportMaximum;
                    var pixelPerUnit = this.lineCoordinates.width / Math.log(this.range);
                    for (var i = this._labels.length - 1; i >= 0; i--) {
                        label = this._labels[i];

                        if (label.position < this.viewportMinimum)// don't consider stripLine's lable
                            break;
                        if (label.position > this.viewportMaximum)// don't consider stripLine's lable
                            continue;

                        if (i === this._labels.length - 1 || nextWidth < Math.log(nextPosition / label.position) * pixelPerUnit / thresholdRatio) {
                            labels.push(label);
                            nextPosition = label.position;
                            nextWidth = label.textBlock.width * Math.abs(Math.cos(Math.PI / 180 * this.labelAngle)) + label.textBlock.height * Math.abs(Math.sin(Math.PI / 180 * this.labelAngle));
                        }
                    }
                    this._labels = labels;

                } else {
                    //thresholdRatio = .9;// More space is preferred between labels when axis is horizontally aligned

                    for (var i = 0; i < this._labels.length; i++) {
                        label = this._labels[i];
                        if (label.position < this.viewportMinimum)// don't consider stripLine's label
                            continue;
                        var width = label.textBlock.width * Math.abs(Math.cos(Math.PI / 180 * this.labelAngle)) + label.textBlock.height * Math.abs(Math.sin(Math.PI / 180 * this.labelAngle));

                        totalLabelWidth += width;
                    }

                    if (totalLabelWidth > this.lineCoordinates.width * thresholdRatio && this.labelAutoFit) {
                        skipLabels = true;
                    }
                }
            } if (this._position === "left" || this._position === "right") {

                if (this.logarithmic && !this.equidistantInterval && this.labelAutoFit) {
                    var labels = [];
                    var nextHeight, nextPosition = this.viewportMaximum;
                    var pixelPerUnit = this.lineCoordinates.height / Math.log(this.range);
                    for (var i = this._labels.length - 1; i >= 0; i--) {
                        label = this._labels[i];

                        if (label.position < this.viewportMinimum)// don't consider stripLine's lable
                            break;
                        if (label.position > this.viewportMaximum)// don't consider stripLine's lable
                            continue;

                        if (i === this._labels.length - 1 || nextHeight < Math.log(nextPosition / label.position) * pixelPerUnit) {
                            labels.push(label);
                            nextPosition = label.position;
                            nextHeight = label.textBlock.height * Math.abs(Math.cos(Math.PI / 180 * this.labelAngle)) + label.textBlock.width * Math.abs(Math.sin(Math.PI / 180 * this.labelAngle));
                        }
                    }
                    this._labels = labels;
                } else {
                    for (var i = 0; i < this._labels.length; i++) {
                        label = this._labels[i];
                        if (label.position < this.viewportMinimum)// don't consider stripLine's lable
                            continue;

                        var height = label.textBlock.height * Math.abs(Math.cos(Math.PI / 180 * this.labelAngle)) + label.textBlock.width * Math.abs(Math.sin(Math.PI / 180 * this.labelAngle));

                        totalLabelHeight += height;
                    }

                    if (totalLabelHeight > this.lineCoordinates.height * thresholdRatio && this.labelAutoFit) {
                        skipLabels = true;
                    }
                }

            }
        }
        //		var width = label.textBlock.height * Math.cos(Math.PI / 180 * this.labelAngle) + label.textBlock.width * Math.sin(Math.PI / 180 * this.labelAngle);
        //		if (label.position * this.conversionParameters.pixelPerUnit + width > labelNext.position * this.conversionParameters.pixelPerUnit)
        //			skipLabels = true;
        //	}
        //}


        if (this._position === "bottom") {
            var i = 0;

            var label;
            var tick;
            var xy;

            for (i = 0; i < this._labels.length; i++) {

                label = this._labels[i];
                if (label.position < this.viewportMinimum || label.position > this.viewportMaximum)
                    continue;

                xy = this.getPixelCoordinatesOnAxis(label.position);

                if (skipLabels && labelCount++ % skipStep !== 0 && this.labelAutoFit)
                    continue;

                if (this.tickThickness) {
                    this.ctx.lineWidth = this.tickThickness;
                    this.ctx.strokeStyle = this.tickColor;
                    var tickX = (this.ctx.lineWidth % 2 === 1) ? (xy.x << 0) + .5 : (xy.x << 0);
                    this.ctx.beginPath();
                    this.ctx.moveTo(tickX, xy.y << 0);
                    this.ctx.lineTo(tickX, (xy.y + this.tickLength) << 0);
                    this.ctx.stroke();
                }

                if (label.textBlock.angle === 0) {
                    xy.x -= label.textBlock.width / 2;
                    xy.y += this.tickLength + label.textBlock.fontSize / 2;

                } else {
                    xy.x -= (this.labelAngle < 0 ? (label.textBlock.width * Math.cos(Math.PI / 180 * this.labelAngle)) : 0);
                    xy.y += this.tickLength + Math.abs((this.labelAngle < 0 ? label.textBlock.width * Math.sin(Math.PI / 180 * this.labelAngle) - 5 : 5));
                }
                label.textBlock.x = xy.x;
                label.textBlock.y = xy.y;

                label.textBlock.render(true);

            }

            if (this.title) {

                this._titleTextBlock.measureText();
                this._titleTextBlock.x = this.lineCoordinates.x1 + this.lineCoordinates.width / 2 - this._titleTextBlock.width / 2;
                this._titleTextBlock.y = this.bounds.y2 - this._titleTextBlock.height - 3;
                this.titleMaxWidth = this._titleTextBlock.maxWidth;
                this._titleTextBlock.render(true);
            }
        }
        else if (this._position === "top") {
            var i = 0;

            var label;
            var tick;
            var xy;

            for (i = 0; i < this._labels.length; i++) {
                label = this._labels[i];
                if (label.position < this.viewportMinimum || label.position > this.viewportMaximum)
                    continue;

                xy = this.getPixelCoordinatesOnAxis(label.position);

                if (skipLabels && labelCount++ % skipStep !== 0 && this.labelAutoFit)
                    continue;

                if (this.tickThickness) {
                    this.ctx.lineWidth = this.tickThickness;
                    this.ctx.strokeStyle = this.tickColor;
                    var tickX = (this.ctx.lineWidth % 2 === 1) ? (xy.x << 0) + .5 : (xy.x << 0);
                    this.ctx.beginPath();
                    this.ctx.moveTo(tickX, xy.y << 0);
                    this.ctx.lineTo(tickX, (xy.y - this.tickLength) << 0);
                    this.ctx.stroke();

                }

                if (label.textBlock.angle === 0) {
                    xy.x -= label.textBlock.width / 2;
                    xy.y -= this.tickLength + label.textBlock.height / 2;
                } else {
                    //xy.x -= label.textBlock.angle < 0 ? ((label.textBlock.width * Math.cos(Math.PI / 180 * this.labelAngle)) - (label.textBlock.height - this.labelFontSize / 2) * Math.sin(Math.PI / 180 * this.labelAngle)) : (label.textBlock.width * Math.cos(Math.PI / 180 * this.labelAngle)) + (label.textBlock.height - this.labelFontSize / 2) * Math.sin(Math.PI / 180 * this.labelAngle);
                    //xy.y -= this.tickLength + Math.abs((label.textBlock.width * Math.sin(Math.PI / 180 * this.labelAngle) + (label.textBlock.height - this.labelFontSize / 2 - 5) * Math.cos(Math.PI / 180 * this.labelAngle)));
                    xy.x += ((label.textBlock.height - this.tickLength - this.labelFontSize / 2) * Math.sin(Math.PI / 180 * this.labelAngle)) - (this.labelAngle > 0 ? label.textBlock.width * Math.cos(Math.PI / 180 * this.labelAngle) : 0);
                    xy.y -= this.tickLength + (label.textBlock.height / 2 * Math.cos(Math.PI / 180 * this.labelAngle) + (this.labelAngle > 0 ? label.textBlock.width * Math.sin(Math.PI / 180 * this.labelAngle) : 0));
                }
                label.textBlock.x = xy.x;
                label.textBlock.y = xy.y;

                label.textBlock.render(true);
            }

            if (this.title) {

                this._titleTextBlock.measureText();
                this._titleTextBlock.x = this.lineCoordinates.x1 + this.lineCoordinates.width / 2 - this._titleTextBlock.width / 2;
                this._titleTextBlock.y = this.bounds.y1 + 1;
                this.titleMaxWidth = this._titleTextBlock.maxWidth;
                this._titleTextBlock.render(true);
            }
        }
        else if (this._position === "left") {


            var label;
            var tick;
            var xy;

            for (var i = 0; i < this._labels.length; i++) {
                label = this._labels[i];
                if (label.position < this.viewportMinimum || label.position > this.viewportMaximum)
                    continue;

                xy = this.getPixelCoordinatesOnAxis(label.position);

                if (skipLabels && labelCount++ % skipStep !== 0 && this.labelAutoFit)
                    continue;

                if (this.tickThickness) {
                    this.ctx.lineWidth = this.tickThickness;
                    this.ctx.strokeStyle = this.tickColor;
                    var tickY = (this.ctx.lineWidth % 2 === 1) ? (xy.y << 0) + .5 : (xy.y << 0);
                    this.ctx.beginPath();
                    this.ctx.moveTo(xy.x << 0, tickY);
                    this.ctx.lineTo((xy.x - this.tickLength) << 0, tickY);
                    this.ctx.stroke();
                }

                //label.textBlock.x = xy.x - (label.textBlock.width * Math.cos(Math.PI / 180 * this.labelAngle)) - this.tickLength - 5;

                if (this.labelAngle === 0) {
                    label.textBlock.y = xy.y;
                    label.textBlock.x = xy.x - (label.textBlock.width * Math.cos(Math.PI / 180 * this.labelAngle)) - this.tickLength - 5;
                } else {
                    label.textBlock.y = (xy.y - (label.textBlock.width * Math.sin(Math.PI / 180 * this.labelAngle)));
                    label.textBlock.x = this.labelAngle > 0 ? (xy.x - (label.textBlock.width * Math.cos(Math.PI / 180 * this.labelAngle)) - this.tickLength - 5) : (xy.x - (label.textBlock.width * Math.cos(Math.PI / 180 * this.labelAngle)) + (label.textBlock.height - label.textBlock.fontSize / 2 - 5) * Math.sin(Math.PI / 180 * this.labelAngle) - this.tickLength);
                }
                label.textBlock.render(true);
            }

            if (this.title) {

                var size = this._titleTextBlock.measureText();

                //this._titleTextBlock.x -= 4;
                this._titleTextBlock.x = this.bounds.x1 + 1;
                this._titleTextBlock.y = (this.lineCoordinates.height / 2 + this._titleTextBlock.width / 2 + this.lineCoordinates.y1);
                this.titleMaxWidth = this._titleTextBlock.maxWidth;
                this._titleTextBlock.render(true);

                //if (isDebugMode) {
                //	window.console.log("titleFontSize: " + this.titleFontSize + "; width: " + size.width + "; height: " + size.height);
                //	window.console.log("this.bounds.x1: " + this.bounds.x1);

                //	//this.ctx.rect(this._titleTextBlock.x, this._titleTextBlock.y, this._titleTextBlock.height, -this._titleTextBlock.width);
                //	//this.ctx.stroke();

                //}

            }
        }
        else if (this._position === "right") {


            var label;
            var tick;
            var xy;

            for (var i = 0; i < this._labels.length; i++) {
                label = this._labels[i];
                if (label.position < this.viewportMinimum || label.position > this.viewportMaximum)
                    continue;

                xy = this.getPixelCoordinatesOnAxis(label.position);

                if (skipLabels && labelCount++ % skipStep !== 0 && this.labelAutoFit)
                    continue;

                if (this.tickThickness) {
                    this.ctx.lineWidth = this.tickThickness;
                    this.ctx.strokeStyle = this.tickColor;
                    var tickY = (this.ctx.lineWidth % 2 === 1) ? (xy.y << 0) + .5 : (xy.y << 0);
                    this.ctx.beginPath();
                    this.ctx.moveTo(xy.x << 0, tickY);
                    this.ctx.lineTo((xy.x + this.tickLength) << 0, tickY);
                    this.ctx.stroke();
                }

                //label.textBlock.y = xy.y - (label.textBlock.width * Math.sin(Math.PI / 180 * this.labelAngle));

                if (this.labelAngle === 0) {
                    label.textBlock.y = xy.y;
                    label.textBlock.x = xy.x + this.tickLength + 5;
                } else {
                    label.textBlock.y = this.labelAngle < 0 ? xy.y : xy.y - (label.textBlock.height - label.textBlock.fontSize / 2 - 5) * Math.cos(Math.PI / 180 * this.labelAngle);
                    label.textBlock.x = this.labelAngle > 0 ? (xy.x + ((label.textBlock.height - label.textBlock.fontSize / 2 - 5) * Math.sin(Math.PI / 180 * this.labelAngle)) + this.tickLength) : xy.x + this.tickLength + 5;//(xy.x + (label.textBlock.width * Math.sin(Math.PI / 180 * this.labelAngle)) + (label.textBlock.height - label.textBlock.fontSize / 2) * Math.cos(Math.PI / 180 * this.labelAngle) - this.tickLength - 5);
                }

                label.textBlock.render(true);
            }

            if (this.title) {

                this._titleTextBlock.measureText();
                this._titleTextBlock.x = this.bounds.x2 - 1;
                this._titleTextBlock.y = (this.lineCoordinates.height / 2 - this._titleTextBlock.width / 2 + this.lineCoordinates.y1);
                this.titleMaxWidth = this._titleTextBlock.maxWidth;
                this._titleTextBlock.render(true);

            }
        }
    }

    Axis.prototype.renderInterlacedColors = function () {
        var ctx = this.chart.plotArea.ctx;
        //return;

        var interlacedGridStartPoint;
        var interlacedGridEndPoint;
        var plotAreaCoordinates = this.chart.plotArea;
        var i = 0, renderInterlacedGrid = true;

        if ((this._position === "bottom" || this._position === "top") && this.interlacedColor) {

            ctx.fillStyle = this.interlacedColor;

            for (i = 0; i < this._labels.length; i++) {

                if (renderInterlacedGrid) {//So that the interlaced color alternates
                    interlacedGridStartPoint = this.getPixelCoordinatesOnAxis(this._labels[i].position);

                    if (i + 1 > this._labels.length - 1)
                        interlacedGridEndPoint = this.getPixelCoordinatesOnAxis(this.viewportMaximum);
                    else
                        interlacedGridEndPoint = this.getPixelCoordinatesOnAxis(this._labels[i + 1].position);
                    ctx.fillRect(Math.min(interlacedGridEndPoint.x, interlacedGridStartPoint.x), plotAreaCoordinates.y1, Math.abs(interlacedGridEndPoint.x - interlacedGridStartPoint.x), Math.abs(plotAreaCoordinates.y1 - plotAreaCoordinates.y2));
                    renderInterlacedGrid = false;
                } else
                    renderInterlacedGrid = true;

            }

        } else if ((this._position === "left" || this._position === "right") && this.interlacedColor) {

            ctx.fillStyle = this.interlacedColor;

            for (i = 0; i < this._labels.length; i++) {

                if (renderInterlacedGrid) {//So that the interlaced color alternates

                    interlacedGridEndPoint = this.getPixelCoordinatesOnAxis(this._labels[i].position);

                    if (i + 1 > this._labels.length - 1)
                        interlacedGridStartPoint = this.getPixelCoordinatesOnAxis(this.viewportMaximum);
                    else
                        interlacedGridStartPoint = this.getPixelCoordinatesOnAxis(this._labels[i + 1].position);

                    ctx.fillRect(plotAreaCoordinates.x1, Math.min(interlacedGridEndPoint.y, interlacedGridStartPoint.y), Math.abs(plotAreaCoordinates.x1 - plotAreaCoordinates.x2), Math.abs(interlacedGridStartPoint.y - interlacedGridEndPoint.y));
                    renderInterlacedGrid = false;
                } else
                    renderInterlacedGrid = true;
            }
            //throw "123";
        }

        ctx.beginPath();
    }

    //Renders stripLines of given thickness type.
    Axis.prototype.renderStripLinesOfThicknessType = function (thicknessType) {

        if (!(this.stripLines && this.stripLines.length > 0) || !thicknessType)
            return;

        var _this = this;
        var label;
        var xy;
        var i = 0, j = 0;
        var stripLineShowOnTopHandled = false;
        var labelShowOnTopHandled = false;
        var stripLinesToRender = [];
        var labelsToRender = [];
        var clippingRectHandler = false;

        for (i = 0; i < this.stripLines.length; i++) {
            var stripLine = this.stripLines[i];

            if (stripLine._thicknessType !== thicknessType)
                continue;

            //Should be skipped only if thicknessType is "pixel". If it is "value" then clipping is automatically applied before calling.
            if (thicknessType === "pixel" && (stripLine.value < this.viewportMinimum || stripLine.value > this.viewportMaximum || isNullOrUndefined(stripLine.value) || isNaN(this.range)))
                continue;

            stripLinesToRender.push(stripLine);
        }

        //Stripline Label placement
        for (i = 0; i < this._stripLineLabels.length; i++) {
            var stripLine = this.stripLines[i];
            label = this._stripLineLabels[i];
            if (label.position < this.viewportMinimum || label.position > this.viewportMaximum || isNaN(this.range))
                continue;

            xy = this.getPixelCoordinatesOnAxis(label.position);

            if (label.stripLine.labelPlacement === "outside") {
                if (stripLine) {
                    this.ctx.strokeStyle = stripLine.color;
                    if (stripLine._thicknessType === "pixel")
                        this.ctx.lineWidth = stripLine.thickness;
                }
                if (this._position === "bottom") {
                    var tickX = (this.ctx.lineWidth % 2 === 1) ? (xy.x << 0) + .5 : (xy.x << 0);
                    this.ctx.beginPath();
                    this.ctx.moveTo(tickX, xy.y << 0);
                    this.ctx.lineTo(tickX, (xy.y + this.tickLength) << 0);
                    this.ctx.stroke();

                    if (this.labelAngle === 0) {
                        xy.x -= label.textBlock.width / 2;
                        xy.y += this.tickLength + label.textBlock.fontSize / 2;

                    } else {
                        xy.x -= (this.labelAngle < 0 ? (label.textBlock.width * Math.cos(Math.PI / 180 * this.labelAngle)) : 0);
                        xy.y += this.tickLength + Math.abs((this.labelAngle < 0 ? label.textBlock.width * Math.sin(Math.PI / 180 * this.labelAngle) - 5 : 5));
                    }
                }
                else if (this._position === "top") {
                    var tickX = (this.ctx.lineWidth % 2 === 1) ? (xy.x << 0) + .5 : (xy.x << 0);
                    this.ctx.beginPath();
                    this.ctx.moveTo(tickX, xy.y << 0);
                    this.ctx.lineTo(tickX, (xy.y - this.tickLength) << 0);
                    this.ctx.stroke();
                    if (this.labelAngle === 0) {
                        xy.x -= label.textBlock.width / 2;
                        xy.y -= this.tickLength + label.textBlock.height;
                    } else {
                        xy.x += ((label.textBlock.height - this.tickLength - this.labelFontSize / 2) * Math.sin(Math.PI / 180 * this.labelAngle)) - (this.labelAngle > 0 ? label.textBlock.width * Math.cos(Math.PI / 180 * this.labelAngle) : 0);
                        xy.y -= this.tickLength + (label.textBlock.height * Math.cos(Math.PI / 180 * this.labelAngle) + (this.labelAngle > 0 ? label.textBlock.width * Math.sin(Math.PI / 180 * this.labelAngle) : 0));
                    }
                }
                else if (this._position === "left") {
                    var tickY = (this.ctx.lineWidth % 2 === 1) ? (xy.y << 0) + .5 : (xy.y << 0);
                    this.ctx.beginPath();
                    this.ctx.moveTo(xy.x << 0, tickY);
                    this.ctx.lineTo((xy.x - this.tickLength) << 0, tickY);
                    this.ctx.stroke();

                    if (this.labelAngle === 0) {
                        xy.x = xy.x - (label.textBlock.width * Math.cos(Math.PI / 180 * this.labelAngle)) - this.tickLength - 5;
                    } else {
                        xy.y = (xy.y - (label.textBlock.width * Math.sin(Math.PI / 180 * this.labelAngle)));
                        xy.x = this.labelAngle > 0 ? (xy.x - (label.textBlock.width * Math.cos(Math.PI / 180 * this.labelAngle)) - this.tickLength - 5) : (xy.x - (label.textBlock.width * Math.cos(Math.PI / 180 * this.labelAngle)) + (label.textBlock.height - label.textBlock.fontSize / 2 - 5) * Math.sin(Math.PI / 180 * this.labelAngle) - this.tickLength);
                    }
                }
                else if (this._position === "right") {
                    var tickY = (this.ctx.lineWidth % 2 === 1) ? (xy.y << 0) + .5 : (xy.y << 0);
                    this.ctx.beginPath();
                    this.ctx.moveTo(xy.x << 0, tickY);
                    this.ctx.lineTo((xy.x + this.tickLength) << 0, tickY);
                    this.ctx.stroke();

                    if (this.labelAngle === 0) {
                        xy.x = xy.x + this.tickLength + 5;
                    } else {
                        xy.y = this.labelAngle < 0 ? xy.y : xy.y - (label.textBlock.height - label.textBlock.fontSize / 2 - 5) * Math.cos(Math.PI / 180 * this.labelAngle);
                        xy.x = this.labelAngle > 0 ? (xy.x + ((label.textBlock.height - label.textBlock.fontSize / 2 - 5) * Math.sin(Math.PI / 180 * this.labelAngle)) + this.tickLength) : xy.x + this.tickLength + 5;//(xy.x + (label.textBlock.width * Math.sin(Math.PI / 180 * this.labelAngle)) + (label.textBlock.height - label.textBlock.fontSize / 2) * Math.cos(Math.PI / 180 * this.labelAngle) - this.tickLength - 5);
                    }
                }


                label.textBlock.x = xy.x;
                label.textBlock.y = xy.y;
                labelsToRender.push(label);
            }

            else {		//labelPlacement === "inside"
                label.textBlock.angle = -90;

                if (this._position === "bottom") {
                    label.textBlock.maxWidth = this.options.stripLines[i].labelMaxWidth ? this.options.stripLines[i].labelMaxWidth : this.chart.plotArea.height - 3;
                    label.textBlock.measureText();
                    if (xy.x - label.textBlock.height > this.chart.plotArea.x1) {
                        if (isNullOrUndefined(stripLine.startValue))
                            xy.x -= label.textBlock.height - label.textBlock.fontSize / 2;
                        else
                            xy.x -= label.textBlock.height / 2 - label.textBlock.fontSize / 2 + 3;
                    }
                    else {
                        label.textBlock.angle = 90;
                        if (isNullOrUndefined(stripLine.startValue))
                            xy.x += label.textBlock.height - label.textBlock.fontSize / 2;
                        else
                            xy.x += label.textBlock.height / 2 - label.textBlock.fontSize / 2 + 3;
                    }

                    if (label.textBlock.angle === -90)
                        xy.y = label.stripLine.labelAlign === "near" ? (this.chart.plotArea.y2) - 3 : label.stripLine.labelAlign === "center" ? (this.chart.plotArea.y2 + this.chart.plotArea.y1 + label.textBlock.width) / 2 : (this.chart.plotArea.y1) + label.textBlock.width + 3;
                    else
                        xy.y = label.stripLine.labelAlign === "near" ? (this.chart.plotArea.y2) - label.textBlock.width - 3 : label.stripLine.labelAlign === "center" ? (this.chart.plotArea.y2 + this.chart.plotArea.y1 - label.textBlock.width) / 2 : (this.chart.plotArea.y1) + 3;

                }
                else if (this._position === "top") {
                    label.textBlock.maxWidth = this.options.stripLines[i].labelMaxWidth ? this.options.stripLines[i].labelMaxWidth : this.chart.plotArea.height - 3;
                    label.textBlock.measureText();
                    if (xy.x - label.textBlock.height > this.chart.plotArea.x1) {
                        if (isNullOrUndefined(stripLine.startValue))
                            xy.x -= label.textBlock.height - label.textBlock.fontSize / 2;
                        else
                            xy.x -= label.textBlock.height / 2 - label.textBlock.fontSize / 2 + 3;
                    }
                    else {
                        label.textBlock.angle = 90;
                        if (isNullOrUndefined(stripLine.startValue))
                            xy.x += label.textBlock.height - label.textBlock.fontSize / 2;
                        else
                            xy.x += label.textBlock.height / 2 - label.textBlock.fontSize / 2 + 3;
                    }

                    if (label.textBlock.angle === -90)
                        xy.y = label.stripLine.labelAlign === "near" ? (this.chart.plotArea.y1) + label.textBlock.width + 3 : label.stripLine.labelAlign === "center" ? (this.chart.plotArea.y2 + this.chart.plotArea.y1 + label.textBlock.width) / 2 : (this.chart.plotArea.y2) - 3;
                    else
                        xy.y = label.stripLine.labelAlign === "near" ? (this.chart.plotArea.y1) + 3 : label.stripLine.labelAlign === "center" ? (this.chart.plotArea.y2 + this.chart.plotArea.y1 - label.textBlock.width) / 2 : (this.chart.plotArea.y2) - label.textBlock.width - 3;

                }
                else if (this._position === "left") {
                    label.textBlock.maxWidth = this.options.stripLines[i].labelMaxWidth ? this.options.stripLines[i].labelMaxWidth : this.chart.plotArea.width - 3;
                    label.textBlock.angle = 0;
                    label.textBlock.measureText();
                    if (xy.y - label.textBlock.height > this.chart.plotArea.y1) {
                        if (isNullOrUndefined(stripLine.startValue))
                            xy.y -= label.textBlock.height - label.textBlock.fontSize / 2;
                        else
                            xy.y -= label.textBlock.height / 2 - label.textBlock.fontSize + 3;
                    }

                    else if (xy.y - label.textBlock.height < this.chart.plotArea.y2) {
                        xy.y += label.textBlock.fontSize / 2 + 3;
                    }
                    else {
                        if (isNullOrUndefined(stripLine.startValue))
                            xy.y -= label.textBlock.height - label.textBlock.fontSize / 2;
                        else
                            xy.y -= label.textBlock.height / 2 - label.textBlock.fontSize + 3;
                    }

                    xy.x = label.stripLine.labelAlign === "near" ? (this.chart.plotArea.x1) + 3 : label.stripLine.labelAlign === "center" ? (this.chart.plotArea.x2 + this.chart.plotArea.x1) / 2 - label.textBlock.width / 2 : (this.chart.plotArea.x2) - label.textBlock.width - 3;

                }
                else if (this._position === "right") {
                    label.textBlock.maxWidth = this.options.stripLines[i].labelMaxWidth ? this.options.stripLines[i].labelMaxWidth : this.chart.plotArea.width - 3;
                    label.textBlock.angle = 0;
                    label.textBlock.measureText();
                    if (xy.y - +label.textBlock.height > this.chart.plotArea.y1) {
                        if (isNullOrUndefined(stripLine.startValue))
                            xy.y -= label.textBlock.height - label.textBlock.fontSize / 2;
                        else
                            xy.y -= label.textBlock.height / 2 - label.textBlock.fontSize / 2 - 3;
                    }
                    else if (xy.y - label.textBlock.height < this.chart.plotArea.y2) {
                        xy.y += label.textBlock.fontSize / 2 + 3;
                    }
                    else {
                        if (isNullOrUndefined(stripLine.startValue))
                            xy.y -= label.textBlock.height - label.textBlock.fontSize / 2;
                        else
                            xy.y -= label.textBlock.height / 2 - label.textBlock.fontSize / 2 + 3;
                    }

                    xy.x = label.stripLine.labelAlign === "near" ? (this.chart.plotArea.x2) - label.textBlock.width - 3 : label.stripLine.labelAlign === "center" ? (this.chart.plotArea.x2 + this.chart.plotArea.x1) / 2 - label.textBlock.width / 2 : (this.chart.plotArea.x1) + 3;

                }


                label.textBlock.x = xy.x;
                label.textBlock.y = xy.y;
                labelsToRender.push(label);
            }
        }

        if (!clippingRectHandler) {//Render all StripLines and labels with labelPlacement="inside"
            labelShowOnTopHandled = false;
            this.ctx.save();
            this.ctx.beginPath();
            this.ctx.rect(this.chart.plotArea.x1, this.chart.plotArea.y1, this.chart.plotArea.width, this.chart.plotArea.height);
            this.ctx.clip();

            //Render all StripLines
            for (i = 0; i < stripLinesToRender.length; i++) {
                var stripLine = stripLinesToRender[i];
                if (stripLine.showOnTop) {
                    if (!stripLineShowOnTopHandled) {
                        stripLineShowOnTopHandled = true;
                        this.chart.addEventListener("dataAnimationIterationEnd", function () {
                            this.ctx.save();
                            this.ctx.beginPath();
                            this.ctx.rect(this.chart.plotArea.x1, this.chart.plotArea.y1, this.chart.plotArea.width, this.chart.plotArea.height);
                            this.ctx.clip();
                            for (j = 0; j < stripLinesToRender.length; j++) {
                                stripLine = stripLinesToRender[j];
                                if (stripLine.showOnTop)
                                    stripLine.render();
                                else
                                    continue;
                            }
                            this.ctx.restore();
                        }, stripLine);
                    }
                }
                else
                    stripLine.render();
            }
            //Render all labels with labelPlacement="inside" and labelPLacement="outside" and showOnTop=true
            for (i = 0; i < labelsToRender.length; i++) {
                label = labelsToRender[i];
                if (label.stripLine.showOnTop) {
                    if (!labelShowOnTopHandled) {
                        labelShowOnTopHandled = true;
                        this.chart.addEventListener("dataAnimationIterationEnd", function () {
                            for (j = 0; j < labelsToRender.length; j++) {
                                label = labelsToRender[j];
                                if (label.stripLine.labelPlacement === "inside" && label.stripLine.showOnTop) {
                                    _this.ctx.save();
                                    _this.ctx.beginPath();
                                    _this.ctx.rect(_this.chart.plotArea.x1, _this.chart.plotArea.y1, _this.chart.plotArea.width, _this.chart.plotArea.height);
                                    _this.ctx.clip();
                                    label.textBlock.render(true);
                                    _this.ctx.restore();
                                }
                                else
                                    continue;
                            }
                        }, label.textBlock);
                    }
                }
                else {
                    if (label.stripLine.labelPlacement === "inside")
                        label.textBlock.render(true);
                }
            }
            this.ctx.restore();
            clippingRectHandler = true;
        }
        if (clippingRectHandler) {//render all labels with labelPlacement="outside"
            labelShowOnTopHandled = false;
            for (i = 0; i < labelsToRender.length; i++) {
                label = labelsToRender[i];
                if (label.stripLine.showOnTop) {
                    if (!labelShowOnTopHandled) {
                        labelShowOnTopHandled = true;
                        this.chart.addEventListener("dataAnimationIterationEnd", function () {
                            for (j = 0; j < labelsToRender.length; j++) {
                                label = labelsToRender[j];
                                if (label.stripLine.labelPlacement === "outside" && label.stripLine.showOnTop) {
                                    label.textBlock.render(true);
                                }
                                else
                                    continue;
                            }
                        }, label.textBlock);
                    }
                }
                else {
                    if (label.stripLine.labelPlacement === "outside")
                        label.textBlock.render(true);
                }
            }
        }
    };

    Axis.prototype.renderGrid = function () {

        if (!(this.gridThickness && this.gridThickness > 0))
            return;

        //var ctx = this.chart.plotArea.ctx;
        var ctx = this.chart.ctx;
        ctx.save();

        var xy;
        var plotAreaCoordinates = this.chart.plotArea;
        var stripLine;
        var tempLineWidth, tempStrokeStyle;

        ctx.lineWidth = this.gridThickness;
        ctx.strokeStyle = this.gridColor;

        if (ctx.setLineDash) {
            ctx.setLineDash(getLineDashArray(this.gridDashType, this.gridThickness));
        }


        if (this._position === "bottom" || this._position === "top") {

            for (i = 0; i < this._labels.length; i++) {

                if (this._labels[i].position < this.viewportMinimum || this._labels[i].position > this.viewportMaximum)
                    continue;

                ctx.beginPath();

                xy = this.getPixelCoordinatesOnAxis(this._labels[i].position);

                var gridX = (ctx.lineWidth % 2 === 1) ? (xy.x << 0) + .5 : (xy.x << 0);

                ctx.moveTo(gridX, plotAreaCoordinates.y1 << 0);
                ctx.lineTo(gridX, plotAreaCoordinates.y2 << 0);

                ctx.stroke();
            }

        }
        else if (this._position === "left" || this._position === "right") {

            for (var i = 0; i < this._labels.length; i++) {

                //if (i === 0 && this.type === "axisY" && this.chart.axisX && this.chart.axisX.lineThickness && this._labels[i].position === this.viewportMinimum)
                //	continue;

                if (this._labels[i].position < this.viewportMinimum || this._labels[i].position > this.viewportMaximum)
                    continue;

                ctx.beginPath();

                xy = this.getPixelCoordinatesOnAxis(this._labels[i].position);

                var gridY = (ctx.lineWidth % 2 === 1) ? (xy.y << 0) + .5 : (xy.y << 0);

                ctx.moveTo(plotAreaCoordinates.x1 << 0, gridY);
                ctx.lineTo(plotAreaCoordinates.x2 << 0, gridY);

                ctx.stroke();
            }

        }

        ctx.restore();
    }

    Axis.prototype.renderAxisLine = function () {
        //var ctx = this.chart.plotArea.ctx;
        var ctx = this.chart.ctx;
        ctx.save();

        if (this._position === "bottom" || this._position === "top") {
            if (this.lineThickness) {
                ctx.lineWidth = this.lineThickness;
                ctx.strokeStyle = this.lineColor ? this.lineColor : "black";

                if (ctx.setLineDash) {
                    ctx.setLineDash(getLineDashArray(this.lineDashType, this.lineThickness));
                }

                var lineY = (this.lineThickness % 2 === 1) ? (this.lineCoordinates.y1 << 0) + .5 : (this.lineCoordinates.y1 << 0);

                ctx.beginPath();
                ctx.moveTo(this.lineCoordinates.x1, lineY);
                ctx.lineTo(this.lineCoordinates.x2, lineY);
                ctx.stroke();
            }

        } else if (this._position === "left" || this._position === "right") {
            if (this.lineThickness) {
                ctx.lineWidth = this.lineThickness;
                ctx.strokeStyle = this.lineColor;

                if (ctx.setLineDash) {
                    ctx.setLineDash(getLineDashArray(this.lineDashType, this.lineThickness));
                }

                var lineX = (this.lineThickness % 2 === 1) ? (this.lineCoordinates.x1 << 0) + .5 : (this.lineCoordinates.x1 << 0);

                ctx.beginPath();
                ctx.moveTo(lineX, this.lineCoordinates.y1);
                ctx.lineTo(lineX, this.lineCoordinates.y2);
                ctx.stroke();
            }
        }

        ctx.restore();
    }

    Axis.prototype.getPixelCoordinatesOnAxis = function (value) {
        var xy = {
        };
        var width = this.lineCoordinates.width;
        var height = this.lineCoordinates.height;

        if (this._position === "bottom" || this._position === "top") {
            var pixelPerUnit = this.conversionParameters.pixelPerUnit;

            xy.x = this.convertValueToPixel(value);
            xy.y = this.lineCoordinates.y1;
        }
        if (this._position === "left" || this._position === "right") {
            var pixelPerUnit = -this.conversionParameters.pixelPerUnit;

            xy.y = this.convertValueToPixel(value);
            xy.x = this.lineCoordinates.x2;
        }

        return xy;
    }

    Axis.prototype.convertPixelToValue = function (pixel) {
        if (typeof (pixel) === "undefined")
            return null;

        var value = 0;
        var p = 0;

        if (typeof (pixel) === "number")
            p = pixel;
        else
            p = (this._position === "left" || this._position === "right") ? pixel.y : pixel.x;

        if (this.logarithmic)
            value = Math.pow(this.logarithmBase, (p - this.conversionParameters.reference) / this.conversionParameters.pixelPerUnit) * this.viewportMinimum;
        else
            value = this.conversionParameters.minimum + (p - this.conversionParameters.reference) / this.conversionParameters.pixelPerUnit;

        return value;
    }

    Axis.prototype.convertValueToPixel = function (value) {

        var pixel;

        if (this.logarithmic)
            pixel = (this.conversionParameters.reference + this.conversionParameters.pixelPerUnit * Math.log(value / this.conversionParameters.minimum) / this.conversionParameters.lnLogarithmBase) + .5 << 0;
        else
            pixel = (this.conversionParameters.reference + this.conversionParameters.pixelPerUnit * (value - this.conversionParameters.minimum) + .5) << 0;

        return pixel;
    }

    Axis.prototype.setViewPortRange = function (viewportMinimum, viewportMaximum) {

        this.sessionVariables.newViewportMinimum = this.viewportMinimum = Math.min(viewportMinimum, viewportMaximum);
        this.sessionVariables.newViewportMaximum = this.viewportMaximum = Math.max(viewportMinimum, viewportMaximum);

    }

    Axis.prototype.getXValueAt = function (pixel) {
        if (!pixel)
            return null;

        var xval = null;

        if (this._position === "left") {
            xval = this.convertPixelToValue(pixel.y);
        }
        else if (this._position === "bottom") {
            xval = this.convertPixelToValue(pixel.x);
        }

        return xval;
    }

    Axis.prototype.calculateValueToPixelConversionParameters = function (value) {
        //this.reversed = false;

        var conversionParameters = {
            pixelPerUnit: null, minimum: null, reference: null
        };

        var width = this.lineCoordinates.width;
        var height = this.lineCoordinates.height;

        conversionParameters.minimum = this.viewportMinimum;

        if (this._position === "bottom" || this._position === "top") {
            if (this.logarithmic) {
                conversionParameters.lnLogarithmBase = Math.log(this.logarithmBase);
                conversionParameters.pixelPerUnit = (this.reversed ? -1 : 1) * width * conversionParameters.lnLogarithmBase / Math.log(Math.abs(this.range));
            }
            else
                conversionParameters.pixelPerUnit = (this.reversed ? -1 : 1) * width / Math.abs(this.range);
            conversionParameters.reference = (this.reversed ? this.lineCoordinates.x2 : this.lineCoordinates.x1);
        }

        if (this._position === "left" || this._position === "right") {
            if (this.logarithmic) {
                conversionParameters.lnLogarithmBase = Math.log(this.logarithmBase);
                conversionParameters.pixelPerUnit = (this.reversed ? 1 : -1) * height * conversionParameters.lnLogarithmBase / Math.log(Math.abs(this.range));
            }
            else
                conversionParameters.pixelPerUnit = (this.reversed ? 1 : -1) * height / Math.abs(this.range);
            conversionParameters.reference = (this.reversed ? this.lineCoordinates.y1 : this.lineCoordinates.y2);
        }


        this.conversionParameters = conversionParameters;
    }

    Axis.prototype.calculateAxisParameters = function () {

        if (this.logarithmic) {
            this.calculateLogarithamicAxisParameters();
            return;
        }

        var freeSpace = this.chart.layoutManager.getFreeSpace();
        var availableWidth = 0;
        var availableHeight = 0;
        var isLessThanTwoDataPoints = false;
        var isDateTime = false;

        if (this._position === "bottom" || this._position === "top") {
            this.maxWidth = freeSpace.width;
            this.maxHeight = freeSpace.height;
        } else {
            this.maxWidth = freeSpace.height;
            this.maxHeight = freeSpace.width;
        }

        var pixelsPerInterval = this.type === "axisX" ? (this.chart.plotInfo.axisPlacement === "xySwapped" ? 62 : 70) : (this.chart.plotInfo.axisPlacement === "xySwapped" ? 50 : 40);
        var minTicks = 4;

        if (this.type === "axisX") {
            if (this.maxWidth < 600)
                minTicks = 8;
            else
                minTicks = 6;
        }

        var noTicks = Math.max(minTicks, Math.floor(this.maxWidth / pixelsPerInterval));


        var min, max;
        var minDiff;
        var range;
        var rangePadding = 0;

        if (!isNullOrUndefined(this.options.viewportMinimum) && !isNullOrUndefined(this.options.viewportMaximum) && this.options.viewportMinimum >= this.options.viewportMaximum)
            this.viewportMinimum = this.viewportMaximum = null;

        if (isNullOrUndefined(this.options.viewportMinimum) && !isNullOrUndefined(this.sessionVariables.newViewportMinimum) && !isNaN(this.sessionVariables.newViewportMinimum))
            this.viewportMinimum = this.sessionVariables.newViewportMinimum;
        else if (this.viewportMinimum === null || isNaN(this.viewportMinimum))
            this.viewportMinimum = this.minimum;

        if (isNullOrUndefined(this.options.viewportMaximum) && !isNullOrUndefined(this.sessionVariables.newViewportMaximum) && !isNaN(this.sessionVariables.newViewportMaximum))
            this.viewportMaximum = this.sessionVariables.newViewportMaximum;
        else if (this.viewportMaximum === null || isNaN(this.viewportMaximum))
            this.viewportMaximum = this.maximum;

        if (this.type === "axisX") {
            if (this.dataSeries && this.dataSeries.length > 0) {
                for (var k = 0; k < this.dataSeries.length; k++) {
                    if (this.dataSeries[k].xValueType === "dateTime")
                        isDateTime = true;
                }
            }

            min = (this.viewportMinimum !== null) ? this.viewportMinimum : this.dataInfo.viewPortMin;
            max = (this.viewportMaximum !== null) ? this.viewportMaximum : this.dataInfo.viewPortMax;

            if (max - min === 0) {
                rangePadding = typeof (this.options.interval) === "undefined" ? .4 : this.options.interval;

                max += rangePadding;
                min -= rangePadding;
            }

            if (this.dataInfo.minDiff !== Infinity)
                minDiff = this.dataInfo.minDiff;
            else if (max - min > 1) {
                minDiff = Math.abs(max - min) * .5;
            }
            else {
                minDiff = 1;

                if (isDateTime)
                    isLessThanTwoDataPoints = true;
            }

        } else if (this.type === "axisY") {

            //min = typeof (this.options.viewportMinimum) === "undefined" || this.options.viewportMinimum === null ? this.dataInfo.viewPortMin : this.options.viewportMinimum;
            //max = typeof (this.options.viewportMaximum) === "undefined" || this.options.viewportMaximum === null ? this.dataInfo.viewPortMax : this.options.viewportMaximum;
            min = (this.viewportMinimum !== null) ? this.viewportMinimum : this.dataInfo.viewPortMin;
            max = (this.viewportMaximum !== null) ? this.viewportMaximum : this.dataInfo.viewPortMax;

            if (!isFinite(min) && !isFinite(max)) {
                max = typeof (this.options.interval) === "undefined" ? -Infinity : this.options.interval;
                min = (typeof (this.options.interval) === "undefined" && !isFinite(this.dataInfo.minDiff)) ? Infinity : 0;
            } else if (!isFinite(min)) {
                min = max;
            } else if (!isFinite(max)) {
                max = min;
            }

            if (min === 0 && max === 0) {// When all dataPoints are zero
                max += 9;
                min = 0;
            }
            else if (max - min === 0) {// When there is only a single dataPoint or when all dataPoints have same Y Value
                rangePadding = Math.min(Math.abs(Math.abs(max) * .01), 5);
                max += rangePadding;
                min -= rangePadding;
            }
            else if (min > max) {
                rangePadding = Math.min(Math.abs(Math.abs(max - min) * .01), 5);

                if (max >= 0)
                    min = max - rangePadding;
                else
                    max = (isFinite(min) ? min + rangePadding : 0);
            }
            else {

                rangePadding = Math.min(Math.abs(Math.abs(max - min) * .01), .05);

                if (max !== 0)
                    max += rangePadding;
                if (min !== 0)
                    min -= rangePadding;
            }

            if (this.dataInfo.minDiff !== Infinity)
                minDiff = this.dataInfo.minDiff;
            else if (max - min > 1) {
                minDiff = Math.abs(max - min) * .5;
            }
            else {
                minDiff = 1;
            }


            //Apply includeZero
            if (this.includeZero && (this.viewportMinimum === null || isNaN(this.viewportMinimum))) {
                if (min > 0)
                    min = 0;
            }

            if (this.includeZero && (this.viewportMaximum === null || isNaN(this.viewportMaximum))) {
                if (max < 0)
                    max = 0;
            }
        }

        range = (isNaN(this.viewportMaximum) || this.viewportMaximum === null ? max : this.viewportMaximum) - (isNaN(this.viewportMinimum) || this.viewportMinimum === null ? min : this.viewportMinimum);

        if (this.type === "axisX" && isDateTime) {

            if (!this.intervalType) {

                if (range / (1 * 1) <= noTicks) {
                    this.interval = 1;
                    this.intervalType = "millisecond";
                } else if (range / (1 * 2) <= noTicks) {
                    this.interval = 2;
                    this.intervalType = "millisecond";
                } else if (range / (1 * 5) <= noTicks) {
                    this.interval = 5;
                    this.intervalType = "millisecond";
                } else if (range / (1 * 10) <= noTicks) {
                    this.interval = 10;
                    this.intervalType = "millisecond";
                } else if (range / (1 * 20) <= noTicks) {
                    this.interval = 20;
                    this.intervalType = "millisecond";
                } else if (range / (1 * 50) <= noTicks) {
                    this.interval = 50;
                    this.intervalType = "millisecond";
                } else if (range / (1 * 100) <= noTicks) {
                    this.interval = 100;
                    this.intervalType = "millisecond";
                } else if (range / (1 * 200) <= noTicks) {
                    this.interval = 200;
                    this.intervalType = "millisecond";
                } else if (range / (1 * 250) <= noTicks) {
                    this.interval = 250;
                    this.intervalType = "millisecond";
                } else if (range / (1 * 300) <= noTicks) {
                    this.interval = 300;
                    this.intervalType = "millisecond";
                } else if (range / (1 * 400) <= noTicks) {
                    this.interval = 400;
                    this.intervalType = "millisecond";
                } else if (range / (1 * 500) <= noTicks) {
                    this.interval = 500;
                    this.intervalType = "millisecond";
                } else if (range / (constants.secondDuration * 1) <= noTicks) {
                    this.interval = 1;
                    this.intervalType = "second";
                } else if (range / (constants.secondDuration * 2) <= noTicks) {
                    this.interval = 2;
                    this.intervalType = "second";
                } else if (range / (constants.secondDuration * 5) <= noTicks) {
                    this.interval = 5;
                    this.intervalType = "second";
                } else if (range / (constants.secondDuration * 10) <= noTicks) {
                    this.interval = 10;
                    this.intervalType = "second";
                } else if (range / (constants.secondDuration * 15) <= noTicks) {
                    this.interval = 15;
                    this.intervalType = "second";
                } else if (range / (constants.secondDuration * 20) <= noTicks) {
                    this.interval = 20;
                    this.intervalType = "second";
                } else if (range / (constants.secondDuration * 30) <= noTicks) {
                    this.interval = 30;
                    this.intervalType = "second";
                } else if (range / (constants.minuteDuration * 1) <= noTicks) {
                    this.interval = 1;
                    this.intervalType = "minute";
                } else if (range / (constants.minuteDuration * 2) <= noTicks) {
                    this.interval = 2;
                    this.intervalType = "minute";
                } else if (range / (constants.minuteDuration * 5) <= noTicks) {
                    this.interval = 5;
                    this.intervalType = "minute";
                } else if (range / (constants.minuteDuration * 10) <= noTicks) {
                    this.interval = 10;
                    this.intervalType = "minute";
                } else if (range / (constants.minuteDuration * 15) <= noTicks) {
                    this.interval = 15;
                    this.intervalType = "minute";
                } else if (range / (constants.minuteDuration * 20) <= noTicks) {
                    this.interval = 20;
                    this.intervalType = "minute";
                } else if (range / (constants.minuteDuration * 30) <= noTicks) {
                    this.interval = 30;
                    this.intervalType = "minute";
                } else if (range / (constants.hourDuration * 1) <= noTicks) {
                    this.interval = 1;
                    this.intervalType = "hour";
                } else if (range / (constants.hourDuration * 2) <= noTicks) {
                    this.interval = 2;
                    this.intervalType = "hour";
                } else if (range / (constants.hourDuration * 3) <= noTicks) {
                    this.interval = 3;
                    this.intervalType = "hour";
                } else if (range / (constants.hourDuration * 6) <= noTicks) {
                    this.interval = 6;
                    this.intervalType = "hour";
                } else if (range / (constants.dayDuration * 1) <= noTicks) {
                    this.interval = 1;
                    this.intervalType = "day";
                } else if (range / (constants.dayDuration * 2) <= noTicks) {
                    this.interval = 2;
                    this.intervalType = "day";
                } else if (range / (constants.dayDuration * 4) <= noTicks) {
                    this.interval = 4;
                    this.intervalType = "day";
                } else if (range / (constants.weekDuration * 1) <= noTicks) {
                    this.interval = 1;
                    this.intervalType = "week";
                } else if (range / (constants.weekDuration * 2) <= noTicks) {
                    this.interval = 2;
                    this.intervalType = "week";
                } else if (range / (constants.weekDuration * 3) <= noTicks) {
                    this.interval = 3;
                    this.intervalType = "week";
                } else if (range / (constants.monthDuration * 1) <= noTicks) {
                    this.interval = 1;
                    this.intervalType = "month";
                } else if (range / (constants.monthDuration * 2) <= noTicks) {
                    this.interval = 2;
                    this.intervalType = "month";
                } else if (range / (constants.monthDuration * 3) <= noTicks) {
                    this.interval = 3;
                    this.intervalType = "month";
                } else if (range / (constants.monthDuration * 6) <= noTicks) {
                    this.interval = 6;
                    this.intervalType = "month";
                } else if (range / (constants.yearDuration * 1) <= noTicks) {
                    this.interval = 1;
                    this.intervalType = "year";
                } else if (range / (constants.yearDuration * 2) <= noTicks) {
                    this.interval = 2;
                    this.intervalType = "year";
                } else if (range / (constants.yearDuration * 4) <= noTicks) {
                    this.interval = 4;
                    this.intervalType = "year";
                } else {
                    this.interval = Math.floor(Axis.getNiceNumber(range / (noTicks - 1), true) / constants.yearDuration);
                    this.intervalType = "year";
                }

            }

            if (this.viewportMinimum === null || isNaN(this.viewportMinimum))
                this.viewportMinimum = min - minDiff / 2;

            if (this.viewportMaximum === null || isNaN(this.viewportMaximum))
                this.viewportMaximum = max + minDiff / 2;


            if (isLessThanTwoDataPoints) {
                this.autoValueFormatString = "MMM DD YYYY HH:mm";
            } else if (this.intervalType === "year") {
                this.autoValueFormatString = "YYYY";
            } else if (this.intervalType === "month") {
                this.autoValueFormatString = "MMM YYYY";
            } else if (this.intervalType === "week") {
                this.autoValueFormatString = "MMM DD YYYY";
            } else if (this.intervalType === "day") {
                this.autoValueFormatString = "MMM DD YYYY";
            } else if (this.intervalType === "hour") {
                this.autoValueFormatString = "hh:mm TT";
            } else if (this.intervalType === "minute") {
                this.autoValueFormatString = "hh:mm TT";
            } else if (this.intervalType === "second") {
                this.autoValueFormatString = "hh:mm:ss TT";
            } else if (this.intervalType === "millisecond") {
                this.autoValueFormatString = "fff'ms'";
            }

            if (!this.valueFormatString) {
                this.valueFormatString = this.autoValueFormatString;
            }

        } else {

            this.intervalType = "number";

            range = Axis.getNiceNumber(range, false);

            if (this.options && this.options.interval > 0)
                this.interval = this.options.interval;
            else {
                this.interval = Axis.getNiceNumber(range / (noTicks - 1), true);
            }
            //if (this.labelAutoFit) {
            //	this.interval = Axis.getNiceNumber(range / (noTicks - 1), true);
            //	this.interval = this.options.interval ? this.options.interval < this.interval ? this.interval : this.options.interval : this.interval ;
            //}

            if (this.viewportMinimum === null || isNaN(this.viewportMinimum)) {
                if (this.type === "axisX")
                    this.viewportMinimum = min - minDiff / 2;
                else
                    this.viewportMinimum = Math.floor(min / this.interval) * this.interval;
            }

            if (this.viewportMaximum === null || isNaN(this.viewportMaximum)) {
                if (this.type === "axisX")
                    this.viewportMaximum = max + minDiff / 2;
                else
                    this.viewportMaximum = Math.ceil(max / this.interval) * this.interval;
            }

            if (this.viewportMaximum === 0 && this.viewportMinimum === 0) {

                if (this.options.viewportMinimum === 0) {
                    this.viewportMaximum += 10;
                }
                else if (this.options.viewportMaximum === 0) {
                    this.viewportMinimum -= 10;
                }

                if (this.options && typeof (this.options.interval) === "undefined") {
                    this.interval = Axis.getNiceNumber((this.viewportMaximum - this.viewportMinimum) / (noTicks - 1), true);
                }
            }
        }

        //Calculate minimum and maximum if not provided by the user
        if (this.minimum === null || this.maximum === null) {
            if (this.type === "axisX") {
                min = (this.minimum !== null) ? this.minimum : this.dataInfo.min;
                max = (this.maximum !== null) ? this.maximum : this.dataInfo.max;

                if (max - min === 0) {
                    rangePadding = typeof (this.options.interval) === "undefined" ? .4 : this.options.interval;

                    max += rangePadding;
                    min -= rangePadding;
                }

                if (this.dataInfo.minDiff !== Infinity)
                    minDiff = this.dataInfo.minDiff;
                else if (max - min > 1) {
                    minDiff = Math.abs(max - min) * .5;
                }
                else {
                    minDiff = 1;
                }

            } else if (this.type === "axisY") {

                min = (this.minimum !== null) ? this.minimum : this.dataInfo.min;
                max = (this.maximum !== null) ? this.maximum : this.dataInfo.max;

                if (!isFinite(min) && !isFinite(max)) {
                    max = typeof (this.options.interval) === "undefined" ? -Infinity : this.options.interval;
                    min = (typeof (this.options.interval) === "undefined" && !isFinite(this.dataInfo.minDiff)) ? Infinity : 0;
                }
                else
                if (min === 0 && max === 0) {// When all dataPoints are zero
                    max += 9;
                    min = 0;
                }
                else if (max - min === 0) {// When there is only a single dataPoint or when all dataPoints have same Y Value
                    rangePadding = Math.min(Math.abs(Math.abs(max) * .01), 5);
                    max += rangePadding;
                    min -= rangePadding;
                }
                else if (min > max) {
                    rangePadding = Math.min(Math.abs(Math.abs(max - min) * .01), 5);

                    if (max >= 0)
                        min = max - rangePadding;
                    else
                        max = (isFinite(min) ? min + rangePadding : 0);
                }
                else {

                    rangePadding = Math.min(Math.abs(Math.abs(max - min) * .01), .05);

                    if (max !== 0)
                        max += rangePadding;
                    if (min !== 0)
                        min -= rangePadding;
                }

                if (this.dataInfo.minDiff !== Infinity)
                    minDiff = this.dataInfo.minDiff;
                else if (max - min > 1) {
                    minDiff = Math.abs(max - min) * .5;
                }
                else {
                    minDiff = 1;
                }


                //Apply includeZero
                if (this.includeZero && (this.minimum === null || isNaN(this.minimum))) {
                    if (min > 0)
                        min = 0;
                }

                if (this.includeZero && (this.maximum === null || isNaN(this.maximum))) {
                    if (max < 0)
                        max = 0;
                }
            }

            range = max - min;

            if (this.type === "axisX" && isDateTime) {

                if (this.minimum === null || isNaN(this.minimum))
                    this.minimum = min - minDiff / 2;

                if (this.maximum === null || isNaN(this.maximum))
                    this.maximum = max + minDiff / 2;

            } else {

                this.intervalType = "number";

                if (this.minimum === null) {
                    if (this.type === "axisX")
                        this.minimum = min - minDiff / 2;
                    else
                        this.minimum = Math.floor(min / this.interval) * this.interval;

                    this.minimum = Math.min(this.minimum, this.sessionVariables.viewportMinimum === null || isNaN(this.sessionVariables.viewportMinimum) ? Infinity : this.sessionVariables.viewportMinimum);
                }

                if (this.maximum === null) {
                    if (this.type === "axisX")
                        this.maximum = max + minDiff / 2;
                    else
                        this.maximum = Math.ceil(max / this.interval) * this.interval;

                    this.maximum = Math.max(this.maximum, this.sessionVariables.viewportMaximum === null || isNaN(this.sessionVariables.viewportMaximum) ? -Infinity : this.sessionVariables.viewportMaximum);
                }

                //var nfrac = Math.max(-Math.floor(Math.log(d)/Math.LN10), 0); //number of fractional digits to show


                if (this.maximum === 0 && this.minimum === 0) {

                    if (this.options.minimum === 0) {
                        this.maximum += 10;
                    }
                    else if (this.options.maximum === 0) {
                        this.minimum -= 10;
                    }
                }
            }
        }
        if (isNullOrUndefined(this.sessionVariables.newViewportMinimum))
            this.viewportMinimum = Math.max(this.viewportMinimum, this.minimum);
        if (isNullOrUndefined(this.sessionVariables.newViewportMaximum))
            this.viewportMaximum = Math.min(this.viewportMaximum, this.maximum);

        this.range = this.viewportMaximum - this.viewportMinimum;

        if (this.type === "axisX" && isDateTime)
            this.intervalStartPosition = this.getLabelStartPoint(new Date(this.viewportMinimum), this.intervalType, this.interval);
        else
            this.intervalStartPosition = Math.floor((this.viewportMinimum + (this.interval * .2)) / this.interval) * this.interval;

        //Set valueFormatString
        if (!this.valueFormatString) {
            this.valueFormatString = "#,##0.##";

            if (this.range < 1) {
                var numberOfDecimals = Math.floor(Math.abs(Math.log(this.range) / Math.LN10)) + 2;

                if (isNaN(numberOfDecimals) || !isFinite(numberOfDecimals))
                    numberOfDecimals = 2;

                if (numberOfDecimals > 2) {
                    for (var i = 0; i < numberOfDecimals - 2; i++)
                        this.valueFormatString += "#";
                }
            }

        }

        //if (isDebugMode && window.console) {
        //    window.console.log(this.type + ": Min = " + this.viewportMinimum);
        //    window.console.log(this.type + ": Max = " + this.viewportMaximum);
        //    window.console.log(this.type + ": Interval = " + this.interval);
        //}
    }

    Axis.prototype.calculateLogarithamicAxisParameters = function () {

        var freeSpace = this.chart.layoutManager.getFreeSpace();
        var availableWidth = 0;
        var availableHeight = 0;
        var isLessThanTwoDataPoints = false;
        var lnLogarithmBase = Math.log(this.logarithmBase);
        var linearInterval;

        if (this._position === "bottom" || this._position === "top") {
            this.maxWidth = freeSpace.width;
            this.maxHeight = freeSpace.height;
        } else {
            this.maxWidth = freeSpace.height;
            this.maxHeight = freeSpace.width;
        }

        var noTicks = (this.type === "axisX" ? (this.maxWidth < 500 ? 7 : Math.max(7, Math.floor(this.maxWidth / 100))) : Math.max(Math.floor(this.maxWidth / 50), 3));
        var min, max;
        var minDiff;
        var range;
        var rangePadding = 1;


        if (this.viewportMinimum === null || isNaN(this.viewportMinimum))
            this.viewportMinimum = this.minimum;

        if (this.viewportMaximum === null || isNaN(this.viewportMaximum))
            this.viewportMaximum = this.maximum;

        if (this.type === "axisX") {
            min = (this.viewportMinimum !== null) ? this.viewportMinimum : this.dataInfo.viewPortMin;
            max = (this.viewportMaximum !== null) ? this.viewportMaximum : this.dataInfo.viewPortMax;

            if (max / min === 1) {
                rangePadding = Math.pow(this.logarithmBase, typeof (this.options.interval) === "undefined" ? .4 : this.options.interval);

                max *= rangePadding;
                min /= rangePadding;
            }

            if (this.dataInfo.minDiff !== Infinity)
                minDiff = this.dataInfo.minDiff;
            else if (max / min > this.logarithmBase) {
                minDiff = max / min * Math.pow(this.logarithmBase, .5);
            }
            else {
                minDiff = this.logarithmBase;
            }

        } else if (this.type === "axisY") {

            min = (this.viewportMinimum !== null) ? this.viewportMinimum : this.dataInfo.viewPortMin;
            max = (this.viewportMaximum !== null) ? this.viewportMaximum : this.dataInfo.viewPortMax;

            if (min <= 0 && !isFinite(max)) {
                max = typeof (this.options.interval) === "undefined" ? 0 : this.options.interval;
                min = 1;
            } else if (min <= 0) {
                min = max;
            } else if (!isFinite(max)) {
                max = min;
            }

            if (min === 1 && max === 1) {// When all dataPoints are one
                max *= this.logarithmBase - 1 / this.logarithmBase;
                min = 1;
            }
            else if (max / min === 1) {// When there is only a single dataPoint or when all dataPoints have same Y Value
                rangePadding = Math.min(max * Math.pow(this.logarithmBase, .01), Math.pow(this.logarithmBase, 5));
                max *= rangePadding;
                min /= rangePadding;
            }
            else if (min > max) {
                rangePadding = Math.min(min / max * Math.pow(this.logarithmBase, .01), Math.pow(this.logarithmBase, 5));

                if (max >= 1)
                    min = max / rangePadding;
                else
                    max = min * rangePadding;
            }
            else {

                rangePadding = Math.min(max / min * Math.pow(this.logarithmBase, .01), Math.pow(this.logarithmBase, .04));

                if (max !== 1)
                    max *= rangePadding;
                if (min !== 1)
                    min /= rangePadding;
            }

            if (this.dataInfo.minDiff !== Infinity)
                minDiff = this.dataInfo.minDiff;
            else if (max / min > this.logarithmBase) {
                minDiff = max / min * Math.pow(this.logarithmBase, .5);
            }
            else {
                minDiff = this.logarithmBase;
            }


            //Apply includeZero
            if (this.includeZero && (this.viewportMinimum === null || isNaN(this.viewportMinimum))) {
                if (min > 1)
                    min = 1;
            }

            if (this.includeZero && (this.viewportMaximum === null || isNaN(this.viewportMaximum))) {
                if (max < 1)
                    max = 1;
            }
        }

        range = (isNaN(this.viewportMaximum) || this.viewportMaximum === null ? max : this.viewportMaximum) / (isNaN(this.viewportMinimum) || this.viewportMinimum === null ? min : this.viewportMinimum);
        linearRange = (isNaN(this.viewportMaximum) || this.viewportMaximum === null ? max : this.viewportMaximum) - (isNaN(this.viewportMinimum) || this.viewportMinimum === null ? min : this.viewportMinimum);



        this.intervalType = "number";

        range = Math.pow(this.logarithmBase, Axis.getNiceNumber(Math.abs(Math.log(range) / lnLogarithmBase), false));

        if (this.options && this.options.interval > 0)
            this.interval = this.options.interval;
        else {
            this.interval = Axis.getNiceExponent(Math.log(range) / lnLogarithmBase / (noTicks - 1), true);
            linearInterval = Axis.getNiceNumber(linearRange / (noTicks - 1), true);
        }



        if (this.viewportMinimum === null || isNaN(this.viewportMinimum)) {
            if (this.type === "axisX")
                this.viewportMinimum = min / Math.sqrt(minDiff);
            else
                this.viewportMinimum = Math.pow(this.logarithmBase, this.interval * Math.floor(Math.log(min) / lnLogarithmBase / this.interval));
        }

        if (this.viewportMaximum === null || isNaN(this.viewportMaximum)) {
            if (this.type === "axisX")
                this.viewportMaximum = max * Math.sqrt(minDiff);
            else
                this.viewportMaximum = Math.pow(this.logarithmBase, this.interval * Math.ceil(Math.log(max) / lnLogarithmBase / this.interval));
        }

        if (this.viewportMaximum === 1 && this.viewportMinimum === 1) {

            if (this.options.viewportMinimum === 1) {
                this.viewportMaximum *= this.logarithmBase - 1 / this.logarithmBase;
            }
            else if (this.options.viewportMaximum === 1) {
                this.viewportMinimum /= this.logarithmBase - 1 / this.logarithmBase;
            }

            if (this.options && typeof (this.options.interval) === "undefined") {
                this.interval = Axis.getNiceExponent(Math.ceil(Math.log(range) / lnLogarithmBase) / (noTicks - 1));
                linearInterval = Axis.getNiceNumber((this.viewportMaximum - this.viewportMinimum) / (noTicks - 1), true);
            }
        }

        //console.log(this.interval, range, lnLogarithmBase);

        //Calculate minimum and maximum if not provided by the user
        if (this.minimum === null || this.maximum === null) {
            if (this.type === "axisX") {
                min = (this.minimum !== null) ? this.minimum : this.dataInfo.min;
                max = (this.maximum !== null) ? this.maximum : this.dataInfo.max;

                if (max / min === 1) {
                    rangePadding = Math.pow(this.logarithmBase, typeof (this.options.interval) === "undefined" ? .4 : this.options.interval);

                    max *= rangePadding;
                    min /= rangePadding;
                }

                if (this.dataInfo.minDiff !== Infinity)
                    minDiff = this.dataInfo.minDiff;
                else if (max / min > this.logarithmBase) {
                    minDiff = max / min * Math.pow(this.logarithmBase, .5);
                }
                else {
                    minDiff = this.logarithmBase;
                }

            } else if (this.type === "axisY") {

                min = (this.minimum !== null) ? this.minimum : this.dataInfo.min;
                max = (this.maximum !== null) ? this.maximum : this.dataInfo.max;

                if (!isFinite(min) && !isFinite(max)) {
                    max = typeof (this.options.interval) === "undefined" ? 0 : this.options.interval;
                    min = 1;
                }
                else
                if (min === 1 && max === 1) {// When all dataPoints are one
                    max *= this.logarithmBase;
                    min /= this.logarithmBase;
                }
                else if (max / min === 1) {// When there is only a single dataPoint or when all dataPoints have same Y Value
                    rangePadding = Math.pow(this.logarithmBase, this.interval); //Math.min(max * .01, 5);
                    max *= rangePadding;
                    min /= rangePadding;
                }
                else if (min > max) {
                    rangePadding = Math.min(min / max * .01, 5);

                    if (max >= 1)
                        min = max / rangePadding;
                    else
                        max = min * rangePadding;
                }
                else {

                    rangePadding = Math.min(max / min * Math.pow(this.logarithmBase, .01), Math.pow(this.logarithmBase, .04));

                    if (max !== 1)
                        max *= rangePadding;
                    if (min !== 1)
                        min /= rangePadding;
                }

                if (this.dataInfo.minDiff !== Infinity)
                    minDiff = this.dataInfo.minDiff;
                else if (max / min > this.logarithmBase) {
                    minDiff = max / min * Math.pow(this.logarithmBase, .5);
                }
                else {
                    minDiff = this.logarithmBase;
                }


                //Apply includeZero
                if (this.includeZero && (this.minimum === null || isNaN(this.minimum))) {
                    if (min > 1)
                        min = 1;
                }

                if (this.includeZero && (this.maximum === null || isNaN(this.maximum))) {
                    if (max < 1)
                        max = 1;
                }
            }

            range = max / min;



            this.intervalType = "number";

            if (this.minimum === null) {
                if (this.type === "axisX")
                    this.minimum = min / Math.sqrt(minDiff);
                else
                    this.minimum = Math.pow(this.logarithmBase, this.interval * Math.floor(Math.log(min) / lnLogarithmBase / this.interval));

                this.minimum = Math.min(this.minimum, this.sessionVariables.viewportMinimum === null || isNaN(this.sessionVariables.viewportMinimum) ? typeof this.sessionVariables.newViewportMinimum === "undefined" ? Infinity : this.sessionVariables.newViewportMinimum : this.sessionVariables.viewportMinimum);
            }

            if (this.maximum === null) {
                if (this.type === "axisX")
                    this.maximum = max * Math.sqrt(minDiff);
                else
                    this.maximum = Math.pow(this.logarithmBase, this.interval * Math.ceil(Math.log(max) / lnLogarithmBase / this.interval));

                this.maximum = Math.max(this.maximum, this.sessionVariables.viewportMaximum === null || isNaN(this.sessionVariables.viewportMaximum) ? typeof this.sessionVariables.newViewportMaximum === "undefined" ? 0 : this.sessionVariables.newViewportMaximum : this.sessionVariables.viewportMaximum);
            }



            if (this.maximum === 1 && this.minimum === 1) {

                if (this.options.minimum === 1) {
                    this.maximum *= this.logarithmBase - 1 / this.logarithmBase;
                }
                else if (this.options.maximum === 1) {
                    this.minimum /= this.logarithmBase - 1 / this.logarithmBase;
                }
            }

        }

        this.viewportMinimum = Math.max(this.viewportMinimum, this.minimum);
        this.viewportMaximum = Math.min(this.viewportMaximum, this.maximum);

        if (this.viewportMinimum > this.viewportMaximum) {
            if ((this.options.viewportMinimum || this.options.minimum) && !(this.options.viewportMaximum || this.options.maximum))
                this.viewportMaximum = this.maximum = (this.options.viewportMinimum || this.options.minimum);
            else if (!(this.options.viewportMinimum || this.options.minimum) && (this.options.viewportMaximum || this.options.maximum))
                this.viewportMinimum = this.minimum = (this.options.viewportMaximum || this.options.maximum) / Math.pow(this.logarithmBase, 2 * Math.ceil(this.interval));
        }

        var intervalStartPosition = Math.pow(this.logarithmBase, Math.floor(Math.log(this.viewportMinimum) / (lnLogarithmBase * this.interval) + 0.2) * this.interval);
        this.range = this.viewportMaximum / this.viewportMinimum;
        this.noTicks = noTicks;

        if (!this.options.interval && this.range < Math.pow(this.logarithmBase, /*this.type === "axisX" || */this.viewportMaximum < 8 || noTicks < 3 ? 2 : 3)) {

            var linearIntervalStartPosition = Math.floor(this.viewportMinimum / linearInterval + .5) * linearInterval;

            while (linearIntervalStartPosition < this.viewportMinimum) {
                linearIntervalStartPosition += linearInterval;
            }

            this.equidistantInterval = false;
            this.intervalStartPosition = linearIntervalStartPosition;
            this.interval = linearInterval;
        }
        else {
            if (!this.options.interval) {
                var lnInterval = Math.ceil(this.interval);
                if (this.range > this.interval) {
                    this.interval = lnInterval;
                    intervalStartPosition = Math.pow(this.logarithmBase, Math.floor(Math.log(this.viewportMinimum) / (lnLogarithmBase * this.interval) + 0.2) * this.interval);
                }
            }
            this.equidistantInterval = true;
            this.intervalStartPosition = intervalStartPosition;
        }


        //Set valueFormatString
        if (!this.valueFormatString) {
            this.valueFormatString = "#,##0.##";

            if (this.viewportMinimum < 1) {
                var numberOfDecimals = Math.floor(Math.abs(Math.log(this.viewportMinimum) / Math.LN10)) + 2;
                if (isNaN(numberOfDecimals) || !isFinite(numberOfDecimals))
                    numberOfDecimals = 2;

                if (numberOfDecimals > 2) {
                    for (var i = 0; i < numberOfDecimals - 2; i++)
                        this.valueFormatString += "#";
                }
            }


        }
    }

    Axis.getNiceExponent = function (x, round) {

        var exp = Math.floor(Math.log(x) / Math.LN10);
        var f = x / Math.pow(10, exp);
        var nf;

        if (exp < 0) {
            if (f <= 1)
                nf = 1;
            else if (f <= 5)
                nf = 5;
            else nf = 10;
        } else {
            nf = Math.max(Math.floor(f), 1);
        }


        return Number((nf * Math.pow(10, exp)).toFixed(20));
    }

    Axis.getNiceNumber = function (x, round) {

        var exp = Math.floor(Math.log(x) / Math.LN10);
        var f = x / Math.pow(10, exp);
        var nf;

        if (round) {
            if (f < 1.5)
                nf = 1;
            else if (f < 3)
                nf = 2;
            else if (f < 7)
                nf = 5;
            else
                nf = 10;
        }
        else {
            if (f <= 1)
                nf = 1;
            else if (f <= 2)
                nf = 2;
            else if (f <= 5)
                nf = 5;
            else nf = 10;
        }

        return Number((nf * Math.pow(10, exp)).toFixed(20));
    }

    Axis.prototype.getLabelStartPoint = function () {

        var intervalInMilliseconds = convertToNumber(this.interval, this.intervalType);
        var minimum = Math.floor((this.viewportMinimum) / intervalInMilliseconds) * intervalInMilliseconds;
        var dateTime = new Date(minimum);

        if (this.intervalType === "millisecond") {
            //millisecond = dateTime.getMilliSecond();
            //millisecond = Math.floor((millisecond + this.interval) / this.interval) * this.interval;
        }
        else if (this.intervalType === "second") {
            if (dateTime.getMilliseconds() > 0) {
                dateTime.setSeconds(dateTime.getSeconds() + 1);
                dateTime.setMilliseconds(0);
            }
        }
        else if (this.intervalType === "minute") {
            if (dateTime.getSeconds() > 0 || dateTime.getMilliseconds() > 0) {
                dateTime.setMinutes(dateTime.getMinutes() + 1);
                dateTime.setSeconds(0);
                dateTime.setMilliseconds(0);
            }
        }
        else if (this.intervalType === "hour") {
            if (dateTime.getMinutes() > 0 || dateTime.getSeconds() > 0 || dateTime.getMilliseconds() > 0) {
                dateTime.setHours(dateTime.getHours() + 1);
                dateTime.setMinutes(0);
                dateTime.setSeconds(0);
                dateTime.setMilliseconds(0);
            }
        }
        else if (this.intervalType === "day") {
            if (dateTime.getHours() > 0 || dateTime.getMinutes() > 0 || dateTime.getSeconds() > 0 || dateTime.getMilliseconds() > 0) {
                dateTime.setDate(dateTime.getDate() + 1);
                dateTime.setHours(0);
                dateTime.setMinutes(0);
                dateTime.setSeconds(0);
                dateTime.setMilliseconds(0);
            }
        }
        else if (this.intervalType === "week") {
            if (dateTime.getDay() > 0 || dateTime.getHours() > 0 || dateTime.getMinutes() > 0 || dateTime.getSeconds() > 0 || dateTime.getMilliseconds() > 0) {
                dateTime.setDate(dateTime.getDate() + (7 - dateTime.getDay()));
                dateTime.setHours(0);
                dateTime.setMinutes(0);
                dateTime.setSeconds(0);
                dateTime.setMilliseconds(0);
            }
        }
        else if (this.intervalType === "month") {
            if (dateTime.getDate() > 1 || dateTime.getHours() > 0 || dateTime.getMinutes() > 0 || dateTime.getSeconds() > 0 || dateTime.getMilliseconds() > 0) {
                dateTime.setMonth(dateTime.getMonth() + 1);
                dateTime.setDate(1);
                dateTime.setHours(0);
                dateTime.setMinutes(0);
                dateTime.setSeconds(0);
                dateTime.setMilliseconds(0);
            }
        }
        else if (this.intervalType === "year") {
            if (dateTime.getMonth() > 0 || dateTime.getDate() > 1 || dateTime.getHours() > 0 || dateTime.getMinutes() > 0 || dateTime.getSeconds() > 0 || dateTime.getMilliseconds() > 0) {
                dateTime.setFullYear(dateTime.getFullYear() + 1);
                dateTime.setMonth(0);
                dateTime.setDate(1);
                dateTime.setHours(0);
                dateTime.setMinutes(0);
                dateTime.setSeconds(0);
                dateTime.setMilliseconds(0);
            }
        }

        return dateTime;
    }

    //#endregion Axis

    //#region StripLine

    function StripLine(chart, options, theme, id, axis) {
        StripLine.base.constructor.call(this, "StripLine", options, theme, axis);

        this.id = id;
        this.chart = chart;
        this.ctx = this.chart.ctx;

        this.label = this.label;
        this.axis = axis;

        this.optionsName = "stripLines"
        this.isOptionsInArray = true;

        this._thicknessType = "pixel";
        if (this.startValue !== null && this.endValue !== null) {

            this.value = axis.logarithmic ? Math.sqrt((this.startValue.getTime ? this.startValue.getTime() : this.startValue) * (this.endValue.getTime ? this.endValue.getTime() : this.endValue)) : ((this.startValue.getTime ? this.startValue.getTime() : this.startValue) + (this.endValue.getTime ? this.endValue.getTime() : this.endValue)) / 2;
            this.thickness = axis.logarithmic ? Math.log(this.endValue / this.startValue) / Math.log(axis.logarithmBase) : Math.max(this.endValue - this.startValue);
            this._thicknessType = "value";
        }
    }
    extend(StripLine, CanvasJSObject);

    StripLine.prototype.createUserOptions = function (options) {
        if (typeof (options) === "undefined" && !this.options._isPlaceholder)
            return;

        var optionsIndex = 0;

        if (this.parent.options._isPlaceholder)
            this.parent.createUserOptions();


        if (!this.options._isPlaceholder) {
            addArrayIndexOf(this.parent.stripLines);
            optionsIndex = this.parent.options.stripLines.indexOf(this.options);
        }

        this.options = typeof (options) === "undefined" ? {} : options;


        this.parent.options.stripLines[optionsIndex] = this.options;
    }

    StripLine.prototype.render = function () {

        this.ctx.save();
        //this.ctx.rect(this.chart.plotArea.x1, this.chart.plotArea.y1, this.chart.plotArea.width, this.chart.plotArea.height);
        //this.ctx.clip();

        var xy = this.parent.getPixelCoordinatesOnAxis(this.value);

        var lineWidth = Math.abs(this._thicknessType === "pixel" ? this.thickness : this.parent.conversionParameters.pixelPerUnit * this.thickness);

        if (lineWidth > 0) {
            //var opacity = this.opacity === null ? ( this.showOnTop && this._thicknessType === "pixel" ? 1 : 1) : this.opacity;
            var opacity = this.opacity === null ? 1 : this.opacity;

            this.ctx.strokeStyle = this.color;
            this.ctx.beginPath();

            var oldGlobalAlpha = this.ctx.globalAlpha;
            this.ctx.globalAlpha = opacity;

            var hexColor = intToHexColorString(this.id);
            var x1, x2, y1, y2;

            this.ctx.lineWidth = lineWidth;


            if (this.ctx.setLineDash) {
                this.ctx.setLineDash(getLineDashArray(this.lineDashType, lineWidth));
            }

            if (this.parent._position === "bottom" || this.parent._position === "top") {

                var stripX = (this.ctx.lineWidth % 2 === 1) ? (xy.x << 0) + .5 : (xy.x << 0);

                x1 = x2 = stripX;
                y1 = this.chart.plotArea.y1;
                y2 = this.chart.plotArea.y2;

                this.bounds = { x1: x1 - lineWidth / 2, y1: y1, x2: x2 + lineWidth / 2, y2: y2 };
            }
            else if (this.parent._position === "left" || this.parent._position === "right") {
                var stripY = (this.ctx.lineWidth % 2 === 1) ? (xy.y << 0) + .5 : (xy.y << 0);

                y1 = y2 = stripY;
                x1 = this.chart.plotArea.x1;
                x2 = this.chart.plotArea.x2;

                this.bounds = { x1: x1, y1: y1 - lineWidth / 2, x2: x2, y2: y2 + lineWidth / 2 };
            }

            this.ctx.moveTo(x1, y1);
            this.ctx.lineTo(x2, y2);
            this.ctx.stroke();


            this.ctx.globalAlpha = oldGlobalAlpha;
        }
        this.ctx.restore();
    };

    //#endregion StripLine

    //#region ToolTip

    function ToolTip(chart, options) {
        ToolTip.base.constructor.call(this, "ToolTip", options, chart.theme, chart);

        this.chart = chart;
        this.canvas = chart.canvas;
        this.ctx = this.chart.ctx;
        this.currentSeriesIndex = -1;
        this.currentDataPointIndex = -1;
        this._timerId = 0;
        this._prevX = NaN;
        this._prevY = NaN;

        this.optionsName = "toolTip";

        this._initialize();
    }
    extend(ToolTip, CanvasJSObject);

    ToolTip.prototype._initialize = function () {

        if (this.enabled) {
            this.container = document.createElement("div");
            this.container.setAttribute("class", "canvasjs-chart-tooltip");
            this.container.style.position = "absolute";
            this.container.style.height = "auto";
            this.container.style.boxShadow = "1px 1px 2px 2px rgba(0,0,0,0.1)";
            this.container.style.zIndex = "1000";
            //this.container.style.pointerEvents = "none";
            this.container.style.display = "none";
            //this.container.style.whiteSpace = "no-wrap";

            var toolTipHtml = "<div style=\" width: auto;";
            toolTipHtml += "height: auto;";
            toolTipHtml += "min-width: 50px;";
            toolTipHtml += "line-height: auto;";
            toolTipHtml += "margin: 0px 0px 0px 0px;";
            toolTipHtml += "padding: 5px;";
            toolTipHtml += "font-family: Calibri, Arial, Georgia, serif;";
            toolTipHtml += "font-weight: normal;";
            toolTipHtml += "font-style: " + (isCanvasSupported ? "italic;" : "normal;");
            toolTipHtml += "font-size: 14px;";
            toolTipHtml += "color: #000000;";
            toolTipHtml += "text-shadow: 1px 1px 1px rgba(0, 0, 0, 0.1);";
            toolTipHtml += "text-align: left;";
            toolTipHtml += "border: 2px solid gray;";

            //Older browsers like IE8- don't support alpha values
            toolTipHtml += isCanvasSupported ? "background: rgba(255,255,255,.9);" : "background: rgb(255,255,255);";

            toolTipHtml += "text-indent: 0px;";
            toolTipHtml += "white-space: nowrap;";
            //toolTipHtml += "pointer-events:none;";
            toolTipHtml += "border-radius: 5px;";

            //Disable Text Selection
            toolTipHtml += "-moz-user-select:none;";
            toolTipHtml += "-khtml-user-select: none;";
            toolTipHtml += "-webkit-user-select: none;";
            toolTipHtml += "-ms-user-select: none;";
            toolTipHtml += "user-select: none;";

            //toolTipHtml += "opacity: 0;";
            //toolTipHtml += "filter: progid: DXImageTransform.Microsoft.gradient(GradientType = 0, startColorstr = '#4cffffff', endColorstr = '#4cffffff');";

            if (!isCanvasSupported) {
                //toolTipHtml += "-ms-filter:'progid:DXImageTransform.Microsoft.Alpha(Opacity=90)'";
                //-ms-filter: "progid:DXImageTransform.Microsoft.Shadow(Strength=4, Direction=135, Color='#000000')";
                /* For IE 5.5 - 7 */
                toolTipHtml += "filter: alpha(opacity = 90);";
                toolTipHtml += "filter: progid:DXImageTransform.Microsoft.Shadow(Strength=3, Direction=135, Color='#666666');";
            }

            toolTipHtml += "} \"> Sample Tooltip</div>";

            this.container.innerHTML = toolTipHtml;
            this.contentDiv = this.container.firstChild;


            this.container.style.borderRadius = this.contentDiv.style.borderRadius;
            this.chart._canvasJSContainer.appendChild(this.container);
        }
    }

    ToolTip.prototype.mouseMoveHandler = function (x, y) {

        if (!(this._lastUpdated && (new Date().getTime() - this._lastUpdated) < 40)) {
            this._lastUpdated = new Date().getTime();
            this._updateToolTip(x, y);
        }
    }

    ToolTip.prototype._updateToolTip = function (mouseX, mouseY, closest) {
        //return;

        //if (typeof (closest) === "undefined")
        //	window.console.log("Canvas: ", mouseX, mouseY);

        closest = typeof (closest) === "undefined" ? true : closest;

        if (!this.container)
            this._initialize();

        if (!this.enabled) {
            this.hide();
        }

        if (this.chart.disableToolTip) // Disabled during animation, etc
            return;

        if (typeof (mouseX) === "undefined" || typeof (mouseY) === "undefined") {
            if (isNaN(this._prevX) || isNaN(this._prevY))
                return;
            else {
                mouseX = this._prevX;
                mouseY = this._prevY;
            }
        } else {
            this._prevX = mouseX;
            this._prevY = mouseY;
        }


        var dataPoint = null;
        var dataSeries = null;
        var toolTipContent = "";
        var entries = [];
        var toolTipRight;
        var toolTipBottom;
        var x = 0;

        if (this.shared && this.enabled && this.chart.plotInfo.axisPlacement !== "none") {
            // && this.chart.plotInfo.axisPlacement !== "none"

            if (this.chart.plotInfo.axisPlacement === "xySwapped") {
                var nearbyEntries = [];
                if (this.chart.axisX) {
                    for (var k = 0; k < this.chart.axisX.length; k++) {
                        x = this.chart.axisX[k].convertPixelToValue({ y: mouseY });
                        var entry = null;
                        for (var i = 0; i < this.chart.axisX[k].dataSeries.length; i++) {
                            entry = this.chart.axisX[k].dataSeries[i].getDataPointAtX(x, closest);

                            if (entry && entry.index >= 0) {
                                entry.dataSeries = this.chart.axisX[k].dataSeries[i];

                                if (entry.dataPoint.y !== null)
                                    nearbyEntries.push(entry);
                            }
                        }
                        entry = null;
                    }
                }
                if (this.chart.axisX2) {
                    for (var k = 0; k < this.chart.axisX2.length; k++) {
                        x = this.chart.axisX2[k].convertPixelToValue({ y: mouseY });
                        var entry = null;
                        for (var i = 0; i < this.chart.axisX2[k].dataSeries.length; i++) {
                            entry = this.chart.axisX2[k].dataSeries[i].getDataPointAtX(x, closest);

                            if (entry && entry.index >= 0) {
                                entry.dataSeries = this.chart.axisX2[k].dataSeries[i];

                                if (entry.dataPoint.y !== null)
                                    nearbyEntries.push(entry);
                            }
                        }
                        entry = null;
                    }
                }
            }
            else {
                var nearbyEntries = [];
                if (this.chart.axisX) {
                    for (var k = 0; k < this.chart.axisX.length; k++) {
                        x = this.chart.axisX[k].convertPixelToValue({ x: mouseX });
                        var entry = null;
                        for (var i = 0; i < this.chart.axisX[k].dataSeries.length; i++) {
                            entry = this.chart.axisX[k].dataSeries[i].getDataPointAtX(x, closest);

                            if (entry && entry.index >= 0) {
                                entry.dataSeries = this.chart.axisX[k].dataSeries[i];

                                if (entry.dataPoint.y !== null)
                                    nearbyEntries.push(entry);
                            }
                        }
                    }
                }
                if (this.chart.axisX2) {
                    for (var k = 0; k < this.chart.axisX2.length; k++) {
                        x = this.chart.axisX2[k].convertPixelToValue({ x: mouseX });
                        var entry = null;
                        for (var i = 0; i < this.chart.axisX2[k].dataSeries.length; i++) {
                            entry = this.chart.axisX2[k].dataSeries[i].getDataPointAtX(x, closest);

                            if (entry && entry.index >= 0) {
                                entry.dataSeries = this.chart.axisX2[k].dataSeries[i];

                                if (entry.dataPoint.y !== null)
                                    nearbyEntries.push(entry);
                            }
                        }
                    }
                }
            }

            if (nearbyEntries.length === 0)
                return;

            nearbyEntries.sort(function (entry1, entry2) {
                return entry1.distance - entry2.distance;
            });


            var closest = nearbyEntries[0];

            for (i = 0; i < nearbyEntries.length; i++) {

                if (nearbyEntries[i].dataPoint.x.valueOf() === closest.dataPoint.x.valueOf())
                    entries.push(nearbyEntries[i]);
            }

            nearbyEntries = null;

        } else {

            var dataPointInfo = this.chart.getDataPointAtXY(mouseX, mouseY, closest);
            //dataPointInfo = null;

            if (dataPointInfo) {
                this.currentDataPointIndex = dataPointInfo.dataPointIndex;
                this.currentSeriesIndex = dataPointInfo.dataSeries.index;
            } else if (isCanvasSupported) {

                var id = getObjectId(mouseX, mouseY, this.chart._eventManager.ghostCtx);
                if (id > 0 && typeof this.chart._eventManager.objectMap[id] !== "undefined") {//DataPoint/DataSeries event
                    var eventObject = this.chart._eventManager.objectMap[id];

                    if (eventObject.objectType === "legendItem")
                        return;

                    //if (this.currentSeriesIndex === eventObject.dataSeriesIndex && this.currentDataPointIndex === eventObject.dataPointIndex)
                    //  return;
                    //else {
                    this.currentSeriesIndex = eventObject.dataSeriesIndex;
                    this.currentDataPointIndex = eventObject.dataPointIndex >= 0 ? eventObject.dataPointIndex : -1;
                    //}

                    //window.console.log("id: " + id + "; hex: " + intToHexColorString(id));
                } else
                    this.currentDataPointIndex = -1;

            } else
                this.currentDataPointIndex = -1;


            if (this.currentSeriesIndex >= 0) {

                dataSeries = this.chart.data[this.currentSeriesIndex];

                var entry = {
                };

                if (this.currentDataPointIndex >= 0) {
                    dataPoint = dataSeries.dataPoints[this.currentDataPointIndex];

                    entry.dataSeries = dataSeries;
                    entry.dataPoint = dataPoint;
                    entry.index = this.currentDataPointIndex;
                    entry.distance = Math.abs(dataPoint.x - x);
                } else if (this.enabled && (dataSeries.type === "line" || dataSeries.type === "stepLine" || dataSeries.type === "spline" || dataSeries.type === "area" || dataSeries.type === "stepArea"
                    || dataSeries.type === "splineArea" || dataSeries.type === "stackedArea" || dataSeries.type === "stackedArea100"
                    || dataSeries.type === "rangeArea" || dataSeries.type === "rangeSplineArea"
                    || dataSeries.type === "candlestick" || dataSeries.type === "ohlc")) {

                    var x = dataSeries.axisX.convertPixelToValue({ x: mouseX });
                    entry = dataSeries.getDataPointAtX(x, closest);

                    entry.dataSeries = dataSeries;
                    this.currentDataPointIndex = entry.index;
                    dataPoint = entry.dataPoint;
                } else {
                    //this.hide();
                    return;
                }

                if (!isNullOrUndefined(entry.dataPoint.y)) {
                    if (entry.dataSeries.axisY) {
                        if (entry.dataPoint.y.length > 0) {
                            var unboundToViewport = 0;
                            for (var i = 0; i < entry.dataPoint.y.length; i++)
                                if (entry.dataPoint.y[i] < entry.dataSeries.axisY.viewportMinimum)
                                    unboundToViewport--;
                                else if (entry.dataPoint.y[i] > entry.dataSeries.axisY.viewportMaximum)
                                    unboundToViewport++;
                            if (unboundToViewport < entry.dataPoint.y.length && unboundToViewport > -entry.dataPoint.y.length)
                                entries.push(entry);
                        } else {
                            if (dataSeries.type === "column" || dataSeries.type === "bar") {
                                if (entry.dataPoint.y < 0 /*use entry.dataPoint.y < offset when it will be introduced*/) {
                                    if (entry.dataSeries.axisY.viewportMinimum < 0 && entry.dataSeries.axisY.viewportMaximum >= entry.dataPoint.y)
                                        entries.push(entry);
                                }
                                else if (entry.dataSeries.axisY.viewportMinimum <= entry.dataPoint.y && entry.dataSeries.axisY.viewportMaximum >= 0) // If entry.dataPoint.y >= 0
                                    entries.push(entry);
                            }
                            else if (dataSeries.type === "bubble") {
                                var radius = this.chart._eventManager.objectMap[dataSeries.dataPointIds[entry.index]].size / 2;
                                if (entry.dataPoint.y >= entry.dataSeries.axisY.viewportMinimum - radius && entry.dataPoint.y <= entry.dataSeries.axisY.viewportMaximum + radius)
                                    entries.push(entry);
                            }
                            else if (entry.dataSeries.type.indexOf("100") >= 0 || dataSeries.type === "stackedColumn" || dataSeries.type === "stackedBar" || (entry.dataPoint.y >= entry.dataSeries.axisY.viewportMinimum && entry.dataPoint.y <= entry.dataSeries.axisY.viewportMaximum))
                                entries.push(entry);
                        }
                    } else
                        entries.push(entry);
                }

            }
        }


        if (entries.length > 0) {

            this.highlightObjects(entries);

            if (this.enabled) {

                var toolTipInnerHtml = "";

                toolTipInnerHtml = this.getToolTipInnerHTML({ entries: entries });

                if (toolTipInnerHtml !== null) {
                    this.contentDiv.innerHTML = toolTipInnerHtml;

                    this.contentDiv.innerHTML = toolTipInnerHtml;

                    var previouslyHidden = false;
                    if (this.container.style.display === "none") {
                        previouslyHidden = true;
                        this.container.style.display = "block";
                    }

                    try {
                        this.contentDiv.style.background = this.backgroundColor ? this.backgroundColor : isCanvasSupported ? "rgba(255,255,255,.9)" : "rgb(255,255,255)";

                        this.borderColor = this.contentDiv.style.borderRightColor = this.contentDiv.style.borderLeftColor = this.contentDiv.style.borderColor = this.options.borderColor ? this.options.borderColor : entries[0].dataPoint.color ? entries[0].dataPoint.color : entries[0].dataSeries.color ? entries[0].dataSeries.color : entries[0].dataSeries._colorSet[entries[0].index % entries[0].dataSeries._colorSet.length];

                        this.contentDiv.style.borderWidth = (this.borderThickness || this.borderThickness === 0) ? this.borderThickness + "px" : 2 + "px";

                        this.contentDiv.style.borderRadius = (this.cornerRadius || this.cornerRadius === 0) ? this.cornerRadius + "px" : 5 + "px";
                        this.container.style.borderRadius = this.contentDiv.style.borderRadius;


                        this.contentDiv.style.fontSize = (this.fontSize || this.fontSize === 0) ? this.fontSize + "px" : 14 + "px";
                        this.contentDiv.style.color = this.fontColor ? this.fontColor : "#000000";
                        this.contentDiv.style.fontFamily = this.fontFamily ? this.fontFamily : "Calibri, Arial, Georgia, serif;";
                        this.contentDiv.style.fontWeight = this.fontWeight ? this.fontWeight : "normal";
                        this.contentDiv.style.fontStyle = this.fontStyle ? this.fontStyle : isCanvasSupported ? "italic" : "normal";

                    } catch (e) {
                    }
                    var toolTipLeft;
                    if (entries[0].dataSeries.type === "pie" || entries[0].dataSeries.type === "doughnut" || entries[0].dataSeries.type === "funnel" || entries[0].dataSeries.type === "bar" || entries[0].dataSeries.type === "rangeBar" || entries[0].dataSeries.type === "stackedBar" || entries[0].dataSeries.type === "stackedBar100") {
                        toolTipLeft = mouseX - 10 - this.container.clientWidth;
                    } else {
                        toolTipLeft = entries[0].dataSeries.axisX.convertValueToPixel(entries[0].dataPoint.x) - this.container.clientWidth << 0;
                        toolTipLeft -= 10;
                    }


                    if (toolTipLeft < 0) {
                        toolTipLeft += this.container.clientWidth + 20;
                    }

                    if (toolTipLeft + this.container.clientWidth > Math.max(this.chart.container.clientWidth, this.chart.width))
                        toolTipLeft = Math.max(0, Math.max(this.chart.container.clientWidth, this.chart.width) - this.container.clientWidth);

                    toolTipLeft += "px";

                    if (entries.length === 1 && !this.shared && (entries[0].dataSeries.type === "line" || entries[0].dataSeries.type === "stepLine" || entries[0].dataSeries.type === "spline" || entries[0].dataSeries.type === "area" || entries[0].dataSeries.type === "stepArea" || entries[0].dataSeries.type === "splineArea" /*|| entries[0].dataSeries.type === "stackedArea" || entries[0].dataSeries.type === "stackedArea100"*/)) {
                        //toolTipBottom = (entries[0].dataSeries.axisY.lineCoordinates.y2 - entries[0].dataSeries.axisY.lineCoordinates.height / Math.abs(entries[0].dataSeries.axisY.maximum - entries[0].dataSeries.axisY.viewportMinimum) * Math.abs(entries[0].dataPoint.y - entries[0].dataSeries.axisY.viewportMinimum) + .5) << 0;
                        toolTipBottom = entries[0].dataSeries.axisY.convertValueToPixel(entries[0].dataPoint.y);
                    } else if (entries[0].dataSeries.type === "bar" || entries[0].dataSeries.type === "rangeBar" || entries[0].dataSeries.type === "stackedBar" || entries[0].dataSeries.type === "stackedBar100") {
                        //toolTipBottom = (entries[0].dataSeries.axisX.lineCoordinates.y2 - entries[0].dataSeries.axisX.lineCoordinates.height / Math.abs(entries[0].dataSeries.axisX.maximum - entries[0].dataSeries.axisX.viewportMinimum) * Math.abs(entries[0].dataPoint.x - entries[0].dataSeries.axisX.viewportMinimum) + .5) << 0;
                        toolTipBottom = entries[0].dataSeries.axisX.convertValueToPixel(entries[0].dataPoint.x);
                    }
                    else {
                        toolTipBottom = mouseY;
                    }

                    toolTipBottom = (-toolTipBottom + 10);

                    if (toolTipBottom + this.container.clientHeight + 5 > 0) {
                        toolTipBottom -= toolTipBottom + this.container.clientHeight + 5 - 0
                    }

                    toolTipBottom += "px";

                    //this.container.style.right = toolTipRight;
                    this.container.style.left = toolTipLeft;
                    this.container.style.bottom = toolTipBottom;

                    if (!this.animationEnabled || previouslyHidden) {
                        this.disableAnimation();
                    }
                    else
                        this.enableAnimation();
                } else {
                    this.hide(false);
                }

            }

            //if (isDebugMode)
            //  console.log("searchX: " + x + " x: " + searchResult.dataPoint.x + "; y: " + searchResult.dataPoint.y + "; distance: " + searchResult.distance + "; steps: " + steps);
        }
    }


    ToolTip.prototype.highlightObjects = function (entries) {
        //if (!this.enabled)
        //	return;

        //this.chart.overlaidCanvasCtx.clearRect(0, 0, this.chart.overlaidCanvas.width, this.chart.overlaidCanvas.height);
        var overlaidCanvasCtx = this.chart.overlaidCanvasCtx;
        this.chart.resetOverlayedCanvas();

        overlaidCanvasCtx.clearRect(0, 0, this.chart.width, this.chart.height);
        overlaidCanvasCtx.save();


        var plotArea = this.chart.plotArea;

        var offset = 0;
        overlaidCanvasCtx.beginPath();
        overlaidCanvasCtx.rect(plotArea.x1, plotArea.y1, plotArea.x2 - plotArea.x1, plotArea.y2 - plotArea.y1);
        overlaidCanvasCtx.clip();


        for (var i = 0; i < entries.length; i++) {

            var entry = entries[i];

            var eventObject = this.chart._eventManager.objectMap[entry.dataSeries.dataPointIds[entry.index]];

            if (!eventObject || !eventObject.objectType || eventObject.objectType !== "dataPoint")
                continue;

            var dataSeries = this.chart.data[eventObject.dataSeriesIndex];
            var dataPoint = dataSeries.dataPoints[eventObject.dataPointIndex];
            var index = eventObject.dataPointIndex;

            if (dataPoint.highlightEnabled !== false && (dataSeries.highlightEnabled === true || dataPoint.highlightEnabled === true)) {

                if (dataSeries.type === "line" || dataSeries.type === "stepLine" || dataSeries.type === "spline" || dataSeries.type === "scatter"
                    || dataSeries.type === "area" || dataSeries.type === "stepArea" || dataSeries.type === "splineArea"
                    || dataSeries.type === "stackedArea" || dataSeries.type === "stackedArea100"
                    || dataSeries.type === "rangeArea" || dataSeries.type === "rangeSplineArea") {
                    var markerProps = dataSeries.getMarkerProperties(index, eventObject.x1, eventObject.y1, this.chart.overlaidCanvasCtx);
                    markerProps.size = Math.max(markerProps.size * 1.5 << 0, 10);

                    markerProps.borderColor = markerProps.borderColor || "#FFFFFF";
                    markerProps.borderThickness = markerProps.borderThickness || Math.ceil(markerProps.size * .1);

                    //overlaidCanvasCtx.globalAlpha = .8;
                    RenderHelper.drawMarkers([markerProps]);
                    //overlaidCanvasCtx.globalAlpha = .8;

                    if (typeof (eventObject.y2) !== "undefined") {

                        var markerProps = dataSeries.getMarkerProperties(index, eventObject.x1, eventObject.y2, this.chart.overlaidCanvasCtx);
                        markerProps.size = Math.max(markerProps.size * 1.5 << 0, 10);

                        markerProps.borderColor = markerProps.borderColor || "#FFFFFF";
                        markerProps.borderThickness = markerProps.borderThickness || Math.ceil(markerProps.size * .1);

                        //overlaidCanvasCtx.globalAlpha = .8;
                        RenderHelper.drawMarkers([markerProps]);
                        //overlaidCanvasCtx.globalAlpha = .8;
                    }
                } else if (dataSeries.type === "bubble") {
                    var markerProps = dataSeries.getMarkerProperties(index, eventObject.x1, eventObject.y1, this.chart.overlaidCanvasCtx);
                    markerProps.size = eventObject.size;
                    markerProps.color = "white";
                    markerProps.borderColor = "white";
                    //markerProps.borderThickness = 2;
                    overlaidCanvasCtx.globalAlpha = .3;
                    RenderHelper.drawMarkers([markerProps]);
                    overlaidCanvasCtx.globalAlpha = 1;
                } else if (dataSeries.type === "column" || dataSeries.type === "stackedColumn" || dataSeries.type === "stackedColumn100"
                    || dataSeries.type === "bar" || dataSeries.type === "rangeBar" || dataSeries.type === "stackedBar" || dataSeries.type === "stackedBar100"
                    || dataSeries.type === "rangeColumn") {
                    drawRect(overlaidCanvasCtx, eventObject.x1, eventObject.y1, eventObject.x2, eventObject.y2, "white", 0, null, false, false, false, false, .3);
                }
                else if (dataSeries.type === "pie" || dataSeries.type === "doughnut") {
                    drawSegment(overlaidCanvasCtx, eventObject.center, eventObject.radius, "white", dataSeries.type, eventObject.startAngle, eventObject.endAngle, .3, eventObject.percentInnerRadius);
                } else if (dataSeries.type === "candlestick") {

                    overlaidCanvasCtx.globalAlpha = 1;
                    overlaidCanvasCtx.strokeStyle = eventObject.color;
                    overlaidCanvasCtx.lineWidth = eventObject.borderThickness * 2;
                    offset = (overlaidCanvasCtx.lineWidth) % 2 === 0 ? 0 : .5;

                    overlaidCanvasCtx.beginPath();
                    overlaidCanvasCtx.moveTo(eventObject.x3 - offset, Math.min(eventObject.y2, eventObject.y3));
                    overlaidCanvasCtx.lineTo(eventObject.x3 - offset, Math.min(eventObject.y1, eventObject.y4));
                    overlaidCanvasCtx.stroke();

                    overlaidCanvasCtx.beginPath();
                    overlaidCanvasCtx.moveTo(eventObject.x3 - offset, Math.max(eventObject.y1, eventObject.y4));
                    overlaidCanvasCtx.lineTo(eventObject.x3 - offset, Math.max(eventObject.y2, eventObject.y3));
                    overlaidCanvasCtx.stroke();

                    drawRect(overlaidCanvasCtx, eventObject.x1, Math.min(eventObject.y1, eventObject.y4), eventObject.x2, Math.max(eventObject.y1, eventObject.y4), "transparent", eventObject.borderThickness * 2, eventObject.color, false, false, false, false);
                    overlaidCanvasCtx.globalAlpha = 1;

                } else if (dataSeries.type === "ohlc") {
                    overlaidCanvasCtx.globalAlpha = 1;

                    overlaidCanvasCtx.strokeStyle = eventObject.color;
                    overlaidCanvasCtx.lineWidth = eventObject.borderThickness * 2;

                    offset = (overlaidCanvasCtx.lineWidth) % 2 === 0 ? 0 : .5;

                    overlaidCanvasCtx.beginPath();
                    overlaidCanvasCtx.moveTo(eventObject.x3 - offset, eventObject.y2);
                    overlaidCanvasCtx.lineTo(eventObject.x3 - offset, eventObject.y3);
                    overlaidCanvasCtx.stroke();

                    overlaidCanvasCtx.beginPath();
                    overlaidCanvasCtx.moveTo(eventObject.x3, eventObject.y1);
                    overlaidCanvasCtx.lineTo(eventObject.x1, eventObject.y1);
                    overlaidCanvasCtx.stroke();

                    overlaidCanvasCtx.beginPath();
                    overlaidCanvasCtx.moveTo(eventObject.x3, eventObject.y4);
                    overlaidCanvasCtx.lineTo(eventObject.x2, eventObject.y4);
                    overlaidCanvasCtx.stroke();

                    overlaidCanvasCtx.globalAlpha = 1;

                }
            }
        }

        overlaidCanvasCtx.restore();
        overlaidCanvasCtx.globalAlpha = 1;
        overlaidCanvasCtx.beginPath();

        return;
    }

    ToolTip.prototype.getToolTipInnerHTML = function (e) {
        var entries = e.entries;
        var toolTipInnerHtml = null;
        var dataSeries = null;
        var dataPoint = null;
        var index = 0;
        var color = null;
        var toolTipContent = "";

        var isToolTipDefinedInData = true;
        for (var i = 0; i < entries.length; i++) {
            if (entries[i].dataSeries.toolTipContent || entries[i].dataPoint.toolTipContent) {
                isToolTipDefinedInData = false;
                break;
            }
        }

        if (isToolTipDefinedInData && ((this.content && typeof (this.content) === "function") || this.contentFormatter)) {

            var param = {
                chart: this.chart, toolTip: this.options, entries: entries
            };
            toolTipInnerHtml = this.contentFormatter ? this.contentFormatter(param) : this.content(param);

        } else {

            if (this.shared && this.chart.plotInfo.axisPlacement !== "none") {
                var prevDataSeriesXIndex = null;
                var toolTipInnerHtmlPrefix = "";

                for (var i = 0; i < entries.length; i++) {
                    dataSeries = entries[i].dataSeries;
                    dataPoint = entries[i].dataPoint;
                    index = entries[i].index;

                    toolTipContent = "";

                    if (i === 0 && isToolTipDefinedInData && !this.content) {
                        if (this.chart.axisX && this.chart.axisX.length > 0) {
                            toolTipInnerHtmlPrefix += typeof (this.chart.axisX[0].labels[dataPoint.x]) !== "undefined" ? this.chart.axisX[0].labels[dataPoint.x] : "{x}";
                        }

                        else if (this.chart.axisX2 && this.chart.axisX2.length > 0) {
                            toolTipInnerHtmlPrefix += typeof (this.chart.axisX2[0].labels[dataPoint.x]) !== "undefined" ? this.chart.axisX2[0].labels[dataPoint.x] : "{x}";
                        }
                        toolTipInnerHtmlPrefix += "</br>";
                        toolTipInnerHtmlPrefix = this.chart.replaceKeywordsWithValue(toolTipInnerHtmlPrefix, dataPoint, dataSeries, index);
                    }

                    //Allows disabling of toolTip for individual dataPoints/dataSeries
                    if (dataPoint.toolTipContent === null || (typeof (dataPoint.toolTipContent) === "undefined" && dataSeries.options.toolTipContent === null))
                        continue;


                    if (dataSeries.type === "line" || dataSeries.type === "stepLine" || dataSeries.type === "spline" || dataSeries.type === "area" || dataSeries.type === "stepArea" || dataSeries.type === "splineArea" || dataSeries.type === "column" || dataSeries.type === "bar" || dataSeries.type === "scatter"
                        || dataSeries.type === "stackedColumn" || dataSeries.type === "stackedColumn100" || dataSeries.type === "stackedBar" || dataSeries.type === "stackedBar100"
                        || dataSeries.type === "stackedArea" || dataSeries.type === "stackedArea100") {
                        if (this.chart.axisX && this.chart.axisX.length > 1)
                            toolTipContent += (prevDataSeriesXIndex != dataSeries.axisXIndex) ? (dataSeries.axisX.title ? dataSeries.axisX.title + "<br/>" : "X:{axisXIndex}<br/>") : "";

                        toolTipContent += dataPoint.toolTipContent ? dataPoint.toolTipContent : dataSeries.toolTipContent ? dataSeries.toolTipContent : this.content && typeof (this.content) !== "function" ? this.content : "<span style='\"" + (this.options.fontColor ? "" : "'color:{color};'") + "\"'>{name}:</span>&nbsp;&nbsp;{y}";
                        prevDataSeriesXIndex = dataSeries.axisXIndex;
                    }
                    else if (dataSeries.type === "bubble") {
                        if (this.chart.axisX && this.chart.axisX.length > 1)
                            toolTipContent += (prevDataSeriesXIndex != dataSeries.axisXIndex) ? (dataSeries.axisX.title ? dataSeries.axisX.title + "<br/>" : "X:{axisXIndex}<br/>") : "";

                        toolTipContent += dataPoint.toolTipContent ? dataPoint.toolTipContent : dataSeries.toolTipContent ? dataSeries.toolTipContent : this.content && typeof (this.content) !== "function" ? this.content : "<span style='\"" + (this.options.fontColor ? "" : "'color:{color};'") + "\"'>{name}:</span>&nbsp;&nbsp;{y}, &nbsp;&nbsp;{z}";
                    } else if (dataSeries.type === "rangeColumn" || dataSeries.type === "rangeBar" || dataSeries.type === "rangeArea" || dataSeries.type === "rangeSplineArea") {
                        if (this.chart.axisX && this.chart.axisX.length > 1)
                            toolTipContent += (prevDataSeriesXIndex != dataSeries.axisXIndex) ? (dataSeries.axisX.title ? dataSeries.axisX.title + "<br/>" : "X:{axisXIndex}<br/>") : "";

                        toolTipContent += dataPoint.toolTipContent ? dataPoint.toolTipContent : dataSeries.toolTipContent ? dataSeries.toolTipContent : this.content && typeof (this.content) !== "function" ? this.content : "<span style='\"" + (this.options.fontColor ? "" : "'color:{color};'") + "\"'>{name}:</span>&nbsp;&nbsp;{y[0]},&nbsp;{y[1]}";
                    } else if (dataSeries.type === "candlestick" || dataSeries.type === "ohlc") {
                        if (this.chart.axisX && this.chart.axisX.length > 1)
                            toolTipContent += (prevDataSeriesXIndex != dataSeries.axisXIndex) ? (dataSeries.axisX.title ? dataSeries.axisX.title + "<br/>" : "X:{axisXIndex}<br/>") : "";

                        toolTipContent += dataPoint.toolTipContent ? dataPoint.toolTipContent : dataSeries.toolTipContent ? dataSeries.toolTipContent : this.content && typeof (this.content) !== "function" ? this.content : "<span style='\"" + (this.options.fontColor ? "" : "'color:{color};'") + "\"'>{name}:</span>"
                            + "<br/>Open: &nbsp;&nbsp;{y[0]}"
                            + "<br/>High: &nbsp;&nbsp;&nbsp;{y[1]}"
                            + "<br/>Low:&nbsp;&nbsp;&nbsp;{y[2]}"
                            + "<br/>Close: &nbsp;&nbsp;{y[3]}";
                    }

                    if (toolTipInnerHtml === null)
                        toolTipInnerHtml = "";


                    if (this.reversed === true) {

                        toolTipInnerHtml = this.chart.replaceKeywordsWithValue(toolTipContent, dataPoint, dataSeries, index) + toolTipInnerHtml;

                        if (i < entries.length - 1)
                            toolTipInnerHtml = "</br>" + toolTipInnerHtml;

                    } else {

                        toolTipInnerHtml += this.chart.replaceKeywordsWithValue(toolTipContent, dataPoint, dataSeries, index);

                        if (i < entries.length - 1)
                            toolTipInnerHtml += "</br>";

                    }
                    //dataSeries.toolTipContent = toolTipContent;
                }

                if (toolTipInnerHtml !== null)
                    toolTipInnerHtml = toolTipInnerHtmlPrefix + toolTipInnerHtml;

            } else {

                dataSeries = entries[0].dataSeries;
                dataPoint = entries[0].dataPoint;
                index = entries[0].index;

                //Allows disabling of toolTip for individual dataPoints/dataSeries
                if (dataPoint.toolTipContent === null || (typeof (dataPoint.toolTipContent) === "undefined" && dataSeries.options.toolTipContent === null))
                    return null;


                if (dataSeries.type === "line" || dataSeries.type === "stepLine" || dataSeries.type === "spline" || dataSeries.type === "area" || dataSeries.type === "stepArea" || dataSeries.type === "splineArea" || dataSeries.type === "column" || dataSeries.type === "bar" || dataSeries.type === "scatter"
                    || dataSeries.type === "stackedColumn" || dataSeries.type === "stackedColumn100" || dataSeries.type === "stackedBar" || dataSeries.type === "stackedBar100"
                    || dataSeries.type === "stackedArea" || dataSeries.type === "stackedArea100") {
                    toolTipContent = dataPoint.toolTipContent ? dataPoint.toolTipContent : dataSeries.toolTipContent ? dataSeries.toolTipContent : this.content && typeof (this.content) !== "function" ? this.content : "<span style='\"" + (this.options.fontColor ? "" : "'color:{color};'") + "\"'>" + (dataPoint.label ? "{label}" : "{x}") + ":</span>&nbsp;&nbsp;{y}";
                } else if (dataSeries.type === "bubble") {
                    toolTipContent = dataPoint.toolTipContent ? dataPoint.toolTipContent : dataSeries.toolTipContent ? dataSeries.toolTipContent : this.content && typeof (this.content) !== "function" ? this.content : "<span style='\"" + (this.options.fontColor ? "" : "'color:{color};'") + "\"'>" + (dataPoint.label ? "{label}" : "{x}") + ":</span>&nbsp;&nbsp;{y}, &nbsp;&nbsp;{z}";
                } else if (dataSeries.type === "pie" || dataSeries.type === "doughnut" || dataSeries.type === "funnel") {
                    toolTipContent = dataPoint.toolTipContent ? dataPoint.toolTipContent : dataSeries.toolTipContent ? dataSeries.toolTipContent : this.content && typeof (this.content) !== "function" ? this.content : "<span style='\"" + (this.options.fontColor ? "" : "'color:{color};'") + "\"'>" + (dataPoint.name ? "{name}:</span>&nbsp;&nbsp;" : dataPoint.label ? "{label}:</span>&nbsp;&nbsp;" : "</span>") + "{y}";
                } else if (dataSeries.type === "rangeColumn" || dataSeries.type === "rangeBar" || dataSeries.type === "rangeArea" || dataSeries.type === "rangeSplineArea") {
                    toolTipContent = dataPoint.toolTipContent ? dataPoint.toolTipContent : dataSeries.toolTipContent ? dataSeries.toolTipContent : this.content && typeof (this.content) !== "function" ? this.content : "<span style='\"" + (this.options.fontColor ? "" : "'color:{color};'") + "\"'>" + (dataPoint.label ? "{label}" : "{x}") + " :</span>&nbsp;&nbsp;{y[0]}, &nbsp;{y[1]}";
                } else if (dataSeries.type === "candlestick" || dataSeries.type === "ohlc") {
                    toolTipContent = dataPoint.toolTipContent ? dataPoint.toolTipContent : dataSeries.toolTipContent ? dataSeries.toolTipContent : this.content && typeof (this.content) !== "function" ? this.content : "<span style='\"" + (this.options.fontColor ? "" : "'color:{color};'") + "\"'>" + (dataPoint.label ? "{label}" : "{x}") + "</span>"
                        + "<br/>Open: &nbsp;&nbsp;{y[0]}"
                        + "<br/>High: &nbsp;&nbsp;&nbsp;{y[1]}"
                        + "<br/>Low: &nbsp;&nbsp;&nbsp;&nbsp;{y[2]}"
                        + "<br/>Close: &nbsp;&nbsp;{y[3]}";
                }

                if (toolTipInnerHtml === null)
                    toolTipInnerHtml = "";

                toolTipInnerHtml += this.chart.replaceKeywordsWithValue(toolTipContent, dataPoint, dataSeries, index);
            }
        }
        //this.content = toolTipContent;

        return toolTipInnerHtml;
    }

    ToolTip.prototype.enableAnimation = function () {
        if (this.container.style.WebkitTransition)
            return;

        this.container.style.WebkitTransition = "left .2s ease-out, bottom .2s ease-out";
        this.container.style.MozTransition = "left .2s ease-out, bottom .2s ease-out";
        this.container.style.MsTransition = "left .2s ease-out, bottom .2s ease-out";
        this.container.style.transition = "left .2s ease-out, bottom .2s ease-out";
    }

    ToolTip.prototype.disableAnimation = function () {
        if (!this.container.style.WebkitTransition)
            return;

        this.container.style.WebkitTransition = "";
        this.container.style.MozTransition = "";
        this.container.style.MsTransition = "";
        this.container.style.transition = "";
    }

    ToolTip.prototype.hide = function (resetOverlayedCanvas) {
        if (!this.container)
            return;

        resetOverlayedCanvas = typeof (resetOverlayedCanvas) === "undefined" ? true : resetOverlayedCanvas;

        this.container.style.display = "none";
        this.currentSeriesIndex = -1;
        this._prevX = NaN;
        this._prevY = NaN;
        //this.chart.overlaidCanvasCtx.clearRect(0, 0, this.chart.overlaidCanvas.width, this.chart.overlaidCanvas.height);
        if (resetOverlayedCanvas)
            this.chart.resetOverlayedCanvas();
    }

    ToolTip.prototype.show = function (px, py, closest) {

        closest = typeof (closest) === "undefined" ? false : closest;
        this._updateToolTip(px, py, closest);
    }

    Chart.prototype.getPercentAndTotal = function (ds, dp) {

        var dpX = null;
        var total = null;
        var percent = null;

        if (ds.type.indexOf("stacked") >= 0) {
            total = 0;
            dpX = dp.x.getTime ? dp.x.getTime() : dp.x;
            if (dpX in ds.plotUnit.yTotals) {
                total = ds.plotUnit.yTotals[dpX];

                if (!isNaN(dp.y)) {
                    if (total === 0)
                        percent = 0;
                    else
                        percent = (dp.y / total) * 100;
                }
                else
                    percent = 0;
            }
        } else if (ds.type === "pie" || ds.type === "doughnut") {
            total = 0;
            for (i = 0; i < ds.dataPoints.length; i++) {

                if (!isNaN(ds.dataPoints[i].y))
                    total += ds.dataPoints[i].y;
            }

            if (!isNaN(dp.y))
                percent = (dp.y / total) * 100;
            else
                percent = 0;
        }

        return {
            percent: percent, total: total
        };
    }

    Chart.prototype.replaceKeywordsWithValue = function (str, dp, ds, dpIndex, indexKeywordValue) {
        //var regex = /\{\s*[a-zA-Z]+\s*\}|"[^"]*"|'[^']*'/g;
        var regex = /\{.*?\}|"[^"]*"|'[^']*'/g;
        var chart = this;
        indexKeywordValue = typeof (indexKeywordValue) === "undefined" ? 0 : indexKeywordValue;

        if ((ds.type.indexOf("stacked") >= 0 || (ds.type === "pie" || ds.type === "doughnut")) && (str.indexOf("#percent") >= 0 || str.indexOf("#total") >= 0)) {
            var percent = "#percent";
            var total = "#total";
            var dpX = null;

            var percentAndTotal = this.getPercentAndTotal(ds, dp);

            total = isNaN(percentAndTotal.total) ? total : percentAndTotal.total;
            percent = isNaN(percentAndTotal.percent) ? percent : percentAndTotal.percent;

            do {
                var percentFormatString = "";
                if (ds.percentFormatString)
                    percentFormatString = ds.percentFormatString;
                else {
                    percentFormatString = "#,##0.";
                    var numberOfDecimals = Math.max(Math.ceil(Math.log(1 / Math.abs(percent)) / Math.LN10), 2);

                    if (isNaN(numberOfDecimals) || !isFinite(numberOfDecimals))
                        numberOfDecimals = 2;

                    for (var n = 0; n < numberOfDecimals; n++) {
                        percentFormatString += "#";
                    }
                    ds.percentFormatString = percentFormatString;
                }

                str = str.replace("#percent", numberFormat(percent, percentFormatString, chart._cultureInfo));
                str = str.replace("#total", numberFormat(total, ds.yValueFormatString ? ds.yValueFormatString : "#,##0.########", chart._cultureInfo));
            } while (str.indexOf("#percent") >= 0 || str.indexOf("#total") >= 0);
        }


        var fcn = function ($0) {
            if (($0[0] === "\"" && $0[$0.length - 1] === "\"") || ($0[0] === "\'" && $0[$0.length - 1] === "\'"))
                return $0.slice(1, $0.length - 1);

            var key = trimString($0.slice(1, $0.length - 1));
            key = key.replace("#index", indexKeywordValue);

            var index = null;

            try {
                var match = key.match(/(.*?)\s*\[\s*(.*?)\s*\]/);
                if (match && match.length > 0) {
                    index = trimString(match[2]);
                    key = trimString(match[1]);
                }
            } catch (e) {
            };


            var obj = null;

            if (key === "color") {
                return dp.color ? dp.color : ds.color ? ds.color : ds._colorSet[dpIndex % ds._colorSet.length];
            }

            if (dp.hasOwnProperty(key))
                obj = dp;
            else if (ds.hasOwnProperty(key))
                obj = ds;
            else return "";

            var value = obj[key];
            if (index !== null)
                value = value[index];

            if (key === "x") {
                if (chart.plotInfo.axisXValueType === "dateTime" || ds.xValueType === "dateTime" || (dp.x && dp.x.getTime)) {
                    if (chart.plotInfo.plotTypes[0].plotUnits[0].axisX && !chart.plotInfo.plotTypes[0].plotUnits[0].axisX.logarithmic)
                        return dateFormat(value, dp.xValueFormatString ? dp.xValueFormatString : ds.xValueFormatString ? ds.xValueFormatString : (ds.xValueFormatString = chart.axisX && chart.axisX.autoValueFormatString ? chart.axisX.autoValueFormatString : "DD MMM YY"), chart._cultureInfo);
                }
                else
                    return numberFormat(value, dp.xValueFormatString ? dp.xValueFormatString : ds.xValueFormatString ? ds.xValueFormatString : (ds.xValueFormatString = "#,##0.########"), chart._cultureInfo);
            } else if (key === "y")
                return numberFormat(value, dp.yValueFormatString ? dp.yValueFormatString : ds.yValueFormatString ? ds.yValueFormatString : (ds.yValueFormatString = "#,##0.########"), chart._cultureInfo);
            else if (key === "z")
                return numberFormat(value, dp.zValueFormatString ? dp.zValueFormatString : ds.zValueFormatString ? ds.zValueFormatString : (ds.zValueFormatString = "#,##0.########"), chart._cultureInfo);
            else
                return value;
        }

        return str.replace(regex, fcn);
    }


    //#endregion ToolTip

    //#region Event Manager

    function EventManager(chart) {
        this.chart = chart;
        this.lastObjectId = 0;
        var _this = this;
        this.objectMap = [];
        this.rectangularRegionEventSubscriptions = [];
        this.previousDataPointEventObject = null;
        //this.previousDataSeriesEventObject = null;

        this.ghostCanvas = createCanvas(this.chart.width, this.chart.height);
        //this.ghostCanvas.width = this.chart.width;
        //this.ghostCanvas.height = this.chart.height;

        this.ghostCtx = this.ghostCanvas.getContext("2d");

        var eventHandler = function (ev) {
            _this.mouseEventHandler.call(_this, ev);
        };

        this.mouseoveredObjectMaps = [];
        //this.chart.canvas.addEventListener("mouseover", eventHandler);
        //this.chart.canvas.addEventListener("mousemove", eventHandler);
        //this.chart.canvas.addEventListener("mouseout", eventHandler);
        //this.chart.canvas.addEventListener("click", eventHandler);
    }

    EventManager.prototype.reset = function () {
        this.lastObjectId = 0;
        this.objectMap = [];
        this.rectangularRegionEventSubscriptions = [];
        this.previousDataPointEventObject = null;

        this.eventObjects = [];
        //this.ghostCanvas.width = this.chart.width;
        //this.ghostCanvas.height = this.chart.height;

        if (isCanvasSupported) {
            this.ghostCtx.clearRect(0, 0, this.chart.width, this.chart.height);
            this.ghostCtx.beginPath();
        }
    }

    EventManager.prototype.getNewObjectTrackingId = function () {
        return ++this.lastObjectId;
    }

    EventManager.prototype.mouseEventHandler = function (ev) {

        if (ev.type !== "mousemove" && ev.type !== "click")
            return;

        var eventObjectMaps = [];
        var xy = getMouseCoordinates(ev);
        var id = null;

        //var dataPointInfo = this.chart.getDataPointAtXY(xy.x, xy.y, false);

        //if (dataPointInfo) {
        //	id = dataPointInfo.dataSeries.dataPointIds[dataPointInfo.dataPointIndex];
        //} else if (isCanvasSupported) {//IE9+
        //	id = getObjectId(xy.x, xy.y, this.ghostCtx);
        //}
        id = this.chart.getObjectAtXY(xy.x, xy.y, false);

        if (id && typeof (this.objectMap[id]) !== "undefined") {

            var eventObjectMap = this.objectMap[id];

            if (eventObjectMap.objectType === "dataPoint") {
                var dataSeries = this.chart.data[eventObjectMap.dataSeriesIndex];
                var dataPoint = dataSeries.dataPoints[eventObjectMap.dataPointIndex];
                var dataPointIndex = eventObjectMap.dataPointIndex;

                //Event Parameter should not contain reference to dataSeries directly. But to its options.
                eventObjectMap.eventParameter = {
                    x: xy.x, y: xy.y, dataPoint: dataPoint,
                    dataSeries: dataSeries.options, dataPointIndex: dataPointIndex, dataSeriesIndex: dataSeries.index,
                    chart: this.chart
                };
                eventObjectMap.eventContext = {
                    context: dataPoint, userContext: dataPoint, mouseover: "mouseover", mousemove: "mousemove", mouseout: "mouseout", click: "click"
                };
                eventObjectMaps.push(eventObjectMap);

                //Add Dataseries too because mouse event on dataPoint also means there is an event on dataSeries. DataSeries is not present on ghost canvas
                eventObjectMap = this.objectMap[dataSeries.id];

                //Event Parameter should not contain reference to dataSeries directly. But to its options.
                eventObjectMap.eventParameter = {
                    x: xy.x, y: xy.y,
                    dataPoint: dataPoint, dataSeries: dataSeries.options, dataPointIndex: dataPointIndex, dataSeriesIndex: dataSeries.index,
                    chart: this.chart
                };

                eventObjectMap.eventContext = {
                    context: dataSeries, userContext: dataSeries.options, mouseover: "mouseover", mousemove: "mousemove", mouseout: "mouseout", click: "click"
                };
                eventObjectMaps.push(this.objectMap[dataSeries.id]);
            }
                //else if (eventObjectMap.objectType === "stripLine") {

                //	//Event Parameter should not contain reference to stripLine directly. But to its options.
                //	eventObjectMap.eventParameter = { x: xy.x, y: xy.y, stripLine: eventObjectMap.stripLine.options, axis: eventObjectMap.axis.options, stripLineIndex: eventObjectMap.stripLineIndex };
                //	eventObjectMap.eventContext = { context: eventObjectMap.stripLine, userContext: eventObjectMap.stripLine.options, mouseover: "mouseover", mousemove: "mousemove", mouseout: "mouseout", click: "click" };

                //	eventObjectMaps.push(eventObjectMap);
            //}
            else if (eventObjectMap.objectType === "legendItem") {

                var dataSeries = this.chart.data[eventObjectMap.dataSeriesIndex];
                var dataPoint = eventObjectMap.dataPointIndex !== null ? dataSeries.dataPoints[eventObjectMap.dataPointIndex] : null;

                //Event Parameter should not contain reference to DataSeries directly. But to its options.
                eventObjectMap.eventParameter = {
                    x: xy.x, y: xy.y,
                    dataSeries: dataSeries.options, dataPoint: dataPoint, dataPointIndex: eventObjectMap.dataPointIndex, dataSeriesIndex: eventObjectMap.dataSeriesIndex,
                    chart: this.chart
                };
                eventObjectMap.eventContext = {
                    context: this.chart.legend, userContext: this.chart.legend.options, mouseover: "itemmouseover", mousemove: "itemmousemove", mouseout: "itemmouseout", click: "itemclick"
                };
                eventObjectMaps.push(eventObjectMap);
            }
        }

        //Fire mouseout if existing mouseovered objects are not present in the objectmap.
        var mouseOutObjectMapsExcluded = [];
        for (var i = 0; i < this.mouseoveredObjectMaps.length; i++) {
            var mouseOut = true;

            for (var j = 0; j < eventObjectMaps.length; j++) {
                if (eventObjectMaps[j].id === this.mouseoveredObjectMaps[i].id) {
                    mouseOut = false;
                    break;
                }
            }

            if (mouseOut) {
                this.fireEvent(this.mouseoveredObjectMaps[i], "mouseout", ev);
            } else {
                mouseOutObjectMapsExcluded.push(this.mouseoveredObjectMaps[i]);
            }
        }

        this.mouseoveredObjectMaps = mouseOutObjectMapsExcluded;

        //Process new eventObectMaps
        //If they already don't exist, add them and fire mouseover
        //If ev.type is mousemove, then just fire mousemove
        //If ev.type is click, then fire two events - click followed by mousemove
        for (var i = 0; i < eventObjectMaps.length; i++) {

            var existing = false;

            for (var j = 0; j < this.mouseoveredObjectMaps.length; j++) {
                if (eventObjectMaps[i].id === this.mouseoveredObjectMaps[j].id) {
                    existing = true;
                    break;
                }
            }

            if (!existing) {
                this.fireEvent(eventObjectMaps[i], "mouseover", ev);
                this.mouseoveredObjectMaps.push(eventObjectMaps[i]);
            }

            if (ev.type === "click") {
                this.fireEvent(eventObjectMaps[i], "click", ev);
            } else if (ev.type === "mousemove") {
                this.fireEvent(eventObjectMaps[i], "mousemove", ev);
            }
        }
    }

    EventManager.prototype.fireEvent = function (eventObjectMap, eventType, ev) {

        if (!eventObjectMap || !eventType)
            return;

        var eventParameter = eventObjectMap.eventParameter;
        var eventContext = eventObjectMap.eventContext;
        //var context = eventObjectMap.eventContext.context;
        var userContext = eventObjectMap.eventContext.userContext

        if (userContext && eventContext && userContext[eventContext[eventType]])
            userContext[eventContext[eventType]].call(userContext, eventParameter);

        if (eventType !== "mouseout") {
            if (userContext.cursor && userContext.cursor !== ev.target.style.cursor) {
                ev.target.style.cursor = userContext.cursor;
            }
        } else {
            ev.target.style.cursor = this.chart._defaultCursor;
            delete eventObjectMap.eventParameter; // reference no longer required.
            delete eventObjectMap.eventContext; // reference no longer required.
        }

        //This is just a quick fix. Need to find a better way of calling internal event handlers.
        if (eventType === "click" && eventObjectMap.objectType === "dataPoint" && this.chart.pieDoughnutClickHandler) {
            this.chart.pieDoughnutClickHandler.call(this.chart.data[eventObjectMap.dataSeriesIndex], eventParameter);
        }
    }

    //#endregion Event Manager

    //#region Class CultureInfo

    function CultureInfo(culture) {

        var cultureInfo;

        if (culture && cultures[culture])
            cultureInfo = cultures[culture];

        CultureInfo.base.constructor.call(this, "CultureInfo", cultureInfo);
    }

    extend(CultureInfo, CanvasJSObject);

    //#endregion Class CultureInfo

    //#region Animator


    function Animator(chart) {

        this.chart = chart;
        this.ctx = this.chart.plotArea.ctx;
        this.animations = [];
        this.animationRequestId = null;
    }

    //Animator.prototype.animate = function (duration, base, dest, source, animationCallback, onComplete) {
    Animator.prototype.animate = function (startDelay, duration, animationCallback, onComplete, easingFunction) {
        var _this = this;

        this.chart.isAnimating = true;
        easingFunction = easingFunction || AnimationHelper.easing.linear;

        if (animationCallback) {

            this.animations.push({
                startTime: (new Date()).getTime() + (startDelay ? startDelay : 0),
                duration: duration,
                animationCallback: animationCallback,
                onComplete: onComplete
            });
        }

        var remainingAnimations = [];

        while (this.animations.length > 0) {

            var animation = this.animations.shift();
            var now = (new Date()).getTime();
            var fractionComplete = 0;
            //var fractionComplete = Math.min(((new Date()).getTime() - animation.startTime) / animation.duration, 1);

            if (animation.startTime <= now) {
                fractionComplete = easingFunction(Math.min((now - animation.startTime), animation.duration), 0, 1, animation.duration);
                //var fractionComplete = AnimationHelper.easing.easeOutQuad(Math.min(((new Date()).getTime() - animation.startTime), animation.duration), 0, 1, animation.duration);

                fractionComplete = Math.min(fractionComplete, 1);

                if (isNaN(fractionComplete) || !isFinite(fractionComplete))
                    fractionComplete = 1;
            }

            if (fractionComplete < 1) {
                remainingAnimations.push(animation);
            }

            animation.animationCallback(fractionComplete);

            if (fractionComplete >= 1 && animation.onComplete)
                animation.onComplete();
        }

        this.animations = remainingAnimations;

        if (this.animations.length > 0) {
            this.animationRequestId = this.chart.requestAnimFrame.call(window, function () {
                _this.animate.call(_this);
            });
        } else {
            this.chart.isAnimating = false;
        }

    }

    Animator.prototype.cancelAllAnimations = function () {

        this.animations = [];

        if (this.animationRequestId) {
            this.chart.cancelRequestAnimFrame.call(window, this.animationRequestId);
        }

        this.animationRequestId = null;
        this.chart.isAnimating = false;
    }

    var AnimationHelper = {
        yScaleAnimation: function (fractionComplete, animationInfo) {
            if (fractionComplete === 0)
                return;

            var ctx = animationInfo.dest;
            var sourceCanvas = animationInfo.source.canvas;
            var base = animationInfo.animationBase;

            var offsetY = (base - base * fractionComplete);

            ctx.drawImage(sourceCanvas, 0, 0, sourceCanvas.width, sourceCanvas.height, 0, offsetY, ctx.canvas.width / devicePixelBackingStoreRatio, fractionComplete * ctx.canvas.height / devicePixelBackingStoreRatio);
        },
        xScaleAnimation: function (fractionComplete, animationInfo) {
            if (fractionComplete === 0)
                return;

            var ctx = animationInfo.dest;
            var sourceCanvas = animationInfo.source.canvas;
            var base = animationInfo.animationBase;

            var offsetX = (base - base * fractionComplete);

            ctx.drawImage(sourceCanvas, 0, 0, sourceCanvas.width, sourceCanvas.height, offsetX, 0, fractionComplete * ctx.canvas.width / devicePixelBackingStoreRatio, ctx.canvas.height / devicePixelBackingStoreRatio);
        },
        xClipAnimation: function (fractionComplete, animationInfo) {

            if (fractionComplete === 0)
                return;

            var ctx = animationInfo.dest;
            var sourceCanvas = animationInfo.source.canvas;

            ctx.save();

            if (fractionComplete > 0)
                ctx.drawImage(sourceCanvas, 0, 0, sourceCanvas.width * fractionComplete, sourceCanvas.height, 0, 0, sourceCanvas.width * fractionComplete / devicePixelBackingStoreRatio, sourceCanvas.height / devicePixelBackingStoreRatio);

            ctx.restore();
        },
        fadeInAnimation: function (fractionComplete, animationInfo) {

            if (fractionComplete === 0)
                return;

            var ctx = animationInfo.dest;
            var sourceCanvas = animationInfo.source.canvas;

            ctx.save();

            ctx.globalAlpha = fractionComplete;

            ctx.drawImage(sourceCanvas, 0, 0, sourceCanvas.width, sourceCanvas.height, 0, 0, ctx.canvas.width / devicePixelBackingStoreRatio, ctx.canvas.height / devicePixelBackingStoreRatio);

            ctx.restore();
        },
        easing: {
            linear: function (t, b, c, d) {
                return c * t / d + b;
            },
            easeOutQuad: function (t, b, c, d) {
                return -c * (t /= d) * (t - 2) + b;
            },
            easeOutQuart: function (t, b, c, d) {
                return -c * ((t = t / d - 1) * t * t * t - 1) + b;
            },
            easeInQuad: function (t, b, c, d) {
                return c * (t /= d) * t + b;
            },
            easeInQuart: function (t, b, c, d) {
                return c * (t /= d) * t * t * t + b;
            }
        }
    }

    //#endregion Animator

    //#region Render Helper

    var RenderHelper = {
        drawMarker: function (x, y, ctx, markerType, markerSize, markerColor, markerBorderColor, markerBorderThickness) {

            if (!ctx)
                return;

            var alpha = 1;

            ctx.fillStyle = markerColor ? markerColor : "#000000";
            ctx.strokeStyle = markerBorderColor ? markerBorderColor : "#000000";
            ctx.lineWidth = markerBorderThickness ? markerBorderThickness : 0;


            if (markerType === "circle") {

                ctx.moveTo(x, y);
                ctx.beginPath();
                //return;

                ctx.arc(x, y, markerSize / 2, 0, Math.PI * 2, false);

                if (markerColor)
                    ctx.fill();

                if (markerBorderThickness) {

                    if (!markerBorderColor) {
                        alpha = ctx.globalAlpha;
                        ctx.globalAlpha = .15;
                        ctx.strokeStyle = "black";
                        ctx.stroke();
                        ctx.globalAlpha = alpha;
                    } else
                        ctx.stroke();

                }
            }
            else if (markerType === "square") {

                //ctx.moveTo(x - markerSize / 2, y - markerSize / 2);
                ctx.beginPath();
                ctx.rect(x - markerSize / 2, y - markerSize / 2, markerSize, markerSize);

                if (markerColor)
                    ctx.fill();

                if (markerBorderThickness) {

                    if (!markerBorderColor) {
                        alpha = ctx.globalAlpha;
                        ctx.globalAlpha = .15;
                        ctx.strokeStyle = "black";
                        ctx.stroke();
                        ctx.globalAlpha = alpha;
                    } else
                        ctx.stroke();

                }
            } else if (markerType === "triangle") {

                ctx.beginPath();
                ctx.moveTo(x - markerSize / 2, y + markerSize / 2);
                ctx.lineTo(x + markerSize / 2, y + markerSize / 2);
                ctx.lineTo(x, y - markerSize / 2);
                ctx.closePath();

                if (markerColor)
                    ctx.fill();

                if (markerBorderThickness) {

                    if (!markerBorderColor) {
                        alpha = ctx.globalAlpha;
                        ctx.globalAlpha = .15;
                        ctx.strokeStyle = "black";
                        ctx.stroke();
                        ctx.globalAlpha = alpha;
                    } else
                        ctx.stroke();

                }
                ctx.beginPath();
            } else if (markerType === "cross") {

                ctx.strokeStyle = markerColor;
                markerBorderThickness = markerSize / 4;
                ctx.lineWidth = markerBorderThickness;

                ctx.beginPath();
                ctx.moveTo(x - markerSize / 2, y - markerSize / 2);
                ctx.lineTo(x + markerSize / 2, y + markerSize / 2);
                ctx.stroke();

                ctx.moveTo(x + markerSize / 2, y - markerSize / 2);
                ctx.lineTo(x - markerSize / 2, y + markerSize / 2);
                ctx.stroke();

            }


        },
        drawMarkers: function (markers) {
            for (var i = 0; i < markers.length; i++) {
                var marker = markers[i];

                RenderHelper.drawMarker(marker.x, marker.y, marker.ctx, marker.type, marker.size, marker.color, marker.borderColor, marker.borderThickness);
            }
        }
        //,
        //draw1pxLine: function (x1, y1, x2, y2, color, ctx) {
        //	ctx.beginPath();
        //	ctx.drawRect(x1, y1, x2 - x1, y2 - y1);
        //	ctx.stroke();
        //}
    }

    //#endregion Render Helper

    //#endregion Class Definitions

    //#region Public API

    var publicAPIs = {
        title: {},
        toolTip: {},
        axisX: {},
        axisY: {}
    };

    var CanvasJS = {

        Chart: Chart,
        addColorSet: function (name, colorSet) {
            colorSets[name] = colorSet;
        },
        addCultureInfo: function (name, cultureInfo) {
            cultures[name] = cultureInfo;
        },
        formatNumber: function (number, formatString, culture) {
            culture = culture || "en";
            formatString = formatString || "#,##0.##";

            if (!cultures[culture])
                throw "Unknown Culture Name";
            else {
                return numberFormat(number, formatString, new CultureInfo(culture));
            }
        },
        formatDate: function (date, formatString, culture) {
            culture = culture || "en";
            formatString = formatString || "DD MMM YYYY";

            if (!cultures[culture])
                throw "Unknown Culture Name";
            else {
                return dateFormat(date, formatString, new CultureInfo(culture));
            }
        }

    }

    CanvasJS.Chart.version = "v1.9.10 GA";
    window.CanvasJS = CanvasJS;
    //#endregion Public API

})();
var BogusChartObject = {
    render: function() { return false; },
    options: { data: {} },
    title: { fontsize: "12px" },
};


var QueuestatsC = UCPMC.extend({
    previous_alerts: {},
    charts: {},
    chartdata: {},
    events: {},
    chart_defaults: {
        dailyqueuestats: {
            title: {
                text: "Daily Queue Statistics"
            },
            toolTip:{
                content:"{tooltip}" ,
            },
            data: [
                {
                    type: "spline",
                    datapoints: []
                }
            ],
            axisX: {
                labelFormatter: function (e) {
                    return UCP.timeFormatter(e.value);
                }
            }
        },
        weeklyqueuestats: {
            title: {
                text: "Weekly Queue Statistics"
            },
            toolTip:{
                content:"{tooltip}" ,
            },
            data: [
                {
                    type: "spline", datapoints: []
                }
            ],
            axisX: {
                labelFormatter: function (e) {
                    return UCP.timeFormatter(e.value);
                }
            }
        },
        activequeuecalls: { title: { text: "Current Queue Activity" }, data: [ { type: "doughnut", datapoints: [ ] } ] },
        sla: { title: { text: "SLA for Queue" }, data: [ { type: "doughnut", datapoints: [ ] } ] },
        abandonedqueuecalls: { title: { text: "Abandoned Queue Activity" }, data: [ { type: "doughnut", datapoints: [ ] } ] },
        receivedcalls: { title: { text: "Received Calls for Queue" }, data: [ { type: "doughnut", datapoints: [ ] } ] },
        longwaittime: {
            title: {
                text: "LWT for Queue"
            }, data: [
                {
                    type: "doughnut", datapoints: [ ]
                }
            ]
        },
        avgwaittime: {
            title: {
                text: "Avg Wait Time for Queue"
            },
            toolTip:{
                content:"{tooltip}" ,
            },
            data: [
                {
                    type: "spline",
                    datapoints: [ ]
                }
            ],
            axisX: {
                labelFormatter: function (e) {
                    return UCP.timeFormatter(e.value);
                }
            },
            axisY: {
                title : "Seconds"
            }
        },
        queuesummary: { title: { text: "Queue Summary for Queue" }, data: [ { type: "doughnut", datapoints: [ ] } ] },
        genhtmltext: { title: { text: "Generic HTML|Text for Queue" }, data: [ { type: "doughnut", datapoints: [ ] } ] },
        calleroutcome: { title: { text: "Caller Outcome for Queue" }, data: [ { type: "doughnut", datapoints: [ ] } ] },
    },

    init: function() {
    },
    showDashboard: function(dashboard_id) {
        var self = this;
    },
    resize: function(x, y, z) {
        // Resize all of our charts.
        for (var uuid in this.charts) {
            this.charts[uuid].render();
        }
    },
    displayWidget: function(widget_id,dashboard_id) {
        var uuid = $(".grid-stack-item[data-id='"+widget_id+"']").data('widget_type_id');
        if(this.charts[uuid]) {
            this.charts[uuid].destroy();
            this.charts[uuid] = null;
            delete(this.charts[uuid]);
        }
        this.renderWidgetContent(uuid);
    },
    prepoll: function() {
        // Get our current elements
        var uuids = [];
        $.each($(".grid-stack-item[data-rawname='queuestats']"), function () {
            uuids.push($(this).data('widget_type_id'));
        });
        return uuids;
    },

    poll: function(data) {
        // The data we get back is dict of uuid => { data }, uuid => { data }.
        // Iterate over the UUIDs, and if they've registered in window.QE,
        // give them the data.
        for (var uuid in data) {
            this.chartdata[uuid] = data[uuid];
            this.renderWidgetContent(uuid);
        }

    },
    renderWidgetContent: function(uuid) {
        var self = this,
            data = this.chartdata[uuid];
        // Do we need to do anything with it?
        if (typeof this.events[uuid] === "undefined") {
            console.log("No handler registered for "+uuid+", skipping");
            return;
        }

        var widget = $(".grid-stack-item[data-widget_type_id='"+uuid+"']");
        if (widget.length === 0) {
            console.log("Returned data for uuid "+uuid+", but can't find it.");
            return;
        }

        var handler = this.events[uuid];
        if(typeof handler !== "string") {
            throw "Handler was an object or function when it should have been a string";
        }

        //$('head').append('<link rel="stylesheet" type="text/css" href="widget.css">');

        // Update any i18n fields
        widget.find(".qs-i18n").each(function() {
            self.update_i18n($(this), data);
        });

        widget.find(".qs-bscstff").each(function() {
            self.update_bscstff($(this));
        });

        widget.find(".qs-divtable").each(function() {
            self.update_divtable($(this));
        });

        widget.find(".qs-divtblcell").each(function() {
            self.update_divtblcell($(this));
        });

        widget.find(".qs-flexmain").each(function() {
            self.update_flexmain($(this));
        });

        widget.find(".qs-flexelement").each(function() {
            self.update_flexelement($(this));
        });

        widget.find(".qs-flexgrow").each(function() {
            self.update_flexgrow($(this));
        });

        // If there's a chart in this widget, load it.
        var cd = widget.find(".chartdiv");
        if (cd.length !== 0) {
            if (typeof data.chartdata !== "undefined") {
                var chart = this.get_chart(cd, uuid, cd.data('charttype'));
                chart.options.data = data.chartdata;
                chart.options.title.text = data.title;
                chart.render();
            }
            // Does this chart have a flextext that needs to be resized?
            var ft = widget.find(".flextext");
            if (typeof ft !== "undefined") {
                $(ft).each(function() {
                    if (!chart || !chart.title) {
                        console.log("Widget "+uuid+" has a flextext but no chart. This is only a warning");
                        // Strange. Has a flextext but no chart
                        return;
                    }
                    // Set the font size to be twice the chart title size
                    $(this).css('font-size', chart.title.fontSize * 2).
                        // and move it down so it's actually in the center
                        css('padding-top', chart.title.fontSize);
                });
            }
        }

        // It's something we should know about already
        var methodname = "handler_"+handler;
        if (typeof this[methodname] === "undefined") {
            console.log("Unable to find handler "+handler);
            return;
        }
        this[methodname](widget, uuid, data);
    },

    // This simply dumps data into any 'debug' div it finds.
    handler_debug: function(widget, uuid, data) {
        var debugtext = JSON.stringify(data, null, '\t');
        widget.find('.debug').each(function() { $(this).text(debugtext); });
    },

    update_bscstff: function(div){
        $(div).css("background-color", "white");
    },

    update_divtable: function(div){
        $(div).css("width", "100%");
        $(div).css("height", "100%");
        //$(div).css("background-color", "blue");
    },

    update_divtblcell: function(div){
        $(div).css("border", "5px solid white");
        $(div).css("background-color", "red");
    },

    update_flexmain: function(div){
        $(div).css("display", "flex");
        //$(div).css("flex-flow", "row wrap");
        $(div).css("flex-flow", "row nowrap");
        $(div).css("justify-content", "space-around");
        //$(div).css("justify-content", "center");
        //$(div).css("height", "33%");
        $(div).css("align-items", "center");
    },
    /*
	update_flexmain: function(div){
		$(div).css("display", "flex");
		//$(div).css("flex-flow", "row wrap");
		$(div).css("flex-flow", "row nowrap");
		$(div).css("justify-content", "space-around");
		//$(div).css("justify-content", "center");
		$(div).css("height", "33%");
		$(div).css("align-items", "center");
	},

	update_flexelement: function(div){
		$(div).css("background", "tomato");
		$(div).css("padding", "5px");
		$(div).css("width", "200%");
		$(div).css("height", "100%");
		$(div).css("margin-top", "10px");
		$(div).css("line-height:", "100px");
		$(div).css("color", "white");
		$(div).css("font-weight", "bold");
		$(div).css("font-size", "3em");
		$(div).css("text-align", "center");
	},
 */
    update_flexelement: function(div){
        $(div).css("background", "tomato");
        $(div).css("padding", "5px");
        $(div).css("width", "200%");
        $(div).css("height", "100%");
        $(div).css("margin-top", "10px");
        $(div).css("line-height:", "100px");
        $(div).css("color", "white");
        $(div).css("font-weight", "bold");
        $(div).css("font-size", "3em");
        $(div).css("text-align", "center");
    },

    /*
	update_flexelement: function(div){
		//$(div).css("background", "tomato");
		//$(div).css("padding", "5px");
		//$(div).css("margin-top", "10px");
		//$(div).css("width", "100%");
		//$(div).css("height", "100%");
		//$(div).css("line-height:", "100px");
		//$(div).css("color", "white");
		$(div).css("font-weight", "bold");
		//$(div).css("font-size", "3em");
		$(div).css("text-align", "center");
	},
*/
    update_flexgrow: function(div){
        $(div).css("flex-grow", "1");
        //$(div).css("align-items", "flex-end");
    },

    update_i18n: function(div, data) {
        // Match anything that is NOT a _, between __ and __
        var regexp = /(__([^_]+)__)/g;
        var newtext = div.data('i18n').replace(regexp, function(x, y, z) {
            // x and y are __WHATEVER__ and z is WHATEVER
            var newval = data[z.toLowerCase()];
            if (typeof newval !== "undefined") {
                if (!newval) {
                    return "";
                }
                return newval;
            }
            return "__ERROR-"+z+"__";
        });
        div.html(newtext);
    },

    get_chart: function(chartdiv, uuid, name) {
        var chart = this.charts[uuid];
        // If we don't have a CanvasJS object in the global namespace,
        // return a bogus chart object
        if (typeof CanvasJS === "undefined") {
            return BogusChartObject;
        }

        if (typeof this.charts[uuid]  === "undefined" || this.charts[uuid] === null) {
            var chartOptions = jQuery.extend({backgroundColor: null},this.chart_defaults[name]);
            this.charts[uuid] = new CanvasJS.Chart(chartdiv[0], chartOptions);
        }
        return this.charts[uuid];
    },

    handler_toplwt: function(widget, uuid, data) {
        if (typeof data.title !== "undefined" && typeof this.charts[uuid] !== "undefined") {
            this.charts[uuid].options.title.text = data.title;
        }

        var container = widget.find('ul.list-container');
        container.html("");
        if(data.calls.length) {
            async.each(data.calls, function(call, callback) {
                    container.append("<li>"+sprintf(_("On %s at %s caller '%s' waited for %s"),UCP.dateFormatter(call.entrytime),UCP.timeFormatter(call.entrytime),call.callerid,call.holdtimenice)+"</li>");
                    callback();
                }, function(err) {
                }
            );
        } else {
            container.append("<li>"+_("No Longest Wait Times on Record")+"</li>");
        }
    },

    handler_sla: function(widget, uuid, data) {
        // Update the title of the chart if we can
        if (typeof data.title !== "undefined" && typeof this.charts[uuid] !== "undefined") {
            this.charts[uuid].options.title.text = data.title;
        }

        if (typeof data.alrtmsg !== "undefined") {
            this.displayNotification(uuid, data.widgetname, data.alrtmsg);
        }
    },

    handler_activecalls: function(widget, uuid, data) {
        widget.find('td.activecalls').text(data.active);
        widget.find('td.waitingcalls').text(data.waiting);
        widget.find('td.agentcount').text(data.agentcount);
    },

    handler_abandoned: function(widget, uuid, data) {

    },

    handler_receivedcalls: function(widget, uuid, data) {
        if (typeof data.title !== "undefined" && typeof this.charts[uuid] !== "undefined") {
            this.charts[uuid].options.title.text = data.title;
        }
    },

    handler_longwaittime: function(widget, uuid, data) {
        // Update the title of the chart if we can
        if (typeof data.title !== "undefined" && typeof this.charts[uuid] !== "undefined") {
            this.charts[uuid].options.title.text = data.title;
        }

        if (typeof data.alrtmsg !== "undefined") {
            this.displayNotification(uuid, data.widgetname, data.alrtmsg);
        }
    },

    map_agent_icon: function(state) {
        var mappings = {
            unknown: {
                "class": [ "fa-question-circle-o", "red" ],
                "text": _("Unknown")
            },
            idle: {
                "class": [ "fa-user-circle-o" ],
                "text": _("Idle")
            },
            ringing: {
                "class": [ "fa-phone", "animated", "faa-ring", "green" ],
                "text": _("Ringing")
            },
            queuecall: {
                "class": [ "fa-phone", "green" ],
                "text": _("In Queue Call")
            },
            othercall: {
                "class": [ "fa-phone-square", "green" ],
                "text": _("In Non-Queue Call")
            },
            wrapup: {
                "class": [ "fa-tty", "green" ],
                "text": _("Wrapping Up")
            },
            paused: {
                "class": [ "fa-eye-slash", "green" ],
                "text": _("Paused")
            },
            dnd: {
                "class": [ "fa-eye-slash", "red" ],
                "text": _("DND")
            },
        };

        var icon = (typeof mappings[state] !== "undefined") ? mappings[state] : mappings.unknown;
        return icon;
    },

    handler_agentstate: function(widget, uuid, data) {
        var icon = this.map_agent_icon(data.currentstatus)
        var html = "<i class='fa fa-5x "+icon.class.join(" ")+"'></i>";
        widget.find(".stateicon").each(function() { $(this).html(html); });
        widget.find(".agent-status-text").each(function() { $(this).text(icon.text); });
        return;
    },

    handler_dailyqueuestats: function(widget, uuid, data) {
        // Nothing here, as it's all done backend.
    },

    handler_avgwaittime: function(widget, uuid, data) {
        if (typeof data.title !== "undefined" && typeof this.charts[uuid] !== "undefined") {
            this.charts[uuid].options.title.text = data.title;
        }
    },

    handler_agentsummary: function(widget, uuid, data) {
        var icon = this.map_agent_icon(data.currentstatus)
        var html = "<i class='fa fa-5x "+icon.class.join(" ")+"'></i>";
        widget.find(".stateicon").each(function() { $(this).html(html); });
        widget.find(".agent-status-text").each(function() { $(this).text(icon.text); });
        return;
    },

    handler_multipleagentsummary: function(widget, uuid, data) {
        var self = this;
        widget.find(".agent-container").each(function() {
            var container = $(this);
            var agent = container.data("agent");
            if(typeof data['currentstatus-'+agent] === "undefined") {
                return true;
            }
            var icon = self.map_agent_icon(data['currentstatus-'+agent])
            var html = "<i class='fa fa-5x "+icon.class.join(" ")+"'></i>";
            container.find(".stateicon").each(function() { $(this).html(html); });
            container.find(".agent-status-text").each(function() { $(this).text(icon.text); });
        });
    },

    handler_queuesummary: function(widget, uuid, data) {
        var settings = {
            strokeWidth: 6,
            easing: 'easeInOut',
            duration: 1400,
            color: '#369dad',
            trailColor: 'rgb(202, 202, 202)',
            trailWidth: 1,
            svgStyle: null,
            text: {
                autoStyleContainer: false,
                style: {
                    fontSize: "1.7rem",
                    textAlign: 'center',
                    position: 'absolute',
                    top: '0',
                    paddingTop: '15px',
                    paddingLeft: '6px',
                    paddingRight: '6px',
                    width: '50%',
                    height: '100%',
                    color: 'rgb(47, 64, 80)'
                }
            }
        };
        $(".progress-circle-"+uuid).html("");
        var bar = new ProgressBar.Circle('#progress-circle-abandonded-'+uuid, settings);
        bar.set(1);
        //bar.animate(1);
        bar.setText('<span><i class="fa fa-times fa-lg" aria-hidden="true"></i><br/>'+data.abandoned+'</span>');
        $('#progress-circle-abandonded-'+uuid).textfill({
            explicitHeight: $(".progress-circle").one().height()-55
        })

        var bar = new ProgressBar.Circle('#progress-circle-received-'+uuid, settings);
        bar.set(1);
        //bar.animate(1);
        bar.setText('<span><i class="fa fa-phone fa-lg" aria-hidden="true"></i><br/>'+data.received+'</span>');
        $('#progress-circle-received-'+uuid).textfill({
            explicitHeight: $(".progress-circle").one().height()-55
        })

        var bar = new ProgressBar.Circle('#progress-circle-waiting-'+uuid, settings);
        bar.set(1);
        //bar.animate(1);
        bar.setText('<span><i class="fa fa-pause fa-lg" aria-hidden="true"></i><div style="font-size: 0.65em;line-height: 1;margin-top: 0.3em;">'+moment.duration(parseInt(data.avgwaitsec), 'seconds').format('D[ day] H[ hour(s)] m[ minute] s[ second]')+'</div></span>');
        $('#progress-circle-waiting-'+uuid).textfill({
            explicitHeight: $(".progress-circle").one().height()-55
        })
    },

    handler_calleroutcome: function(widget, uuid, data) {
        var settings = {
            strokeWidth: 6,
            easing: 'easeInOut',
            duration: 1400,
            color: '#369dad',
            trailColor: 'rgb(202, 202, 202)',
            trailWidth: 1,
            svgStyle: null,
            text: {
                autoStyleContainer: false,
                style: {
                    fontSize: "1.7rem",
                    textAlign: 'center',
                    position: 'absolute',
                    top: '0',
                    paddingTop: '15px',
                    paddingLeft: '6px',
                    paddingRight: '6px',
                    width: '50%',
                    height: '100%',
                    color: 'rgb(47, 64, 80)'
                }
            }
        };
        $(".progress-circle-"+uuid).html("");

        var bar = new ProgressBar.Circle('#progress-circle-answered-'+uuid, settings);
        bar.set(1);
        //bar.animate(1);
        bar.setText('<span><i class="fa fa-phone fa-lg" aria-hidden="true"></i><br/>'+data.answered+'</span>');
        $('#progress-circle-answered-'+uuid).textfill({
            explicitHeight: $(".progress-circle").one().height()-55
        })

        var bar = new ProgressBar.Circle('#progress-circle-timeout-'+uuid, settings);
        bar.set(1);
        //bar.animate(1);
        bar.setText('<span><i class="fa fa-hourglass-end fa-lg" aria-hidden="true"></i><br/>'+data.timeout+'</span>');
        $('#progress-circle-timeout-'+uuid).textfill({
            explicitHeight: $(".progress-circle").one().height()-55
        })

        var bar = new ProgressBar.Circle('#progress-circle-hungup-'+uuid, settings);
        bar.set(1);
        //bar.animate(1);
        bar.setText('<span><i class="fa fa-times fa-lg" aria-hidden="true"></i><br/>'+data.hungup+'</span>');
        $('#progress-circle-hungup-'+uuid).textfill({
            explicitHeight: $(".progress-circle").one().height()-55
        })

    },

    handler_genhtmltext: function(widget, uuid, data) {
        if (typeof data.title !== "undefined" && typeof this.charts[uuid] !== "undefined") {
            this.charts[uuid].options.title.text = data.title;
        }
    },

    displayNotification: function(uuid, title, body) {
        if(!UCP.notify) {
            return;
        }
        if (typeof this.previous_alerts[uuid] === "undefined" || this.previous_alerts[uuid] === null || this.previous_alerts[uuid] !== body) {
            this.previous_alerts[uuid] = body;
            var notification = new Notify(title, {
                body: body,
                icon: "modules/Queuestats/assets/images/alert.png"
            });
            notification.show();

            //after 1 minute re-display the alert
            var $this = this;
            setTimeout(function(){
                if($this.previous_alerts[uuid] !== body) {
                    return
                }
                $this.previous_alerts[uuid] = null;
                delete($this.previous_alerts[uuid]);
            },60000);
        }
    }
});

(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.ProgressBar = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
        /* shifty - v1.5.3 - 2016-11-29 - http://jeremyckahn.github.io/shifty */
        ;(function () {
            var root = this || Function('return this')();

            /**
             * Shifty Core
             * By Jeremy Kahn - jeremyckahn@gmail.com
             */

            var Tweenable = (function () {

                'use strict';

                // Aliases that get defined later in this function
                var formula;

                // CONSTANTS
                var DEFAULT_SCHEDULE_FUNCTION;
                var DEFAULT_EASING = 'linear';
                var DEFAULT_DURATION = 500;
                var UPDATE_TIME = 1000 / 60;

                var _now = Date.now
                    ? Date.now
                    : function () {return +new Date();};

                var now = typeof SHIFTY_DEBUG_NOW !== 'undefined' ? SHIFTY_DEBUG_NOW : _now;

                if (typeof window !== 'undefined') {
                    // requestAnimationFrame() shim by Paul Irish (modified for Shifty)
                    // http://paulirish.com/2011/requestanimationframe-for-smart-animating/
                    DEFAULT_SCHEDULE_FUNCTION = window.requestAnimationFrame
                        || window.webkitRequestAnimationFrame
                        || window.oRequestAnimationFrame
                        || window.msRequestAnimationFrame
                        || (window.mozCancelRequestAnimationFrame
                            && window.mozRequestAnimationFrame)
                        || setTimeout;
                } else {
                    DEFAULT_SCHEDULE_FUNCTION = setTimeout;
                }

                function noop () {
                    // NOOP!
                }

                /**
                 * Handy shortcut for doing a for-in loop. This is not a "normal" each
                 * function, it is optimized for Shifty.  The iterator function only receives
                 * the property name, not the value.
                 * @param {Object} obj
                 * @param {Function(string)} fn
                 * @private
                 */
                function each (obj, fn) {
                    var key;
                    for (key in obj) {
                        if (Object.hasOwnProperty.call(obj, key)) {
                            fn(key);
                        }
                    }
                }

                /**
                 * Perform a shallow copy of Object properties.
                 * @param {Object} targetObject The object to copy into
                 * @param {Object} srcObject The object to copy from
                 * @return {Object} A reference to the augmented `targetObj` Object
                 * @private
                 */
                function shallowCopy (targetObj, srcObj) {
                    each(srcObj, function (prop) {
                        targetObj[prop] = srcObj[prop];
                    });

                    return targetObj;
                }

                /**
                 * Copies each property from src onto target, but only if the property to
                 * copy to target is undefined.
                 * @param {Object} target Missing properties in this Object are filled in
                 * @param {Object} src
                 * @private
                 */
                function defaults (target, src) {
                    each(src, function (prop) {
                        if (typeof target[prop] === 'undefined') {
                            target[prop] = src[prop];
                        }
                    });
                }

                /**
                 * Calculates the interpolated tween values of an Object for a given
                 * timestamp.
                 * @param {Number} forPosition The position to compute the state for.
                 * @param {Object} currentState Current state properties.
                 * @param {Object} originalState: The original state properties the Object is
                 * tweening from.
                 * @param {Object} targetState: The destination state properties the Object
                 * is tweening to.
                 * @param {number} duration: The length of the tween in milliseconds.
                 * @param {number} timestamp: The UNIX epoch time at which the tween began.
                 * @param {Object} easing: This Object's keys must correspond to the keys in
                 * targetState.
                 * @private
                 */
                function tweenProps (forPosition, currentState, originalState, targetState,
                                     duration, timestamp, easing) {
                    var normalizedPosition =
                        forPosition < timestamp ? 0 : (forPosition - timestamp) / duration;


                    var prop;
                    var easingObjectProp;
                    var easingFn;
                    for (prop in currentState) {
                        if (currentState.hasOwnProperty(prop)) {
                            easingObjectProp = easing[prop];
                            easingFn = typeof easingObjectProp === 'function'
                                ? easingObjectProp
                                : formula[easingObjectProp];

                            currentState[prop] = tweenProp(
                                originalState[prop],
                                targetState[prop],
                                easingFn,
                                normalizedPosition
                            );
                        }
                    }

                    return currentState;
                }

                /**
                 * Tweens a single property.
                 * @param {number} start The value that the tween started from.
                 * @param {number} end The value that the tween should end at.
                 * @param {Function} easingFunc The easing curve to apply to the tween.
                 * @param {number} position The normalized position (between 0.0 and 1.0) to
                 * calculate the midpoint of 'start' and 'end' against.
                 * @return {number} The tweened value.
                 * @private
                 */
                function tweenProp (start, end, easingFunc, position) {
                    return start + (end - start) * easingFunc(position);
                }

                /**
                 * Applies a filter to Tweenable instance.
                 * @param {Tweenable} tweenable The `Tweenable` instance to call the filter
                 * upon.
                 * @param {String} filterName The name of the filter to apply.
                 * @private
                 */
                function applyFilter (tweenable, filterName) {
                    var filters = Tweenable.prototype.filter;
                    var args = tweenable._filterArgs;

                    each(filters, function (name) {
                        if (typeof filters[name][filterName] !== 'undefined') {
                            filters[name][filterName].apply(tweenable, args);
                        }
                    });
                }

                var timeoutHandler_endTime;
                var timeoutHandler_currentTime;
                var timeoutHandler_isEnded;
                var timeoutHandler_offset;
                /**
                 * Handles the update logic for one step of a tween.
                 * @param {Tweenable} tweenable
                 * @param {number} timestamp
                 * @param {number} delay
                 * @param {number} duration
                 * @param {Object} currentState
                 * @param {Object} originalState
                 * @param {Object} targetState
                 * @param {Object} easing
                 * @param {Function(Object, *, number)} step
                 * @param {Function(Function,number)}} schedule
                 * @param {number=} opt_currentTimeOverride Needed for accurate timestamp in
                 * Tweenable#seek.
                 * @private
                 */
                function timeoutHandler (tweenable, timestamp, delay, duration, currentState,
                                         originalState, targetState, easing, step, schedule,
                                         opt_currentTimeOverride) {

                    timeoutHandler_endTime = timestamp + delay + duration;

                    timeoutHandler_currentTime =
                        Math.min(opt_currentTimeOverride || now(), timeoutHandler_endTime);

                    timeoutHandler_isEnded =
                        timeoutHandler_currentTime >= timeoutHandler_endTime;

                    timeoutHandler_offset = duration - (
                        timeoutHandler_endTime - timeoutHandler_currentTime);

                    if (tweenable.isPlaying()) {
                        if (timeoutHandler_isEnded) {
                            step(targetState, tweenable._attachment, timeoutHandler_offset);
                            tweenable.stop(true);
                        } else {
                            tweenable._scheduleId =
                                schedule(tweenable._timeoutHandler, UPDATE_TIME);

                            applyFilter(tweenable, 'beforeTween');

                            // If the animation has not yet reached the start point (e.g., there was
                            // delay that has not yet completed), just interpolate the starting
                            // position of the tween.
                            if (timeoutHandler_currentTime < (timestamp + delay)) {
                                tweenProps(1, currentState, originalState, targetState, 1, 1, easing);
                            } else {
                                tweenProps(timeoutHandler_currentTime, currentState, originalState,
                                    targetState, duration, timestamp + delay, easing);
                            }

                            applyFilter(tweenable, 'afterTween');

                            step(currentState, tweenable._attachment, timeoutHandler_offset);
                        }
                    }
                }


                /**
                 * Creates a usable easing Object from a string, a function or another easing
                 * Object.  If `easing` is an Object, then this function clones it and fills
                 * in the missing properties with `"linear"`.
                 * @param {Object.<string|Function>} fromTweenParams
                 * @param {Object|string|Function} easing
                 * @return {Object.<string|Function>}
                 * @private
                 */
                function composeEasingObject (fromTweenParams, easing) {
                    var composedEasing = {};
                    var typeofEasing = typeof easing;

                    if (typeofEasing === 'string' || typeofEasing === 'function') {
                        each(fromTweenParams, function (prop) {
                            composedEasing[prop] = easing;
                        });
                    } else {
                        each(fromTweenParams, function (prop) {
                            if (!composedEasing[prop]) {
                                composedEasing[prop] = easing[prop] || DEFAULT_EASING;
                            }
                        });
                    }

                    return composedEasing;
                }

                /**
                 * Tweenable constructor.
                 * @class Tweenable
                 * @param {Object=} opt_initialState The values that the initial tween should
                 * start at if a `from` object is not provided to `{{#crossLink
                 * "Tweenable/tween:method"}}{{/crossLink}}` or `{{#crossLink
                 * "Tweenable/setConfig:method"}}{{/crossLink}}`.
                 * @param {Object=} opt_config Configuration object to be passed to
                 * `{{#crossLink "Tweenable/setConfig:method"}}{{/crossLink}}`.
                 * @module Tweenable
                 * @constructor
                 */
                function Tweenable (opt_initialState, opt_config) {
                    this._currentState = opt_initialState || {};
                    this._configured = false;
                    this._scheduleFunction = DEFAULT_SCHEDULE_FUNCTION;

                    // To prevent unnecessary calls to setConfig do not set default
                    // configuration here.  Only set default configuration immediately before
                    // tweening if none has been set.
                    if (typeof opt_config !== 'undefined') {
                        this.setConfig(opt_config);
                    }
                }

                /**
                 * Configure and start a tween.
                 * @method tween
                 * @param {Object=} opt_config Configuration object to be passed to
                 * `{{#crossLink "Tweenable/setConfig:method"}}{{/crossLink}}`.
                 * @chainable
                 */
                Tweenable.prototype.tween = function (opt_config) {
                    if (this._isTweening) {
                        return this;
                    }

                    // Only set default config if no configuration has been set previously and
                    // none is provided now.
                    if (opt_config !== undefined || !this._configured) {
                        this.setConfig(opt_config);
                    }

                    this._timestamp = now();
                    this._start(this.get(), this._attachment);
                    return this.resume();
                };

                /**
                 * Configure a tween that will start at some point in the future.
                 *
                 * @method setConfig
                 * @param {Object} config The following values are valid:
                 * - __from__ (_Object=_): Starting position.  If omitted, `{{#crossLink
                 *   "Tweenable/get:method"}}get(){{/crossLink}}` is used.
                 * - __to__ (_Object=_): Ending position.
                 * - __duration__ (_number=_): How many milliseconds to animate for.
                 * - __delay__ (_delay=_): How many milliseconds to wait before starting the
                 *   tween.
                 * - __start__ (_Function(Object, *)_): Function to execute when the tween
                 *   begins.  Receives the state of the tween as the first parameter and
                 *   `attachment` as the second parameter.
                 * - __step__ (_Function(Object, *, number)_): Function to execute on every
                 *   tick.  Receives `{{#crossLink
                 *   "Tweenable/get:method"}}get(){{/crossLink}}` as the first parameter,
                 *   `attachment` as the second parameter, and the time elapsed since the
                 *   start of the tween as the third. This function is not called on the
                 *   final step of the animation, but `finish` is.
                 * - __finish__ (_Function(Object, *)_): Function to execute upon tween
                 *   completion.  Receives the state of the tween as the first parameter and
                 *   `attachment` as the second parameter.
                 * - __easing__ (_Object.<string|Function>|string|Function=_): Easing curve
                 *   name(s) or function(s) to use for the tween.
                 * - __attachment__ (_*_): Cached value that is passed to the
                 *   `step`/`start`/`finish` methods.
                 * @chainable
                 */
                Tweenable.prototype.setConfig = function (config) {
                    config = config || {};
                    this._configured = true;

                    // Attach something to this Tweenable instance (e.g.: a DOM element, an
                    // object, a string, etc.);
                    this._attachment = config.attachment;

                    // Init the internal state
                    this._pausedAtTime = null;
                    this._scheduleId = null;
                    this._delay = config.delay || 0;
                    this._start = config.start || noop;
                    this._step = config.step || noop;
                    this._finish = config.finish || noop;
                    this._duration = config.duration || DEFAULT_DURATION;
                    this._currentState = shallowCopy({}, config.from || this.get());
                    this._originalState = this.get();
                    this._targetState = shallowCopy({}, config.to || this.get());

                    var self = this;
                    this._timeoutHandler = function () {
                        timeoutHandler(self,
                            self._timestamp,
                            self._delay,
                            self._duration,
                            self._currentState,
                            self._originalState,
                            self._targetState,
                            self._easing,
                            self._step,
                            self._scheduleFunction
                        );
                    };

                    // Aliases used below
                    var currentState = this._currentState;
                    var targetState = this._targetState;

                    // Ensure that there is always something to tween to.
                    defaults(targetState, currentState);

                    this._easing = composeEasingObject(
                        currentState, config.easing || DEFAULT_EASING);

                    this._filterArgs =
                        [currentState, this._originalState, targetState, this._easing];

                    applyFilter(this, 'tweenCreated');
                    return this;
                };

                /**
                 * @method get
                 * @return {Object} The current state.
                 */
                Tweenable.prototype.get = function () {
                    return shallowCopy({}, this._currentState);
                };

                /**
                 * @method set
                 * @param {Object} state The current state.
                 */
                Tweenable.prototype.set = function (state) {
                    this._currentState = state;
                };

                /**
                 * Pause a tween.  Paused tweens can be resumed from the point at which they
                 * were paused.  This is different from `{{#crossLink
                 * "Tweenable/stop:method"}}{{/crossLink}}`, as that method
                 * causes a tween to start over when it is resumed.
                 * @method pause
                 * @chainable
                 */
                Tweenable.prototype.pause = function () {
                    this._pausedAtTime = now();
                    this._isPaused = true;
                    return this;
                };

                /**
                 * Resume a paused tween.
                 * @method resume
                 * @chainable
                 */
                Tweenable.prototype.resume = function () {
                    if (this._isPaused) {
                        this._timestamp += now() - this._pausedAtTime;
                    }

                    this._isPaused = false;
                    this._isTweening = true;

                    this._timeoutHandler();

                    return this;
                };

                /**
                 * Move the state of the animation to a specific point in the tween's
                 * timeline.  If the animation is not running, this will cause the `step`
                 * handlers to be called.
                 * @method seek
                 * @param {millisecond} millisecond The millisecond of the animation to seek
                 * to.  This must not be less than `0`.
                 * @chainable
                 */
                Tweenable.prototype.seek = function (millisecond) {
                    millisecond = Math.max(millisecond, 0);
                    var currentTime = now();

                    if ((this._timestamp + millisecond) === 0) {
                        return this;
                    }

                    this._timestamp = currentTime - millisecond;

                    if (!this.isPlaying()) {
                        this._isTweening = true;
                        this._isPaused = false;

                        // If the animation is not running, call timeoutHandler to make sure that
                        // any step handlers are run.
                        timeoutHandler(this,
                            this._timestamp,
                            this._delay,
                            this._duration,
                            this._currentState,
                            this._originalState,
                            this._targetState,
                            this._easing,
                            this._step,
                            this._scheduleFunction,
                            currentTime
                        );

                        this.pause();
                    }

                    return this;
                };

                /**
                 * Stops and cancels a tween.
                 * @param {boolean=} gotoEnd If `false` or omitted, the tween just stops at
                 * its current state, and the `finish` handler is not invoked.  If `true`,
                 * the tweened object's values are instantly set to the target values, and
                 * `finish` is invoked.
                 * @method stop
                 * @chainable
                 */
                Tweenable.prototype.stop = function (gotoEnd) {
                    this._isTweening = false;
                    this._isPaused = false;
                    this._timeoutHandler = noop;

                    (root.cancelAnimationFrame            ||
                        root.webkitCancelAnimationFrame     ||
                        root.oCancelAnimationFrame          ||
                        root.msCancelAnimationFrame         ||
                        root.mozCancelRequestAnimationFrame ||
                        root.clearTimeout)(this._scheduleId);

                    if (gotoEnd) {
                        applyFilter(this, 'beforeTween');
                        tweenProps(
                            1,
                            this._currentState,
                            this._originalState,
                            this._targetState,
                            1,
                            0,
                            this._easing
                        );
                        applyFilter(this, 'afterTween');
                        applyFilter(this, 'afterTweenEnd');
                        this._finish.call(this, this._currentState, this._attachment);
                    }

                    return this;
                };

                /**
                 * @method isPlaying
                 * @return {boolean} Whether or not a tween is running.
                 */
                Tweenable.prototype.isPlaying = function () {
                    return this._isTweening && !this._isPaused;
                };

                /**
                 * Set a custom schedule function.
                 *
                 * If a custom function is not set,
                 * [`requestAnimationFrame`](https://developer.mozilla.org/en-US/docs/Web/API/window.requestAnimationFrame)
                 * is used if available, otherwise
                 * [`setTimeout`](https://developer.mozilla.org/en-US/docs/Web/API/Window.setTimeout)
                 * is used.
                 * @method setScheduleFunction
                 * @param {Function(Function,number)} scheduleFunction The function to be
                 * used to schedule the next frame to be rendered.
                 */
                Tweenable.prototype.setScheduleFunction = function (scheduleFunction) {
                    this._scheduleFunction = scheduleFunction;
                };

                /**
                 * `delete` all "own" properties.  Call this when the `Tweenable` instance
                 * is no longer needed to free memory.
                 * @method dispose
                 */
                Tweenable.prototype.dispose = function () {
                    var prop;
                    for (prop in this) {
                        if (this.hasOwnProperty(prop)) {
                            delete this[prop];
                        }
                    }
                };

                /**
                 * Filters are used for transforming the properties of a tween at various
                 * points in a Tweenable's life cycle.  See the README for more info on this.
                 * @private
                 */
                Tweenable.prototype.filter = {};

                /**
                 * This object contains all of the tweens available to Shifty.  It is
                 * extensible - simply attach properties to the `Tweenable.prototype.formula`
                 * Object following the same format as `linear`.
                 *
                 * `pos` should be a normalized `number` (between 0 and 1).
                 * @property formula
                 * @type {Object(function)}
                 */
                Tweenable.prototype.formula = {
                    linear: function (pos) {
                        return pos;
                    }
                };

                formula = Tweenable.prototype.formula;

                shallowCopy(Tweenable, {
                    'now': now
                    ,'each': each
                    ,'tweenProps': tweenProps
                    ,'tweenProp': tweenProp
                    ,'applyFilter': applyFilter
                    ,'shallowCopy': shallowCopy
                    ,'defaults': defaults
                    ,'composeEasingObject': composeEasingObject
                });

                // `root` is provided in the intro/outro files.

                // A hook used for unit testing.
                if (typeof SHIFTY_DEBUG_NOW === 'function') {
                    root.timeoutHandler = timeoutHandler;
                }

                // Bootstrap Tweenable appropriately for the environment.
                if (typeof exports === 'object') {
                    // CommonJS
                    module.exports = Tweenable;
                } else if (typeof define === 'function' && define.amd) {
                    // AMD
                    define(function () {return Tweenable;});
                } else if (typeof root.Tweenable === 'undefined') {
                    // Browser: Make `Tweenable` globally accessible.
                    root.Tweenable = Tweenable;
                }

                return Tweenable;

            } ());

            /*!
 * All equations are adapted from Thomas Fuchs'
 * [Scripty2](https://github.com/madrobby/scripty2/blob/master/src/effects/transitions/penner.js).
 *
 * Based on Easing Equations (c) 2003 [Robert
 * Penner](http://www.robertpenner.com/), all rights reserved. This work is
 * [subject to terms](http://www.robertpenner.com/easing_terms_of_use.html).
 */

            /*!
 *  TERMS OF USE - EASING EQUATIONS
 *  Open source under the BSD License.
 *  Easing Equations (c) 2003 Robert Penner, all rights reserved.
 */

            ;(function () {

                Tweenable.shallowCopy(Tweenable.prototype.formula, {
                    easeInQuad: function (pos) {
                        return Math.pow(pos, 2);
                    },

                    easeOutQuad: function (pos) {
                        return -(Math.pow((pos - 1), 2) - 1);
                    },

                    easeInOutQuad: function (pos) {
                        if ((pos /= 0.5) < 1) {return 0.5 * Math.pow(pos,2);}
                        return -0.5 * ((pos -= 2) * pos - 2);
                    },

                    easeInCubic: function (pos) {
                        return Math.pow(pos, 3);
                    },

                    easeOutCubic: function (pos) {
                        return (Math.pow((pos - 1), 3) + 1);
                    },

                    easeInOutCubic: function (pos) {
                        if ((pos /= 0.5) < 1) {return 0.5 * Math.pow(pos,3);}
                        return 0.5 * (Math.pow((pos - 2),3) + 2);
                    },

                    easeInQuart: function (pos) {
                        return Math.pow(pos, 4);
                    },

                    easeOutQuart: function (pos) {
                        return -(Math.pow((pos - 1), 4) - 1);
                    },

                    easeInOutQuart: function (pos) {
                        if ((pos /= 0.5) < 1) {return 0.5 * Math.pow(pos,4);}
                        return -0.5 * ((pos -= 2) * Math.pow(pos,3) - 2);
                    },

                    easeInQuint: function (pos) {
                        return Math.pow(pos, 5);
                    },

                    easeOutQuint: function (pos) {
                        return (Math.pow((pos - 1), 5) + 1);
                    },

                    easeInOutQuint: function (pos) {
                        if ((pos /= 0.5) < 1) {return 0.5 * Math.pow(pos,5);}
                        return 0.5 * (Math.pow((pos - 2),5) + 2);
                    },

                    easeInSine: function (pos) {
                        return -Math.cos(pos * (Math.PI / 2)) + 1;
                    },

                    easeOutSine: function (pos) {
                        return Math.sin(pos * (Math.PI / 2));
                    },

                    easeInOutSine: function (pos) {
                        return (-0.5 * (Math.cos(Math.PI * pos) - 1));
                    },

                    easeInExpo: function (pos) {
                        return (pos === 0) ? 0 : Math.pow(2, 10 * (pos - 1));
                    },

                    easeOutExpo: function (pos) {
                        return (pos === 1) ? 1 : -Math.pow(2, -10 * pos) + 1;
                    },

                    easeInOutExpo: function (pos) {
                        if (pos === 0) {return 0;}
                        if (pos === 1) {return 1;}
                        if ((pos /= 0.5) < 1) {return 0.5 * Math.pow(2,10 * (pos - 1));}
                        return 0.5 * (-Math.pow(2, -10 * --pos) + 2);
                    },

                    easeInCirc: function (pos) {
                        return -(Math.sqrt(1 - (pos * pos)) - 1);
                    },

                    easeOutCirc: function (pos) {
                        return Math.sqrt(1 - Math.pow((pos - 1), 2));
                    },

                    easeInOutCirc: function (pos) {
                        if ((pos /= 0.5) < 1) {return -0.5 * (Math.sqrt(1 - pos * pos) - 1);}
                        return 0.5 * (Math.sqrt(1 - (pos -= 2) * pos) + 1);
                    },

                    easeOutBounce: function (pos) {
                        if ((pos) < (1 / 2.75)) {
                            return (7.5625 * pos * pos);
                        } else if (pos < (2 / 2.75)) {
                            return (7.5625 * (pos -= (1.5 / 2.75)) * pos + 0.75);
                        } else if (pos < (2.5 / 2.75)) {
                            return (7.5625 * (pos -= (2.25 / 2.75)) * pos + 0.9375);
                        } else {
                            return (7.5625 * (pos -= (2.625 / 2.75)) * pos + 0.984375);
                        }
                    },

                    easeInBack: function (pos) {
                        var s = 1.70158;
                        return (pos) * pos * ((s + 1) * pos - s);
                    },

                    easeOutBack: function (pos) {
                        var s = 1.70158;
                        return (pos = pos - 1) * pos * ((s + 1) * pos + s) + 1;
                    },

                    easeInOutBack: function (pos) {
                        var s = 1.70158;
                        if ((pos /= 0.5) < 1) {
                            return 0.5 * (pos * pos * (((s *= (1.525)) + 1) * pos - s));
                        }
                        return 0.5 * ((pos -= 2) * pos * (((s *= (1.525)) + 1) * pos + s) + 2);
                    },

                    elastic: function (pos) {
                        // jshint maxlen:90
                        return -1 * Math.pow(4,-8 * pos) * Math.sin((pos * 6 - 1) * (2 * Math.PI) / 2) + 1;
                    },

                    swingFromTo: function (pos) {
                        var s = 1.70158;
                        return ((pos /= 0.5) < 1) ?
                            0.5 * (pos * pos * (((s *= (1.525)) + 1) * pos - s)) :
                            0.5 * ((pos -= 2) * pos * (((s *= (1.525)) + 1) * pos + s) + 2);
                    },

                    swingFrom: function (pos) {
                        var s = 1.70158;
                        return pos * pos * ((s + 1) * pos - s);
                    },

                    swingTo: function (pos) {
                        var s = 1.70158;
                        return (pos -= 1) * pos * ((s + 1) * pos + s) + 1;
                    },

                    bounce: function (pos) {
                        if (pos < (1 / 2.75)) {
                            return (7.5625 * pos * pos);
                        } else if (pos < (2 / 2.75)) {
                            return (7.5625 * (pos -= (1.5 / 2.75)) * pos + 0.75);
                        } else if (pos < (2.5 / 2.75)) {
                            return (7.5625 * (pos -= (2.25 / 2.75)) * pos + 0.9375);
                        } else {
                            return (7.5625 * (pos -= (2.625 / 2.75)) * pos + 0.984375);
                        }
                    },

                    bouncePast: function (pos) {
                        if (pos < (1 / 2.75)) {
                            return (7.5625 * pos * pos);
                        } else if (pos < (2 / 2.75)) {
                            return 2 - (7.5625 * (pos -= (1.5 / 2.75)) * pos + 0.75);
                        } else if (pos < (2.5 / 2.75)) {
                            return 2 - (7.5625 * (pos -= (2.25 / 2.75)) * pos + 0.9375);
                        } else {
                            return 2 - (7.5625 * (pos -= (2.625 / 2.75)) * pos + 0.984375);
                        }
                    },

                    easeFromTo: function (pos) {
                        if ((pos /= 0.5) < 1) {return 0.5 * Math.pow(pos,4);}
                        return -0.5 * ((pos -= 2) * Math.pow(pos,3) - 2);
                    },

                    easeFrom: function (pos) {
                        return Math.pow(pos,4);
                    },

                    easeTo: function (pos) {
                        return Math.pow(pos,0.25);
                    }
                });

            }());

// jshint maxlen:100
            /**
             * The Bezier magic in this file is adapted/copied almost wholesale from
             * [Scripty2](https://github.com/madrobby/scripty2/blob/master/src/effects/transitions/cubic-bezier.js),
             * which was adapted from Apple code (which probably came from
             * [here](http://opensource.apple.com/source/WebCore/WebCore-955.66/platform/graphics/UnitBezier.h)).
             * Special thanks to Apple and Thomas Fuchs for much of this code.
             */

            /**
             *  Copyright (c) 2006 Apple Computer, Inc. All rights reserved.
             *
             *  Redistribution and use in source and binary forms, with or without
             *  modification, are permitted provided that the following conditions are met:
             *
             *  1. Redistributions of source code must retain the above copyright notice,
             *  this list of conditions and the following disclaimer.
             *
             *  2. Redistributions in binary form must reproduce the above copyright notice,
             *  this list of conditions and the following disclaimer in the documentation
             *  and/or other materials provided with the distribution.
             *
             *  3. Neither the name of the copyright holder(s) nor the names of any
             *  contributors may be used to endorse or promote products derived from
             *  this software without specific prior written permission.
             *
             *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
             *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
             *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
             *  ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
             *  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
             *  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
             *  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
             *  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
             *  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
             *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
             *  POSSIBILITY OF SUCH DAMAGE.
             */
            ;(function () {
                // port of webkit cubic bezier handling by http://www.netzgesta.de/dev/
                function cubicBezierAtTime(t,p1x,p1y,p2x,p2y,duration) {
                    var ax = 0,bx = 0,cx = 0,ay = 0,by = 0,cy = 0;
                    function sampleCurveX(t) {
                        return ((ax * t + bx) * t + cx) * t;
                    }
                    function sampleCurveY(t) {
                        return ((ay * t + by) * t + cy) * t;
                    }
                    function sampleCurveDerivativeX(t) {
                        return (3.0 * ax * t + 2.0 * bx) * t + cx;
                    }
                    function solveEpsilon(duration) {
                        return 1.0 / (200.0 * duration);
                    }
                    function solve(x,epsilon) {
                        return sampleCurveY(solveCurveX(x, epsilon));
                    }
                    function fabs(n) {
                        if (n >= 0) {
                            return n;
                        } else {
                            return 0 - n;
                        }
                    }
                    function solveCurveX(x, epsilon) {
                        var t0,t1,t2,x2,d2,i;
                        for (t2 = x, i = 0; i < 8; i++) {
                            x2 = sampleCurveX(t2) - x;
                            if (fabs(x2) < epsilon) {
                                return t2;
                            }
                            d2 = sampleCurveDerivativeX(t2);
                            if (fabs(d2) < 1e-6) {
                                break;
                            }
                            t2 = t2 - x2 / d2;
                        }
                        t0 = 0.0;
                        t1 = 1.0;
                        t2 = x;
                        if (t2 < t0) {
                            return t0;
                        }
                        if (t2 > t1) {
                            return t1;
                        }
                        while (t0 < t1) {
                            x2 = sampleCurveX(t2);
                            if (fabs(x2 - x) < epsilon) {
                                return t2;
                            }
                            if (x > x2) {
                                t0 = t2;
                            }else {
                                t1 = t2;
                            }
                            t2 = (t1 - t0) * 0.5 + t0;
                        }
                        return t2; // Failure.
                    }
                    cx = 3.0 * p1x;
                    bx = 3.0 * (p2x - p1x) - cx;
                    ax = 1.0 - cx - bx;
                    cy = 3.0 * p1y;
                    by = 3.0 * (p2y - p1y) - cy;
                    ay = 1.0 - cy - by;
                    return solve(t, solveEpsilon(duration));
                }
                /**
                 *  getCubicBezierTransition(x1, y1, x2, y2) -> Function
                 *
                 *  Generates a transition easing function that is compatible
                 *  with WebKit's CSS transitions `-webkit-transition-timing-function`
                 *  CSS property.
                 *
                 *  The W3C has more information about CSS3 transition timing functions:
                 *  http://www.w3.org/TR/css3-transitions/#transition-timing-function_tag
                 *
                 *  @param {number} x1
                 *  @param {number} y1
                 *  @param {number} x2
                 *  @param {number} y2
                 *  @return {function}
                 *  @private
                 */
                function getCubicBezierTransition (x1, y1, x2, y2) {
                    return function (pos) {
                        return cubicBezierAtTime(pos,x1,y1,x2,y2,1);
                    };
                }
                // End ported code

                /**
                 * Create a Bezier easing function and attach it to `{{#crossLink
                 * "Tweenable/formula:property"}}Tweenable#formula{{/crossLink}}`.  This
                 * function gives you total control over the easing curve.  Matthew Lein's
                 * [Ceaser](http://matthewlein.com/ceaser/) is a useful tool for visualizing
                 * the curves you can make with this function.
                 * @method setBezierFunction
                 * @param {string} name The name of the easing curve.  Overwrites the old
                 * easing function on `{{#crossLink
                 * "Tweenable/formula:property"}}Tweenable#formula{{/crossLink}}` if it
                 * exists.
                 * @param {number} x1
                 * @param {number} y1
                 * @param {number} x2
                 * @param {number} y2
                 * @return {function} The easing function that was attached to
                 * Tweenable.prototype.formula.
                 */
                Tweenable.setBezierFunction = function (name, x1, y1, x2, y2) {
                    var cubicBezierTransition = getCubicBezierTransition(x1, y1, x2, y2);
                    cubicBezierTransition.displayName = name;
                    cubicBezierTransition.x1 = x1;
                    cubicBezierTransition.y1 = y1;
                    cubicBezierTransition.x2 = x2;
                    cubicBezierTransition.y2 = y2;

                    return Tweenable.prototype.formula[name] = cubicBezierTransition;
                };


                /**
                 * `delete` an easing function from `{{#crossLink
                 * "Tweenable/formula:property"}}Tweenable#formula{{/crossLink}}`.  Be
                 * careful with this method, as it `delete`s whatever easing formula matches
                 * `name` (which means you can delete standard Shifty easing functions).
                 * @method unsetBezierFunction
                 * @param {string} name The name of the easing function to delete.
                 * @return {function}
                 */
                Tweenable.unsetBezierFunction = function (name) {
                    delete Tweenable.prototype.formula[name];
                };

            })();

            ;(function () {

                function getInterpolatedValues (
                    from, current, targetState, position, easing, delay) {
                    return Tweenable.tweenProps(
                        position, current, from, targetState, 1, delay, easing);
                }

                // Fake a Tweenable and patch some internals.  This approach allows us to
                // skip uneccessary processing and object recreation, cutting down on garbage
                // collection pauses.
                var mockTweenable = new Tweenable();
                mockTweenable._filterArgs = [];

                /**
                 * Compute the midpoint of two Objects.  This method effectively calculates a
                 * specific frame of animation that `{{#crossLink
                 * "Tweenable/tween:method"}}{{/crossLink}}` does many times over the course
                 * of a full tween.
                 *
                 *     var interpolatedValues = Tweenable.interpolate({
                 *       width: '100px',
                 *       opacity: 0,
                 *       color: '#fff'
                 *     }, {
                 *       width: '200px',
                 *       opacity: 1,
                 *       color: '#000'
                 *     }, 0.5);
                 *
                 *     console.log(interpolatedValues);
                 *     // {opacity: 0.5, width: "150px", color: "rgb(127,127,127)"}
                 *
                 * @static
                 * @method interpolate
                 * @param {Object} from The starting values to tween from.
                 * @param {Object} targetState The ending values to tween to.
                 * @param {number} position The normalized position value (between `0.0` and
                 * `1.0`) to interpolate the values between `from` and `to` for.  `from`
                 * represents `0` and `to` represents `1`.
                 * @param {Object.<string|Function>|string|Function} easing The easing
                 * curve(s) to calculate the midpoint against.  You can reference any easing
                 * function attached to `Tweenable.prototype.formula`, or provide the easing
                 * function(s) directly.  If omitted, this defaults to "linear".
                 * @param {number=} opt_delay Optional delay to pad the beginning of the
                 * interpolated tween with.  This increases the range of `position` from (`0`
                 * through `1`) to (`0` through `1 + opt_delay`).  So, a delay of `0.5` would
                 * increase all valid values of `position` to numbers between `0` and `1.5`.
                 * @return {Object}
                 */
                Tweenable.interpolate = function (
                    from, targetState, position, easing, opt_delay) {

                    var current = Tweenable.shallowCopy({}, from);
                    var delay = opt_delay || 0;
                    var easingObject = Tweenable.composeEasingObject(
                        from, easing || 'linear');

                    mockTweenable.set({});

                    // Alias and reuse the _filterArgs array instead of recreating it.
                    var filterArgs = mockTweenable._filterArgs;
                    filterArgs.length = 0;
                    filterArgs[0] = current;
                    filterArgs[1] = from;
                    filterArgs[2] = targetState;
                    filterArgs[3] = easingObject;

                    // Any defined value transformation must be applied
                    Tweenable.applyFilter(mockTweenable, 'tweenCreated');
                    Tweenable.applyFilter(mockTweenable, 'beforeTween');

                    var interpolatedValues = getInterpolatedValues(
                        from, current, targetState, position, easingObject, delay);

                    // Transform values back into their original format
                    Tweenable.applyFilter(mockTweenable, 'afterTween');

                    return interpolatedValues;
                };

            }());

            /**
             * This module adds string interpolation support to Shifty.
             *
             * The Token extension allows Shifty to tween numbers inside of strings.  Among
             * other things, this allows you to animate CSS properties.  For example, you
             * can do this:
             *
             *     var tweenable = new Tweenable();
             *     tweenable.tween({
             *       from: { transform: 'translateX(45px)' },
             *       to: { transform: 'translateX(90xp)' }
             *     });
             *
             * `translateX(45)` will be tweened to `translateX(90)`.  To demonstrate:
             *
             *     var tweenable = new Tweenable();
             *     tweenable.tween({
             *       from: { transform: 'translateX(45px)' },
             *       to: { transform: 'translateX(90px)' },
             *       step: function (state) {
             *         console.log(state.transform);
             *       }
             *     });
             *
             * The above snippet will log something like this in the console:
             *
             *     translateX(60.3px)
             *     ...
             *     translateX(76.05px)
             *     ...
             *     translateX(90px)
             *
             * Another use for this is animating colors:
             *
             *     var tweenable = new Tweenable();
             *     tweenable.tween({
             *       from: { color: 'rgb(0,255,0)' },
             *       to: { color: 'rgb(255,0,255)' },
             *       step: function (state) {
             *         console.log(state.color);
             *       }
             *     });
             *
             * The above snippet will log something like this:
             *
             *     rgb(84,170,84)
             *     ...
             *     rgb(170,84,170)
             *     ...
             *     rgb(255,0,255)
             *
             * This extension also supports hexadecimal colors, in both long (`#ff00ff`)
             * and short (`#f0f`) forms.  Be aware that hexadecimal input values will be
             * converted into the equivalent RGB output values.  This is done to optimize
             * for performance.
             *
             *     var tweenable = new Tweenable();
             *     tweenable.tween({
             *       from: { color: '#0f0' },
             *       to: { color: '#f0f' },
             *       step: function (state) {
             *         console.log(state.color);
             *       }
             *     });
             *
             * This snippet will generate the same output as the one before it because
             * equivalent values were supplied (just in hexadecimal form rather than RGB):
             *
             *     rgb(84,170,84)
             *     ...
             *     rgb(170,84,170)
             *     ...
             *     rgb(255,0,255)
             *
             * ## Easing support
             *
             * Easing works somewhat differently in the Token extension.  This is because
             * some CSS properties have multiple values in them, and you might need to
             * tween each value along its own easing curve.  A basic example:
             *
             *     var tweenable = new Tweenable();
             *     tweenable.tween({
             *       from: { transform: 'translateX(0px) translateY(0px)' },
             *       to: { transform:   'translateX(100px) translateY(100px)' },
             *       easing: { transform: 'easeInQuad' },
             *       step: function (state) {
             *         console.log(state.transform);
             *       }
             *     });
             *
             * The above snippet will create values like this:
             *
             *     translateX(11.56px) translateY(11.56px)
             *     ...
             *     translateX(46.24px) translateY(46.24px)
             *     ...
             *     translateX(100px) translateY(100px)
             *
             * In this case, the values for `translateX` and `translateY` are always the
             * same for each step of the tween, because they have the same start and end
             * points and both use the same easing curve.  We can also tween `translateX`
             * and `translateY` along independent curves:
             *
             *     var tweenable = new Tweenable();
             *     tweenable.tween({
             *       from: { transform: 'translateX(0px) translateY(0px)' },
             *       to: { transform:   'translateX(100px) translateY(100px)' },
             *       easing: { transform: 'easeInQuad bounce' },
             *       step: function (state) {
             *         console.log(state.transform);
             *       }
             *     });
             *
             * The above snippet will create values like this:
             *
             *     translateX(10.89px) translateY(82.35px)
             *     ...
             *     translateX(44.89px) translateY(86.73px)
             *     ...
             *     translateX(100px) translateY(100px)
             *
             * `translateX` and `translateY` are not in sync anymore, because `easeInQuad`
             * was specified for `translateX` and `bounce` for `translateY`.  Mixing and
             * matching easing curves can make for some interesting motion in your
             * animations.
             *
             * The order of the space-separated easing curves correspond the token values
             * they apply to.  If there are more token values than easing curves listed,
             * the last easing curve listed is used.
             * @submodule Tweenable.token
             */

// token function is defined above only so that dox-foundation sees it as
// documentation and renders it.  It is never used, and is optimized away at
// build time.

            ;(function (Tweenable) {

                /**
                 * @typedef {{
                 *   formatString: string
                 *   chunkNames: Array.<string>
                 * }}
                 * @private
                 */
                var formatManifest;

                // CONSTANTS

                var R_NUMBER_COMPONENT = /(\d|\-|\.)/;
                var R_FORMAT_CHUNKS = /([^\-0-9\.]+)/g;
                var R_UNFORMATTED_VALUES = /[0-9.\-]+/g;
                var R_RGB = new RegExp(
                    'rgb\\(' + R_UNFORMATTED_VALUES.source +
                    (/,\s*/.source) + R_UNFORMATTED_VALUES.source +
                    (/,\s*/.source) + R_UNFORMATTED_VALUES.source + '\\)', 'g');
                var R_RGB_PREFIX = /^.*\(/;
                var R_HEX = /#([0-9]|[a-f]){3,6}/gi;
                var VALUE_PLACEHOLDER = 'VAL';

                // HELPERS

                /**
                 * @param {Array.number} rawValues
                 * @param {string} prefix
                 *
                 * @return {Array.<string>}
                 * @private
                 */
                function getFormatChunksFrom (rawValues, prefix) {
                    var accumulator = [];

                    var rawValuesLength = rawValues.length;
                    var i;

                    for (i = 0; i < rawValuesLength; i++) {
                        accumulator.push('_' + prefix + '_' + i);
                    }

                    return accumulator;
                }

                /**
                 * @param {string} formattedString
                 *
                 * @return {string}
                 * @private
                 */
                function getFormatStringFrom (formattedString) {
                    var chunks = formattedString.match(R_FORMAT_CHUNKS);

                    if (!chunks) {
                        // chunks will be null if there were no tokens to parse in
                        // formattedString (for example, if formattedString is '2').  Coerce
                        // chunks to be useful here.
                        chunks = ['', ''];

                        // If there is only one chunk, assume that the string is a number
                        // followed by a token...
                        // NOTE: This may be an unwise assumption.
                    } else if (chunks.length === 1 ||
                        // ...or if the string starts with a number component (".", "-", or a
                        // digit)...
                        formattedString.charAt(0).match(R_NUMBER_COMPONENT)) {
                        // ...prepend an empty string here to make sure that the formatted number
                        // is properly replaced by VALUE_PLACEHOLDER
                        chunks.unshift('');
                    }

                    return chunks.join(VALUE_PLACEHOLDER);
                }

                /**
                 * Convert all hex color values within a string to an rgb string.
                 *
                 * @param {Object} stateObject
                 *
                 * @return {Object} The modified obj
                 * @private
                 */
                function sanitizeObjectForHexProps (stateObject) {
                    Tweenable.each(stateObject, function (prop) {
                        var currentProp = stateObject[prop];

                        if (typeof currentProp === 'string' && currentProp.match(R_HEX)) {
                            stateObject[prop] = sanitizeHexChunksToRGB(currentProp);
                        }
                    });
                }

                /**
                 * @param {string} str
                 *
                 * @return {string}
                 * @private
                 */
                function  sanitizeHexChunksToRGB (str) {
                    return filterStringChunks(R_HEX, str, convertHexToRGB);
                }

                /**
                 * @param {string} hexString
                 *
                 * @return {string}
                 * @private
                 */
                function convertHexToRGB (hexString) {
                    var rgbArr = hexToRGBArray(hexString);
                    return 'rgb(' + rgbArr[0] + ',' + rgbArr[1] + ',' + rgbArr[2] + ')';
                }

                var hexToRGBArray_returnArray = [];
                /**
                 * Convert a hexadecimal string to an array with three items, one each for
                 * the red, blue, and green decimal values.
                 *
                 * @param {string} hex A hexadecimal string.
                 *
                 * @returns {Array.<number>} The converted Array of RGB values if `hex` is a
                 * valid string, or an Array of three 0's.
                 * @private
                 */
                function hexToRGBArray (hex) {

                    hex = hex.replace(/#/, '');

                    // If the string is a shorthand three digit hex notation, normalize it to
                    // the standard six digit notation
                    if (hex.length === 3) {
                        hex = hex.split('');
                        hex = hex[0] + hex[0] + hex[1] + hex[1] + hex[2] + hex[2];
                    }

                    hexToRGBArray_returnArray[0] = hexToDec(hex.substr(0, 2));
                    hexToRGBArray_returnArray[1] = hexToDec(hex.substr(2, 2));
                    hexToRGBArray_returnArray[2] = hexToDec(hex.substr(4, 2));

                    return hexToRGBArray_returnArray;
                }

                /**
                 * Convert a base-16 number to base-10.
                 *
                 * @param {Number|String} hex The value to convert
                 *
                 * @returns {Number} The base-10 equivalent of `hex`.
                 * @private
                 */
                function hexToDec (hex) {
                    return parseInt(hex, 16);
                }

                /**
                 * Runs a filter operation on all chunks of a string that match a RegExp
                 *
                 * @param {RegExp} pattern
                 * @param {string} unfilteredString
                 * @param {function(string)} filter
                 *
                 * @return {string}
                 * @private
                 */
                function filterStringChunks (pattern, unfilteredString, filter) {
                    var pattenMatches = unfilteredString.match(pattern);
                    var filteredString = unfilteredString.replace(pattern, VALUE_PLACEHOLDER);

                    if (pattenMatches) {
                        var pattenMatchesLength = pattenMatches.length;
                        var currentChunk;

                        for (var i = 0; i < pattenMatchesLength; i++) {
                            currentChunk = pattenMatches.shift();
                            filteredString = filteredString.replace(
                                VALUE_PLACEHOLDER, filter(currentChunk));
                        }
                    }

                    return filteredString;
                }

                /**
                 * Check for floating point values within rgb strings and rounds them.
                 *
                 * @param {string} formattedString
                 *
                 * @return {string}
                 * @private
                 */
                function sanitizeRGBChunks (formattedString) {
                    return filterStringChunks(R_RGB, formattedString, sanitizeRGBChunk);
                }

                /**
                 * @param {string} rgbChunk
                 *
                 * @return {string}
                 * @private
                 */
                function sanitizeRGBChunk (rgbChunk) {
                    var numbers = rgbChunk.match(R_UNFORMATTED_VALUES);
                    var numbersLength = numbers.length;
                    var sanitizedString = rgbChunk.match(R_RGB_PREFIX)[0];

                    for (var i = 0; i < numbersLength; i++) {
                        sanitizedString += parseInt(numbers[i], 10) + ',';
                    }

                    sanitizedString = sanitizedString.slice(0, -1) + ')';

                    return sanitizedString;
                }

                /**
                 * @param {Object} stateObject
                 *
                 * @return {Object} An Object of formatManifests that correspond to
                 * the string properties of stateObject
                 * @private
                 */
                function getFormatManifests (stateObject) {
                    var manifestAccumulator = {};

                    Tweenable.each(stateObject, function (prop) {
                        var currentProp = stateObject[prop];

                        if (typeof currentProp === 'string') {
                            var rawValues = getValuesFrom(currentProp);

                            manifestAccumulator[prop] = {
                                'formatString': getFormatStringFrom(currentProp)
                                ,'chunkNames': getFormatChunksFrom(rawValues, prop)
                            };
                        }
                    });

                    return manifestAccumulator;
                }

                /**
                 * @param {Object} stateObject
                 * @param {Object} formatManifests
                 * @private
                 */
                function expandFormattedProperties (stateObject, formatManifests) {
                    Tweenable.each(formatManifests, function (prop) {
                        var currentProp = stateObject[prop];
                        var rawValues = getValuesFrom(currentProp);
                        var rawValuesLength = rawValues.length;

                        for (var i = 0; i < rawValuesLength; i++) {
                            stateObject[formatManifests[prop].chunkNames[i]] = +rawValues[i];
                        }

                        delete stateObject[prop];
                    });
                }

                /**
                 * @param {Object} stateObject
                 * @param {Object} formatManifests
                 * @private
                 */
                function collapseFormattedProperties (stateObject, formatManifests) {
                    Tweenable.each(formatManifests, function (prop) {
                        var currentProp = stateObject[prop];
                        var formatChunks = extractPropertyChunks(
                            stateObject, formatManifests[prop].chunkNames);
                        var valuesList = getValuesList(
                            formatChunks, formatManifests[prop].chunkNames);
                        currentProp = getFormattedValues(
                            formatManifests[prop].formatString, valuesList);
                        stateObject[prop] = sanitizeRGBChunks(currentProp);
                    });
                }

                /**
                 * @param {Object} stateObject
                 * @param {Array.<string>} chunkNames
                 *
                 * @return {Object} The extracted value chunks.
                 * @private
                 */
                function extractPropertyChunks (stateObject, chunkNames) {
                    var extractedValues = {};
                    var currentChunkName, chunkNamesLength = chunkNames.length;

                    for (var i = 0; i < chunkNamesLength; i++) {
                        currentChunkName = chunkNames[i];
                        extractedValues[currentChunkName] = stateObject[currentChunkName];
                        delete stateObject[currentChunkName];
                    }

                    return extractedValues;
                }

                var getValuesList_accumulator = [];
                /**
                 * @param {Object} stateObject
                 * @param {Array.<string>} chunkNames
                 *
                 * @return {Array.<number>}
                 * @private
                 */
                function getValuesList (stateObject, chunkNames) {
                    getValuesList_accumulator.length = 0;
                    var chunkNamesLength = chunkNames.length;

                    for (var i = 0; i < chunkNamesLength; i++) {
                        getValuesList_accumulator.push(stateObject[chunkNames[i]]);
                    }

                    return getValuesList_accumulator;
                }

                /**
                 * @param {string} formatString
                 * @param {Array.<number>} rawValues
                 *
                 * @return {string}
                 * @private
                 */
                function getFormattedValues (formatString, rawValues) {
                    var formattedValueString = formatString;
                    var rawValuesLength = rawValues.length;

                    for (var i = 0; i < rawValuesLength; i++) {
                        formattedValueString = formattedValueString.replace(
                            VALUE_PLACEHOLDER, +rawValues[i].toFixed(4));
                    }

                    return formattedValueString;
                }

                /**
                 * Note: It's the duty of the caller to convert the Array elements of the
                 * return value into numbers.  This is a performance optimization.
                 *
                 * @param {string} formattedString
                 *
                 * @return {Array.<string>|null}
                 * @private
                 */
                function getValuesFrom (formattedString) {
                    return formattedString.match(R_UNFORMATTED_VALUES);
                }

                /**
                 * @param {Object} easingObject
                 * @param {Object} tokenData
                 * @private
                 */
                function expandEasingObject (easingObject, tokenData) {
                    Tweenable.each(tokenData, function (prop) {
                        var currentProp = tokenData[prop];
                        var chunkNames = currentProp.chunkNames;
                        var chunkLength = chunkNames.length;

                        var easing = easingObject[prop];
                        var i;

                        if (typeof easing === 'string') {
                            var easingChunks = easing.split(' ');
                            var lastEasingChunk = easingChunks[easingChunks.length - 1];

                            for (i = 0; i < chunkLength; i++) {
                                easingObject[chunkNames[i]] = easingChunks[i] || lastEasingChunk;
                            }

                        } else {
                            for (i = 0; i < chunkLength; i++) {
                                easingObject[chunkNames[i]] = easing;
                            }
                        }

                        delete easingObject[prop];
                    });
                }

                /**
                 * @param {Object} easingObject
                 * @param {Object} tokenData
                 * @private
                 */
                function collapseEasingObject (easingObject, tokenData) {
                    Tweenable.each(tokenData, function (prop) {
                        var currentProp = tokenData[prop];
                        var chunkNames = currentProp.chunkNames;
                        var chunkLength = chunkNames.length;

                        var firstEasing = easingObject[chunkNames[0]];
                        var typeofEasings = typeof firstEasing;

                        if (typeofEasings === 'string') {
                            var composedEasingString = '';

                            for (var i = 0; i < chunkLength; i++) {
                                composedEasingString += ' ' + easingObject[chunkNames[i]];
                                delete easingObject[chunkNames[i]];
                            }

                            easingObject[prop] = composedEasingString.substr(1);
                        } else {
                            easingObject[prop] = firstEasing;
                        }
                    });
                }

                Tweenable.prototype.filter.token = {
                    'tweenCreated': function (currentState, fromState, toState, easingObject) {
                        sanitizeObjectForHexProps(currentState);
                        sanitizeObjectForHexProps(fromState);
                        sanitizeObjectForHexProps(toState);
                        this._tokenData = getFormatManifests(currentState);
                    },

                    'beforeTween': function (currentState, fromState, toState, easingObject) {
                        expandEasingObject(easingObject, this._tokenData);
                        expandFormattedProperties(currentState, this._tokenData);
                        expandFormattedProperties(fromState, this._tokenData);
                        expandFormattedProperties(toState, this._tokenData);
                    },

                    'afterTween': function (currentState, fromState, toState, easingObject) {
                        collapseFormattedProperties(currentState, this._tokenData);
                        collapseFormattedProperties(fromState, this._tokenData);
                        collapseFormattedProperties(toState, this._tokenData);
                        collapseEasingObject(easingObject, this._tokenData);
                    }
                };

            } (Tweenable));

        }).call(null);

    },{}],2:[function(require,module,exports){
// Circle shaped progress bar

        var Shape = require('./shape');
        var utils = require('./utils');

        var Circle = function Circle(container, options) {
            // Use two arcs to form a circle
            // See this answer http://stackoverflow.com/a/10477334/1446092
            this._pathTemplate =
                'M 50,50 m 0,-{radius}' +
                ' a {radius},{radius} 0 1 1 0,{2radius}' +
                ' a {radius},{radius} 0 1 1 0,-{2radius}';

            this.containerAspectRatio = 1;

            Shape.apply(this, arguments);
        };

        Circle.prototype = new Shape();
        Circle.prototype.constructor = Circle;

        Circle.prototype._pathString = function _pathString(opts) {
            var widthOfWider = opts.strokeWidth;
            if (opts.trailWidth && opts.trailWidth > opts.strokeWidth) {
                widthOfWider = opts.trailWidth;
            }

            var r = 50 - widthOfWider / 2;

            return utils.render(this._pathTemplate, {
                radius: r,
                '2radius': r * 2
            });
        };

        Circle.prototype._trailString = function _trailString(opts) {
            return this._pathString(opts);
        };

        module.exports = Circle;

    },{"./shape":7,"./utils":9}],3:[function(require,module,exports){
// Line shaped progress bar

        var Shape = require('./shape');
        var utils = require('./utils');

        var Line = function Line(container, options) {
            this._pathTemplate = 'M 0,{center} L 100,{center}';
            Shape.apply(this, arguments);
        };

        Line.prototype = new Shape();
        Line.prototype.constructor = Line;

        Line.prototype._initializeSvg = function _initializeSvg(svg, opts) {
            svg.setAttribute('viewBox', '0 0 100 ' + opts.strokeWidth);
            svg.setAttribute('preserveAspectRatio', 'none');
        };

        Line.prototype._pathString = function _pathString(opts) {
            return utils.render(this._pathTemplate, {
                center: opts.strokeWidth / 2
            });
        };

        Line.prototype._trailString = function _trailString(opts) {
            return this._pathString(opts);
        };

        module.exports = Line;

    },{"./shape":7,"./utils":9}],4:[function(require,module,exports){
        module.exports = {
            // Higher level API, different shaped progress bars
            Line: require('./line'),
            Circle: require('./circle'),
            SemiCircle: require('./semicircle'),
            Square: require('./square'),

            // Lower level API to use any SVG path
            Path: require('./path'),

            // Base-class for creating new custom shapes
            // to be in line with the API of built-in shapes
            // Undocumented.
            Shape: require('./shape'),

            // Internal utils, undocumented.
            utils: require('./utils')
        };

    },{"./circle":2,"./line":3,"./path":5,"./semicircle":6,"./shape":7,"./square":8,"./utils":9}],5:[function(require,module,exports){
// Lower level API to animate any kind of svg path

        var Tweenable = require('shifty');
        var utils = require('./utils');

        var EASING_ALIASES = {
            easeIn: 'easeInCubic',
            easeOut: 'easeOutCubic',
            easeInOut: 'easeInOutCubic'
        };

        var Path = function Path(path, opts) {
            // Throw a better error if not initialized with `new` keyword
            if (!(this instanceof Path)) {
                throw new Error('Constructor was called without new keyword');
            }

            // Default parameters for animation
            opts = utils.extend({
                duration: 800,
                easing: 'linear',
                from: {},
                to: {},
                step: function() {}
            }, opts);

            var element;
            if (utils.isString(path)) {
                element = document.querySelector(path);
            } else {
                element = path;
            }

            // Reveal .path as public attribute
            this.path = element;
            this._opts = opts;
            this._tweenable = null;

            // Set up the starting positions
            var length = this.path.getTotalLength();
            this.path.style.strokeDasharray = length + ' ' + length;
            this.set(0);
        };

        Path.prototype.value = function value() {
            var offset = this._getComputedDashOffset();
            var length = this.path.getTotalLength();

            var progress = 1 - offset / length;
            // Round number to prevent returning very small number like 1e-30, which
            // is practically 0
            return parseFloat(progress.toFixed(6), 10);
        };

        Path.prototype.set = function set(progress) {
            this.stop();

            this.path.style.strokeDashoffset = this._progressToOffset(progress);

            var step = this._opts.step;
            if (utils.isFunction(step)) {
                var easing = this._easing(this._opts.easing);
                var values = this._calculateTo(progress, easing);
                var reference = this._opts.shape || this;
                step(values, reference, this._opts.attachment);
            }
        };

        Path.prototype.stop = function stop() {
            this._stopTween();
            this.path.style.strokeDashoffset = this._getComputedDashOffset();
        };

// Method introduced here:
// http://jakearchibald.com/2013/animated-line-drawing-svg/
        Path.prototype.animate = function animate(progress, opts, cb) {
            opts = opts || {};

            if (utils.isFunction(opts)) {
                cb = opts;
                opts = {};
            }

            var passedOpts = utils.extend({}, opts);

            // Copy default opts to new object so defaults are not modified
            var defaultOpts = utils.extend({}, this._opts);
            opts = utils.extend(defaultOpts, opts);

            var shiftyEasing = this._easing(opts.easing);
            var values = this._resolveFromAndTo(progress, shiftyEasing, passedOpts);

            this.stop();

            // Trigger a layout so styles are calculated & the browser
            // picks up the starting position before animating
            this.path.getBoundingClientRect();

            var offset = this._getComputedDashOffset();
            var newOffset = this._progressToOffset(progress);

            var self = this;
            this._tweenable = new Tweenable();
            this._tweenable.tween({
                from: utils.extend({ offset: offset }, values.from),
                to: utils.extend({ offset: newOffset }, values.to),
                duration: opts.duration,
                easing: shiftyEasing,
                step: function(state) {
                    self.path.style.strokeDashoffset = state.offset;
                    var reference = opts.shape || self;
                    opts.step(state, reference, opts.attachment);
                },
                finish: function(state) {
                    if (utils.isFunction(cb)) {
                        cb();
                    }
                }
            });
        };

        Path.prototype._getComputedDashOffset = function _getComputedDashOffset() {
            var computedStyle = window.getComputedStyle(this.path, null);
            return parseFloat(computedStyle.getPropertyValue('stroke-dashoffset'), 10);
        };

        Path.prototype._progressToOffset = function _progressToOffset(progress) {
            var length = this.path.getTotalLength();
            return length - progress * length;
        };

// Resolves from and to values for animation.
        Path.prototype._resolveFromAndTo = function _resolveFromAndTo(progress, easing, opts) {
            if (opts.from && opts.to) {
                return {
                    from: opts.from,
                    to: opts.to
                };
            }

            return {
                from: this._calculateFrom(easing),
                to: this._calculateTo(progress, easing)
            };
        };

// Calculate `from` values from options passed at initialization
        Path.prototype._calculateFrom = function _calculateFrom(easing) {
            return Tweenable.interpolate(this._opts.from, this._opts.to, this.value(), easing);
        };

// Calculate `to` values from options passed at initialization
        Path.prototype._calculateTo = function _calculateTo(progress, easing) {
            return Tweenable.interpolate(this._opts.from, this._opts.to, progress, easing);
        };

        Path.prototype._stopTween = function _stopTween() {
            if (this._tweenable !== null) {
                this._tweenable.stop();
                this._tweenable = null;
            }
        };

        Path.prototype._easing = function _easing(easing) {
            if (EASING_ALIASES.hasOwnProperty(easing)) {
                return EASING_ALIASES[easing];
            }

            return easing;
        };

        module.exports = Path;

    },{"./utils":9,"shifty":1}],6:[function(require,module,exports){
// Semi-SemiCircle shaped progress bar

        var Shape = require('./shape');
        var Circle = require('./circle');
        var utils = require('./utils');

        var SemiCircle = function SemiCircle(container, options) {
            // Use one arc to form a SemiCircle
            // See this answer http://stackoverflow.com/a/10477334/1446092
            this._pathTemplate =
                'M 50,50 m -{radius},0' +
                ' a {radius},{radius} 0 1 1 {2radius},0';

            this.containerAspectRatio = 2;

            Shape.apply(this, arguments);
        };

        SemiCircle.prototype = new Shape();
        SemiCircle.prototype.constructor = SemiCircle;

        SemiCircle.prototype._initializeSvg = function _initializeSvg(svg, opts) {
            svg.setAttribute('viewBox', '0 0 100 50');
        };

        SemiCircle.prototype._initializeTextContainer = function _initializeTextContainer(
            opts,
            container,
            textContainer
        ) {
            if (opts.text.style) {
                // Reset top style
                textContainer.style.top = 'auto';
                textContainer.style.bottom = '0';

                if (opts.text.alignToBottom) {
                    utils.setStyle(textContainer, 'transform', 'translate(-50%, 0)');
                } else {
                    utils.setStyle(textContainer, 'transform', 'translate(-50%, 50%)');
                }
            }
        };

// Share functionality with Circle, just have different path
        SemiCircle.prototype._pathString = Circle.prototype._pathString;
        SemiCircle.prototype._trailString = Circle.prototype._trailString;

        module.exports = SemiCircle;

    },{"./circle":2,"./shape":7,"./utils":9}],7:[function(require,module,exports){
// Base object for different progress bar shapes

        var Path = require('./path');
        var utils = require('./utils');

        var DESTROYED_ERROR = 'Object is destroyed';

        var Shape = function Shape(container, opts) {
            // Throw a better error if progress bars are not initialized with `new`
            // keyword
            if (!(this instanceof Shape)) {
                throw new Error('Constructor was called without new keyword');
            }

            // Prevent calling constructor without parameters so inheritance
            // works correctly. To understand, this is how Shape is inherited:
            //
            //   Line.prototype = new Shape();
            //
            // We just want to set the prototype for Line.
            if (arguments.length === 0) {
                return;
            }

            // Default parameters for progress bar creation
            this._opts = utils.extend({
                color: '#555',
                strokeWidth: 1.0,
                trailColor: null,
                trailWidth: null,
                fill: null,
                text: {
                    style: {
                        color: null,
                        position: 'absolute',
                        left: '50%',
                        top: '50%',
                        padding: 0,
                        margin: 0,
                        transform: {
                            prefix: true,
                            value: 'translate(-50%, -50%)'
                        }
                    },
                    autoStyleContainer: true,
                    alignToBottom: true,
                    value: null,
                    className: 'progressbar-text'
                },
                svgStyle: {
                    display: 'block',
                    width: '100%'
                },
                warnings: false
            }, opts, true);  // Use recursive extend

            // If user specifies e.g. svgStyle or text style, the whole object
            // should replace the defaults to make working with styles easier
            if (utils.isObject(opts) && opts.svgStyle !== undefined) {
                this._opts.svgStyle = opts.svgStyle;
            }
            if (utils.isObject(opts) && utils.isObject(opts.text) && opts.text.style !== undefined) {
                this._opts.text.style = opts.text.style;
            }

            var svgView = this._createSvgView(this._opts);

            var element;
            if (utils.isString(container)) {
                element = document.querySelector(container);
            } else {
                element = container;
            }

            if (!element) {
                throw new Error('Container does not exist: ' + container);
            }

            this._container = element;
            this._container.appendChild(svgView.svg);
            if (this._opts.warnings) {
                this._warnContainerAspectRatio(this._container);
            }

            if (this._opts.svgStyle) {
                utils.setStyles(svgView.svg, this._opts.svgStyle);
            }

            // Expose public attributes before Path initialization
            this.svg = svgView.svg;
            this.path = svgView.path;
            this.trail = svgView.trail;
            this.text = null;

            var newOpts = utils.extend({
                attachment: undefined,
                shape: this
            }, this._opts);
            this._progressPath = new Path(svgView.path, newOpts);

            if (utils.isObject(this._opts.text) && this._opts.text.value !== null) {
                this.setText(this._opts.text.value);
            }
        };

        Shape.prototype.animate = function animate(progress, opts, cb) {
            if (this._progressPath === null) {
                throw new Error(DESTROYED_ERROR);
            }

            this._progressPath.animate(progress, opts, cb);
        };

        Shape.prototype.stop = function stop() {
            if (this._progressPath === null) {
                throw new Error(DESTROYED_ERROR);
            }

            // Don't crash if stop is called inside step function
            if (this._progressPath === undefined) {
                return;
            }

            this._progressPath.stop();
        };

        Shape.prototype.destroy = function destroy() {
            if (this._progressPath === null) {
                throw new Error(DESTROYED_ERROR);
            }

            this.stop();
            this.svg.parentNode.removeChild(this.svg);
            this.svg = null;
            this.path = null;
            this.trail = null;
            this._progressPath = null;

            if (this.text !== null) {
                this.text.parentNode.removeChild(this.text);
                this.text = null;
            }
        };

        Shape.prototype.set = function set(progress) {
            if (this._progressPath === null) {
                throw new Error(DESTROYED_ERROR);
            }

            this._progressPath.set(progress);
        };

        Shape.prototype.value = function value() {
            if (this._progressPath === null) {
                throw new Error(DESTROYED_ERROR);
            }

            if (this._progressPath === undefined) {
                return 0;
            }

            return this._progressPath.value();
        };

        Shape.prototype.setText = function setText(newText) {
            if (this._progressPath === null) {
                throw new Error(DESTROYED_ERROR);
            }

            if (this.text === null) {
                // Create new text node
                this.text = this._createTextContainer(this._opts, this._container);
                this._container.appendChild(this.text);
            }

            // Remove previous text and add new
            if (utils.isObject(newText)) {
                utils.removeChildren(this.text);
                this.text.appendChild(newText);
            } else {
                this.text.innerHTML = newText;
            }
        };

        Shape.prototype._createSvgView = function _createSvgView(opts) {
            var svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            this._initializeSvg(svg, opts);

            var trailPath = null;
            // Each option listed in the if condition are 'triggers' for creating
            // the trail path
            if (opts.trailColor || opts.trailWidth) {
                trailPath = this._createTrail(opts);
                svg.appendChild(trailPath);
            }

            var path = this._createPath(opts);
            svg.appendChild(path);

            return {
                svg: svg,
                path: path,
                trail: trailPath
            };
        };

        Shape.prototype._initializeSvg = function _initializeSvg(svg, opts) {
            svg.setAttribute('viewBox', '0 0 100 100');
        };

        Shape.prototype._createPath = function _createPath(opts) {
            var pathString = this._pathString(opts);
            return this._createPathElement(pathString, opts);
        };

        Shape.prototype._createTrail = function _createTrail(opts) {
            // Create path string with original passed options
            var pathString = this._trailString(opts);

            // Prevent modifying original
            var newOpts = utils.extend({}, opts);

            // Defaults for parameters which modify trail path
            if (!newOpts.trailColor) {
                newOpts.trailColor = '#eee';
            }
            if (!newOpts.trailWidth) {
                newOpts.trailWidth = newOpts.strokeWidth;
            }

            newOpts.color = newOpts.trailColor;
            newOpts.strokeWidth = newOpts.trailWidth;

            // When trail path is set, fill must be set for it instead of the
            // actual path to prevent trail stroke from clipping
            newOpts.fill = null;

            return this._createPathElement(pathString, newOpts);
        };

        Shape.prototype._createPathElement = function _createPathElement(pathString, opts) {
            var path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            path.setAttribute('d', pathString);
            path.setAttribute('stroke', opts.color);
            path.setAttribute('stroke-width', opts.strokeWidth);

            if (opts.fill) {
                path.setAttribute('fill', opts.fill);
            } else {
                path.setAttribute('fill-opacity', '0');
            }

            return path;
        };

        Shape.prototype._createTextContainer = function _createTextContainer(opts, container) {
            var textContainer = document.createElement('div');
            textContainer.className = opts.text.className;

            var textStyle = opts.text.style;
            if (textStyle) {
                if (opts.text.autoStyleContainer) {
                    container.style.position = 'relative';
                }

                utils.setStyles(textContainer, textStyle);
                // Default text color to progress bar's color
                if (!textStyle.color) {
                    textContainer.style.color = opts.color;
                }
            }

            this._initializeTextContainer(opts, container, textContainer);
            return textContainer;
        };

// Give custom shapes possibility to modify text element
        Shape.prototype._initializeTextContainer = function(opts, container, element) {
            // By default, no-op
            // Custom shapes should respect API options, such as text.style
        };

        Shape.prototype._pathString = function _pathString(opts) {
            throw new Error('Override this function for each progress bar');
        };

        Shape.prototype._trailString = function _trailString(opts) {
            throw new Error('Override this function for each progress bar');
        };

        Shape.prototype._warnContainerAspectRatio = function _warnContainerAspectRatio(container) {
            if (!this.containerAspectRatio) {
                return;
            }

            var computedStyle = window.getComputedStyle(container, null);
            var width = parseFloat(computedStyle.getPropertyValue('width'), 10);
            var height = parseFloat(computedStyle.getPropertyValue('height'), 10);
            if (!utils.floatEquals(this.containerAspectRatio, width / height)) {
                console.warn(
                    'Incorrect aspect ratio of container',
                    '#' + container.id,
                    'detected:',
                    computedStyle.getPropertyValue('width') + '(width)',
                    '/',
                    computedStyle.getPropertyValue('height') + '(height)',
                    '=',
                    width / height
                );

                console.warn(
                    'Aspect ratio of should be',
                    this.containerAspectRatio
                );
            }
        };

        module.exports = Shape;

    },{"./path":5,"./utils":9}],8:[function(require,module,exports){
// Square shaped progress bar
// Note: Square is not core part of API anymore. It's left here
//       for reference. square is not included to the progressbar
//       build anymore

        var Shape = require('./shape');
        var utils = require('./utils');

        var Square = function Square(container, options) {
            this._pathTemplate =
                'M 0,{halfOfStrokeWidth}' +
                ' L {width},{halfOfStrokeWidth}' +
                ' L {width},{width}' +
                ' L {halfOfStrokeWidth},{width}' +
                ' L {halfOfStrokeWidth},{strokeWidth}';

            this._trailTemplate =
                'M {startMargin},{halfOfStrokeWidth}' +
                ' L {width},{halfOfStrokeWidth}' +
                ' L {width},{width}' +
                ' L {halfOfStrokeWidth},{width}' +
                ' L {halfOfStrokeWidth},{halfOfStrokeWidth}';

            Shape.apply(this, arguments);
        };

        Square.prototype = new Shape();
        Square.prototype.constructor = Square;

        Square.prototype._pathString = function _pathString(opts) {
            var w = 100 - opts.strokeWidth / 2;

            return utils.render(this._pathTemplate, {
                width: w,
                strokeWidth: opts.strokeWidth,
                halfOfStrokeWidth: opts.strokeWidth / 2
            });
        };

        Square.prototype._trailString = function _trailString(opts) {
            var w = 100 - opts.strokeWidth / 2;

            return utils.render(this._trailTemplate, {
                width: w,
                strokeWidth: opts.strokeWidth,
                halfOfStrokeWidth: opts.strokeWidth / 2,
                startMargin: opts.strokeWidth / 2 - opts.trailWidth / 2
            });
        };

        module.exports = Square;

    },{"./shape":7,"./utils":9}],9:[function(require,module,exports){
// Utility functions

        var PREFIXES = 'Webkit Moz O ms'.split(' ');
        var FLOAT_COMPARISON_EPSILON = 0.001;

// Copy all attributes from source object to destination object.
// destination object is mutated.
        function extend(destination, source, recursive) {
            destination = destination || {};
            source = source || {};
            recursive = recursive || false;

            for (var attrName in source) {
                if (source.hasOwnProperty(attrName)) {
                    var destVal = destination[attrName];
                    var sourceVal = source[attrName];
                    if (recursive && isObject(destVal) && isObject(sourceVal)) {
                        destination[attrName] = extend(destVal, sourceVal, recursive);
                    } else {
                        destination[attrName] = sourceVal;
                    }
                }
            }

            return destination;
        }

// Renders templates with given variables. Variables must be surrounded with
// braces without any spaces, e.g. {variable}
// All instances of variable placeholders will be replaced with given content
// Example:
// render('Hello, {message}!', {message: 'world'})
        function render(template, vars) {
            var rendered = template;

            for (var key in vars) {
                if (vars.hasOwnProperty(key)) {
                    var val = vars[key];
                    var regExpString = '\\{' + key + '\\}';
                    var regExp = new RegExp(regExpString, 'g');

                    rendered = rendered.replace(regExp, val);
                }
            }

            return rendered;
        }

        function setStyle(element, style, value) {
            var elStyle = element.style;  // cache for performance

            for (var i = 0; i < PREFIXES.length; ++i) {
                var prefix = PREFIXES[i];
                elStyle[prefix + capitalize(style)] = value;
            }

            elStyle[style] = value;
        }

        function setStyles(element, styles) {
            forEachObject(styles, function(styleValue, styleName) {
                // Allow disabling some individual styles by setting them
                // to null or undefined
                if (styleValue === null || styleValue === undefined) {
                    return;
                }

                // If style's value is {prefix: true, value: '50%'},
                // Set also browser prefixed styles
                if (isObject(styleValue) && styleValue.prefix === true) {
                    setStyle(element, styleName, styleValue.value);
                } else {
                    element.style[styleName] = styleValue;
                }
            });
        }

        function capitalize(text) {
            return text.charAt(0).toUpperCase() + text.slice(1);
        }

        function isString(obj) {
            return typeof obj === 'string' || obj instanceof String;
        }

        function isFunction(obj) {
            return typeof obj === 'function';
        }

        function isArray(obj) {
            return Object.prototype.toString.call(obj) === '[object Array]';
        }

// Returns true if `obj` is object as in {a: 1, b: 2}, not if it's function or
// array
        function isObject(obj) {
            if (isArray(obj)) {
                return false;
            }

            var type = typeof obj;
            return type === 'object' && !!obj;
        }

        function forEachObject(object, callback) {
            for (var key in object) {
                if (object.hasOwnProperty(key)) {
                    var val = object[key];
                    callback(val, key);
                }
            }
        }

        function floatEquals(a, b) {
            return Math.abs(a - b) < FLOAT_COMPARISON_EPSILON;
        }

// https://coderwall.com/p/nygghw/don-t-use-innerhtml-to-empty-dom-elements
        function removeChildren(el) {
            while (el.firstChild) {
                el.removeChild(el.firstChild);
            }
        }

        module.exports = {
            extend: extend,
            render: render,
            setStyle: setStyle,
            setStyles: setStyles,
            capitalize: capitalize,
            isString: isString,
            isFunction: isFunction,
            isObject: isObject,
            forEachObject: forEachObject,
            floatEquals: floatEquals,
            removeChildren: removeChildren
        };

    },{}]},{},[4])(4)
});

var SettingsC = UCPMC.extend({
    init: function() {
        this.language = language;
        this.timezone = timezone;
        this.datetimeformat = datetimeformat;
        this.timeformat = timeformat;
        this.dateformat = dateformat;
    },
    poll: function(data) {
        //console.log(data)
    },
    showMessage: function(message, type, timeout) {
        type = typeof type !== "undefined" ? type : "info";
        timeout = typeof timeout !== "undefined" ? timeout : 2000;
        $("#settings-message").removeClass().addClass("alert alert-"+type+" text-center").text(message);
        setTimeout(function() {
            $("#settings-message").addClass("hidden");
        }, timeout);
    },
    updateTimeDisplay: function() {
        if(language === "") {
            language = this.language;
            Cookies.set("lang", language, { path: window.location.pathname.replace(/\/?$/,'') });
        }
        if(timezone === "") {
            timezone = this.timezone;
        }
        moment.locale(language);

        var userdtf = $("#datetimeformat").val();
        userdtf = (userdtf !== "") ? userdtf : datetimeformat;
        $("#datetimeformat-now").text(moment().tz(timezone).format(userdtf));

        var usertf = $("#timeformat").val();
        usertf = (usertf !== "") ? usertf : timeformat;
        $("#timeformat-now").text(moment().tz(timezone).format(usertf));

        var userdf = $("#dateformat").val();
        userdf = (userdf !== "") ? userdf : dateformat;
        $("#dateformat-now").text(moment().tz(timezone).format(userdf));
    },
    displaySimpleWidgetSettings: function(widget_id) {
        var $this = this;
        setInterval(function() {
            $this.updateTimeDisplay();
        },1000);
        $("#datetimeformat, #timeformat, #dateformat").keydown(function() {
            $this.updateTimeDisplay();
        });
        $("#browserlang").on("click", function(e){
            e.preventDefault();
            var bl =  browserLocale();
            bl = bl.replace("-","_");
            if(typeof bl === 'undefined'){
                UCP.showAlert(_("The Browser Language could not be determined"),"warning");
            }else{
                $("#lang").multiselect('select', bl);
                $("#lang").multiselect('refresh');
                $("#lang").trigger("onchange",[$("#lang option:selected"), $("#lang option:selected").is(":checked")]);
            }
        });
        $("#systemlang").on("click", function(e){
            e.preventDefault();
            var sl = UIDEFAULTLANG;
            if(typeof sl === 'undefined'){
                UCP.showAlert(_("The PBX Language is not set"),"warning");
            }else{
                $("#lang").multiselect('select', sl);
                $("#lang").multiselect('refresh');
                $("#lang").trigger("onchange",[$("#lang option:selected"), $("#lang option:selected").is(":checked")]);
            }
        });
        $("#browsertz").on("click", function(e){
            e.preventDefault();
            var btz =  moment.tz.guess();
            if(typeof btz === 'undefined'){
                UCP.showAlert(_("The Browser Timezone could not be determined"),"warning");
            }else{
                $("#timezone").multiselect('select', btz);
                $("#timezone").multiselect('refresh');
                $("#timezone").trigger("onchange",[$("#timezone option:selected"), $("#timezone option:selected").is(":checked")]);
            }
        });
        $("#systemtz").on("click", function(e){
            e.preventDefault();
            var stz = PHPTIMEZONE;
            if(typeof stz === 'undefined'){
                UCP.showAlert(_("The PBX Timezone is not set"),"warning");
            }else{
                $("#timezone").multiselect('select', stz);
                $("#timezone").multiselect('refresh');
                $("#timezone").trigger("onchange",[$("#timezone option:selected"), $("#timezone option:selected").is(":checked")]);
            }
        });
        $("#timezone").on("onchange", function(el, option, checked) {
            $.post( "ajax.php?module=Settings&command=settings", { key: "timezone", value: option.val() }, function( data ) {
                if(data.status) {
                    timezone = option.val();
                    $this.updateTimeDisplay();
                    $this.showMessage(_("Success!"),"success");
                    UCP.showConfirm(_("UCP needs to reload, ok?"), 'warning', function() {
                        window.location.reload();
                    });
                } else {
                    $this.showMessage(data.message,"danger");
                }
            });
        });
        $("#lang").on("onchange", function(el, option, checked) {
            $.post( "ajax.php?module=Settings&command=settings", { key: "language", value: option.val() }, function( data ) {
                if(data.status) {
                    language = option.val();
                    $this.showMessage(_("Success!"),"success");
                    $this.updateTimeDisplay();
                    Cookies.set("lang", option.val(), { path: window.location.pathname.replace(/\/?$/,'') });
                    UCP.showConfirm(_("UCP needs to reload, ok?"), 'warning', function() {
                        window.location.reload();
                    });
                } else {
                    $this.showMessage(data.message,"danger");
                }
            });

        });
        if (Notify.isSupported()) {
            $("#ucp-settings .desktopnotifications-group").removeClass("hidden");
            $("#ucp-settings input[name=\"desktopnotifications\"]").prop("checked", UCP.notify);
            $("#ucp-settings input[name=\"desktopnotifications\"]").change(function() {
                if (!UCP.notify && $(this).is(":checked")) {
                    Notify.requestPermission(function() {
                        UCP.notificationsAllowed();
                        $("#ucp-settings input[name=\"desktopnotifications\"]").prop("checked", true);
                    }, function() {
                        UCP.showAlert(_("Enabling notifications was denied"),"danger");
                        UCP.notificationsDenied();
                        $("#ucp-settings input[name=\"desktopnotifications\"]").prop("checked", false);
                    });
                } else {
                    UCP.notify = false;
                }
            });
        }

        var restartTour = false;
        $("#ucp-settings input[name=\"tour\"]").prop("checked", false);
        $("#ucp-settings input[name=\"tour\"]").change(function() {
            if($(this).is(":checked")) {
                restartTour = true;
            } else {
                restartTour = false;
            }
            $.post( UCP.ajaxUrl + "?module=ucptour&command=tour", { state: (restartTour ? 1 : 0) }, function( data ) {

            });
        });

        $("#widget_settings").one('hidden.bs.modal', function() {
            if(restartTour) {
                UCP.Modules.Ucptour.tour.restart();
            }
        });

        $("#update-pwd").click(function(e) {
            e.preventDefault();
            e.stopPropagation();
            var password = $("#pwd").val(), confirm = $("#pwd-confirm").val();
            if (password !== "" && password != "******" && confirm !== "") {
                if (confirm != password) {
                    $this.showMessage(_("Password Confirmation Didn't Match!"),"danger");
                } else {
                    $.post( "ajax.php?module=Settings&command=settings", { key: "password", value: confirm }, function( data ) {
                        if (data.status) {
                            $this.showMessage(_("Saved!"),"success");
                            UCP.showConfirm(_("UCP needs to reload, ok?"), 'warning', function() {
                                window.location.reload();
                            });
                        } else {
                            $this.showMessage(data.message,"danger");
                        }
                    });
                }
            } else {
                $this.showMessage(_("Password has not changed!"));
            }
        });

        $("#username").blur(function() {
            new_user = $(this).val();
            if($(this).val() != $(this).data("prevusername")) {
                UCP.showConfirm(_("Are you sure you wish to change your username? UCP will reload after"), 'warning', function() {
                    $.post( "ajax.php?module=Settings&command=settings", { key: "username", value: new_user}, function( data ) {
                        if(data.status) {
                            $this.showMessage(_("Username has been changed, reloading"),"success");
                            window.location.reload();
                        } else {
                            $this.showMessage(data.message,"danger");
                        }
                    });
                });
            }
        });
        $("#userinfo input[type!=checkbox][type!=radio][name!=dateformat][name!=timeformat][name!=datetimeformat]").blur(function() {
            $.post( "ajax.php?module=Settings&command=settings", { key: $(this).prop("name"), value: $(this).val() }, function( data ) {
                if (data.status) {
                    $this.showMessage(_("Saved!"),"success");
                } else {
                    $this.showMessage(data.message,"danger");
                }
                $(this).off("blur");
            });
        });
        $("#dateformat, #timeformat, #datetimeformat").blur(function() {
            var name = $(this).prop("name"),
                value = $(this).val();
            $.post( "ajax.php?module=Settings&command=settings", { key: name, value: value }, function( data ) {
                if (data.status) {
                    if(value === "" && typeof $this[name] === "string") {
                        window[name] = $this[name];
                    } else {
                        window[name] = value;
                    }
                    $this.showMessage(_("Saved!"),"success");
                } else {
                    $this.showMessage(data.message,"danger");
                }
                $(this).off("blur");
            });
        });
        if($("#Contactmanager-image").length) {
            /**
             * Drag/Drop/Upload Files
             */
            $('#contactmanager_dropzone').on('drop dragover', function (e) {
                e.preventDefault();
            });
            $('#contactmanager_dropzone').on('dragleave drop', function (e) {
                $(this).removeClass("activate");
            });
            $('#contactmanager_dropzone').on('dragover', function (e) {
                $(this).addClass("activate");
            });
            var supportedRegExp = "png|jpg|jpeg";
            $( document ).ready(function() {
                $('#contactmanager_imageupload').fileupload({
                    dataType: 'json',
                    dropZone: $("#contactmanager_dropzone"),
                    add: function (e, data) {
                        //TODO: Need to check all supported formats
                        var sup = "\.("+supportedRegExp+")$",
                            patt = new RegExp(sup),
                            submit = true;
                        $.each(data.files, function(k, v) {
                            if(!patt.test(v.name.toLowerCase())) {
                                submit = false;
                                alert(_("Unsupported file type"));
                                return false;
                            }
                        });
                        if(submit) {
                            $("#contactmanager_upload-progress .progress-bar").addClass("progress-bar-striped active");
                            data.submit();
                        }
                    },
                    drop: function () {
                        $("#contactmanager_upload-progress .progress-bar").css("width", "0%");
                    },
                    dragover: function (e, data) {
                    },
                    change: function (e, data) {
                    },
                    done: function (e, data) {
                        $("#contactmanager_upload-progress .progress-bar").removeClass("progress-bar-striped active");
                        $("#contactmanager_upload-progress .progress-bar").css("width", "0%");

                        if(data.result.status) {
                            $("#contactmanager_dropzone img").attr("src",data.result.url);
                            $("#contactmanager_image").val(data.result.filename);
                            $("#contactmanager_dropzone img").removeClass("hidden");
                            $("#contactmanager_del-image").removeClass("hidden");
                            $("#contactmanager_gravatar").prop('checked', false);
                        } else {
                            alert(data.result.message);
                        }
                    },
                    progressall: function (e, data) {
                        var progress = parseInt(data.loaded / data.total * 100, 10);
                        $("#contactmanager_upload-progress .progress-bar").css("width", progress+"%");
                    },
                    fail: function (e, data) {
                    },
                    always: function (e, data) {
                    }
                });

                $("#contactmanager_del-image").click(function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    var id = $("input[name=user]").val(),
                        grouptype = 'userman';
                    $.post( "ajax.php?&module=Contactmanager&command=delimage", {id: id, img: $("#contactmanager_image").val()}, function( data ) {
                        if(data.status) {
                            $("#contactmanager_image").val("");
                            $("#contactmanager_dropzone img").addClass("hidden");
                            $("#contactmanager_dropzone img").attr("src","");
                            $("#contactmanager_del-image").addClass("hidden");
                            $("#contactmanager_gravatar").prop('checked', false);
                        }
                    });
                });

                $("#contactmanager_gravatar").change(function() {
                    if($(this).is(":checked")) {
                        var id = $("input[name=user]").val(),
                            grouptype = 'userman';
                        if($("#email").val() === "") {
                            alert(_("No email defined"));
                            $("#contactmanager_gravatar").prop('checked', false);
                            return;
                        }
                        var t = $("label[for=contactmanager_gravatar]").text();
                        $("label[for=contactmanager_gravatar]").text(_("Loading..."));
                        $.post( "ajax.php?module=Contactmanager&command=getgravatar", {id: id, grouptype: grouptype, email: $("#email").val()}, function( data ) {
                            $("label[for=contactmanager_gravatar]").text(t);
                            if(data.status) {
                                $("#contactmanager_dropzone img").data("oldsrc",$("#dropzone img").attr("src"));
                                $("#contactmanager_dropzone img").attr("src",data.url);
                                $("#contactmanager_image").data("old",$("#image").val());
                                $("#contactmanager_image").val(data.filename);
                                $("#contactmanager_dropzone img").removeClass("hidden");
                                $("#contactmanager_del-image").removeClass("hidden");
                            } else {
                                alert(data.message);
                                $("#contactmanager_gravatar").prop('checked', false);
                            }
                        });
                    } else {
                        var oldsrc = $("#contactmanager_dropzone img").data("oldsrc");
                        if(typeof oldsrc !== "undefined" && oldsrc !== "") {
                            $("#contactmanager_dropzone img").attr("src",oldsrc);
                            $("#contactmanager_image").val($("#image").data("old"));
                        } else {
                            $("#contactmanager_image").val("");
                            $("#contactmanager_dropzone img").addClass("hidden");
                            $("#contactmanager_dropzone img").attr("src","");
                            $("#contactmanager_del-image").addClass("hidden");
                        }
                    }
                });
            });
        }
    }
});

//15
var SmsC = UCPMC.extend({
    init: function(UCP) {
        this.lastchecked = Math.round(new Date().getTime() / 1000);
        this.dids = [];
        this.icon = "fa fa-comments-o";
        this.supportedFiles = "png|jpg|jpeg|gif|tiff|pdf|vcf|mp3|wav|ogg|mov|avi|mp4|m4a|ical|ics";
        //Logged In
        var Sms = this;
        $(document).on("chatWindowAdded", function(event, windowId, module, object) {
            if (module == "Sms") {
                object.on("click", function() {
                    object.find(".title-bar").css("background-color", "");
                });
                var from = object.data("from"),
                    to = object.data("to"),
                    cwindow = $(".message-box[data-id=\"" + windowId + "\"] .window");
                var ea = object.find("textarea").emojioneArea()[0].emojioneArea;
                ea.on("keyup", function(editor, event) {
                    if (event.keyCode == 13) {
                        Sms.sendMessage(windowId, from, to, ea.getText());
                        ea.setText(" ");
                    }
                });
                object.find(".chat").scroll(function() {
                    if ($(this)[0].scrollTop === 0) {
                        var id = $(".chat .message:lt(1)").data("id");
                        $(".message-box[data-id=\"" + windowId + "\"] .chat .history").prepend('<div class="message status">'+_('Loading')+'...</div>');
                        $.post( UCP.ajaxUrl + "?module=sms&command=history", { id: id, from: from, to: to }, function( data ) {
                            $(".message-box[data-id=\"" + windowId + "\"] .chat .history .status").remove();
                            var html = "";
                            $.each(data.messages, function(i, v) {
                                html = html + '<div class="message '+v.direction+'" data-id="' + v.emid + '" title="'+UCP.dateTimeFormatter(v.date)+'">'+ v.message +'</div>';
                            });
                            $(".message-box[data-id=\"" + windowId + "\"] .chat .history").prepend(html);
                        });
                    }
                });
                object.find(".window").prepend("<input id='file-" + windowId + "' type='file' class='hidden'><label for='file-" + windowId + "'><i class='fa fa-upload'></i></label>");
                $("#file-" + windowId).fileupload({
                    url: UCP.ajaxUrl + "?module=sms&command=upload&from="+from+"&to="+to,
                    dropZone: cwindow,
                    dataType: "json",
                    add: function(e, data) {
                        var sup = "\.("+Sms.supportedFiles+")$",
                            patt = new RegExp(sup,'i'),
                            submit = true;
                        $.each(data.files, function(k, v) {
                            if(!patt.test(v.name)) {
                                submit = false;
                                alert(_("Unsupported file type"));
                                return false;
                            }
                            if(v.size > 1500000) {
                                submit = false;
                                alert(_("File size is too large. Max: 1.5mb"));
                                return false;
                            }
                        });
                        if(submit) {
                            object.find(".response-status").html("");
                            object.find(".response-status").prepend('<div class="progress"><div class="progress-bar" role="progressbar" aria-valuenow="0" aria-valuemin="0" aria-valuemax="100" style="width: 0%;"><span class="sr-only">0% Complete</span></div></div>');
                            data.submit();
                        }
                    },
                    done: function(e, data) {
                        if (data.result.status) {
                            UCP.addChatMessage(windowId, data.result.emid, data.result.html, false, true, 'out');
                            if($('#sms-grid-'+from).length) {
                                $('#sms-grid-'+from).bootstrapTable('refresh', {silent: true});
                            }
                        } else {
                            object.find(".response-status").html(data.result.message);
                        }
                        object.find(".progress").remove();
                    },
                    progressall: function(e, data) {
                        var progress = parseInt(data.loaded / data.total * 100, 10);
                        object.find(".progress-bar").css("width", progress + "%");
                    },
                    drop: function(e, data) {
                        cwindow.removeClass("hover");
                    }
                });
                cwindow.on("dragover", function(event) {
                    if (event.preventDefault) {
                        event.preventDefault(); // Necessary. Allows us to drop.
                    }
                    $(this).addClass("hover");
                });
                cwindow.on("dragleave", function(event) {
                    $(this).removeClass("hover");
                });
            }
        });

        $(document).bind("staticSettingsFinished", function( event ) {
            if ((typeof Sms.staticsettings !== "undefined") && Sms.staticsettings.enabled) {
                Sms.dids = Sms.staticsettings.dids;
            }
        });
    },
    displayWidget: function(widget_id,dashboard_id) {
        var $this = this;
        var did = $(".grid-stack-item[data-rawname=sms][data-id='"+widget_id+"']").data("widget_type_id");

        $(".grid-stack-item[data-rawname=sms][data-id='"+widget_id+"'] .delete-selection").click(function() {
            var sel = $("#sms-grid-"+did).bootstrapTable('getAllSelections');
            UCP.showConfirm(_("Are you sure you wish to delete this conversation?"), 'warning', function() {
                var threads = [];
                $.each(sel, function(i, v) {
                    threads.push(v.threadid);
                });
                $.post( UCP.ajaxUrl + "?module=sms&command=deletemany", { threads: threads }, function( data ) {
                    if(data.status) {
                        $('#sms-grid-'+did).bootstrapTable('refresh');
                    }
                });
            });
        });

        $(".grid-stack-item[data-rawname=sms][data-id='"+widget_id+"'] .start-conversation").click(function() {
            UCP.showDialog(_("Send Message"),
                '<label for="SMSto">'+_("To")+':</label><input class="form-control" id="SMSto"></input>',
                '<button class="btn btn-default" id="initiateSMS">'+_("Initiate")+'</button>',
                function() {
                    $("#initiateSMS").click(function() {
                        $this.initiateChat(did,$("#SMSto").val(),function() {
                            UCP.closeDialog();
                        });

                    });
                    $("#SMSto").keypress(function(event) {
                        if (event.keyCode == 13) {
                            $this.initiateChat(did,$("#SMSto").val(),function() {
                                UCP.closeDialog();
                            });
                        }
                    });
                }
            );
        });
        $("#sms-grid-"+did).on("check.bs.table uncheck.bs.table check-all.bs.table uncheck-all.bs.table", function () {
            var sel = $(this).bootstrapTable('getAllSelections'),
                dis = true;
            if(sel.length) {
                dis = false;
            }
            $(".grid-stack-item[data-rawname=sms][data-id='"+widget_id+"'] .delete-selection").prop("disabled",dis);
        });
        $("#sms-grid-"+did).on("post-body.bs.table", function() {
            $("#sms-grid-"+did+" td .view").click(function() {
                var from = $(this).data("from"), to = $(this).data("to");
                UCP.showDialog(
                    sprintf(_("Conversation Detail with %s"),from),
                    $(".sms-detail-table-container").html(),
                    '<button type="button" class="btn btn-default" data-dismiss="modal">'+_("Close")+'</button>',
                    function() {
                        $("#globalModal .sms-detail-table").bootstrapTable('showLoading');
                        $.post( UCP.ajaxUrl + "?module=sms&command=messages", { from: from, to: to }, function( data ) {
                            $("#globalModal .sms-detail-table").bootstrapTable('load', data);
                            $("#globalModal .sms-detail-table").bootstrapTable('hideLoading');
                        });
                    }
                );
            });
            $("#sms-grid-"+did+" td .delete").click(function() {
                var from = $(this).data("from"), to = $(this).data("to"), id = $(this).data("id");
                UCP.showConfirm(_("Are you sure you wish to delete this conversation?"), 'warning', function() {
                    $.post( UCP.ajaxUrl + "?module=sms&command=delete", { from: from, to: to }, function( data ) {
                        if(data.status) {
                            $('#sms-grid-'+did).bootstrapTable('remove', {field: "id", values: [String(id)]});
                        }
                    });
                });
            });
        });
    },
    contactClickInitiate: function(did) {
        var tdid = did, Sms = this,
            name = tdid,
            selected = "",
            temp = "";
        if (UCP.validMethod("Contactmanager", "lookup")) {
            if (typeof UCP.Modules.Contactmanager.lookup(tdid).displayname !== "undefined") {
                name = UCP.Modules.Contactmanager.lookup(tdid).displayname;
            } else {
                temp = String(tdid).length == 11 ? String(tdid).substring(1) : tdid;
                if (typeof UCP.Modules.Contactmanager.lookup(temp).displayname !== "undefined") {
                    name = UCP.Modules.Contactmanager.lookup(temp).displayname;
                }
            }
        }

        selected = "<option value=\"" + tdid + "\" selected>" + name + "</option>";
        UCP.showDialog(_("Send Message"),
            '<label for="SMSfrom">From:</label> <select id="SMSfrom" class="form-control">'+ sfrom +'</select><label for="SMSto">To:</label><select class="form-control Tokenize Fill" id="SMSto" multiple>' + selected + '</select>',
            '<button class="btn btn-default" id="initiateSMS" style="margin-left: 72px;">'+_("Initiate")+'</button>',
            function() {
                $("#SMSto").tokenize({
                    maxElements: 1,
                    datas: UCP.ajaxUrl + "?module=sms&command=contacts"
                });
                $("#initiateSMS").click(function() {
                    setTimeout(function() {Sms.initiateChat($("#SMSfrom").val(),$("#SMSto").val(),function(){UCP.closeDialog();});}, 50);
                });
                $("#SMSto").keypress(function(event) {
                    if (event.keyCode == 13) {
                        setTimeout(function() {Sms.initiateChat();}, 50);
                    }
                });
            }
        );
    },
    contactClickOptions: function(type) {
        if (type != "number") {
            return false;
        }
        $.get( UCP.ajaxUrl + "?module=sms&command=dids",function( data ) {
            sfrom = "";
            $.each(data.dids, function(i, v) {
                sfrom = sfrom + "<option>" + v + "</option>"
            });
        });
        return [ { text: _("Send SMS"), function: "contactClickInitiate", type: "sms" } ];
    },
    replaceContact: function(contact) {
        var entry = null;
        if (UCP.validMethod("Contactmanager", "lookup")) {
            scontact = contact.length == 11 ? contact.substring(1) : contact;
            entry = UCP.Modules.Contactmanager.lookup(scontact);
            if (entry !== null && entry !== false) {
                return entry.displayname;
            }
            entry = UCP.Modules.Contactmanager.lookup(contact);
            if (entry !== null && entry !== false) {
                return entry.displayname;
            }
        }
        return contact;
    },
    prepoll: function(data) {
        var Sms = this,
            messageBoxes = { messageWindows: {}, lastchecked: this.lastchecked };
        $(".message-box[data-module=\"Sms\"]").each(function(i, v) {
            var windowid = $(this).data("id"),
                from = $(this).data("from"),
                to = $(this).data("to"),
                last = $(this).data("last-msg-id");
            messageBoxes.messageWindows[i] = { from: from, to: to, last: last, windowid: windowid };
        });
        return messageBoxes;
    },
    poll: function(data) {
        var Sms = this,
            delivered = [];
        if (data.status) {
            $.each(data.messages, function(windowid, messages) {
                $.each(messages, function(index, v) {
                    //message already exists
                    if($( "#messages-container .message-box[data-id=\"" + windowid + "\"] .message[data-id='"+v.emid+"']").length) {
                        return true;
                    }
                    var Notification = new Notify(sprintf(_("New Message from %s"), Sms.replaceContact(v.from)), {
                        body: v.html ? _("New Message") : emojione.unifyUnicode(v.body),
                        icon: "modules/Sms/assets/images/comment.png",
                        timeout: 3
                    });
                    UCP.addChat("Sms", windowid, Sms.icon, v.did, v.recp, Sms.replaceContact(v.cnam), v.emid, emojione.shortnameToImage(v.body), null, true, v.direction);
                    delivered.push(v.id);
                    if (UCP.notify) {
                        Notification.show();
                    }
                    if($('#sms-grid-'+v.did).length) {
                        $('#sms-grid-'+v.did).bootstrapTable('refresh', {silent: true});
                    }
                });
            });
            if (delivered.length) {
                $.post( UCP.ajaxUrl + "?module=sms&command=delivered", { ids: delivered }, function( data ) {});
            }
        }
        this.lastchecked = data.lastchecked;
    },
    initiateChat: function(did, to, callback) {
        var Sms = this,
            pattern = new RegExp(/^\d*$/);
        if (to !== "" && pattern.test(to)) {
            to = (to.length === 10) ? "1" + to : to;
            this.startChat(did, to);
            if(typeof callback === "function") {
                callback();
            }
        } else {
            UCP.showAlert(_("Invalid Number"));
        }
    },
    startChat: function(from, to) {
        var Sms = this;
        UCP.addChat("Sms", from + to, Sms.icon, from, to);
    },
    sendMessage: function(windowId, from, to, message, callback) {
        var Sms = this;
        $(".message-box[data-id='" + windowId + "'] .response-status").html(_("Sending..."));
        $(".message-box[data-id=\"" + windowId + "\"] .response .emojionearea-editor").addClass("hidden");
        $.post( UCP.ajaxUrl + "?module=sms&command=send", { from: from, to: to, message: message }, function( data ) {
            if (data.status) {
                $(".message-box[data-id='" + windowId + "'] .response-status").html("");
                UCP.addChatMessage(windowId, data.emid, message, false, false, 'out');
                $(".message-box[data-id='" + windowId + "'] textarea").val("");
                if($('#sms-grid-'+from).length) {
                    $('#sms-grid-'+from).bootstrapTable('refresh', {silent: true});
                }
                if(typeof callback === "function") {
                    callback();
                }
            } else {
                $(".message-box[data-id='" + windowId + "'] .response-status").html(data.message);
            }
            $(".message-box[data-id=\"" + windowId + "\"] .response .emojionearea-editor").removeClass("hidden");
            $(".message-box[data-id=\"" + windowId + "\"] .response .emojionearea-editor").focus();
        });
    },
    dateFormatter: function(value, row) {
        return UCP.dateTimeFormatter(row.timestamp);
    },
    actionFormatter: function(value, row) {
        return '<a><i class="fa fa-eye view" data-from="'+row.localdid+'" data-to="'+row.remotedid+'"></i></a><a><i class="fa fa-trash-o delete" data-from="'+row.localdid+'" data-to="'+row.remotedid+'" data-id="'+row.id+'"></i></a></td>';
    },
    toFormatter: function(value, row) {
        return '<a onclick="UCP.Modules.Sms.startChat(\''+row.localdid+'\',\''+row.remotedid+'\')">'+row.prettyto+'</a>';
    },
    directionFormatter: function(value) {
        switch(value) {
            case "out":
                return _("Sent");
                break;
            case "in":
                return _("Received");
                break;
        }
    },
    bodyFormatter: function(value, row) {
        return emojione.toImage(value);
    }
});

var SysadminC = UCPMC.extend({
        init: function() {
        },
        hide: function(event) {

        }
    }),
    Sysadmin = new SysadminC();

/* ========================================================================
 * bootstrap-tour - v0.10.3
 * http://bootstraptour.com
 * ========================================================================
 * Copyright 2012-2015 Ulrich Sossou
 *
 * ========================================================================
 * Licensed under the MIT License (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://opensource.org/licenses/MIT
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * ========================================================================
 */

(function(window, factory) {
    if (typeof define === 'function' && define.amd) {
        return define(['jquery'], function(jQuery) {
            return window.Tour = factory(jQuery);
        });
    } else if (typeof exports === 'object') {
        return module.exports = factory(require('jQuery'));
    } else {
        return window.Tour = factory(window.jQuery);
    }
})(window, function($) {
    var Tour, document;
    document = window.document;
    Tour = (function() {
        function Tour(options) {
            var storage;
            try {
                storage = window.localStorage;
            } catch (_error) {
                storage = false;
            }
            this._options = $.extend({
                name: 'tour',
                steps: [],
                container: 'body',
                autoscroll: true,
                keyboard: true,
                storage: storage,
                debug: false,
                backdrop: false,
                backdropContainer: 'body',
                backdropPadding: 0,
                redirect: true,
                orphan: false,
                duration: false,
                delay: false,
                basePath: '',
                template: '<div class="popover" role="tooltip"> <div class="arrow"></div> <h3 class="popover-title"></h3> <div class="popover-content"></div> <div class="popover-navigation"> <div class="btn-group"> <button class="btn btn-sm btn-default" data-role="prev">&laquo; Prev</button> <button class="btn btn-sm btn-default" data-role="next">Next &raquo;</button> <button class="btn btn-sm btn-default" data-role="pause-resume" data-pause-text="Pause" data-resume-text="Resume">Pause</button> </div> <button class="btn btn-sm btn-default" data-role="end">End tour</button> </div> </div>',
                afterSetState: function(key, value) {},
                afterGetState: function(key, value) {},
                afterRemoveState: function(key) {},
                onStart: function(tour) {},
                onEnd: function(tour) {},
                onShow: function(tour) {},
                onShown: function(tour) {},
                onHide: function(tour) {},
                onHidden: function(tour) {},
                onNext: function(tour) {},
                onPrev: function(tour) {},
                onPause: function(tour, duration) {},
                onResume: function(tour, duration) {},
                onRedirectError: function(tour) {}
            }, options);
            this._force = false;
            this._inited = false;
            this._current = null;
            this.backdrop = {
                overlay: null,
                $element: null,
                $background: null,
                backgroundShown: false,
                overlayElementShown: false
            };
            this;
        }

        Tour.prototype.addSteps = function(steps) {
            var step, _i, _len;
            for (_i = 0, _len = steps.length; _i < _len; _i++) {
                step = steps[_i];
                this.addStep(step);
            }
            return this;
        };

        Tour.prototype.addStep = function(step) {
            this._options.steps.push(step);
            return this;
        };

        Tour.prototype.getStep = function(i) {
            if (this._options.steps[i] != null) {
                return $.extend({
                    id: "step-" + i,
                    path: '',
                    host: '',
                    placement: 'right',
                    title: '',
                    content: '<p></p>',
                    next: i === this._options.steps.length - 1 ? -1 : i + 1,
                    prev: i - 1,
                    animation: true,
                    container: this._options.container,
                    autoscroll: this._options.autoscroll,
                    backdrop: this._options.backdrop,
                    backdropContainer: this._options.backdropContainer,
                    backdropPadding: this._options.backdropPadding,
                    redirect: this._options.redirect,
                    reflexElement: this._options.steps[i].element,
                    backdropElement: this._options.steps[i].element,
                    orphan: this._options.orphan,
                    duration: this._options.duration,
                    delay: this._options.delay,
                    template: this._options.template,
                    onShow: this._options.onShow,
                    onShown: this._options.onShown,
                    onHide: this._options.onHide,
                    onHidden: this._options.onHidden,
                    onNext: this._options.onNext,
                    onPrev: this._options.onPrev,
                    onPause: this._options.onPause,
                    onResume: this._options.onResume,
                    onRedirectError: this._options.onRedirectError
                }, this._options.steps[i]);
            }
        };

        Tour.prototype.init = function(force) {
            this._force = force;
            if (this.ended()) {
                this._debug('Tour ended, init prevented.');
                return this;
            }
            this.setCurrentStep();
            this._initMouseNavigation();
            this._initKeyboardNavigation();
            this._onResize((function(_this) {
                return function() {
                    return _this.showStep(_this._current);
                };
            })(this));
            if (this._current !== null) {
                this.showStep(this._current);
            }
            this._inited = true;
            return this;
        };

        Tour.prototype.start = function(force) {
            var promise;
            if (force == null) {
                force = false;
            }
            if (!this._inited) {
                this.init(force);
            }
            if (this._current === null) {
                promise = this._makePromise(this._options.onStart != null ? this._options.onStart(this) : void 0);
                this._callOnPromiseDone(promise, this.showStep, 0);
            }
            return this;
        };

        Tour.prototype.next = function() {
            var promise;
            promise = this.hideStep(this._current, this._current + 1);
            return this._callOnPromiseDone(promise, this._showNextStep);
        };

        Tour.prototype.prev = function() {
            var promise;
            promise = this.hideStep(this._current, this._current - 1);
            return this._callOnPromiseDone(promise, this._showPrevStep);
        };

        Tour.prototype.goTo = function(i) {
            var promise;
            promise = this.hideStep(this._current, i);
            return this._callOnPromiseDone(promise, this.showStep, i);
        };

        Tour.prototype.end = function() {
            var endHelper, promise;
            endHelper = (function(_this) {
                return function(e) {
                    $(document).off("click.tour-" + _this._options.name);
                    $(document).off("keyup.tour-" + _this._options.name);
                    $(window).off("resize.tour-" + _this._options.name);
                    _this._setState('end', 'yes');
                    _this._inited = false;
                    _this._force = false;
                    _this._clearTimer();
                    if (_this._options.onEnd != null) {
                        return _this._options.onEnd(_this);
                    }
                };
            })(this);
            promise = this.hideStep(this._current);
            return this._callOnPromiseDone(promise, endHelper);
        };

        Tour.prototype.ended = function() {
            return !this._force && !!this._getState('end');
        };

        Tour.prototype.restart = function() {
            this._removeState('current_step');
            this._removeState('end');
            this._removeState('redirect_to');
            return this.start();
        };

        Tour.prototype.pause = function() {
            var step;
            step = this.getStep(this._current);
            if (!(step && step.duration)) {
                return this;
            }
            this._paused = true;
            this._duration -= new Date().getTime() - this._start;
            window.clearTimeout(this._timer);
            this._debug("Paused/Stopped step " + (this._current + 1) + " timer (" + this._duration + " remaining).");
            if (step.onPause != null) {
                return step.onPause(this, this._duration);
            }
        };

        Tour.prototype.resume = function() {
            var step;
            step = this.getStep(this._current);
            if (!(step && step.duration)) {
                return this;
            }
            this._paused = false;
            this._start = new Date().getTime();
            this._duration = this._duration || step.duration;
            this._timer = window.setTimeout((function(_this) {
                return function() {
                    if (_this._isLast()) {
                        return _this.next();
                    } else {
                        return _this.end();
                    }
                };
            })(this), this._duration);
            this._debug("Started step " + (this._current + 1) + " timer with duration " + this._duration);
            if ((step.onResume != null) && this._duration !== step.duration) {
                return step.onResume(this, this._duration);
            }
        };

        Tour.prototype.hideStep = function(i, iNext) {
            var hideDelay, hideStepHelper, promise, step;
            step = this.getStep(i);
            if (!step) {
                return;
            }
            this._clearTimer();
            promise = this._makePromise(step.onHide != null ? step.onHide(this, i) : void 0);
            hideStepHelper = (function(_this) {
                return function(e) {
                    var $element, next_step;
                    $element = $(step.element);
                    if (!($element.data('bs.popover') || $element.data('popover'))) {
                        $element = $('body');
                    }
                    $element.popover('destroy').removeClass("tour-" + _this._options.name + "-element tour-" + _this._options.name + "-" + i + "-element").removeData('bs.popover').focus();
                    if (step.reflex) {
                        $(step.reflexElement).removeClass('tour-step-element-reflex').off("" + (_this._reflexEvent(step.reflex)) + ".tour-" + _this._options.name);
                    }
                    if (step.backdrop) {
                        next_step = (iNext != null) && _this.getStep(iNext);
                        if (!next_step || !next_step.backdrop || next_step.backdropElement !== step.backdropElement) {
                            _this._hideBackdrop();
                        }
                    }
                    if (step.onHidden != null) {
                        return step.onHidden(_this);
                    }
                };
            })(this);
            hideDelay = step.delay.hide || step.delay;
            if ({}.toString.call(hideDelay) === '[object Number]' && hideDelay > 0) {
                this._debug("Wait " + hideDelay + " milliseconds to hide the step " + (this._current + 1));
                window.setTimeout((function(_this) {
                    return function() {
                        return _this._callOnPromiseDone(promise, hideStepHelper);
                    };
                })(this), hideDelay);
            } else {
                this._callOnPromiseDone(promise, hideStepHelper);
            }
            return promise;
        };

        Tour.prototype.showStep = function(i) {
            var path, promise, showDelay, showStepHelper, skipToPrevious, step;
            if (this.ended()) {
                this._debug('Tour ended, showStep prevented.');
                return this;
            }
            step = this.getStep(i);
            if (!step) {
                return;
            }
            skipToPrevious = i < this._current;
            promise = this._makePromise(step.onShow != null ? step.onShow(this, i) : void 0);
            this.setCurrentStep(i);
            path = (function() {
                switch ({}.toString.call(step.path)) {
                    case '[object Function]':
                        return step.path();
                    case '[object String]':
                        return this._options.basePath + step.path;
                    default:
                        return step.path;
                }
            }).call(this);
            if (step.redirect && this._isRedirect(step.host, path, document.location)) {
                this._redirect(step, i, path);
                if (!this._isJustPathHashDifferent(step.host, path, document.location)) {
                    return;
                }
            }
            showStepHelper = (function(_this) {
                return function(e) {
                    var showPopoverAndOverlay;
                    if (_this._isOrphan(step)) {
                        if (step.orphan === false) {
                            _this._debug("Skip the orphan step " + (_this._current + 1) + ".\nOrphan option is false and the element does not exist or is hidden.");
                            if (skipToPrevious) {
                                _this._showPrevStep();
                            } else {
                                _this._showNextStep();
                            }
                            return;
                        }
                        _this._debug("Show the orphan step " + (_this._current + 1) + ". Orphans option is true.");
                    }
                    if (step.backdrop) {
                        _this._showBackdrop(step);
                    }
                    showPopoverAndOverlay = function() {
                        if (_this.getCurrentStep() !== i || _this.ended()) {
                            return;
                        }
                        if ((step.element != null) && step.backdrop) {
                            _this._showOverlayElement(step, true);
                            console.log("redraw");
                            _this.redraw();
                        }
                        _this._showPopover(step, i);
                        if (step.onShown != null) {
                            step.onShown(_this);
                        }
                        return _this._debug("Step " + (_this._current + 1) + " of " + _this._options.steps.length);
                    };
                    if (step.autoscroll) {
                        _this._scrollIntoView(step, showPopoverAndOverlay);
                    } else {
                        showPopoverAndOverlay();
                    }
                    if (step.duration) {
                        return _this.resume();
                    }
                };
            })(this);
            showDelay = step.delay.show || step.delay;
            if ({}.toString.call(showDelay) === '[object Number]' && showDelay > 0) {
                this._debug("Wait " + showDelay + " milliseconds to show the step " + (this._current + 1));
                window.setTimeout((function(_this) {
                    return function() {
                        return _this._callOnPromiseDone(promise, showStepHelper);
                    };
                })(this), showDelay);
            } else {
                this._callOnPromiseDone(promise, showStepHelper);
            }
            return promise;
        };

        Tour.prototype.getCurrentStep = function() {
            return this._current;
        };

        Tour.prototype.setCurrentStep = function(value) {
            if (value != null) {
                this._current = value;
                this._setState('current_step', value);
            } else {
                this._current = this._getState('current_step');
                this._current = this._current === null ? null : parseInt(this._current, 10);
            }
            return this;
        };

        Tour.prototype.redraw = function() {
            return this._showOverlayElement(this.getStep(this.getCurrentStep()).element, true);
        };

        Tour.prototype._setState = function(key, value) {
            var e, keyName;
            if (this._options.storage) {
                keyName = "" + this._options.name + "_" + key;
                try {
                    this._options.storage.setItem(keyName, value);
                } catch (_error) {
                    e = _error;
                    if (e.code === DOMException.QUOTA_EXCEEDED_ERR) {
                        this._debug('LocalStorage quota exceeded. State storage failed.');
                    }
                }
                return this._options.afterSetState(keyName, value);
            } else {
                if (this._state == null) {
                    this._state = {};
                }
                return this._state[key] = value;
            }
        };

        Tour.prototype._removeState = function(key) {
            var keyName;
            if (this._options.storage) {
                keyName = "" + this._options.name + "_" + key;
                this._options.storage.removeItem(keyName);
                return this._options.afterRemoveState(keyName);
            } else {
                if (this._state != null) {
                    return delete this._state[key];
                }
            }
        };

        Tour.prototype._getState = function(key) {
            var keyName, value;
            if (this._options.storage) {
                keyName = "" + this._options.name + "_" + key;
                value = this._options.storage.getItem(keyName);
            } else {
                if (this._state != null) {
                    value = this._state[key];
                }
            }
            if (value === void 0 || value === 'null') {
                value = null;
            }
            this._options.afterGetState(key, value);
            return value;
        };

        Tour.prototype._showNextStep = function() {
            var promise, showNextStepHelper, step;
            step = this.getStep(this._current);
            showNextStepHelper = (function(_this) {
                return function(e) {
                    return _this.showStep(step.next);
                };
            })(this);
            promise = this._makePromise(step.onNext != null ? step.onNext(this) : void 0);
            return this._callOnPromiseDone(promise, showNextStepHelper);
        };

        Tour.prototype._showPrevStep = function() {
            var promise, showPrevStepHelper, step;
            step = this.getStep(this._current);
            showPrevStepHelper = (function(_this) {
                return function(e) {
                    return _this.showStep(step.prev);
                };
            })(this);
            promise = this._makePromise(step.onPrev != null ? step.onPrev(this) : void 0);
            return this._callOnPromiseDone(promise, showPrevStepHelper);
        };

        Tour.prototype._debug = function(text) {
            if (this._options.debug) {
                return window.console.log("Bootstrap Tour '" + this._options.name + "' | " + text);
            }
        };

        Tour.prototype._isRedirect = function(host, path, location) {
            var currentPath;
            if ((host != null) && host !== '' && (({}.toString.call(host) === '[object RegExp]' && !host.test(location.origin)) || ({}.toString.call(host) === '[object String]' && this._isHostDifferent(host, location)))) {
                return true;
            }
            currentPath = [location.pathname, location.search, location.hash].join('');
            return (path != null) && path !== '' && (({}.toString.call(path) === '[object RegExp]' && !path.test(currentPath)) || ({}.toString.call(path) === '[object String]' && this._isPathDifferent(path, currentPath)));
        };

        Tour.prototype._isHostDifferent = function(host, location) {
            switch ({}.toString.call(host)) {
                case '[object RegExp]':
                    return !host.test(location.origin);
                case '[object String]':
                    return this._getProtocol(host) !== this._getProtocol(location.href) || this._getHost(host) !== this._getHost(location.href);
                default:
                    return true;
            }
        };

        Tour.prototype._isPathDifferent = function(path, currentPath) {
            return this._getPath(path) !== this._getPath(currentPath) || !this._equal(this._getQuery(path), this._getQuery(currentPath)) || !this._equal(this._getHash(path), this._getHash(currentPath));
        };

        Tour.prototype._isJustPathHashDifferent = function(host, path, location) {
            var currentPath;
            if ((host != null) && host !== '') {
                if (this._isHostDifferent(host, location)) {
                    return false;
                }
            }
            currentPath = [location.pathname, location.search, location.hash].join('');
            if ({}.toString.call(path) === '[object String]') {
                return this._getPath(path) === this._getPath(currentPath) && this._equal(this._getQuery(path), this._getQuery(currentPath)) && !this._equal(this._getHash(path), this._getHash(currentPath));
            }
            return false;
        };

        Tour.prototype._redirect = function(step, i, path) {
            var href;
            if ($.isFunction(step.redirect)) {
                return step.redirect.call(this, path);
            } else {
                href = {}.toString.call(step.host) === '[object String]' ? "" + step.host + path : path;
                this._debug("Redirect to " + href);
                if (this._getState('redirect_to') === ("" + i)) {
                    this._debug("Error redirection loop to " + path);
                    this._removeState('redirect_to');
                    if (step.onRedirectError != null) {
                        return step.onRedirectError(this);
                    }
                } else {
                    this._setState('redirect_to', "" + i);
                    return document.location.href = href;
                }
            }
        };

        Tour.prototype._isOrphan = function(step) {
            return (step.element == null) || !$(step.element).length || $(step.element).is(':hidden') && ($(step.element)[0].namespaceURI !== 'http://www.w3.org/2000/svg');
        };

        Tour.prototype._isLast = function() {
            return this._current < this._options.steps.length - 1;
        };

        Tour.prototype._showPopover = function(step, i) {
            var $element, $tip, isOrphan, options, shouldAddSmart;
            $(".tour-" + this._options.name).remove();
            options = $.extend({}, this._options);
            isOrphan = this._isOrphan(step);
            step.template = this._template(step, i);
            if (isOrphan) {
                step.element = 'body';
                step.placement = 'top';
            }
            $element = $(step.element);
            $element.addClass("tour-" + this._options.name + "-element tour-" + this._options.name + "-" + i + "-element");
            if (step.options) {
                $.extend(options, step.options);
            }
            if (step.reflex && !isOrphan) {
                $(step.reflexElement).addClass('tour-step-element-reflex').off("" + (this._reflexEvent(step.reflex)) + ".tour-" + this._options.name).on("" + (this._reflexEvent(step.reflex)) + ".tour-" + this._options.name, (function(_this) {
                    return function() {
                        if (_this._isLast()) {
                            return _this.next();
                        } else {
                            return _this.end();
                        }
                    };
                })(this));
            }
            shouldAddSmart = step.smartPlacement === true && step.placement.search(/auto/i) === -1;
            $element.popover({
                placement: shouldAddSmart ? "auto " + step.placement : step.placement,
                trigger: 'manual',
                title: step.title,
                content: step.content,
                html: true,
                animation: step.animation,
                container: step.container,
                template: step.template,
                selector: step.element
            }).popover('show');
            $tip = $element.data('bs.popover') ? $element.data('bs.popover').tip() : $element.data('popover').tip();
            $tip.attr('id', step.id);
            this._focus($tip, $element, step.next < 0);
            this._reposition($tip, step);
            if (isOrphan) {
                return this._center($tip);
            }
        };

        Tour.prototype._template = function(step, i) {
            var $navigation, $next, $prev, $resume, $template, template;
            template = step.template;
            if (this._isOrphan(step) && {}.toString.call(step.orphan) !== '[object Boolean]') {
                template = step.orphan;
            }
            $template = $.isFunction(template) ? $(template(i, step)) : $(template);
            $navigation = $template.find('.popover-navigation');
            $prev = $navigation.find('[data-role="prev"]');
            $next = $navigation.find('[data-role="next"]');
            $resume = $navigation.find('[data-role="pause-resume"]');
            if (this._isOrphan(step)) {
                $template.addClass('orphan');
            }
            $template.addClass("tour-" + this._options.name + " tour-" + this._options.name + "-" + i);
            if (step.reflex) {
                $template.addClass("tour-" + this._options.name + "-reflex");
            }
            if (step.prev < 0) {
                $prev.addClass('disabled').prop('disabled', true).prop('tabindex', -1);
            }
            if (step.next < 0) {
                $next.addClass('disabled').prop('disabled', true).prop('tabindex', -1);
            }
            if (!step.duration) {
                $resume.remove();
            }
            return $template.clone().wrap('<div>').parent().html();
        };

        Tour.prototype._reflexEvent = function(reflex) {
            if ({}.toString.call(reflex) === '[object Boolean]') {
                return 'click';
            } else {
                return reflex;
            }
        };

        Tour.prototype._focus = function($tip, $element, end) {
            var $next, role;
            role = end ? 'end' : 'next';
            $next = $tip.find("[data-role='" + role + "']");
            return $element.on('shown.bs.popover', function() {
                return $next.focus();
            });
        };

        Tour.prototype._reposition = function($tip, step) {
            var offsetBottom, offsetHeight, offsetRight, offsetWidth, originalLeft, originalTop, tipOffset;
            offsetWidth = $tip[0].offsetWidth;
            offsetHeight = $tip[0].offsetHeight;
            tipOffset = $tip.offset();
            originalLeft = tipOffset.left;
            originalTop = tipOffset.top;
            offsetBottom = $(document).outerHeight() - tipOffset.top - $tip.outerHeight();
            if (offsetBottom < 0) {
                tipOffset.top = tipOffset.top + offsetBottom;
            }
            offsetRight = $('html').outerWidth() - tipOffset.left - $tip.outerWidth();
            if (offsetRight < 0) {
                tipOffset.left = tipOffset.left + offsetRight;
            }
            if (tipOffset.top < 0) {
                tipOffset.top = 0;
            }
            if (tipOffset.left < 0) {
                tipOffset.left = 0;
            }
            $tip.offset(tipOffset);
            if (step.placement === 'bottom' || step.placement === 'top') {
                if (originalLeft !== tipOffset.left) {
                    return this._replaceArrow($tip, (tipOffset.left - originalLeft) * 2, offsetWidth, 'left');
                }
            } else {
                if (originalTop !== tipOffset.top) {
                    return this._replaceArrow($tip, (tipOffset.top - originalTop) * 2, offsetHeight, 'top');
                }
            }
        };

        Tour.prototype._center = function($tip) {
            return $tip.css('top', $(window).outerHeight() / 2 - $tip.outerHeight() / 2);
        };

        Tour.prototype._replaceArrow = function($tip, delta, dimension, position) {
            return $tip.find('.arrow').css(position, delta ? 50 * (1 - delta / dimension) + '%' : '');
        };

        Tour.prototype._scrollIntoView = function(step, callback) {
            var $element, $window, counter, height, offsetTop, scrollTop, windowHeight;
            $element = $(step.element);
            if (!$element.length) {
                return callback();
            }
            $window = $(window);
            offsetTop = $element.offset().top;
            height = $element.outerHeight();
            windowHeight = $window.height();
            scrollTop = 0;
            switch (step.placement) {
                case 'top':
                    scrollTop = Math.max(0, offsetTop - (windowHeight / 2));
                    break;
                case 'left':
                case 'right':
                    scrollTop = Math.max(0, (offsetTop + height / 2) - (windowHeight / 2));
                    break;
                case 'bottom':
                    scrollTop = Math.max(0, (offsetTop + height) - (windowHeight / 2));
            }
            this._debug("Scroll into view. ScrollTop: " + scrollTop + ". Element offset: " + offsetTop + ". Window height: " + windowHeight + ".");
            counter = 0;
            return $('body, html').stop(true, true).animate({
                scrollTop: Math.ceil(scrollTop)
            }, (function(_this) {
                return function() {
                    if (++counter === 2) {
                        callback();
                        return _this._debug("Scroll into view.\nAnimation end element offset: " + ($element.offset().top) + ".\nWindow height: " + ($window.height()) + ".");
                    }
                };
            })(this));
        };

        Tour.prototype._onResize = function(callback, timeout) {
            return $(window).on("resize.tour-" + this._options.name, function() {
                clearTimeout(timeout);
                return timeout = setTimeout(callback, 100);
            });
        };

        Tour.prototype._initMouseNavigation = function() {
            var _this;
            _this = this;
            return $(document).off("click.tour-" + this._options.name, ".popover.tour-" + this._options.name + " *[data-role='prev']").off("click.tour-" + this._options.name, ".popover.tour-" + this._options.name + " *[data-role='next']").off("click.tour-" + this._options.name, ".popover.tour-" + this._options.name + " *[data-role='end']").off("click.tour-" + this._options.name, ".popover.tour-" + this._options.name + " *[data-role='pause-resume']").on("click.tour-" + this._options.name, ".popover.tour-" + this._options.name + " *[data-role='next']", (function(_this) {
                return function(e) {
                    e.preventDefault();
                    return _this.next();
                };
            })(this)).on("click.tour-" + this._options.name, ".popover.tour-" + this._options.name + " *[data-role='prev']", (function(_this) {
                return function(e) {
                    e.preventDefault();
                    if (_this._current > 0) {
                        return _this.prev();
                    }
                };
            })(this)).on("click.tour-" + this._options.name, ".popover.tour-" + this._options.name + " *[data-role='end']", (function(_this) {
                return function(e) {
                    e.preventDefault();
                    return _this.end();
                };
            })(this)).on("click.tour-" + this._options.name, ".popover.tour-" + this._options.name + " *[data-role='pause-resume']", function(e) {
                var $this;
                e.preventDefault();
                $this = $(this);
                $this.text(_this._paused ? $this.data('pause-text') : $this.data('resume-text'));
                if (_this._paused) {
                    return _this.resume();
                } else {
                    return _this.pause();
                }
            });
        };

        Tour.prototype._initKeyboardNavigation = function() {
            if (!this._options.keyboard) {
                return;
            }
            return $(document).on("keyup.tour-" + this._options.name, (function(_this) {
                return function(e) {
                    if (!e.which) {
                        return;
                    }
                    switch (e.which) {
                        case 39:
                            e.preventDefault();
                            if (_this._isLast()) {
                                return _this.next();
                            } else {
                                return _this.end();
                            }
                            break;
                        case 37:
                            e.preventDefault();
                            if (_this._current > 0) {
                                return _this.prev();
                            }
                    }
                };
            })(this));
        };

        Tour.prototype._makePromise = function(result) {
            if (result && $.isFunction(result.then)) {
                return result;
            } else {
                return null;
            }
        };

        Tour.prototype._callOnPromiseDone = function(promise, cb, arg) {
            if (promise) {
                return promise.then((function(_this) {
                    return function(e) {
                        return cb.call(_this, arg);
                    };
                })(this));
            } else {
                return cb.call(this, arg);
            }
        };

        Tour.prototype._showBackdrop = function(step) {
            if (this.backdrop.backgroundShown) {
                return;
            }
            this.backdrop = $('<div>', {
                "class": 'tour-backdrop'
            });
            this.backdrop.backgroundShown = true;
            return $(step.backdropContainer).append(this.backdrop);
        };

        Tour.prototype._hideBackdrop = function() {
            this._hideOverlayElement();
            return this._hideBackground();
        };

        Tour.prototype._hideBackground = function() {
            if (this.backdrop && this.backdrop.remove) {
                this.backdrop.remove();
                this.backdrop.overlay = null;
                return this.backdrop.backgroundShown = false;
            }
        };

        Tour.prototype._showOverlayElement = function(step, force) {
            var $backdropElement, $element, elementData;
            $element = $(step.element);
            $backdropElement = $(step.backdropElement);
            if (!$element || $element.length === 0 || this.backdrop.overlayElementShown && !force) {
                return;
            }
            if (!this.backdrop.overlayElementShown) {
                this.backdrop.$element = $backdropElement.addClass('tour-step-backdrop');
                this.backdrop.$background = $('<div>', {
                    "class": 'tour-step-background'
                });
                this.backdrop.$background.appendTo(step.backdropContainer);
                this.backdrop.overlayElementShown = true;
            }
            elementData = {
                width: $backdropElement.innerWidth(),
                height: $backdropElement.innerHeight(),
                offset: $backdropElement.offset()
            };
            if (step.backdropPadding) {
                elementData = this._applyBackdropPadding(step.backdropPadding, elementData);
            }
            return this.backdrop.$background.width(elementData.width).height(elementData.height).offset(elementData.offset);
        };

        Tour.prototype._hideOverlayElement = function() {
            if (!this.backdrop.overlayElementShown) {
                return;
            }
            this.backdrop.$element.removeClass('tour-step-backdrop');
            this.backdrop.$background.remove();
            this.backdrop.$element = null;
            this.backdrop.$background = null;
            return this.backdrop.overlayElementShown = false;
        };

        Tour.prototype._applyBackdropPadding = function(padding, data) {
            if (typeof padding === 'object') {
                if (padding.top == null) {
                    padding.top = 0;
                }
                if (padding.right == null) {
                    padding.right = 0;
                }
                if (padding.bottom == null) {
                    padding.bottom = 0;
                }
                if (padding.left == null) {
                    padding.left = 0;
                }
                data.offset.top = data.offset.top - padding.top;
                data.offset.left = data.offset.left - padding.left;
                data.width = data.width + padding.left + padding.right;
                data.height = data.height + padding.top + padding.bottom;
            } else {
                data.offset.top = data.offset.top - padding;
                data.offset.left = data.offset.left - padding;
                data.width = data.width + (padding * 2);
                data.height = data.height + (padding * 2);
            }
            return data;
        };

        Tour.prototype._clearTimer = function() {
            window.clearTimeout(this._timer);
            this._timer = null;
            return this._duration = null;
        };

        Tour.prototype._getProtocol = function(url) {
            url = url.split('://');
            if (url.length > 1) {
                return url[0];
            } else {
                return 'http';
            }
        };

        Tour.prototype._getHost = function(url) {
            url = url.split('//');
            url = url.length > 1 ? url[1] : url[0];
            return url.split('/')[0];
        };

        Tour.prototype._getPath = function(path) {
            return path.replace(/\/?$/, '').split('?')[0].split('#')[0];
        };

        Tour.prototype._getQuery = function(path) {
            return this._getParams(path, '?');
        };

        Tour.prototype._getHash = function(path) {
            return this._getParams(path, '#');
        };

        Tour.prototype._getParams = function(path, start) {
            var param, params, paramsObject, _i, _len;
            params = path.split(start);
            if (params.length === 1) {
                return {};
            }
            params = params[1].split('&');
            paramsObject = {};
            for (_i = 0, _len = params.length; _i < _len; _i++) {
                param = params[_i];
                param = param.split('=');
                paramsObject[param[0]] = param[1] || '';
            }
            return paramsObject;
        };

        Tour.prototype._equal = function(obj1, obj2) {
            var k, obj1Keys, obj2Keys, v, _i, _len;
            if ({}.toString.call(obj1) === '[object Object]' && {}.toString.call(obj2) === '[object Object]') {
                obj1Keys = Object.keys(obj1);
                obj2Keys = Object.keys(obj2);
                if (obj1Keys.length !== obj2Keys.length) {
                    return false;
                }
                for (k in obj1) {
                    v = obj1[k];
                    if (!this._equal(obj2[k], v)) {
                        return false;
                    }
                }
                return true;
            } else if ({}.toString.call(obj1) === '[object Array]' && {}.toString.call(obj2) === '[object Array]') {
                if (obj1.length !== obj2.length) {
                    return false;
                }
                for (k = _i = 0, _len = obj1.length; _i < _len; k = ++_i) {
                    v = obj1[k];
                    if (!this._equal(v, obj2[k])) {
                        return false;
                    }
                }
                return true;
            } else {
                return obj1 === obj2;
            }
        };

        return Tour;

    })();
    return Tour;
});

var UcptourC = UCPMC.extend({
    init: function() {
        this.tour = null;
    },
    poll: function(data) {
        //console.log(data)
    },

});

$(document).bind("logIn", function( event ) {
    UCP.Modules.Ucptour.tour = new Tour({
        debug: false,
        storage: false,
        keyboard: false,
        onEnd: function (tour) {
            $.post( UCP.ajaxUrl + "?module=ucptour&command=tour", { state: 0 }, function( data ) {

            });
        },
        steps: [
            {
                orphan: true,
                title: sprintf(_("Welcome to %s!"),UCP.Modules.Ucptour.staticsettings.brand),
                content: _("Congratulations!")+"<br><br> "+_("You just successfully logged in for the first time!")+" <br>"+_("This tour will take you on a brief walkthrough of the new User Control Panel in a few simple steps.")+"<br><br>"+_("You can always exit the tour if you'd like, and you can restart the tour at anytime by clicking your User Settings and then 'Restart Tour'")+"<br><br><u>"+_("To continue just click Next")+"</u>",
                backdrop: true,
            }, {
                backdrop: true,
                backdropContainer: "#nav-bar-background",
                element: "#add_new_dashboard",
                placement: "left",
                title: _("Adding a dashboard"),
                content: _("The User Control Panel is now separated by 'Dashboards'. You can add a new dashboard by clicking this symbol")+"<br><br>"+_("Click this symbol to continue"),
                next: -1,
                reflex: true,
                onShow: function(tour) {
                    $(".navbar.navbar-inverse.navbar-fixed-left").css("z-index","1029");
                },
                onShown: function(tour) {
                    var step = tour.getCurrentStep();
                    $("#add_dashboard").one("shown.bs.modal", function() {
                        tour.goTo(step + 1);
                    });
                }
            }, {
                backdrop: true,
                backdropContainer: "#add_dashboard .modal-dialog",
                element: "#dashboard_name",
                placement: "bottom",
                title: _("Name your dashboard"),
                content: _("Enter a name for your dashboard in this input box"),
                onShown: function(tour) {
                    var step = tour.getCurrentStep();
                    $("#dashboard_name").keyup(function(e) {
                        if (e.keyCode == '13') {
                            $(document).one("addDashboard",function(e, id) {
                                $(".dashboard-menu[data-id="+id+"]").addClass("tour-step");
                                $(".dashboard-menu[data-id="+id+"] a").click();
                                tour.goTo(step + 2);
                            });
                        }
                    });
                }
            }, {
                backdrop: true,
                backdropContainer: "#add_dashboard .modal-dialog",
                element: "#create_dashboard",
                placement: "bottom",
                title: _("Save your dashboard"),
                content: _("When you are finished simply hit 'Create Dashboard' to create your dashboard"),
                reflex: true,
                next: -1,
                onShown: function(tour) {
                    var step = tour.getCurrentStep();
                    if($("#dashboard_name").val() === "") {
                        tour.goTo(step - 1);
                    }
                },
                onNext: function(tour) {
                    var step = tour.getCurrentStep();
                    $(document).one("addDashboard",function(e, id) {
                        $(".dashboard-menu[data-id="+id+"]").addClass("tour-step");
                        $(".dashboard-menu[data-id="+id+"] a").click();
                        tour.goTo(step + 1);
                    });
                    return (new jQuery.Deferred()).promise();
                }
            }, {
                backdrop: true,
                backdropContainer: "#nav-bar-background",
                element: ".dashboard-menu.tour-step",
                placement: "bottom",
                title: _("Dashboards"),
                content: _("Your dashboard has been added here"),
                previous: -1
            }, {
                backdrop: true,
                backdropContainer: ".main-content-object",
                element: "#dashboard-content",
                placement: "bottom",
                title: _("Dashboard Widgets"),
                content: _("Dashboard widgets will be displayed here"),
                previous: -1,
                onShown: function(tour) {
                    $("#dashboard-content").css("height","calc(100vh - 66px)");
                },
                onNext: function(tour) {
                    $("#dashboard-content").css("height","");
                }
            }, {
                backdrop: true,
                backdropContainer: "#nav-bar-background",
                element: ".dashboard-menu.tour-step .edit-dashboard",
                placement: "bottom",
                title: _("Editing a Dashboard"),
                content: _("The dashboard's name can be changed by clicking the pencil")
            }, {
                backdrop: true,
                backdropContainer: "#nav-bar-background",
                element: ".dashboard-menu.tour-step .remove-dashboard",
                placement: "left",
                title: _("Delete a Dashboard"),
                content: sprintf(_("A dashboard can be deleted by clicking the '%s'"),'X')
            }, {
                backdrop: true,
                backdropContainer: "#nav-bar-background",
                element: ".dashboard-menu.tour-step",
                placement: "bottom",
                title: _("Ordering dashboards"),
                content: _("Multiple dashboard can be re-ordered by hovering with your mouse until the move cursor is shown. Then clicking and dragging the dashboard in the order you want"),
                onHidden: function(tour) {
                    $(".navbar.navbar-inverse.navbar-fixed-left").css("z-index","");
                }
            }, {
                backdrop: true,
                backdropContainer: "#side_bar_content",
                element: "#side_bar_content .add-widget",
                placement: "right",
                title: _("Adding Widgets"),
                content: sprintf(_("Widgets can be added by clicking the '%s' symbol"),'(+)')+"<br><br>"+_("Click this symbol to continue"),
                reflex: true,
                next: -1,
                onShown: function(tour) {
                    var step = tour.getCurrentStep();
                    $("#add_widget").one("shown.bs.modal", function() {
                        tour.goTo(step + 1);
                    });
                    $(".tour-step-background").css("background-color","white");
                }
            }, {
                backdrop: true,
                backdropContainer: "#add_widget .modal-body",
                element: "#add_widget .modal-body .nav-tabs",
                placement: "left",
                title: _("Selecting Widgets"),
                content: _("There are two different types of widgets. Dashboard Widgets and Side Bar widgets. Let's start with dashboard widgets"),
                previous: -1,
                onShown: function(tour) {
                    $("a[href=#red]").click();
                }
            }, {
                backdrop: true,
                backdropContainer: "#add_widget .tab-pane.active .bhoechie-tab-container",
                element: "#add_widget .tab-pane.active .list-group-item.active",
                placement: "right",
                title: _("Selecting Dashboard Widgets"),
                content: _("Dashboard Widgets are sorted into categories on the left. These widgets will appear directly on your dashboard. You can click on any category to get a listing of the widgets available"),
                previous: -1
            }, {
                backdrop: true,
                backdropContainer: "#add_widget .tab-pane.active .bhoechie-tab-container",
                element: "#add_widget .tab-pane.active .bhoechie-tab-content.active .ibox-content-widget:first",
                placement: "bottom",
                title: _("Selecting Widgets"),
                content: _("Widgets are listed on the right. The titles and descriptions will be shown for each widget"),
                onShown: function(tour) {
                    $("#add_widget .modal-body").scrollTop(0);
                    var myStep = tour.getCurrentStep();
                    $("#add_widget .tab-pane.active .bhoechie-tab-content.active .ibox-content-widget:first .add-widget-button").one("click",function() {
                        tour.goTo(myStep + 2);
                    });
                }
            }, {
                backdrop: true,
                backdropContainer: "#add_widget .tab-pane.active .bhoechie-tab-content.active .ibox-content-widget:first",
                element: "#add_widget .tab-pane.active .bhoechie-tab-content.active .ibox-content-widget:first .add-widget-button",
                placement: "right",
                title: _("Adding Widgets"),
                content: sprintf(_("Clicking the '%s' symbol will add this widget to the currently active dashboard."),'(+)')+"<br><br>"+_("Click this symbol to continue"),
                next: -1,
                onShown: function(tour) {
                    var step = tour.getCurrentStep();
                    $("#add_widget .tab-pane.active .bhoechie-tab-content.active .ibox-content-widget:first .add-widget-button").off("click");
                    $(document).one("post-body.widgets", function(e, widget_id) {
                        $(".grid-stack-item[data-id="+widget_id+"]").addClass("tour-step");
                        tour.goTo(step + 1);
                    });
                }
            }, {
                element: ".grid-stack-item.tour-step",
                placement: "right",
                title: _("Dashboard Widget"),
                content: _("Widgets are placed automatically on the dashboard after they have been added")
            }, {
                element: ".grid-stack-item.tour-step .widget-title",
                placement: "bottom",
                title: _("Widget Placement"),
                content: _("Widgets can be moved around by clicking and dragging on the title bar"),
                onNext: function(tour) {
                    $(".grid-stack-item.tour-step .ui-icon-gripsmall-diagonal-se").show();
                }
            }, {
                element: ".grid-stack-item.tour-step .ui-icon-gripsmall-diagonal-se",
                placement: "right",
                title: _("Widget Size"),
                content: _("Widgets can be resized by placing your mouse near the corner of the widget. Click and drag to resize the widget.")+"<br><br>"+_("Note: some widgets have size restrictions!"),
                onNext: function(tour) {
                    $(".grid-stack-item.tour-step .ui-icon-gripsmall-diagonal-se").hide();
                }
            }, {
                element: ".grid-stack-item.tour-step .widget-title .lock-widget",
                placement: "right",
                title: _("Widget Locking"),
                content: _("Widgets can be locked into place to prevent their movement")
            }, {
                element: ".grid-stack-item.tour-step .widget-title .edit-widget",
                placement: "right",
                title: _("Widget Settings"),
                content: _("Widgets settings can be changed by clicking this icon")
            }, {
                element: ".grid-stack-item.tour-step .widget-title .remove-widget",
                placement: "right",
                title: _("Widget Removal"),
                content: sprintf(_("Widgets can also be removed by clicking the '%s' symbol"),'X')
            }, {
                element: ".dashboard-menu.active .lock-dashboard",
                placement: "bottom",
                title: _("Dashboard Locking"),
                content: sprintf(_("All widgets in a dashboard can also be locked globally by clicking the '%s' symbol on the dashboard tab"),'X')
            }, {
                element: ".navbar.navbar-inverse.navbar-fixed-left",
                placement: "right",
                title: _("Side Bar Widgets"),
                content: _("This is where side bar widgets live. Side bar widgets do not change when you change dashboards. They are global throughout UCP")
            }, {
                backdrop: true,
                backdropContainer: "#side_bar_content",
                element: "#side_bar_content .add-widget",
                placement: "right",
                title: _("Adding Side Bar Widgets"),
                content: sprintf(_("Side bar Widgets can also be added by clicking the '%s' symbol. These appear under the '%s' symbol in this side bar"),'(+)','(+)')+"<br><br>"+_("Click this symbol to continue"),
                reflex: true,
                next: -1,
                onShown: function(tour) {
                    var step = tour.getCurrentStep();
                    $("#add_widget").one("shown.bs.modal", function() {
                        tour.goTo(step + 1);
                    });
                    $(".tour-step-background").css("background-color","white");
                }
            }, {
                backdrop: true,
                backdropContainer: "#add_widget .modal-body",
                element: "#add_widget .modal-body .nav-tabs",
                placement: "right",
                title: _("Selecting Side Bar Widgets"),
                content: _("Side Bar widgets are grouped in a single category called 'Side Bar Widgets'"),
                onShown: function(tour) {
                    $("#add_widget .modal-body").scrollTop(0);
                    $("a[href=#small]").click();
                }
            }, {
                backdrop: true,
                backdropContainer: "#add_widget .tab-pane.active .bhoechie-tab-container",
                element: "#add_widget .tab-pane.active .list-group-item.active",
                placement: "bottom",
                title: _("Selecting Small Widgets"),
                content: _("Small Widgets are listed on the right. The titles and descriptions will be shown for each widget"),
            }, {
                backdrop: true,
                backdropContainer: "#add_widget .tab-pane.active .bhoechie-tab-container",
                element: "#add_widget .tab-pane.active .bhoechie-tab-content.active .ibox-content-widget:first",
                placement: "bottom",
                title: _("Selecting Widgets"),
                content: _("Widgets are listed on the right. The titles and descriptions will be shown for each widget"),
                onShown: function(tour) {
                    $("#add_widget .modal-body").scrollTop(0);
                    var myStep = tour.getCurrentStep();
                    $("#add_widget .tab-pane.active .bhoechie-tab-content.active .ibox-content-widget:first .add-small-widget-button").one("click",function() {
                        tour.goTo(myStep + 2);
                    });
                }
            }, {
                backdrop: true,
                orphan: true,
                backdropContainer: "#add_widget .tab-pane.active .bhoechie-tab-content.active .ibox-content-widget:first",
                element: ".add-small-widget-button",
                placement: "right",
                title: _("Adding Small Widgets"),
                content: sprintf(_("Clicking the '%s' symbol will add this small widget to the display. It will be visible on all dashboards"),'(+)')+"<br><br>"+_("Click this symbol to continue"),
                next: -1,
                onShown: function(tour) {
                    var step = tour.getCurrentStep();
                    $(document).one("post-body.addsimplewidget", function(e, widget_id) {
                        $(".custom-widget[data-widget_id="+widget_id+"]").addClass("tour-step");
                        tour.goTo(step + 1);
                    });
                }
            }, {
                element: "#side_bar_content .custom-widget.tour-step",
                placement: "right",
                title: _("Small Widget Display"),
                content: _("Once a small widget has been added it will show up in the left sidebar")+"<br><br>"+_("Click the widget's icon to continue"),
                next: -1,
                onShown: function(tour) {
                    var step = tour.getCurrentStep();
                    $(document).one("post-body.simplewidget", function(e, widget_id, widget_type_id) {
                        tour.goTo(step + 1);
                    });
                }
            }, {
                element: ".widget-extra-menu:visible .small-widget-content",
                placement: "right",
                title: _("Small Widget Display"),
                content: _("The widget's content is displayed here")
            }, {
                element: ".widget-extra-menu:visible .remove-small-widget",
                placement: "top",
                title: _("Small Widget Display"),
                content: _("To remove this widget from the side bar click 'Remove Widget'")
            }, {
                element: ".widget-extra-menu:visible .close-simple-widget-menu",
                placement: "bottom",
                title: _("Small Widget Display"),
                content: sprintf(_("To just close/hide the widget's content click the '%s' symbol"),'(X)')+"<br><br>"+_("Click this symbol to continue"),
                next: -1,
                onShown: function(tour) {
                    var step = tour.getCurrentStep();
                    $(document).one("post-body.closesimplewidget", function(e, widget_id, widget_type_id) {
                        tour.goTo(step + 1);
                    });
                }
            }, {
                element: "#side_bar_content .settings-widget",
                placement: "right",
                title: _("User Settings"),
                content: _("Your specific settings are defined when clicking the 'gear' icon in the side bar")
            }, {
                element: "#side_bar_content .logout-widget",
                placement: "right",
                title: _("Logout"),
                content: _("Your can logout of UCP by clicking this logout button")
            }, {
                orphan: true,
                title: _("End of tour"),
                content: sprintf(_("You have finished the tour of User Control Panel for %s 14. You can restart this tour at any time in your User Settings"),UCP.Modules.Ucptour.staticsettings.brand)
            }
        ]
    });
    if(UCP.Modules.Ucptour.staticsettings.show) {
        // Initialize the tour
        UCP.Modules.Ucptour.tour.init();

        // Start the tour
        UCP.Modules.Ucptour.tour.start();
    }
});

var VmnotifyC = UCPMC.extend({
    init: function(){
    },

    /**
     * Display Widget
     * @method displayWidget
     * @param  {string}      widget_id    The widget ID on the dashboard
     * @param  {string}      dashboard_id The dashboard ID
     */
    displayWidget: function(widget_id,dashboard_id) {
        var self = this;
        var ext = $(".grid-stack-item[data-id="+widget_id+"][data-rawname=vmnotify]").data('widget_type_id');
        $(".grid-stack-item[data-id='"+widget_id+"'][data-rawname=vmnotify] .widget-content input[name='vmnenable']").change(function() {
            var sidebar = $(".widget-extra-menu[data-module='vmnotify'][data-widget_type_id='"+ext+"']:visible input[name='vmnenable']"),
                checked = $(this).is(':checked'),
                name = $(this).prop('name');
            if(sidebar.length && sidebar.is(":checked") !== checked) {
                var state = checked ? "on" : "off";
                sidebar.bootstrapToggle(state);
            }
            // submit the form group list
            self.saveSettings({key: "vmnenable", value: $(this).is(':checked'), ext: ext});
        });
    },

    /**
     * Display Widget Settings
     * @method displayWidgetSettings
     * @param  {string}      widget_id    The widget ID on the dashboard
     * @param  {string}      dashboard_id The dashboard ID
     */
    displayWidgetSettings: function(widget_id, dashboard_id) {
        var self = this;
        var ext = $("#widget_settings").data('widget_type_id');
        $("#widget_settings .widget-settings-content .vmnrecip").change(function() {
            // submit the form group list
            self.saveSettings({key: "vmnrecip", value: $(this).val(), ext: ext});
        });
    },

    /**
     * Display Side Bar Widget
     * @method displaySimpleWidget
     * @param  {string}            widget_id The widget id in the sidebar
     */
    displaySimpleWidget: function(widget_id) {
        var self = this;
        var ext = $(".widget-extra-menu[data-id="+widget_id+"]").data('widget_type_id');
        $(".widget-extra-menu[data-id="+widget_id+"] .small-widget-content input[name='vmnenable']").change(function() {
            var checked = $(this).is(':checked'),
                name = $(this).prop('name'),
                el = $(".grid-stack-item[data-rawname=vmnotify][data-widget_type_id='"+ext+"']:visible input[name='vmnenable']");

            if(el.length) {
                if(el.is(":checked") !== checked) {
                    var state = checked ? "on" : "off";
                    el.bootstrapToggle(state);
                }
            } else {
                self.saveSettings({key: "vmnenable", value: $(this).is(':checked'), ext: ext});
            }
        });
    },

    /**
     * Display Simple Widget Settings
     * @method displaySimpleWidgetSettings
     * @param  {string}      widget_id    The widget ID on the sidebar
     */
    displaySimpleWidgetSettings: function(widget_id) {
        var self = this;
        var ext = $("#widget_settings").data('widget_type_id');
        $("#widget_settings .widget-settings-content .vmnrecip").change(function() {
            // submit the form group list
            self.saveSettings({key: "vmnrecip", value: $(this).val(), ext: ext});
        });
    },

    saveSettings: function(data) {
        data.module = "vmnotify";
        data.command = "settings";
        $.post( UCP.ajaxUrl, data, function( data ) {
            UCP.showAlert(data.message,data.alert,function() {
            });
        });
    },

});

var VoicemailC = UCPMC.extend({
    init: function() {
        this.loaded = null;
        this.recording = false;
        this.recorder = null;
        this.recordTimer = null;
        this.startTime = null;
        this.soundBlobs = {};
        this.placeholders = [];
    },
    resize: function(widget_id) {
        $(".grid-stack-item[data-id='"+widget_id+"'] .voicemail-grid").bootstrapTable('resetView',{height: $(".grid-stack-item[data-id='"+widget_id+"'] .widget-content").height()});
    },
    findmeFollowState: function() {
        if (!$("#vmx-p1_enable").is(":checked") && $("#ddial").is(":checked") && $("#vmx-state").is(":checked")) {
            $("#vmxerror").text(_("Find me Follow me is enabled when VmX locator option 1 is disabled. This means VmX Locator will be skipped, instead going directly to Find Me/Follow Me")).addClass("alert-danger").fadeIn("fast");
        } else {
            $("#vmxerror").fadeOut("fast");
        }
    },
    saveVmXSettings: function(ext, key, value) {
        var data = { ext: ext, settings: { key: key, value: value } };
        $.post( UCP.ajaxUrl + "?module=voicemail&command=vmxsettings", data, function( data ) {
            if (data.status) {
                $("#vmxmessage").text(data.message).addClass("alert-" + data.alert).fadeIn("fast", function() {

                });
            } else {
                return false;
            }
        });
    },
    poll: function(data) {
        if (typeof data.boxes === "undefined") {
            return;
        }

        var notify = false;
        var self = this;
        async.forEachOf(data.boxes, function (value, extension, callback) {
            var el = $(".grid-stack-item[data-rawname='voicemail'][data-widget_type_id='"+extension+"'] .mailbox");
            self.refreshFolderCount(extension);
            if(el.length && el.data("inbox") != value || window.update_table == true) {
                el.data("inbox",value);
                notify = true;
                if((typeof Cookies.get('vm-refresh-'+extension) === "undefined" && (typeof Cookies.get('vm-refresh-'+extension) === "undefined" || Cookies.get('vm-refresh-'+extension) == 1)) || Cookies.get('vm-refresh-'+extension) == 1) {
                    $(".grid-stack-item[data-rawname='voicemail'][data-widget_type_id='"+extension+"'] .voicemail-grid").bootstrapTable('refresh',{silent: true});
                }
            }
            callback();
        }, function(err) {
            if( err ) {
            } else if(notify) {
                voicemailNotification = new Notify("Voicemail", {
                    body: _("You have a new voicemail"),
                    icon: "modules/Voicemail/assets/images/mail.png"
                });
                if (UCP.notify) {
                    voicemailNotification.show();
                }
            }
        });
    },
    displayWidgetSettings: function(widget_id, dashboard_id) {
        var self = this,
            extension = $("div[data-id='"+widget_id+"']").data("widget_type_id");

        /* Settings changes binds */
        $("#widget_settings .widget-settings-content input[type!='checkbox'][id!=vm-refresh]").change(function() {
            $(this).blur(function() {
                self.saveVMSettings(extension);
                $(this).off("blur");
            });
        });
        $("#widget_settings .widget-settings-content input[type='checkbox'][id!=vm-refresh]").change(function() {
            self.saveVMSettings(extension);
        });

        $("#widget_settings .widget-settings-content input[id=vm-refresh]").change(function() {
            Cookies.remove('vm-refresh-'+extension, {path: ''});
            if($(this).is(":checked")) {
                Cookies.set('vm-refresh-'+extension, 1);
            } else {
                Cookies.set('vm-refresh-'+extension, 0);
            }
        });
        if((typeof Cookies.get('vm-refresh-'+extension) === "undefined" && (typeof Cookies.get('vm-refresh-'+extension) === "undefined" || Cookies.get('vm-refresh-'+extension) == 1)) || Cookies.get('vm-refresh-'+extension) == 1) {
            $("#widget_settings .widget-settings-content input[id=vm-refresh]").prop("checked",true);
        } else {
            $("#widget_settings .widget-settings-content input[id=vm-refresh]").prop("checked",false);
        }
        $("#widget_settings .widget-settings-content input[id=vm-refresh]").bootstrapToggle('destroy');
        $("#widget_settings .widget-settings-content input[id=vm-refresh]").bootstrapToggle({
            on: _("Enable"),
            off: _("Disable")
        });
        this.greetingsDisplay(extension);
        this.bindGreetingPlayers(extension);
        $("#widget_settings .vmx-setting").change(function() {
            var name = $(this).attr("name"),
                val = $(this).val();
            if($(this).attr("type") == "checkbox") {
                self.saveVmXSettings(extension, name, $(this).is(":checked"));
            } else {
                self.saveVmXSettings(extension, name, val);
            }

        });
    },
    displayWidget: function(widget_id, dashboard_id) {
        var self = this,
            extension = $("div[data-id='"+widget_id+"']").data("widget_type_id");
        $(".grid-stack-item[data-id='"+widget_id+"'] .voicemail-grid").one("post-body.bs.table", function() {
            setTimeout(function() {
                self.resize(widget_id);
            },250);
        });

        $("div[data-id='"+widget_id+"'] .voicemail-grid").on("post-body.bs.table", function (e) {
            $("div[data-id='"+widget_id+"'] .voicemail-grid a.listen").click(function() {
                var id = $(this).data("id"),
                    select = '';
                $.each(self.staticsettings.mailboxes, function(i,v) {
                    select = select + "<option value='"+v+"'>"+v+"</option>";
                });
                UCP.showDialog(_("Listen to Voicemail"),
                    _("On") + ':</label><select class="form-control" data-toggle="select" id="VMto">'+select+"</select>",
                    '<button class="btn btn-default" id="listenVM">' + _("Listen") + "</button>",
                    function() {
                        $("#listenVM").click(function() {
                            var recpt = $("#VMto").val();
                            self.listenVoicemail(id,extension,recpt);
                        });
                        $("#VMto").keypress(function(event) {
                            if (event.keyCode == 13) {
                                var recpt = $("#VMto").val();
                                self.listenVoicemail(id,extension,recpt);
                            }
                        });
                    }
                );
            });
            $("div[data-id='"+widget_id+"'] .voicemail-grid .clickable").click(function(e) {
                var text = $(this).text();
                if (UCP.validMethod("Contactmanager", "showActionDialog")) {
                    UCP.Modules.Contactmanager.showActionDialog("number", text, "phone");
                }
            });
            $("div[data-id='"+widget_id+"'] .voicemail-grid a.forward").click(function() {
                var id = $(this).data("id"),
                    select = '';

                $.each(self.staticsettings.mailboxes, function(i,v) {
                    select = select + "<option value='"+v+"'>"+v+"</option>";
                });
                UCP.showDialog(_("Forward Voicemail"),
                    _("To")+':</label><select class="form-control" id="VMto">'+select+'</select>',
                    '<button class="btn btn-default" id="forwardVM">' + _("Forward") + "</button>",
                    function() {
                        $("#forwardVM").click(function() {
                            var recpt = $("#VMto").val();
                            self.forwardVoicemail(id,extension,recpt, function(data) {
                                if(data.status) {
                                    UCP.showAlert(sprintf(_("Successfully forwarded voicemail to %s"),recpt));
                                    UCP.closeDialog();
                                }
                            });
                        });
                        $("#VMto").keypress(function(event) {
                            if (event.keyCode == 13) {
                                var recpt = $("#VMto").val();
                                self.forwardVoicemail(id,extension,recpt, function(data) {
                                    if(data.status) {
                                        UCP.showAlert(sprintf(_("Successfully forwarded voicemail to %s"),recpt));
                                        UCP.closeDialog();
                                    }
                                });
                            }
                        });
                    }
                );
            });
            $("div[data-id='"+widget_id+"'] .voicemail-grid a.delete").click(function() {
                var extension = $("div[data-id='"+widget_id+"']").data("widget_type_id");
                var id = $(this).data("id");
                UCP.showConfirm(_("Are you sure you wish to delete this voicemail?"),'warning',function() {
                    self.deleteVoicemail(id, extension, function(data) {
                        if(data.status) {
                            $("div[data-id='"+widget_id+"'] .voicemail-grid").bootstrapTable('remove', {field: "msg_id", values: [String(id)]});
                        }
                    });
                });
            });
            self.bindPlayers(widget_id);
        });
        $("div[data-id='"+widget_id+"'] .voicemail-grid").on("check.bs.table uncheck.bs.table check-all.bs.table uncheck-all.bs.table", function () {
            var sel = $(this).bootstrapTable('getAllSelections'),
                dis = true;
            if(sel.length) {
                dis = false;
            }
            $("div[data-id='"+widget_id+"'] .delete-selection").prop("disabled",dis);
            $("div[data-id='"+widget_id+"'] .forward-selection").prop("disabled",dis);
            $("div[data-id='"+widget_id+"'] .move-selection").prop("disabled",dis);
        });

        $("div[data-id='"+widget_id+"'] .folder").click(function() {
            $("div[data-id='"+widget_id+"'] .folder").removeClass("active");
            $(this).addClass("active");
            folder = $(this).data("folder");
            $("div[data-id='"+widget_id+"'] .voicemail-grid").bootstrapTable('refreshOptions',{
                url: UCP.ajaxUrl+'?module=voicemail&command=grid&folder='+folder+'&ext='+extension
            });
        });

        $("div[data-id='"+widget_id+"'] .move-selection").click(function() {
            var opts = '', cur = (typeof $.url().param("folder") !== "undefined") ? $.url().param("folder") : "INBOX", sel = $("div[data-id='"+widget_id+"'] .voicemail-grid").bootstrapTable('getAllSelections');
            $.each($("div[data-id='"+widget_id+"'] .folder-list .folder"), function(i, v){
                var folder = $(v).data("folder");
                if(folder != cur) {
                    opts += '<option>'+$(v).data("name")+'</option>';
                }
            });
            UCP.showDialog(_("Move Voicemail"),
                _("To")+':</label><select class="form-control" data-toggle="select" id="VMmove">'+opts+"</select>",
                '<button class="btn btn-default" id="moveVM">' + _("Move") + "</button>",
                function() {
                    var total = sel.length;
                    $("#moveVM").click(function() {
                        $("#moveVM").prop("disabled",true);
                        async.forEachOf(sel, function (v, i, callback) {
                            self.moveVoicemail(v.msg_id, $("#VMmove").val(), extension, function(data) {
                                if(data.status) {
                                    $("div[data-id='"+widget_id+"'] .voicemail-grid").bootstrapTable('remove', {field: "msg_id", values: [String(v.msg_id)]});
                                }
                                callback();
                            })
                        }, function(err) {
                            if( err ) {
                                $("#moveVM").prop("disabled",false);
                                UCP.showAlert(err);
                            } else {
                                UCP.closeDialog();
                            }
                        });
                    });
                    $("#VMmove").keypress(function(event) {
                        if (event.keyCode == 13) {
                            $("#moveVM").prop("disabled",true);
                            async.forEachOf(sel, function (v, i, callback) {
                                self.moveVoicemail(v.msg_id, $("#VMmove").val(), extension, function(data) {
                                    if(data.status) {
                                        $("div[data-id='"+widget_id+"'] .voicemail-grid").bootstrapTable('remove', {field: "msg_id", values: [String(v.msg_id)]});
                                    }
                                    callback();
                                })
                            }, function(err) {
                                if( err ) {
                                    $("#moveVM").prop("disabled",false);
                                    UCP.showAlert(err);
                                } else {
                                    UCP.closeDialog();
                                }
                            });
                        }
                    });
                }
            );
        });
        $("div[data-id='"+widget_id+"'] .delete-selection").click(function() {
            UCP.showConfirm(_("Are you sure you wish to delete these voicemails?"),'warning',function() {
                var extension = $("div[data-id='"+widget_id+"']").data("widget_type_id");
                var sel = $("div[data-id='"+widget_id+"'] .voicemail-grid").bootstrapTable('getAllSelections');
                async.forEachOf(sel, function(v, i, callback){
                    self.deleteVoicemail(v.msg_id, extension, function(data) {
                        if(data.status) {
                            $("div[data-id='"+widget_id+"'] .voicemail-grid").bootstrapTable('remove', {field: "msg_id", values: [String(v.msg_id)]});
                        }
                        callback();
                    })
                }, function(err) {
                    if( err ) {
                        UCP.showAlert(err);
                    }
                });
                $("#delete-selection").prop("disabled",true);
            });
        });
        $("div[data-id='"+widget_id+"'] .forward-selection").click(function() {
            var sel = $("div[data-id='"+widget_id+"'] .voicemail-grid").bootstrapTable('getAllSelections');
            UCP.showDialog(_("Forward Voicemail"),
                _("To")+":</label><input type='text' class='form-control' id='VMto'>",
                '<button class="btn btn-default" id="forwardVM">' + _("Forward") + "</button>",
                function() {
                    $("#forwardVM").click(function() {
                        setTimeout(function() {
                            var recpt = $("#VMto").val();
                            $.each(sel, function(i, v){
                                self.forwardVoicemail(v.msg_id,extension,recpt, function(data) {
                                    if(data.status) {
                                        UCP.showAlert(sprintf(_("Successfully forwarded voicemail to %s"),recpt));
                                        $("div[data-id='"+widget_id+"'] .voicemail-grid").bootstrapTable('uncheckAll');
                                        UCP.closeDialog();
                                    }
                                });
                            });
                        }, 50);
                    });
                    $("#VMto").keypress(function(event) {
                        if (event.keyCode == 13) {
                            var recpt = $("#VMto").val();
                            $.each(sel, function(i, v){
                                self.forwardVoicemail(v.msg_id,extension,recpt, function(data) {
                                    if(data.status) {
                                        UCP.showAlert(sprintf(_("Successfully forwarded voicemail to %s"),recpt));
                                        $("div[data-id='"+widget_id+"'] .voicemail-grid").bootstrapTable('uncheckAll');
                                        UCP.closeDialog();
                                    }
                                });
                            });
                        }
                    });
                }
            );
        });


        $("div[data-id='"+widget_id+"'] .voicemail-grid .clickable").click(function(e) {
            var text = $(this).text();
            if (UCP.validMethod("Contactmanager", "showActionDialog")) {
                UCP.Modules.Contactmanager.showActionDialog("number", text, "phone");
            }
        });
    },
    greetingsDisplay: function(extension) {
        var self = this;
        $("#widget_settings .recording-controls .save").click(function() {
            var id = $(this).data("id");
            self.saveRecording(extension,id);
        });
        $("#widget_settings .recording-controls .delete").click(function() {
            var id = $(this).data("id");
            self.deleteRecording(extension,id);
        });
        $("#widget_settings .file-controls .record, .jp-record").click(function() {
            var id = $(this).data("id");
            self.recordGreeting(extension,id);
        });
        $("#widget_settings .file-controls .delete").click(function() {
            var id = $(this).data("id");
            self.deleteGreeting(extension,id);
        });
        $("#widget_settings .filedrop").on("dragover", function(event) {
            if (event.preventDefault) {
                event.preventDefault(); // Necessary. Allows us to drop.
            }
            $(this).addClass("hover");
        });
        $("#widget_settings .filedrop").on("dragleave", function(event) {
            $(this).removeClass("hover");
        });

        $("#widget_settings .greeting-control .jp-audio-freepbx").on("dragstart", function(event) {
            event.originalEvent.dataTransfer.effectAllowed = "move";
            event.originalEvent.dataTransfer.setData("type", $(this).data("type"))
            $(this).fadeTo( "fast", 0.5);
        });
        $("#widget_settings .greeting-control .jp-audio-freepbx").on("dragend", function(event) {
            $(this).fadeTo( "fast", 1.0);
        });
        $("#widget_settings .filedrop").on("drop", function(event) {
            if (event.originalEvent.dataTransfer.files.length === 0) {
                if (event.stopPropagation) {
                    event.stopPropagation(); // Stops some browsers from redirecting.
                }
                if (event.preventDefault) {
                    event.preventDefault(); // Necessary. Allows us to drop.
                }
                $(this).removeClass("hover");
                var target = $(this).data("type"),
                    source = event.originalEvent.dataTransfer.getData("type");
                if (source === "") {
                    alert(_("Not a valid Draggable Object"));
                    return false;
                }
                if (source == target) {
                    alert(_("Dragging to yourself is not allowed"));
                    return false;
                }
                var data = { ext: extension, source: source, target: target },
                    message = $(this).find(".message");
                message.text(_("Copying..."));
                $.post( UCP.ajaxUrl + "?module=voicemail&command=copy", data, function( data ) {
                    if (data.status) {
                        $("#"+target+" .filedrop .pbar").css("width", "0%");
                        $("#"+target+" .filedrop .message").text($("#"+target+" .filedrop .message").data("message"));
                        $("#freepbx_player_" + target).removeClass("greet-hidden");
                        self.toggleGreeting(target, true);
                    } else {
                        return false;
                    }
                });
            } else {}
        });
        $("#widget_settings .greeting-control").each(function() {
            var id = $(this).attr("id");
            $("#"+id+" input[type=\"file\"]").fileupload({
                url: UCP.ajaxUrl + "?module=voicemail&command=upload&type="+id+"&ext=" + extension,
                dropZone: $("#"+id+" .filedrop"),
                dataType: "json",
                add: function(e, data) {
                    //TODO: Need to check all supported formats
                    var sup = "\.("+self.staticsettings.supportedRegExp+")$",
                        patt = new RegExp(sup),
                        submit = true;
                    $.each(data.files, function(k, v) {
                        if(!patt.test(v.name)) {
                            submit = false;
                            UCP.showAlert(_("Unsupported file type"));
                            return false;
                        }
                    });
                    if(submit) {
                        $("#"+id+" .filedrop .message").text(_("Uploading..."));
                        data.submit();
                    }
                },
                done: function(e, data) {
                    if (data.result.status) {
                        $("#"+id+" .filedrop .pbar").css("width", "0%");
                        $("#"+id+" .filedrop .message").text($("#"+id+" .filedrop .message").data("message"));
                        $("#freepbx_player_"+id).removeClass("greet-hidden");
                        self.toggleGreeting(id, true);
                    } else {
                        console.warn(data.result.message);
                    }
                },
                progressall: function(e, data) {
                    var progress = parseInt(data.loaded / data.total * 100, 10);
                    $("#"+id+" .filedrop .pbar").css("width", progress + "%");
                },
                drop: function(e, data) {
                    $("#"+id+" .filedrop").removeClass("hover");
                }
            });
        });
        //If browser doesnt support get user media requests then just hide it from the display
        if (!Modernizr.getusermedia) {
            $("#widget_settings .jp-record-wrapper").hide();
            $("#widget_settings .record-greeting-btn").hide();
        } else {
            $("#widget_settings .jp-record-wrapper").show();
            $("#widget_settings .jp-stop-wrapper").hide();
            $("#widget_settings .record-greeting-btn").show();
        }
    },
    //Delete a voicemail greeting
    deleteGreeting: function(extension,type) {
        var self = this, data = { msg: type, ext: extension };
        $.post( UCP.ajaxUrl + "?module=voicemail&command=delete", data, function( data ) {
            if (data.status) {
                $("#freepbx_player_" + type).jPlayer( "clearMedia" );
                self.toggleGreeting(type, false);
            } else {
                return false;
            }
        });
    },
    refreshFolderCount: function(extension) {
        var data = {
            ext: extension
        };
        $.post( UCP.ajaxUrl + "?module=voicemail&command=refreshfoldercount", data, function( data ) {
            if(data.status) {
                window.update_table = false;
                $.each(data.folders, function(i,v) {
                    cur_val = $(".grid-stack-item[data-rawname='voicemail'][data-widget_type_id="+extension+"] .mailbox .folder-list .folder[data-name='"+v.name+"'] .badge").text();
                    if(cur_val != v.count){
                        window.update_table = true;
                    }
                    $(".grid-stack-item[data-rawname='voicemail'][data-widget_type_id="+extension+"] .mailbox .folder-list .folder[data-name='"+v.name+"'] .badge").text(v.count);

                });
            }
        });
    },
    moveVoicemail: function(msgid, folder, extension, callback) {
        var data = {
                msg: msgid,
                folder: folder,
                ext: extension
            },
            self = this;
        $.post( UCP.ajaxUrl + "?module=voicemail&command=moveToFolder", data, function(data) {
            self.refreshFolderCount(extension);
            if(typeof callback === "function") {
                callback(data);
            }
        }).fail(function() {
            if(typeof callback === "function") {
                callback({status: false});
            }
        });
    },
    forwardVoicemail: function(msgid, extension, recpt, callback) {
        var data = {
            id: msgid,
            to: recpt
        };
        $.post( UCP.ajaxUrl + "?module=voicemail&command=forward&ext="+extension, data, function(data) {
            if(typeof callback === "function") {
                callback(data);
            }
        }).fail(function() {
            if(typeof callback === "function") {
                callback({status: false});
            }
        });
    },
    //Used to delete a voicemail message
    deleteVoicemail: function(msgid, extension, callback) {
        var data = {
                msg: msgid,
                ext: extension
            },
            self = this;

        $.post( UCP.ajaxUrl + "?module=voicemail&command=delete", data, function( data ) {
            self.refreshFolderCount(extension);
            if(typeof callback === "function") {
                callback(data);
            }
        }).fail(function() {
            if(typeof callback === "function") {
                callback({status: false});
            }
        });
    },
    //Toggle the html5 player for greeting
    toggleGreeting: function(type, visible) {
        if (visible === true) {
            $("#" + type + " button.delete").show();
            $("#jp_container_" + type).removeClass("greet-hidden");
            $("#freepbx_player_"+ type).jPlayer( "clearMedia" );
        } else {
            $("#" + type + " button.delete").hide();
            $("#jp_container_" + type).addClass("greet-hidden");
        }
    },
    //Save Voicemail Settings
    saveVMSettings: function(extension) {
        $("#message").fadeOut("slow");
        var data = { ext: extension };
        $("div[data-rawname='voicemail'] .widget-settings-content input[type!='checkbox']").each(function( index ) {
            data[$( this ).attr("name")] = $( this ).val();
        });
        $("div[data-rawname='voicemail'] .widget-settings-content input[type='checkbox']").each(function( index ) {
            data[$( this ).attr("name")] = $( this ).is(":checked");
        });
        $.post( UCP.ajaxUrl + "?module=voicemail&command=savesettings", data, function( data ) {
            if (data.status) {
                $("#message").addClass("alert-success");
                $("#message").text(_("Your settings have been saved"));
                $("#message").fadeIn( "slow", function() {
                    setTimeout(function() { $("#message").fadeOut("slow"); }, 2000);
                });
            } else {
                $("#message").addClass("alert-error");
                $("#message").text(data.message);
                return false;
            }
        });
    },
    recordGreeting: function(extension,type) {
        var self = this;
        if (!Modernizr.getusermedia) {
            UCP.showAlert(_("Direct Media Recording is Unsupported in your Broswer!"));
            return false;
        }
        counter = $("#jp_container_" + type + " .jp-current-time");
        title = $("#jp_container_" + type + " .title-text");
        filec = $("#" + type + " .file-controls");
        recc = $("#" + type + " .recording-controls");
        var controls = $("#jp_container_" + type + " .jp-controls");
        controls.toggleClass("recording");
        if (self.recording) {
            clearInterval(self.recordTimer);
            title.text(_("Recorded Message"));
            self.recorder.stop();
            self.recorder.exportWAV(function(blob) {
                self.soundBlobs[type] = blob;
                var url = (window.URL || window.webkitURL).createObjectURL(blob);
                $("#freepbx_player_" + type).jPlayer( "clearMedia" );
                $("#freepbx_player_" + type).jPlayer( "setMedia", {
                    wav: url
                });
            });
            self.recording = false;
            recc.show();
            filec.hide();
        } else {
            window.AudioContext = window.AudioContext || window.webkitAudioContext;

            var context = new AudioContext();

            var gUM = Modernizr.prefixed("getUserMedia", navigator);
            gUM({ audio: true }, function(stream) {
                var mediaStreamSource = context.createMediaStreamSource(stream);
                self.recorder = new Recorder(mediaStreamSource,{ workerPath: "assets/js/recorderWorker.js" });
                self.recorder.record();
                self.startTime = new Date();
                self.recordTimer = setInterval(function () {
                    var mil = (new Date() - self.startTime);
                    var temp = (mil / 1000);
                    var min = ("0" + Math.floor((temp %= 3600) / 60)).slice(-2);
                    var sec = ("0" + Math.round(temp % 60)).slice(-2);
                    counter.text(min + ":" + sec);
                }, 1000);
                title.text(_("Recording..."));
                self.recording = true;
                $("#jp_container_" + type).removeClass("greet-hidden");
                recc.hide();
                filec.show();
            }, function(e) {
                UCP.showAlert(_("Your Browser Blocked The Recording, Please check your settings"));
                self.recording = false;
            });
        }
    },
    saveRecording: function(extension,type) {
        var self = this,
            filec = $("#" + type + " .file-controls"),
            recc = $("#" + type + " .recording-controls");
        title = $("#" + type + " .title-text");
        if (self.recording) {
            UCP.showAlert(_("Stop the Recording First before trying to save"));
            return false;
        }
        if ((typeof(self.soundBlobs[type]) !== "undefined") && self.soundBlobs[type] !== null) {
            $("#" + type + " .filedrop .message").text(_("Uploading..."));
            var data = new FormData();
            data.append("file", self.soundBlobs[type]);
            $.ajax({
                type: "POST",
                url: UCP.ajaxUrl + "?module=voicemail&command=record&type=" + type + "&ext=" + extension,
                xhr: function()
                {
                    var xhr = new window.XMLHttpRequest();
                    //Upload progress
                    xhr.upload.addEventListener("progress", function(evt) {
                        if (evt.lengthComputable) {
                            var percentComplete = evt.loaded / evt.total,
                                progress = Math.round(percentComplete * 100);
                            $("#" + type + " .filedrop .pbar").css("width", progress + "%");
                        }
                    }, false);
                    return xhr;
                },
                data: data,
                processData: false,
                contentType: false,
                success: function(data) {
                    $("#" + type + " .filedrop .message").text($("#" + type + " .filedrop .message").data("message"));
                    $("#" + type + " .filedrop .pbar").css("width", "0%");
                    self.soundBlobs[type] = null;
                    $("#freepbx_player_" + type).jPlayer("supplied",self.staticsettings.supportedHTML5);
                    $("#freepbx_player_" + type).jPlayer( "clearMedia" );
                    title.text(title.data("title"));
                    filec.show();
                    recc.hide();
                },
                error: function() {
                    //error
                    filec.show();
                    recc.hide();
                }
            });
        }
    },
    deleteRecording: function(extension,type) {
        var self = this,
            filec = $("#" + type + " .file-controls"),
            recc = $("#" + type + " .recording-controls");
        if (self.recording) {
            UCP.showAlert(_("Stop the Recording First before trying to delete"));
            return false;
        }
        if ((typeof(self.soundBlobs[type]) !== "undefined") && self.soundBlobs[type] !== null) {
            self.soundBlobs[type] = null;
            $("#freepbx_player_" + type).jPlayer("supplied",self.staticsettings.supportedHTML5);
            $("#freepbx_player_" + type).jPlayer( "clearMedia" );
            title.text(title.data("title"));
            filec.show();
            recc.hide();
            self.toggleGreeting(type, false);
        } else {
            UCP.showAlert(_("There is nothing to delete"));
        }
    },
    //This function is here solely because firefox caches media downloads so we have to force it to not do that
    generateRandom: function() {
        return Math.round(new Date().getTime() / 1000);
    },
    dateFormatter: function(value, row, index) {
        return UCP.dateTimeFormatter(value);
    },
    listenVoicemail: function(msgid, extension, recpt) {
        var data = {
            id: msgid,
            to: recpt
        };
        $.post( UCP.ajaxUrl + "?module=voicemail&command=callme&ext="+extension, data, function( data ) {
            UCP.closeDialog();
        });
    },
    playbackFormatter: function (value, row, index) {
        var settings = UCP.Modules.Voicemail.staticsettings,
            rand = Math.floor(Math.random() * 10000);
        if(settings.showPlayback == "0" || row.duration === 0) {
            return '';
        }
        return '<div id="jquery_jplayer_'+row.msg_id+'-'+rand+'" class="jp-jplayer" data-container="#jp_container_'+row.msg_id+'-'+rand+'" data-id="'+row.msg_id+'"></div><div id="jp_container_'+row.msg_id+'-'+rand+'" data-player="jquery_jplayer_'+row.msg_id+'-'+rand+'" class="jp-audio-freepbx" role="application" aria-label="media player">'+
            '<div class="jp-type-single">'+
            '<div class="jp-gui jp-interface">'+
            '<div class="jp-controls">'+
            '<i class="fa fa-play jp-play"></i>'+
            '<i class="fa fa-undo jp-restart"></i>'+
            '</div>'+
            '<div class="jp-progress">'+
            '<div class="jp-seek-bar progress">'+
            '<div class="jp-current-time" role="timer" aria-label="time">&nbsp;</div>'+
            '<div class="progress-bar progress-bar-striped active" style="width: 100%;"></div>'+
            '<div class="jp-play-bar progress-bar"></div>'+
            '<div class="jp-play-bar">'+
            '<div class="jp-ball"></div>'+
            '</div>'+
            '<div class="jp-duration" role="timer" aria-label="duration">&nbsp;</div>'+
            '</div>'+
            '</div>'+
            '<div class="jp-volume-controls">'+
            '<i class="fa fa-volume-up jp-mute"></i>'+
            '<i class="fa fa-volume-off jp-unmute"></i>'+
            '</div>'+
            '</div>'+
            '<div class="jp-no-solution">'+
            '<span>Update Required</span>'+
            sprintf(_("You are missing support for playback in this browser. To fully support HTML5 browser playback you will need to install programs that can not be distributed with the PBX. If you'd like to install the binaries needed for these conversions click <a href='%s'>here</a>"),"http://wiki.freepbx.org/display/FOP/Installing+Media+Conversion+Libraries")+
            '</div>'+
            '</div>'+
            '</div>';
    },
    durationFormatter: function (value, row, index) {
        return (typeof UCP.durationFormatter === 'function') ? UCP.durationFormatter(value) : sprintf(_("%s seconds"),value);
    },
    controlFormatter: function (value, row, index) {
        var html = '<a class="listen" alt="'+_('Listen on your handset')+'" data-id="'+row.msg_id+'"><i class="fa fa-phone"></i></a>'+
            '<a class="forward" alt="'+_('Forward')+'" data-id="'+row.msg_id+'"><i class="fa fa-share"></i></a>';
        var settings = UCP.Modules.Voicemail.staticsettings;
        if(settings.showDownload == "1") {
            html += '<a class="download" alt="'+_('Download')+'" href="'+ UCP.ajaxUrl +'?module=voicemail&amp;command=download&amp;msgid='+row.msg_id+'&amp;ext='+row.origmailbox+'"><i class="fa fa-cloud-download"></i></a>';
        }

        html += '<a class="delete" alt="'+_('Delete')+'" data-id="'+row.msg_id+'"><i class="fa fa-trash-o"></i></a>';

        return html;
    },
    bindPlayers: function(widget_id) {
        var extension = $("div[data-id='"+widget_id+"']").data("widget_type_id");
        $(".grid-stack-item[data-id="+widget_id+"] .jp-jplayer").each(function() {
            var container = $(this).data("container"),
                player = $(this),
                msg_id = $(this).data("id");
            $(this).jPlayer({
                ready: function() {
                    $(container + " .jp-play").click(function() {
                        if($(this).parents(".jp-controls").hasClass("recording")) {
                            var type = $(this).parents(".jp-audio-freepbx").data("type");
                            self.recordGreeting(extension,type);
                            return;
                        }
                        if(!player.data("jPlayer").status.srcSet) {
                            $(container).addClass("jp-state-loading");
                            $.ajax({
                                type: 'POST',
                                url: UCP.ajaxUrl,
                                data: {module: "voicemail", command: "gethtml5", msg_id: msg_id, ext: extension},
                                dataType: 'json',
                                timeout: 30000,
                                success: function(data) {
                                    if(data.status) {
                                        player.on($.jPlayer.event.error, function(event) {
                                            $(container).removeClass("jp-state-loading");
                                            console.warn(event);
                                        });
                                        player.one($.jPlayer.event.canplay, function(event) {
                                            $(container).removeClass("jp-state-loading");
                                            player.jPlayer("play");
                                        });
                                        player.jPlayer( "setMedia", data.files);
                                    } else {
                                        UCP.showAlert(data.message);
                                        $(container).removeClass("jp-state-loading");
                                    }
                                }
                            });
                        }
                    });
                    var self = this;
                    $(container).find(".jp-restart").click(function() {
                        if($(self).data("jPlayer").status.paused) {
                            $(self).jPlayer("pause",0);
                        } else {
                            $(self).jPlayer("play",0);
                        }
                    });
                },
                timeupdate: function(event) {
                    $(container).find(".jp-ball").css("left",event.jPlayer.status.currentPercentAbsolute + "%");
                },
                ended: function(event) {
                    $(container).find(".jp-ball").css("left","0%");
                },
                swfPath: "/js",
                supplied: UCP.Modules.Voicemail.staticsettings.supportedHTML5,
                cssSelectorAncestor: container,
                wmode: "window",
                useStateClassSkin: true,
                remainingDuration: true,
                toggleDuration: true
            });
            $(this).on($.jPlayer.event.play, function(event) {
                $(this).jPlayer("pauseOthers");
            });
        });

        var acontainer = null;
        $('.grid-stack-item[data-rawname=voicemail] .jp-play-bar').mousedown(function (e) {
            acontainer = $(this).parents(".jp-audio-freepbx");
            updatebar(e.pageX);
        });
        $(document).mouseup(function (e) {
            if (acontainer) {
                updatebar(e.pageX);
                acontainer = null;
            }
        });
        $(document).mousemove(function (e) {
            if (acontainer) {
                updatebar(e.pageX);
            }
        });

        //update Progress Bar control
        var updatebar = function (x) {
            var player = $("#" + acontainer.data("player")),
                progress = acontainer.find('.jp-progress'),
                maxduration = player.data("jPlayer").status.duration,
                position = x - progress.offset().left,
                percentage = 100 * position / progress.width();

            //Check within range
            if (percentage > 100) {
                percentage = 100;
            }
            if (percentage < 0) {
                percentage = 0;
            }

            player.jPlayer("playHead", percentage);

            //Update progress bar and video currenttime
            acontainer.find('.jp-ball').css('left', percentage+'%');
            acontainer.find('.jp-play-bar').css('width', percentage + '%');
            player.jPlayer.currentTime = maxduration * percentage / 100;
        };
    },
    bindGreetingPlayers: function(extension) {
        var settings = UCP.Modules.Voicemail.staticsettings,
            supportedHTML5 = settings.supportedHTML5,
            self = this;

        if(Modernizr.getusermedia) {
            supportedHTML5 = supportedHTML5.split(",");
            if(supportedHTML5.indexOf("wav") === -1) {
                supportedHTML5.push("wav");
            }
            supportedHTML5 = supportedHTML5.join(",");
        }

        $("#widget_settings .jp-jplayer, .grid-stack-item[data-rawname=voicemail] .jp-jplayer").each(function() {
            var container = $(this).data("container"),
                player = $(this),
                msg_id = $(this).data("id");
            $(this).jPlayer({
                ready: function() {
                    $(container + " .jp-play").click(function() {
                        if($(this).parents(".jp-controls").hasClass("recording")) {
                            var type = $(this).parents(".jp-audio-freepbx").data("type");
                            self.recordGreeting(extension,type);
                            return;
                        }
                        if(!player.data("jPlayer").status.srcSet) {
                            $(container).addClass("jp-state-loading");
                            $.ajax({
                                type: 'POST',
                                url: UCP.ajaxUrl,
                                data: {module: "voicemail", command: "gethtml5", msg_id: msg_id, ext: extension},
                                dataType: 'json',
                                timeout: 30000,
                                success: function(data) {
                                    if(data.status) {
                                        player.on($.jPlayer.event.error, function(event) {
                                            $(container).removeClass("jp-state-loading");
                                            console.warn(event);
                                        });
                                        player.one($.jPlayer.event.canplay, function(event) {
                                            $(container).removeClass("jp-state-loading");
                                            player.jPlayer("play");
                                        });
                                        player.jPlayer( "setMedia", data.files);
                                    } else {
                                        UCP.showAlert(data.message);
                                        $(container).removeClass("jp-state-loading");
                                    }
                                }
                            });
                        }
                    });
                    var self = this;
                    $(container).find(".jp-restart").click(function() {
                        if($(self).data("jPlayer").status.paused) {
                            $(self).jPlayer("pause",0);
                        } else {
                            $(self).jPlayer("play",0);
                        }
                    });
                },
                timeupdate: function(event) {
                    $(container).find(".jp-ball").css("left",event.jPlayer.status.currentPercentAbsolute + "%");
                },
                ended: function(event) {
                    $(container).find(".jp-ball").css("left","0%");
                },
                swfPath: "/js",
                supplied: supportedHTML5,
                cssSelectorAncestor: container,
                wmode: "window",
                useStateClassSkin: true,
                remainingDuration: true,
                toggleDuration: true
            });
            $(this).on($.jPlayer.event.play, function(event) {
                $(this).jPlayer("pauseOthers");
            });
        });

        var acontainer = null;
        $('#widget_settings .jp-play-bar, .grid-stack-item[data-rawname=voicemail] .jp-play-bar').mousedown(function (e) {
            acontainer = $(this).parents(".jp-audio-freepbx");
            updatebar(e.pageX);
        });
        $(document).mouseup(function (e) {
            if (acontainer) {
                updatebar(e.pageX);
                acontainer = null;
            }
        });
        $(document).mousemove(function (e) {
            if (acontainer) {
                updatebar(e.pageX);
            }
        });

        //update Progress Bar control
        var updatebar = function (x) {
            var player = $("#" + acontainer.data("player")),
                progress = acontainer.find('.jp-progress'),
                maxduration = player.data("jPlayer").status.duration,
                position = x - progress.offset().left,
                percentage = 100 * position / progress.width();

            //Check within range
            if (percentage > 100) {
                percentage = 100;
            }
            if (percentage < 0) {
                percentage = 0;
            }

            player.jPlayer("playHead", percentage);

            //Update progress bar and video currenttime
            acontainer.find('.jp-ball').css('left', percentage+'%');
            acontainer.find('.jp-play-bar').css('width', percentage + '%');
            player.jPlayer.currentTime = maxduration * percentage / 100;
        };
    }
});

var WebrtcC = UCPMC.extend({
    init: function() {
        this.phone = null;
        this.activeCalls = {};
        this.activeCallId = null;
        this.answering = false;
        this.userBlocked = false;
        this.silenced = false;
        this.autoRegister = false;
        this.displayState = null;
        this.state = null;
        this.timerObject = null;
        this.callBinds = [
            "progress",
            "accepted",
            "rejected",
            "failed",
            "terminated",
            "cancel",
            "refer",
            "replaced",
            "dtmf",
            "muted",
            "unmuted",
            "bye",
            "addStream"
        ];

        this.callOptions = {
            "media": {
                "constraints": {
                    "audio": true,
                    "video": false
                },
                "render": {
                    "remote": null
                }
            }
        };

        this.notification = null;
        var st = Cookies.get("webrtc-silenced");
        st = (st === "1") ? true : false;
        this.silence(st);

        var rg = Cookies.get("webrtc-register");
        this.autoRegister = (typeof rg === "undefined" || rg === "1") ? true : false;
    },
    settingsDisplay: function() {

    },
    settingsHide: function() {

    },
    addSimpleWidget: function(widget_id) {
        this.initiateLibrary();
    },
    displaySimpleWidgetSettings: function(widget_id) {
        var $this = this;

        var st = Cookies.get("webrtc-silenced");
        st = (st === "1") ? true : false;

        $("#webrtc-silence-switch").prop("checked",st);

        $("#webrtc-silence-switch").bootstrapToggle('destroy');
        $("#webrtc-silence-switch").bootstrapToggle({
            on: _("Enable"),
            off: _("Disable")
        });

        $("#webrtc-disconnect-switch").prop("checked",!this.autoRegister);

        $("#webrtc-disconnect-switch").bootstrapToggle('destroy');
        $("#webrtc-disconnect-switch").bootstrapToggle({
            on: _("Enable"),
            off: _("Disable")
        });

        if(this.phone === null) {
            $("#webrtc-silence-switch").bootstrapToggle('disable');
            $("#webrtc-disconnect-switch").bootstrapToggle('disable');
            return;
        }

        $("#webrtc-silence-switch").change(function() {
            $this.silence();
        });
        $("#webrtc-disconnect-switch").change(function(e) {
            $this.toggleRegister();
        });
    },
    displaySimpleWidget: function(widget_id) {
        var $this = this;
        $("#menu_webrtc_phone .status span").text(this.displayState);

        if(this.phone === null) {
            $("#menu_webrtc_phone input.dialpad").prop("disabled",true);
            return;
        }

        if(this.state == "hold") {
            this.switchState('accepted');
            this.switchState('hold');
        } else {
            this.switchState(this.state);
        }

        if(typeof this.phone === "object" && this.phone !== null && this.phone.isRegistered()) {
            $("#menu_webrtc_phone .action").prop("disable",false);
        }

        $("#menu_webrtc_phone .keypad td").click(function() {
            var text = $("#menu_webrtc_phone .dialpad").val() + $(this).data("num"),
                button = $("#menu_webrtc_phone button.action");
            if ($this.state == "registered" || $this.state == "accepted") {
                if ($this.state == "registered") {
                    $( "#menu_webrtc_phone .message").text("To: " + text);
                }
                $("#menu_webrtc_phone .dialpad").val(text);
                $this.DTMF($(this).data("num"));
                button.prop("disabled", false);
                $("#menu_webrtc_phone .message-container").textfill();
            }
        });

        $("#menu_webrtc_phone .clear-input").click(function() {
            var button = $("#menu_webrtc_phone button.action");
            $("#menu_webrtc_phone .dialpad").val("");
            if ($this.state == "registered") {
                $( "#menu_webrtc_phone .message").text("");
                button.prop("disabled", true);
            }
        });
        $("#menu_webrtc_phone .dialpad").on('keyup paste', function() {
            var button = $("#menu_webrtc_phone button.action"),
                text = $("#menu_webrtc_phone .dialpad").val();
            if ($(this).val().length === 0 && ($this.state == "accepted" || $this.state == "registered")) {
                $( "#menu_webrtc_phone .message").text("");
                button.prop("disabled", true);
            } else {
                $( "#menu_webrtc_phone .message").text("To: " + text);
                $this.DTMF(text.slice(-1));
                button.prop("disabled", false);
            }
            $("#menu_webrtc_phone .message-container").textfill();
        });
        $("#menu_webrtc_phone button.action").click(function() {
            switch ($this.state) {
                case "registered":
                    $this.call($("#menu_webrtc_phone .dialpad").val());
                    break;
                case "hold":
                case "accepted":
                    $this.hangup();
                    break;
                case "invite":
                    $this.answer();
                    break;
            }
        });
        $("#menu_webrtc_phone button.secondaction").click(function() {
            switch ($this.state) {
                case "hold":
                case "accepted":
                    $this.toggleHold();
                    break;
                case "invite":
                    $this.hangup();
                    break;
            }
        });
        $("#menu_webrtc_phone .message-container").textfill();
    },
    deleteSimpleWidget: function(widget_id) {
        if(this.phone !== null) {
            this.disconnect();
        }
    },
    engineEvent: function(type, event) {
        console.log("Engine " + type);
        switch (type){
            case "invite":
                this.manageSession(event,"inbound");
                this.switchState("invite");
                break;
            case "registered":
                this.switchState("registered");
                break;
            case "unregistered":
                this.switchState("unregistered");
                break;
            case "registrationFailed":
                this.switchState("registrationfailed");
                break;
            case "connected":
                this.switchState("connected");
                break;
            case "disconnected":
                this.switchState("disconnected");
                break;
            case "connecting":
                this.switchState("connecting");
                break;
            case "registering": //custom event type
                this.switchState("registering");
                break;
        }
    },
    setDisplayState: function(state) {
        this.displayState = state;
        $("#menu_webrtc_phone .status span").text(this.displayState);
    },
    playRing: function() {
        if(!this.silenced) {
            $("#ringtone").trigger("play");
        }
    },
    stopRing: function() {
        $("#ringtone").trigger("pause");
        $("#ringtone").trigger("load");
    },
    manageSession: function(session, direction) {
        var Webrtc = this,
            id,
            displayName,
            status,
            cnum,
            cnam,
            call = session;

        id = Math.floor((Math.random() * 100000) + 1);
        // If the session exists with active call reject it.
        // TODO this can be useful for call waiting
        if (this.activeCallId) {
            call.terminate();
            return false;
        }

        // If this is a new session create it
        if (!this.activeCallId) {
            this.activeCallId = id;
            this.activeCalls[id] = call;
        }

        cnum = this.activeCalls[id].remoteIdentity.uri.user;
        cnam = this.activeCalls[this.activeCallId].remoteIdentity.displayName || "";
        displayName = (cnam !== "") ? cnam + " <" + cnum + ">" : cnum;
        $("#menu_webrtc_phone .contactDisplay .contactImage").css("background-image",'url("?quietmode=1&module=Webrtc&command=cimage&did='+cnum+'")');
        Webrtc.answering = false;
        if (direction === "inbound") {
            if (UCP.notify) {
                this.notification = new Notify(sprintf(_("Incoming call from %s"), displayName), {
                    body: _("Click this window to answer or close this window to ignore"),
                    icon: "modules/Webrtc/assets/images/no_user_logo.png", //TODO: get the user logo
                    notifyClose: function() {
                        if (Webrtc.answering) {
                            Webrtc.answering = false;
                        } else {
                            Webrtc.hangup();
                        }
                    },
                    notifyClick: function() {
                        Webrtc.answering = true;
                        Webrtc.answer();
                        $(".custom-widget[data-widget_rawname=webrtc]").click();
                        Webrtc.notification.close();
                    }
                });
                this.notification.show();
            }
        }

        $.each(this.callBinds, function(i, v) {
            Webrtc.activeCalls[Webrtc.activeCallId].on(v, function(data, cause) {
                Webrtc.sessionEvent(v, data, cause);
            });
        });
    },
    sessionEvent: function(type, data, cause) {
        console.log("Session " + type);
        switch (type){
            case "terminated":
                this.switchState("terminated");
                this.endCall(data, cause);
                break;
            case "accepted":
                this.switchState("accepted");
                this.startCall(data);
                break;
            case "progress":
                this.switchState("progress");
                break;
            case "dtmf":
                this.switchState("dtmf");
                break;
            case "muted":
                this.switchState("muted");
                break;
            case "unmuted":
                this.switchState("unmuted");
                break;
        }
    },
    endCall: function(message, cause) {
        this.activeCalls[this.activeCallId] = null;
        this.activeCallId = null;
        if (this.notification !== null) {
            this.notification.close();
        }
        if(typeof cause !== "undefined" && cause === SIP.C.causes.USER_DENIED_MEDIA_ACCESS) {
            this.userBlocked = true;
        }
        $("#menu_webrtc_phone .btn-primary").prop("disabled", false);
        this.stopRing();
    },
    startCall: function(event) {
        if (this.notification !== null) {
            this.notification.close();
        }
        this.stopRing();
    },
    silence: function(state) {
        state = (typeof state !== "undefined") ? state : !this.silenced;
        if(!$("#webrtc-silence").length) {
            $(".custom-widget[data-widget_rawname=webrtc] .fa-phone").after('<i id="webrtc-silence" class="fa fa-ban fa-stack-2x hidden"></i>');
        }
        if(state) {
            this.stopRing();
            $("#webrtc-silence").removeClass("hidden");
            $("#webrtc-silence .fa-check").removeClass("hidden");
        } else {
            $("#webrtc-silence").addClass("hidden");
            $("#webrtc-silence .fa-check").addClass("hidden");
        }
        Cookies.set("webrtc-silenced",(state ? "1" : "0"));
        this.silenced = state;
    },
    call: function(number) {
        if (this.phone.isConnected() && !this.userBlocked) {
            $("#menu_webrtc_phone .btn-primary").prop("disabled", true);
            var session = this.phone.invite(number, this.callOptions);
            this.manageSession(session,"outbound");
        } else if(this.phone.isConnected() && this.userBlocked) {
            alert(_("Unable to start call. Please allow the WebRTC session in your browser and refresh"));
        }
    },
    answer: function() {
        if (this.activeCallId !== null) {
            this.answering = true;
            this.activeCalls[this.activeCallId].accept(this.callOptions);
        }
    },
    toggleHold: function() {
        if (this.activeCallId !== null) {
            var call = this.activeCalls[this.activeCallId],
                holds = this.activeCalls[this.activeCallId].isOnHold();
            if (!holds.local) {
                this.switchState("hold");
                call.hold();
            } else {
                this.switchState("unhold");
                call.unhold();
            }
        }
    },
    DTMF: function(num) {
        if (this.state == "accepted" && this.activeCallId !== null) {
            this.activeCalls[this.activeCallId].dtmf(num);
        }
    },
    hangup: function() {
        if ((this.state == "accepted" || this.state == "invite") && this.activeCallId !== null) {
            this.activeCalls[this.activeCallId].terminate();
        }
        this.stopRing();
    },
    poll: function(data) {

    },
    display: function(event) {

    },
    hide: function(event) {

    },
    switchState: function(t) {
        var button = $("#menu_webrtc_phone button.action"),
            secondbutton = $("#menu_webrtc_phone button.secondaction"),
            input = $("#menu_webrtc_phone input.dialpad"),
            type = (typeof t !== "undefined" && t !== null) ? t : "registered",
            $this = this;
        this.state = type;
        button.data("type", type);
        switch (type){
            case "dtmf":
                this.state = "accepted";
                break;
            case "invite":
                $(".custom-widget[data-widget_rawname=webrtc] .fa-phone").addClass("shake");
                this.playRing();
                $("#menu_webrtc_phone .activeCallSession .keypad").hide();
                $("#menu_webrtc_phone .activeCallSession .input-container").hide();
                $("#menu_webrtc_phone .contactDisplay").show();
                secondbutton.removeClass().addClass("btn btn-danger secondaction").text("Ignore");
                $("#menu_webrtc_phone .actions .right").show();
                button.removeClass().addClass("btn btn-success action").text("Answer");
                button.prop("disabled", false);
                break;
            case "hold":
                secondbutton.removeClass().addClass("btn btn-success secondaction").text("UnHold");
                secondbutton.css("background-color","orange");
                if(!$("#webrtc-hold").length) {
                    $(".custom-widget[data-widget_rawname=webrtc] .fa-phone").after('<i id="webrtc-hold" class="fa fa-pause fa-stack-2x blink hidden"></i>');
                }
                $("#webrtc-hold").removeClass("hidden");
                break;
            case "unhold":
                secondbutton.removeClass().addClass("btn btn-success secondaction").text("Hold");
                secondbutton.css("background-color","");
                if($("#webrtc-hold").length) {
                    $("#webrtc-hold").addClass("hidden");
                }

                this.state = "accepted";
                break;
            case "accepted":
                this.stopRing();
                $(".custom-widget[data-widget_rawname=webrtc] .fa-phone").removeClass("shake");
                $("#menu_webrtc_phone .contactDisplay").hide();
                $("#menu_webrtc_phone .activeCallSession .keypad").show();
                $("#menu_webrtc_phone .activeCallSession .input-container").show();
                secondbutton.removeClass().addClass("btn btn-success secondaction").text("Hold");
                secondbutton.css("color","");
                $("#menu_webrtc_phone .actions .right").show();

                input.prop("disabled", false);
                button.prop("disabled", false);
                button.removeClass().addClass("btn btn-danger action").text("Hangup");
                $("#menu_webrtc_phone .contact-info").addClass("in");
                $("#webrtc-timer-container").remove();
                clearInterval(this.timerObject);
                $('#webrtc-disconnect-switch').bootstrapToggle('disable');
                var updateTimer = function() {
                    if($this.activeCallId === null) {
                        clearInterval($this.timerObject);
                        $("#menu_webrtc_phone .contact-info").removeClass("in");
                        $('#webrtc-disconnect-switch').bootstrapToggle('enable');
                        return;
                    }
                    //
                    var start = moment($this.activeCalls[$this.activeCallId].startTime);
                    var end = moment();
                    var duration = moment.duration(end.diff(start));

                    var padLeft = function(nr){
                        return Array(2-String(nr).length+1).join('0')+nr;
                    };

                    var time = padLeft(duration.hours())+":"+padLeft(duration.minutes())+":"+padLeft(duration.seconds());

                    if($("#menu_webrtc_phone .contact-info .timer").is(":visible")) {
                        $("#menu_webrtc_phone .contact-info .timer").text(time);
                    } else {
                        if(!$("#webrtc-timer-container").length) {
                            $(".custom-widget[data-widget_rawname=webrtc] .fa-phone").after('<div id="webrtc-timer-container"><div class="timer">'+time+'</div></div>');
                        } else {
                            $("#webrtc-timer-container .timer").text(time);
                        }
                    }
                };
                updateTimer();
                this.timerObject = setInterval(updateTimer,1000);

                var cnam = this.activeCalls[this.activeCallId].remoteIdentity.displayName || "",
                    cnum = this.activeCalls[this.activeCallId].remoteIdentity.uri.user,
                    displayName = (cnam !== "") ? cnam + " <" + cnum + ">" : cnum;
                $("#menu_webrtc_phone .contact-info .contact").text(displayName);
                break;
            case "terminated":
                this.stopRing();
                $("#menu_webrtc_phone .actions .right").hide();
                $(".custom-widget[data-widget_rawname=webrtc] .fa-phone").removeClass("shake");
                $("#menu_webrtc_phone .activeCallSession .keypad").show();
                $("#menu_webrtc_phone .activeCallSession .input-container").show();
                $("#menu_webrtc_phone .contactDisplay").hide();
                button.removeClass().addClass("btn btn-primary action").text("Call");
                $("#menu_webrtc_phone .contact-info .contact").text("");
                this.state = "registered";
                break;
            case "registered":
                $(".custom-widget[data-widget_rawname=webrtc] .fa-phone").removeClass("registering");
                this.setDisplayState(_("Registered"));
                $(".custom-widget[data-widget_rawname=webrtc] .fa-phone").css("color", "green");
                input.prop("disabled", false);
                input.val("");
                $("#menu_webrtc_phone .keypad").removeClass("disable");
                button.prop("disabled", true);
                $("#menu_webrtc_phone .actions .right").hide();
                button.removeClass().addClass("btn btn-primary action").text("Call");
                break;
            case "unregistered":
                this.setDisplayState(_("Unregistered"));
                $(".custom-widget[data-widget_rawname=webrtc] .fa-phone").removeClass("registering");
                $(".custom-widget[data-widget_rawname=webrtc] .fa-phone").css("color", "yellow");
                $("#menu_webrtc_phone .keypad").addClass("disable");
                input.prop("disabled", true);
                input.val("");
                break;
            case "registrationfailed":
                this.setDisplayState(_("Registration Failed"));
                $(".custom-widget[data-widget_rawname=webrtc] .fa-phone").removeClass("registering");
                $("#webrtc-dc a span").text(_("Connect Phone"));
                $(".custom-widget[data-widget_rawname=webrtc] .fa-phone").css("color", "red");
                $("#menu_webrtc_phone .keypad").addClass("disable");
                input.prop("disabled", true);
                input.val("");
                break;
            case "connected":
                this.setDisplayState(_("Unregistered"));
                $(".custom-widget[data-widget_rawname=webrtc] .fa-phone").removeClass("connecting");
                $(".custom-widget[data-widget_rawname=webrtc] .fa-phone").css("color", "yellow");
                break;
            case "disconnected":
                this.setDisplayState(_("Disconnected"));
                $(".custom-widget[data-widget_rawname=webrtc] .fa-phone").removeClass("connecting");
                $(".custom-widget[data-widget_rawname=webrtc] .fa-phone").removeClass("registering");
                $(".custom-widget[data-widget_rawname=webrtc] .fa-phone").css("color", "red");
                $("#menu_webrtc_phone .keypad").addClass("disable");
                input.prop("disabled", true);
                input.val("");
                break;
            case "connecting":
                this.setDisplayState(_("Connecting to socket..."));
                $(".custom-widget[data-widget_rawname=webrtc] .fa-phone").css("color", "red");
                $(".custom-widget[data-widget_rawname=webrtc] .fa-phone").addClass("connecting");
                $(".custom-widget[data-widget_rawname=webrtc] .fa-phone").removeClass("registering");
                break;
            case "registering": //custom event type
                this.setDisplayState(_("Registering..."));
                $(".custom-widget[data-widget_rawname=webrtc] .fa-phone").addClass("registering");
                break;
        }
    },
    connect: function() {
        if ((typeof this.staticsettings !== "undefined") &&
            this.staticsettings.enabled &&
            Modernizr.getusermedia &&
            this.phone !== null &&
            !this.phone.isConnected()) {
            this.phone.start();
        }
    },
    disconnect: function() {
        if (this.phone !== null &&
            this.phone.isConnected()) {
            this.phone.stop();
        }
    },
    register: function() {
        if(!this.phone.isConnected()) {
            this.connect();
        }
        if (this.phone !== null &&
            !this.phone.isRegistered()) {
        }
        this.phone.register();
    },
    unregister: function() {
        if(!this.phone.isConnected()) {
            throw "Phone is not connected, nothing to register";
        }
        if (this.phone !== null &&
            this.phone.isRegistered()) {
        }
        this.phone.unregister();
    },
    toggleRegister: function() {
        if(!this.phone.isConnected()) {
            return; //nope
        }
        if($(".custom-widget[data-widget_rawname=webrtc] .fa-phone").hasClass("registering")) {
            return; //we are already doing something
        }
        if(!this.phone.isRegistered()) {
            this.register();
            Cookies.set("webrtc-register",1);
        } else {
            this.unregister();
            Cookies.set("webrtc-register",0);
        }

    },
    initiateLibrary: function() {
        var $this = this,
            ver = "0.7.7";

        if(typeof SIP === "object") {
            return;
        }

        if(!$("html").hasClass("getusermedia")) {
            $(".custom-widget[data-widget_rawname=webrtc] .fa-phone").css("color", "red");
            this.setDisplayState(_("Not supported in this browser"));
            console.warn("WebRTC is not supported in this browser");
            return;
        }

        if(document.location.protocol !== "https:") {
            $(".custom-widget[data-widget_rawname=webrtc] .fa-phone").css("color", "red");
            this.setDisplayState(_("Only supported over HTTPS"));
            console.warn("WebRTC is not supported in non-SSL mode");
            return;
        }

        if(!$(".custom-widget[data-widget_rawname=webrtc]").length) {
            $(".custom-widget[data-widget_rawname=webrtc] .fa-phone").css("color", "red");
            console.warn("WebRTC Widget has not been added");
            return;
        }

        if(typeof moduleSettings.Webrtc === "undefined") {
            $(".custom-widget[data-widget_rawname=webrtc] .fa-phone").css("color", "red");
            console.warn("WebRTC is not configured properly");
            return;
        }

        if(!moduleSettings.Webrtc.enabled) {
            $(".custom-widget[data-widget_rawname=webrtc] .fa-phone").css("color", "red");
            console.warn(moduleSettings.Webrtc.message);
            this.setDisplayState(moduleSettings.Webrtc.message);
            return;
        }

        $.getScript("modules/Webrtc/assets/jssiplibs/sip-" + ver + ".min.js")
            .done(function( script, textStatus ) {
                $("#footer").append("<audio id=\"audio_remote\" autoplay=\"autoplay\" />");
                $("#footer").append("<audio id=\"ringtone\"><source src=\"modules/Webrtc/assets/sounds/ring.mp3\" type=\"audio/mpeg\"></audio>");
                $this.callOptions.media.render.remote = document.getElementById('audio_remote');
                $this.phone = new SIP.UA(
                    {
                        "wsServers": moduleSettings.Webrtc.settings.wsservers,
                        "uri": moduleSettings.Webrtc.settings.uri,
                        "password": moduleSettings.Webrtc.settings.password,
                        "log": {
                            "builtinEnabled": false,
                            "level": moduleSettings.Webrtc.settings.log
                        },
                        "register": $this.autoRegister,
                        "hackWssInTransport": true,
                        "stunServers": moduleSettings.Webrtc.settings.iceServers,
                        "iceCheckingTimeout": moduleSettings.Webrtc.settings.gatheringTimeout,
                        // The rtcpMuxPolicy option is being considered for removal and may be removed no earlier than M60, around August 2017.
                        // If you depend on it, please see https://www.chromestatus.com/features/5654810086866944 for more details.
                        // https://nimblea.pe/monkey-business/2017/01/19/webrtc-asterisk-and-chrome-57/
                        // https://issues.asterisk.org/jira/browse/ASTERISK-26732
                        "rtcpMuxPolicy": "negotiate"
                    }
                );

                var binds = [
                    "connected",
                    "disconnected",
                    "registered",
                    "unregistered",
                    "registrationFailed",
                    "invite",
                    "message",
                    "connecting"
                ];
                $.each(binds, function(i, v) {
                    $this.phone.on(v, function(e) {
                        $this.engineEvent(v, e);
                    });
                });

                $this.connect();
            }).fail(function( jqxhr, settings, exception ) {
            //could not load script, remove button
        });
    }
});

$(document).bind("logIn", function( event ) {
    console.log("loggedin");
});

$(document).bind("logOut", function( event ) {
    if (typeof UCP.Modules.Webrtc !== "undefined" && UCP.Modules.Webrtc.phone !== null && UCP.Modules.Webrtc.phone.isConnected()) {
        UCP.Modules.Webrtc.disconnect();
    }
});

$(window).bind("beforeunload", function() {
    if (typeof UCP.Modules.Webrtc !== "undefined" && UCP.Modules.Webrtc.phone !== null && UCP.Modules.Webrtc.phone.isConnected()) {
        UCP.Modules.Webrtc.disconnect();
    }
});

var WidgetsC = Class.extend({
    init: function() {
        this.activeDashboard = null;
        this.widgetMenuOpen = false;
    },
    ready: function() {
        this.setupAddDashboard();
        this.loadDashboard();
        this.initMenuDragabble();
        this.initDashboardDragabble();
        this.initCategoriesWidgets();
        this.initAddWidgetsButtons();
        this.initRemoveItemButtons();
        this.initLockItemButtons();
        this.initLeftNavBarMenus();
        this.deactivateFullLoading();
        var $this = this;
        var total = $(".custom-widget").length;
        var count = 0;
        var resave = false;
        $(".custom-widget").each(function() {
            var widget_rawname = $(this).data("widget_rawname");
            var widget_id = $(this).data("widget_id");
            UCP.callModuleByMethod(widget_rawname,"addSimpleWidget",widget_id);
            $(document).trigger("post-body.addsimplewidget",[ widget_id, $this.activeDashboard ]);
            if(typeof $(this).find("a").data("regenuuid") !== "undefined" && $(this).find("a").data("regenuuid")) {
                resave = true;
            }
            count++;
            if(total == count) {
                if(resave) {
                    $this.saveSidebarContent();
                }
            }
        });
        window.onpopstate = function(event) {
            if(typeof event.state !== "undefined" && event.state !== null && typeof event.state.activeDashboard !== "undefined") {
                var el = $("#all_dashboards .dashboard-menu[data-id="+event.state.activeDashboard+"] a");
                //set popstate event to true so we dont destroy history
                el.data("popstate",true);
                el.click();
            }
        };
        var title = $("#all_dashboards .dashboard-menu.active a").text();
        //set tab title
        if(title !== "") {
            $("title").text(_("User Control Panel") + " - " + title);
        }
    },
    loadDashboard: function() {
        var $this = this;

        $("#dashboard-content .dashboard-error.no-dash").click(function() {
            $("#add_new_dashboard").click();
        });

        $('#add_dashboard').on('shown.bs.modal', function () {
            $('#dashboard_name').focus();
            $("#add_dashboard").off("keydown");
            $("#add_dashboard").on('keydown', function(event) {
                switch(event.keyCode) {
                    case 13:
                        $("#create_dashboard").click();
                        break;
                }
            });
        });

        $('#add_dashboard').on('hidden.bs.modal', function () {
            $('#dashboard_name').val("");
        });

        $('#edit_dashboard').on('shown.bs.modal', function () {
            $('#edit_dashboard_name').focus();
        });

        $('#edit_dashboard').on('hidden.bs.modal', function () {
            $('#edit_dashboard_name').val("");
        });

        $(document).on("click", ".edit-widget", function(){
            var settings_container = $('#widget_settings .modal-body'),
                parent = $(this).parents(".grid-stack-item"),
                rawname = parent.data("rawname"),
                widget_type_id = parent.data("widget_type_id"),
                widget_id = parent.data("id"),
                title = parent.data("widget_module_name"),
                name = parent.data("name");

            $('#widget_settings').attr("data-rawname",rawname);
            $('#widget_settings').data('rawname',rawname);

            $('#widget_settings').attr("data-id",widget_id);
            $('#widget_settings').data('id',widget_id);

            $('#widget_settings').attr("data-widget_type_id",widget_type_id);
            $('#widget_settings').data('widget_type_id',widget_type_id);

            $this.activateSettingsLoading();
            $("#widget_settings .modal-title").html('<i class="fa fa-cog" aria-hidden="true"></i> '+title+" "+_("Settings")+" ("+name+")");
            $('#widget_settings').modal('show');
            $('#widget_settings').one('shown.bs.modal', function() {
                $this.getSettingsContent(settings_container, widget_id, widget_type_id, rawname, function() {
                    $("#widget_settings .modal-body .fa-question-circle").click(function(e) {
                        e.preventDefault();
                        e.stopPropagation();
                        var f = $(this).parents("label").attr("for");
                        $(".help-block").addClass('help-hidden');
                        $('.help-block[data-for="'+f+'"]').removeClass('help-hidden');
                    });
                    $(document).trigger("post-body.widgetsettings",[ widget_id, $this.activeDashboard ]);
                });
            });
        });

        $(window).resize(function() {
            var gridstack = $(".grid-stack").data('gridstack');
            if(typeof gridstack === "undefined") {
                return;
            }
            setTimeout(function() {
                if(window.innerWidth <= 768) {
                    gridstack.resizable($(".grid-stack-item").not('[data-gs-no-resize]'),false);
                    gridstack.enableMove(false);
                } else {
                    gridstack.resizable($(".grid-stack-item").not('[data-gs-no-resize]'),true);
                    gridstack.enableMove(true);
                }
            },100);
        });

        if(!$(".grid-stack").length) {
            this.activeDashboard = null;
            $(document).trigger("post-body.widgets",[ null, this.activeDashboard ]);
        } else {
            var dashboard_id = $(".grid-stack").data("dashboard_id");
            //Are we looking a dashboard?
            this.activeDashboard = dashboard_id;

            $this.setupGridStack();
            $this.bindGridChanges();

            var gridstack = $(".grid-stack").data('gridstack');
            var total = gridstack.grid.nodes.length;
            var count = 0;
            var resave = false;
            if(total > 0) {
                $.each(gridstack.grid.nodes, function(i,v){
                    var el = v.el;
                    if(!el.hasClass("add-widget-widget")){
                        var widget_id = $(el).data('id');
                        var widget_type_id = $(el).data('widget_type_id');
                        var widget_rawname = $(el).data('rawname');
                        if(typeof $(el).data("regenuuid") !== "undefined" && $(el).data("regenuuid")) {
                            resave = true;
                        }
                        $this.getWidgetContent(widget_id, widget_type_id, widget_rawname, function() {
                            count++;
                            if(count == total) {
                                $(document).trigger("post-body.widgets",[ null, $this.activeDashboard ]);
                                if(resave) {
                                    $this.saveLayoutContent();
                                }
                            }
                        });
                    }
                });
            } else {
                $(document).trigger("post-body.widgets",[ null, $this.activeDashboard ]);
            }


            $(".dashboard-menu").removeClass("active");

            $(".dashboard-menu[data-id='"+this.activeDashboard+"']").addClass("active");
            UCP.callModulesByMethod("showDashboard",this.activeDashboard);
        }
    },
    /**
     * Save Dashboard Layout State
     * @method saveLayoutContent
     */
    saveLayoutContent: function() {
        this.activateFullLoading();

        var $this = this,
            grid = $('.grid-stack').data('gridstack');

        //TODO: lodash :-|
        var gridDataSerialized = lodash.map($('.grid-stack .grid-stack-item:visible').not(".grid-stack-placeholder"), function (el) {
            el = $(el);
            var node = el.data('_gridstack_node'),
                locked = el.find(".lock-widget i").hasClass("fa-lock");

            return {
                id: el.data('id'),
                widget_module_name: el.data('widget_module_name'),
                name: el.data('name'),
                rawname: el.data('rawname'),
                widget_type_id: el.data('widget_type_id'),
                has_settings: el.data('has_settings'),
                size_x: node.x,
                size_y: node.y,
                col: node.width,
                row: node.height,
                locked: locked,
                uuid: el.data('uuid')
            };
        });

        dashboards[$this.activeDashboard] = gridDataSerialized;

        $.post( UCP.ajaxUrl,
            {
                module: "Dashboards",
                command: "savedashlayout",
                id: $this.activeDashboard,
                data: JSON.stringify(gridDataSerialized)
            },
            function( data ) {
                if(data.status){
                    console.log("saved grid");
                }else {
                    UCP.showAlert(_("Something went wrong saving the information (grid)"), "danger");
                }
            }).always(function() {
            $this.deactivateFullLoading();
        }).fail(function(jqXHR, textStatus, errorThrown) {
            UCP.showAlert(textStatus,'warning');
        });
    },
    saveSidebarContent: function(callback) {
        this.activateFullLoading();

        var $this = this,
            sidebar_objects = $("#side_bar_content li.custom-widget a"),
            all_content = [];

        sidebar_objects.each(function(){

            var widget_id = $(this).data('id'),
                widget_type_id = $(this).data('widget_type_id'),
                widget_module_name = $(this).data('module_name'),
                widget_rawname = $(this).data('rawname'),
                widget_name = $(this).data('name'),
                widget_icon = $(this).data('icon'),
                small_widget = {
                    id:widget_id,
                    widget_type_id: widget_type_id,
                    module_name: widget_module_name,
                    rawname: widget_rawname,
                    name: widget_name,
                    icon: widget_icon
                };

            all_content.push(small_widget);

        });

        var gridDataSerialized = JSON.stringify(all_content);

        $.post( UCP.ajaxUrl ,
            {
                module: "Dashboards",
                command: "savesimplelayout",
                data: gridDataSerialized
            },
            function( data ) {
                if(data.status){
                    console.log("sidebar saved");
                }else {
                    UCP.showAlert(_("Something went wrong saving the information (sidebar)"), "danger");
                }
                if(typeof callback === "function") {
                    callback();
                }
            }).always(function() {
            $this.deactivateFullLoading();
        }).fail(function(jqXHR, textStatus, errorThrown) {
            UCP.showAlert(textStatus,'warning');
        });
    },
    /**
     * Show the full screen loading
     * @method activateFullLoading
     */
    activateFullLoading: function(){
        $(".main-block").removeClass("hidden");
        NProgress.start();
    },
    /**
     * Hide the full screen loading
     * @method deactivateFullLoading
     */
    deactivateFullLoading: function(){
        $(".main-block").addClass("hidden");
        NProgress.done();
    },
    /**
     * Show the widget loading screen
     * @method activateWidgetLoading
     * @param  {object}              widget_object jQuery object of the widget content
     * @return {string}                            Returns the html if no object provided
     */
    activateWidgetLoading: function(widget_object){

        var loading_html = '<div class="widget-loading-box">' +
            '					<span class="fa-stack fa">' +
            '						<i class="fa fa-cloud fa-stack-2x text-internal-blue"></i>' +
            '						<i class="fa fa-cog fa-spin fa-stack-1x secundary-color"></i>' +
            '					</span>' +
            '				</div>';

        if(typeof widget_object !== "undefined") {
            widget_object.html(loading_html);
        } else {
            return loading_html;
        }
    },
    /**
     * Show the settings loading screen
     * @method activateSettingsLoading
     */
    activateSettingsLoading: function() {
        var loading_html = '<div class="settings-loading-box">' +
            '					<span class="fa-stack fa">' +
            '						<i class="fa fa-cloud fa-stack-2x text-internal-blue"></i>' +
            '						<i class="fa fa-cog fa-spin fa-stack-1x secundary-color"></i>' +
            '					</span>' +
            '				</div>';
        $("#widget_settings .modal-body").html(loading_html);
    },
    /**
     * Generate Widget Layout
     * @method widget_layout
     * @param  {string}      widget_id           The widget ID
     * @param  {string}      widget_module_name  The widget module name
     * @param  {string}      widget_name         The widget name
     * @param  {string}      widget_type_id      The widget sub ID
     * @param  {string}      widget_rawname      The widget rawname
     * @param  {Boolean}     widget_has_settings If the widget has settings or not
     * @param  {string}      widget_content      The widget content
     * @param  {Boolean}      resizable           is resizable
     * @param  {Boolean}      locked              is locked
     * @return {string}                          The finalized html
     */
    widget_layout: function(widget_id, widget_module_name, widget_name, widget_type_id, widget_rawname, widget_has_settings, widget_content, resizable, locked){
        var cased = widget_rawname.modularize(),
            icon = allWidgets[cased].icon,
            lockIcon = locked ? 'fa-lock' : 'fa-unlock-alt',
            settings_html = '';

        //TODO: boolean is checking by string reference??
        if(widget_has_settings == "1"){
            settings_html = '<div class="widget-option edit-widget" data-rawname="'+widget_rawname+'" data-widget_type_id="'+widget_type_id+'">' +
                '<i class="fa fa-cog" aria-hidden="true"></i>' +
                '</div>';
        }
        var rs_html = '';
        if(!resizable) {
            rs_html = 'data-no-resize="true"';
        }

        var html = '' +
            '<div data-widget_module_name="'+widget_module_name+'" data-id="'+widget_id+'" data-name="'+widget_name+'" data-rawname="'+widget_rawname+'" data-widget_type_id="'+widget_type_id+'" data-has_settings="'+widget_has_settings+'" class="flip-container" '+rs_html+'>' +
            '<div class="grid-stack-item-content flipper">' +
            '<div class="front">' +
            '<div class="widget-title">' +
            '<div class="widget-module-name truncate-text"><i class="fa-fw '+icon+'"></i>' + widget_name + '</div>' +
            '<div class="widget-module-subname truncate-text">('+widget_module_name+')</div>' +
            '<div class="widget-options">' +
            '<div class="widget-option remove-widget" data-widget_id="'+widget_id+'" data-widget_type_id="'+widget_type_id+'" data-widget_rawname="'+widget_rawname+'">' +
            '<i class="fa fa-times" aria-hidden="true"></i>' +
            '</div>' +
            settings_html +
            '<div class="widget-option lock-widget" data-widget_id="'+widget_id+'" data-widget_type_id="'+widget_type_id+'" data-widget_rawname="'+widget_rawname+'">' +
            '<i class="fa '+lockIcon+'" aria-hidden="true"></i>' +
            '</div>' +
            '</div>' +
            '</div>' +
            '<div class="widget-content container">'+widget_content+'</div>' +
            '</div>' +
            '<div class="back">' +
            '<div class="widget-title settings-title">' +
            '<div class="widget-module-name truncate-text">'+_('Settings')+'</div>' +
            '<div class="widget-module-subname truncate-text">(' + widget_module_name + ' '+widget_name+')</div>' +
            '<div class="widget-options">' +
            '<div class="widget-option close-settings" data-rawname="'+widget_rawname+'" data-widget_type_id="'+widget_type_id+'">' +
            '<i class="fa fa-times" aria-hidden="true"></i>' +
            '</div>' +
            '</div>' +
            '</div>' +
            '<div class="widget-settings-content">' +
            '</div>' +
            '</div>' +
            '</div>' +
            '</div>';

        return html;
    },
    /**
     * Generate Side Bar Icon Layout
     * @method smallWidgetLayout
     * @param  {string}          widget_id          The widget ID
     * @param  {string}          widget_rawname     The widget rawname
     * @param  {string}          widget_name        The widget name
     * @param  {string}          widget_type_id     The widget sub id
     * @param  {string}          widget_icon        The widget icon class
     * @return {string}                             The finalized HTML
     */
    smallWidgetLayout: function(widget_id, widget_rawname, widget_name, widget_type_id, widget_icon){
        var html = '' +
            '<li class="custom-widget" data-widget_id="'+widget_id+'" data-widget_rawname="'+widget_rawname+'" data-widget_type_id="'+widget_type_id+'">' +
            '<a href="#" data-id="'+widget_id+'" data-name="'+widget_name+'" data-rawname="'+widget_rawname+'" data-widget_type_id="'+widget_type_id+'" data-icon="' + widget_icon + '"><i class="' + widget_icon + '" aria-hidden="true"></i></a>' +
            '</li>';

        return html;
    },
    /**
     * Small Widget Menu Layout
     * @method smallWidgetMenuLayout
     * @param  {string}              widget_id      The Widget ID
     * @param  {string}              widget_rawname The widget rawname
     * @param  {string}              widget_name    The widget name
     * @param  {string}              widget_type_id The widget name
     * @param  {string}              widget_icon    The widget icon class
     * @param  {string}              widget_sub     The widget sub name
     * @param  {Boolean}             hasSettings    If the settings COG should be generated
     * @return {string}                             The finalized HTML
     */
    smallWidgetMenuLayout: function(widget_id, widget_rawname, widget_name, widget_type_id, widget_icon, widget_sub, hasSettings){
        var settings_html = '';
        if(hasSettings) {
            settings_html = '<i class="fa fa-cog show-simple-widget-settings" aria-hidden="true"></i>';
        }

        var html = '' +
            '<div class="widget-extra-menu" id="menu_'+widget_id+'" data-id="'+widget_id+'" data-widget_type_id="'+widget_type_id+'" data-module="'+widget_rawname+'" data-name="'+widget_name+'" data-widget_name="'+widget_type_id+'" data-icon="'+widget_icon+'">' +
            '<div class="menu-actions">' +
            '<i class="fa fa-times-circle-o close-simple-widget-menu" aria-hidden="true"></i>' +
            settings_html +
            '</div>' +
            '<h5 class="small-widget-title"><i class="fa '+widget_icon+'"></i> <span>'+widget_sub+'</span> <small>('+widget_name+')</small></h5>' +
            '<div class="small-widget-content">' +
            '</div>' +
            '<button type="button" class="btn btn-xs btn-danger remove-small-widget" data-widget_id="'+widget_id+'" data-widget_rawname="'+widget_rawname+'">'+_('Remove Widget')+'</button>' +
            '</div>';

        return html;
    },
    /**
     * Show dashboard error
     * @method showDashboardError
     * @param  {string}           message The message to show
     */
    showDashboardError: function(message) {
        //TODO: should we destroy the gird if it exists?
        $("#dashboard-content .module-page-widgets").html('<div class="dashboard-error"><div class="message"><i class="fa fa-exclamation-circle" aria-hidden="true"></i><br/>'+message+'</div></div>');
    },
    /**
     * Initalize Menu Dragging
     * @method initMenuDragabble
     */
    initMenuDragabble: function(){
        var $this = this,
            el = document.getElementById('side_bar_content');

        var sortable = Sortable.create(el, {
            draggable: ".custom-widget",
            filter: "i",
            onUpdate: function (evt) {
                sortable.option("disabled",true);
                $this.saveSidebarContent(function() {
                    sortable.option("disabled",false);
                });
            }
        });
    },
    /**
     * Initalize Dashboard Tab Dragging
     * @method initDashboardDragabble
     */
    initDashboardDragabble: function() {
        var $this = this,
            el = document.getElementById('all_dashboards');

        var sortable = Sortable.create(el, {
            draggable: ".dashboard-menu",
            filter: "i",
            onUpdate: function (evt) {
                sortable.option("disabled",true);
                $this.saveDashboardOrder(function() {
                    sortable.option("disabled",false);
                });
            }
        });
    },
    /**
     * Save Dashboard Tab order
     * @method saveDashboardOrder
     * @param  {Function}         callback Callback function when finished saving
     */
    saveDashboardOrder: function(callback) {
        var dashboardOrder = [],
            $this = this;
        $this.activateFullLoading();
        $("#all_dashboards li").each(function() {
            dashboardOrder.push($(this).data("id"));
        });
        $.post( UCP.ajaxUrl,
            {
                module: "Dashboards",
                command: "reorder",
                order: dashboardOrder
            },
            function( data ) {
                if(typeof callback === "function") {
                    callback();
                }
            }).always(function() {
            $this.deactivateFullLoading();
        }).fail(function(jqXHR, textStatus, errorThrown) {
            UCP.showAlert(textStatus,'warning');
        });
    },
    /**
     * Open(Show) the extra widget menu
     * @method openExtraWidgetMenu
     * @param  {Function}          callback callback function when the menu is finished opening
     */
    openExtraWidgetMenu: function(callback) {
        var previous = this.widgetMenuOpen;
        this.widgetMenuOpen = true;
        if(previous) {
            if(typeof callback === "function") {
                callback();
            }
            return;
        }
        $(".side-menu-widgets-container").one("transitionend",function() {
            if(typeof callback === "function") {
                callback();
            }
        });
        $(".side-menu-widgets-container").addClass("open");
    },
    /**
     * Close the side bar menu
     * @method closeExtraWidgetMenu
     * @param  {Function}           callback Callback when the menu is finished closing
     */
    closeExtraWidgetMenu: function(callback) {
        var previous = this.widgetMenuOpen;
        this.widgetMenuOpen = false;
        if(!previous) {
            $("#side_bar_content li.active").removeClass("active");
            if(typeof callback === "function") {
                callback();
            }
            return;
        }
        $(".side-menu-widgets-container").one("transitionend",function() {
            $(".widget-extra-menu:visible").addClass("hidden");
            $("#side_bar_content li.active").removeClass("active");
            $(document).trigger("post-body.closesimplewidget");
            if(typeof callback === "function") {
                callback();
            }
        });
        $(".side-menu-widgets-container").removeClass("open");
    },
    /**
     * Initialize Side Bar Widgets
     * @method initLeftNavBarMenus
     */
    initLeftNavBarMenus: function(){
        var $this = this;

        $(document).on("click", ".close-simple-widget-menu", function() {
            $this.closeExtraWidgetMenu();
        });

        /**
         * Click to show the simple widget settings
         */
        $(document).on("click", ".show-simple-widget-settings", function() {
            var parent = $(this).parents(".widget-extra-menu"),
                rawname = parent.data("module"),
                widget_type_id = parent.data("widget_type_id"),
                widget_id = parent.data("id"),
                settings_container = $('#widget_settings .modal-body'),
                title = parent.data("name"),
                name = parent.data("widget_name");

            $('#widget_settings').attr("data-rawname",rawname);
            $('#widget_settings').data('rawname',rawname);

            $('#widget_settings').attr("data-id",widget_id);
            $('#widget_settings').data('id',widget_id);

            $('#widget_settings').attr("data-widget_type_id",widget_type_id);
            $('#widget_settings').data('widget_type_id',widget_type_id);

            $this.activateSettingsLoading();
            $("#widget_settings .modal-title").html('<i class="fa fa-cog" aria-hidden="true"></i> '+title+" "+_("Settings")+" ("+name+")");
            $('#widget_settings').modal('show');
            $('#widget_settings').one('shown.bs.modal', function() {
                $this.getSimpleSettingsContent(settings_container, widget_id, widget_type_id, rawname, function() {
                    $("#widget_settings .modal-body .fa-question-circle").click(function(e) {
                        e.preventDefault();
                        e.stopPropagation();
                        var f = $(this).parents("label").attr("for");
                        $(".help-block").addClass('help-hidden');
                        $('.help-block[data-for="'+f+'"]').removeClass('help-hidden');
                    });
                    $(document).trigger("post-body.simplewidgetsettings",[ widget_id ]);
                });
            });
        });

        /**
         * Click the settings cog on a widget
         */
        $(document).on("click", ".settings-widget", function(event){
            event.preventDefault();
            event.stopPropagation();

            var widget_type_id = 'user',
                widget_id = 'user',
                rawname = 'settings',
                settings_container = $('#widget_settings .modal-body');
            $this.activateSettingsLoading();
            $("#widget_settings .modal-title").html('<i class="fa fa-cog" aria-hidden="true"></i> '+_("User Settings"));
            $('#widget_settings').modal('show');
            $('#widget_settings').one('shown.bs.modal', function() {
                $this.getSimpleSettingsContent(settings_container, widget_id, widget_type_id, rawname, function() {
                    $("#widget_settings .modal-body .fa-question-circle").click(function(e) {
                        e.preventDefault();
                        e.stopPropagation();
                        var f = $(this).parents("label").attr("for");
                        $(".help-block").addClass('help-hidden');
                        $('.help-block[data-for="'+f+'"]').removeClass('help-hidden');
                    });
                    $(document).trigger("post-body.simplewidgetsettings",[ widget_id ]);
                });
            });
        });

        /**
         * Click sidebar widgets (Simple widgets)
         */
        $(document).on("click", ".custom-widget i", function(event){
            event.preventDefault();
            event.stopPropagation();

            var widget = $(this).parents(".custom-widget");

            //We are already looking at it so close it and move on
            if(widget.hasClass("active")) {
                $this.closeExtraWidgetMenu();
                return;
            }

            var clicked_module = widget.find("a").data("rawname"),
                clicked_id = widget.find("a").data("widget_type_id"),
                widget_id = widget.find("a").data("id"),
                content_object = $("#menu_"+widget_id).find(".small-widget-content");

            $("#side_bar_content li.active").removeClass("active");
            widget.addClass("active");

            $(".widget-extra-menu:visible").addClass("hidden");

            $this.activateWidgetLoading(content_object);
            $("#menu_"+widget_id).removeClass("hidden");
            $this.openExtraWidgetMenu();

            $.post( UCP.ajaxUrl,
                {
                    module: "Dashboards",
                    command: "getsimplewidgetcontent",
                    id: clicked_id,
                    rawname: clicked_module,
                    uuid: uuid
                },
                function( data ) {
                    if(typeof data.html !== "undefined"){
                        content_object.html(data.html);

                        UCP.callModuleByMethod(clicked_module,"displaySimpleWidget",widget_id);
                        $(document).trigger("post-body.simplewidget",[ widget_id ]);
                    }else {
                        UCP.showAlert(_("There was an error getting the widget information, try again later"), "danger");
                    }
                }).fail(function(jqXHR, textStatus, errorThrown) {
                UCP.showAlert(textStatus,'warning');
            });
        });
    },
    /**
     * Initialize the item lock buttons
     * @method initLockItemButtons
     * @return {[type]}            [description]
     */
    initLockItemButtons: function(){
        var $this = this;

        /**
         * Lock a single widget on a dashboard
         */
        $(document).on("click", ".lock-widget", function(event){
            event.preventDefault();
            event.stopPropagation();

            if(window.innerWidth <= 768) {
                UCP.showAlert(_("Widgets can not be locked on this device"),"warning");
                return;
            }

            var locked = $(this).find("i").hasClass("fa-lock"),
                id = $(this).data("widget_id"),
                grid = $('.grid-stack').data('gridstack');

            if(locked) {
                $(this).find("i").removeClass().addClass("fa fa-unlock-alt");
            } else {
                $(this).find("i").removeClass().addClass("fa fa-lock");
            }
            if($(".grid-stack-item[data-id="+id+"]").data("no-resize") != "true") {
                grid.resizable($(".grid-stack-item[data-id="+id+"]"), locked);
            }

            //set locking on widgets
            grid.movable($(".grid-stack-item[data-id="+id+"]"), locked);
            grid.locked($(".grid-stack-item[data-id="+id+"]"), !locked);

            //save layout
            $this.saveLayoutContent();
        });

        /**
         * Lock all widgets on a dashboard
         * TODO: this only works with the current dashboard for now
         */
        $(document).on("click", ".lock-dashboard", function(event){
            event.preventDefault();
            event.stopPropagation();

            if($(this).hasClass("fa-unlock-alt")) {
                $(this).removeClass("fa-unlock-alt").addClass("fa-lock");
                $(".widget-options .fa-unlock-alt").click();
            } else {
                $(this).removeClass("fa-lock").addClass("fa-unlock-alt");
                $(".widget-options .fa-lock").click();
            }
        });
    },
    /**
     * Initalize the document remove buttons
     * @method initRemoveItemButtons
     */
    initRemoveItemButtons: function(){
        var $this = this;

        /**
         * Remove widget button
         */
        $(document).on("click", ".remove-widget", function(event){
            //stop browser
            event.preventDefault();
            event.stopPropagation();

            var widget_id = $(this).data("widget_id");
            var widget_rawname = $(this).data("widget_rawname");
            var widget_type_id = $(this).data("widget_type_id");

            UCP.showConfirm(_("Are you sure you want to delete this widget?"), "warning", function() {
                var grid = $('.grid-stack').data('gridstack');
                //remove widget
                grid.removeWidget($(".grid-stack-item[data-id='" + widget_id + "']"));
                //save layout
                $this.saveLayoutContent();
                //call module method
                UCP.callModuleByMethod(widget_rawname,"deleteWidget",widget_type_id,$this.activeDashboard);
                //TODO: does this need a document trigger?
            });
        });

        /**
         * Remove small widget code
         */
        $(document).on("click", ".remove-small-widget", function(event){
            //stop browser
            event.preventDefault();
            event.stopPropagation();

            var widget_to_remove = $(this).data("widget_id"),
                widget_rawname = $(this).data("widget_rawname"),
                sidebar_object_to_remove = $("#side_bar_content li.custom-widget[data-widget_id='" + widget_to_remove + "']"),
                sidebar_menu_to_remove = $(".side-menu-widgets-container .widget-extra-menu[data-id='menu_" + widget_rawname + "_"+widget_to_remove+"']");

            UCP.callModuleByMethod(widget_rawname,"deleteSimpleWidget",widget_to_remove);

            sidebar_object_to_remove.remove();

            //close the menu
            $this.closeExtraWidgetMenu(function() {
                sidebar_menu_to_remove.remove();
            });

            //save the page
            $this.saveSidebarContent();
        });

        /**
         * Edit Dashboard Button
         */
        $(document).on("click", ".edit-dashboard", function(event){
            //stop the browser
            event.preventDefault();
            event.stopPropagation();

            var parent = $(this).parents('.dashboard-menu'),
                dashboard_id = parent.data("id"),
                title = parent.find("a");

            //se the input to what we have now
            $('#edit_dashboard_name').val(title.text());

            //trigger when the modal is shown (once)
            $('#edit_dashboard').one('shown.bs.modal', function () {
                //unbind because we were bound previously
                $("#edit_dashboard").off("keydown");
                $("#edit_dashboard").on('keydown', function(event) {
                    switch(event.keyCode) {
                        case 13: //detect enter
                            $("#edit_dashboard_btn").click();
                            break;
                    }
                });
                //click event
                $("#edit_dashboard_btn").one("click",function() {
                    //get the new name
                    var name = $('#edit_dashboard_name').val();
                    //show loading window so nothing changes
                    $this.activateFullLoading();
                    //send it off and save!
                    $.post( UCP.ajaxUrl,
                        {
                            module: "Dashboards",
                            command: "rename",
                            id: dashboard_id,
                            name: name
                        },
                        function( data ) {
                            if(data.status) {
                                title.text(name);
                                $("#edit_dashboard").modal('hide');
                            } else {
                                UCP.showAlert(_("Something went wrong removing the dashboard"), "danger");
                            }
                        }).always(function() {
                        $this.deactivateFullLoading();
                    }).fail(function(jqXHR, textStatus, errorThrown) {
                        UCP.showAlert(textStatus,'warning');
                    });
                });
                //focus on the name
                $('#dashboard_name').focus();
            });
            //show the modal
            $("#edit_dashboard").modal('show');
        });

        /**
         * Remve Dashboard
         */
        $(document).on("click", ".remove-dashboard", function(event){
            //stop browser from doing what it wants
            event.preventDefault();
            event.stopPropagation();

            var dashboard_id = $(this).parents('.dashboard-actions').data("dashboard_id");

            //Check confirm
            UCP.showConfirm(_("Are you sure you want to delete this dashboard?"), "warning", function() {

                //show loading window so nothing changes
                $this.activateFullLoading();

                $.post( UCP.ajaxUrl ,
                    {
                        module: "Dashboards",
                        command: "remove",
                        id: dashboard_id
                    },
                    function( data ) {
                        if (data.status) {
                            $(".dashboard-menu[data-id='" + dashboard_id + "']").remove();

                            if(dashboard_id == $this.activeDashboard) {
                                if($(".dashboard-menu").length > 0) {
                                    $(".dashboard-menu").first().find("a").click();
                                } else {
                                    $this.showDashboardError(_("You have no dashboards. Click here to add one"));
                                    $("#dashboard-content .dashboard-error").css("cursor","pointer");
                                    $("#dashboard-content .dashboard-error").click(function() {
                                        $("#add_new_dashboard").click();
                                    });
                                }
                            }

                        } else {
                            UCP.showAlert(_("Something went wrong removing the dashboard"), "danger");
                        }
                    }).always(function() {
                    $this.deactivateFullLoading();
                }).fail(function(jqXHR, textStatus, errorThrown) {
                    UCP.showAlert(textStatus,'warning');
                });
            });

        });
    },
    /**
     * Initialize Widget Add Buttons
     * TODO: needs cleanup
     * @method initAddWidgetsButtons
     */
    initAddWidgetsButtons: function(){
        $("#add_widget").on("show.bs.modal",function() {
            $this.closeExtraWidgetMenu();
            $(".navbar-nav .add-widget").addClass("active");
        });
        //tab select scroll position memory
        $('#add_widget .nav-tabs a[data-toggle=tab]').on('shown.bs.tab', function (e) {
            $("#add_widget .bhoechie-tab-menu .list-group-item").each(function() {
                $(this).data("position",$(this).position().top);
            });
            var container = $("#add_widget .tab-content");
            $(e.relatedTarget).data("scroll",container.scrollTop());

            var scroll = $(e.target).data("scroll");
            if(typeof scroll !== "undefined") {
                container.scrollTop(scroll);
            } else {
                container.scrollTop(0);
            }
        });
        $("#add_widget").on("shown.bs.modal",function() {
            $("#add_widget .bhoechie-tab-menu .list-group-item").each(function() {
                $(this).data("position",$(this).position().top);
            });
            $("#add_widget .tab-content").off("scroll");
            $("#add_widget .tab-content").scroll(function() {
                var top = $(this).scrollTop();
                var bottom = $(this).scrollTop() + $(this).height();
                if(($(this).find(".tab-pane.active .bhoechie-tab-menu").height() - (top - 30)) > $(this).height()) {
                    $(this).find(".tab-pane.active .bhoechie-tab").css("top",top);
                }

                var active  = $(this).find(".tab-pane.active .list-group-item.active");
                active.removeClass("top-locked bottom-locked");
                if(top > (active.data("position") + 10)) {
                    active.addClass("top-locked");
                } else if(bottom < (active.data("position") + active.height())) {
                    active.addClass("bottom-locked");
                }
            });
        });
        $("#add_widget").on("hidden.bs.modal",function() {
            $(".navbar-nav .add-widget").removeClass("active top-locked bottom-locked");
        });
        var $this = this;
        $(document).on("click",".add-widget-button", function(){
            if($this.activeDashboard === null) {
                UCP.showAlert(_("There is no active dashboard to add widgets to"), "danger");
                return;
            }
            var current_dashboard_id = $this.activeDashboard,
                widget_id = $(this).data('widget_id'),
                widget_module_name = $(this).data('widget_module_name'),
                widget_rawname = $(this).data('rawname'),
                widget_name = $(this).data('widget_name'),
                new_widget_id = uuid.v4(),
                icon = allWidgets[widget_rawname.modularize()].icon,
                widget_info = allWidgets[widget_rawname.modularize()].list[widget_id],
                widget_has_settings = false,
                default_size_x = 2,
                default_size_y = 2,
                min_size_x = null,
                min_size_y = null,
                max_size_x = null,
                max_size_y = null,
                resizable = true,
                dynamic = false;

            if(typeof widget_info.defaultsize !== "undefined") {
                default_size_x = widget_info.defaultsize.width;
                default_size_y = widget_info.defaultsize.height;
            }

            if(typeof widget_info.maxsize !== "undefined") {
                max_size_x = widget_info.maxsize.width;
                max_size_y = widget_info.maxsize.height;
            }

            if(typeof widget_info.minsize !== "undefined") {
                min_size_x = widget_info.minsize.width;
                min_size_y = widget_info.minsize.height;
            }

            if(typeof widget_info.hasSettings !== "undefined") {
                widget_has_settings = widget_info.hasSettings;
            }

            if(typeof widget_info.resizable !== "undefined") {
                resizable = widget_info.resizable;
            }

            if(typeof widget_info.dynamic !== "undefined") {
                dynamic = widget_info.dynamic;
            }

            //Checking if the widget is already on the dashboard
            var object_on_dashboard = ($(".grid-stack-item[data-rawname='"+widget_rawname+"'][data-widget_type_id='"+widget_id+"']").length > 0);

            if(dynamic || !object_on_dashboard) {

                $this.activateFullLoading();

                $.post( UCP.ajaxUrl ,
                    {
                        module: "Dashboards",
                        command: "getwidgetcontent",
                        id: widget_id,
                        rawname: widget_rawname,
                        uuid: new_widget_id
                    },
                    function( data ) {

                        $("#add_widget").modal("hide");

                        if(typeof data.html !== "undefined"){
                            //So first we go the HTML content to add it to the widget
                            var widget_html = data.html;
                            var full_widget_html = $this.widget_layout(new_widget_id, widget_module_name, widget_name, widget_id, widget_rawname, widget_has_settings, widget_html, resizable, false);
                            var grid = $('.grid-stack').data('gridstack');
                            //We are adding the widget always on the position 1,1
                            grid.addWidget($(full_widget_html), 1, 1, default_size_x, default_size_y, true, min_size_x, max_size_x, min_size_y, max_size_y);
                            grid.resizable($("div[data-id='"+new_widget_id+"']"), resizable);
                            UCP.callModuleByMethod(widget_rawname,"displayWidget",new_widget_id,$this.activeDashboard);
                            $(document).trigger("post-body.widgets",[ new_widget_id, $this.activeDashboard ]);
                        }else {
                            UCP.showAlert(_("There was an error getting the widget information, try again later"), "danger");
                        }
                    }).always(function() {
                    $this.deactivateFullLoading();
                }).fail(function(jqXHR, textStatus, errorThrown) {
                    UCP.showAlert(textStatus,'warning');
                });
            } else {
                UCP.showAlert(_("You already have this widget on this dashboard"), "info");
            }
        });

        /**
         * Add Small Widget Button Bind
         */
        $(".add-small-widget-button").click(function(){

            var widget_id = $(this).data('id'),
                widget_rawname = $(this).data('rawname'),
                widget_name = $(this).data('name'),
                widget_sub = $(this).data('widget_type_id'),
                new_widget_id = uuid.v4(),
                widget_info = allSimpleWidgets[widget_rawname.modularize()].list[widget_id],
                widget_icon = allSimpleWidgets[widget_rawname.modularize()].icon,
                hasSettings = false,
                dynamic = false;

            if(typeof widget_info.hasSettings !== "undefined") {
                hasSettings = widget_info.hasSettings;
            }

            if(typeof widget_info.dynamic !== "undefined") {
                dynamic = widget_info.dynamic;
            }

            //Checking if the widget is already on the dashboard

            var object_on_dashboard = ($("#side_bar_content li.custom-widget[data-widget_rawname='"+widget_rawname+"'][data-widget_type_id='"+widget_id+"']").length > 0);

            //Checking if the widget is already on the bar
            if(dynamic || !object_on_dashboard){

                $this.activateFullLoading();

                $.post( UCP.ajaxUrl,
                    {
                        module: "Dashboards",
                        command: "getsimplewidgetcontent",
                        id: widget_id,
                        rawname: widget_rawname,
                        uuid: new_widget_id
                    },
                    function( data ) {
                        $("#add_widget").modal("hide");

                        if(typeof data.html !== "undefined"){
                            //get small widget layout
                            var full_widget_html = $this.smallWidgetLayout(new_widget_id, widget_rawname, widget_name, widget_id, widget_icon);
                            //get small widget menu layout
                            var menu_widget_html = $this.smallWidgetMenuLayout(new_widget_id, widget_rawname, widget_name, widget_id, widget_icon, widget_sub, hasSettings);

                            //add icon to sidebar
                            if($("#side_bar_content .custom-widget").length) {
                                //we already have an element on the sidebar so add to the end
                                $("#side_bar_content .custom-widget").last().after(full_widget_html);
                            } else {
                                //add widget after the add button because we dont have anything there
                                $("#side_bar_content .add-widget").after(full_widget_html);
                            }

                            //now add the menu (hidden) to the widgets container for expansion later
                            $(".side-menu-widgets-container").append(menu_widget_html);

                            //execute module method
                            UCP.callModuleByMethod(widget_rawname,"addSimpleWidget",new_widget_id);

                            //execute trigger
                            $(document).trigger("post-body.addsimplewidget",[ new_widget_id, $this.activeDashboard ]);

                            //save side bar
                            $this.saveSidebarContent();
                        }else {
                            UCP.showAlert(_("There was an error getting the widget information, try again later"), "danger");
                        }
                    }).always(function() {
                    $this.deactivateFullLoading();
                }).fail(function(jqXHR, textStatus, errorThrown) {
                    UCP.showAlert(textStatus,'warning');
                });
            }else {
                UCP.showAlert(_("You already have this widget on the side bar"), "info");
            }
        });
    },
    /**
     * Initiate Category Binds
     * @method initCategoriesWidgets
     */
    initCategoriesWidgets: function(){
        $("#add_widget .bhoechie-tab-container").each(function() {
            var parent = $(this);
            $(this).find(".list-group-item").click(function(e) {
                e.preventDefault();
                $(this).siblings('a.active').removeClass("active top-locked bottom-locked");
                $(this).addClass("active");
                var id = $(this).data("id");
                parent.find(".bhoechie-tab-content").removeClass("active top-locked bottom-locked");
                parent.find(".bhoechie-tab-content[data-id='"+id+"']").addClass("active");
            });
        });
    },
    /**
     * Get Widget content
     * TODO: This is duplicated in certain places!!!
     * @method getWidgetContent
     * @param  {string}           widget_id             The widget ID
     * @param  {string}           widget_type_id        The widget type ID
     * @param  {string}           widget_rawname        The widget rawname
     * @param  {Function}         callback              Callback Function when done (success + complete)
     */
    getWidgetContent: function(widget_id, widget_type_id, widget_rawname, callback){
        var $this = this,
            widget_content_object = $(".grid-stack-item[data-id='"+widget_id+"'] .widget-content");
        this.activateWidgetLoading(widget_content_object);

        $.post( UCP.ajaxUrl,
            {
                module: "Dashboards",
                command: "getwidgetcontent",
                id: widget_type_id,
                rawname: widget_rawname,
                uuid: widget_id
            },
            function( data ) {

                var widget_html = data.html;

                if(typeof data.html === "undefined"){
                    widget_html = '<div class="alert alert-danger">'+_('Something went wrong getting the content of the widget')+'</div>';
                }

                widget_content_object.html(widget_html);
                UCP.callModuleByMethod(widget_rawname,"displayWidget",widget_id,$this.activeDashboard);
                setTimeout(function() {
                    UCP.callModuleByMethod(widget_rawname,"resize",widget_id,$this.activeDashboard);
                },100);

            }).done(function() {
            if(typeof callback === "function") {
                callback();
            }
        }).fail(function(jqXHR, textStatus, errorThrown) {
            UCP.showAlert(textStatus,'warning');
        });
    },
    /**
     * Get Simple Widget Settings Content
     * @method getSimpleSettingsContent
     * @param  {object}           widget_content_object jQuery object of the settings container
     * @param  {string}           widget_id             The widget ID
     * @param  {string}           widget_type_id        The widget type ID
     * @param  {string}           widget_rawname        The widget rawname
     * @param  {Function}         callback              Callback Function when done (success + complete)
     */
    getSimpleSettingsContent: function(widget_content_object, widget_id, widget_type_id, widget_rawname, callback){
        var $this = this;

        $.post( UCP.ajaxUrl,
            {
                module: "Dashboards",
                command: "getsimplewidgetsettingscontent",
                id: widget_type_id,
                rawname: widget_rawname,
                uuid: widget_id
            },
            function( data ) {

                var widget_html = data.html;

                if(typeof data.html === "undefined"){
                    widget_html = '<div class="alert alert-danger">'+_('Something went wrong getting the settings from the widget')+'</div>';
                }

                widget_content_object.html(widget_html);
                UCP.callModuleByMethod(widget_rawname,"displaySimpleWidgetSettings",widget_id);
            }).done(function() {
            if(typeof callback === "function") {
                callback();
            }
        }).fail(function(jqXHR, textStatus, errorThrown) {
            UCP.showAlert(textStatus,'warning');
        });
    },
    /**
     * Get Module Settings Content
     * @method getSettingsContent
     * @param  {object}           widget_content_object jQuery object of the settings container
     * @param  {string}           widget_id             The widget ID
     * @param  {string}           widget_type_id        The widget type ID
     * @param  {string}           widget_rawname        The widget rawname
     * @param  {Function}         callback              Callback Function when done (success + complete)
     */
    getSettingsContent: function(widget_content_object, widget_id, widget_type_id, widget_rawname, callback){
        var $this = this;

        $.post( UCP.ajaxUrl,
            {
                module: "Dashboards",
                command: "getwidgetsettingscontent",
                id: widget_type_id,
                rawname: widget_rawname,
                uuid: widget_id
            },
            function( data ) {

                var widget_html = data.html;

                if(typeof data.html === "undefined"){
                    widget_html = '<div class="alert alert-danger">'+_('Something went wrong getting the settings from the widget')+'</div>';
                }

                widget_content_object.html(widget_html);
                UCP.callModuleByMethod(widget_rawname,"displayWidgetSettings",widget_id,$this.activeDashboard);
            }).done(function() {
            if(typeof callback === "function") {
                callback();
            }
        }).fail(function(jqXHR, textStatus, errorThrown) {
            UCP.showAlert(textStatus,'warning');
        });
    },
    /**
     * Setup grid stack!
     * @method setupGridStack
     * @return {object}       The gridstack object!
     */
    setupGridStack: function() {
        var gridstack = $(".grid-stack").data('gridstack');
        if(typeof gridstack === "undefined") {
            $('.grid-stack').gridstack({
                cellHeight: 35,
                verticalMargin: 10,
                animate: true,
                float: true,
                draggable: {
                    handle: '.widget-title',
                    scroll: false,
                    appendTo: 'body'
                }
            });
            gridstack = $(".grid-stack").data('gridstack');
        }
        return gridstack;
    },
    /**
     * Bind Grid Stack changes
     * @method bindGridChanges
     */
    bindGridChanges: function() {
        var $this = this;
        $('.grid-stack').on('resizestop', function(event, ui) {
            //Never on mobile, Always on Desktop
            if(window.innerWidth > 768) {
                UCP.callModulesByMethod("resize",ui.element.data("id"),$this.activeDashboard);
            }
        });

        $('.grid-stack').on('removed', function(event, items) {
            //Never on Desktop, Always on mobile
            if(window.innerWidth <= 768) {
                //save layout
                $this.saveLayoutContent();
            }
        });

        $('.grid-stack').on('added', function(event, items) {
            //Never on Desktop, Always on mobile
            if(window.innerWidth <= 768) {
                //save layout
                $this.saveLayoutContent();
            }
        });

        $('.grid-stack').on('change', function(event, items) {
            //This triggers on any bubbling change so if items
            //is undefined then return
            if(typeof items === "undefined") {
                return;
            }
            //Always on Desktop, Never on mobile
            if(window.innerWidth > 768) {
                //save layout
                $this.saveLayoutContent();
            }
        });
        //some gitchy crap going on here, we have to relock the widget
        $('.grid-stack').on('dragstop', function(event, ui) {
            var grid = $(".grid-stack").data('gridstack');
            $('.grid-stack .grid-stack-item:visible').not(".grid-stack-placeholder").each(function(){
                var el = $(this);
                locked = el.find(".lock-widget i").hasClass("fa-lock");
                grid.movable(el, !locked);
                grid.locked(el, locked);
                grid.resizable(el, !locked);
            });
        });
        //some gitchy crap going on here, we have to relock the widget
        $('.grid-stack').on('resizestop', function(event, ui) {
            var grid = $(".grid-stack").data('gridstack');
            $('.grid-stack .grid-stack-item:visible').not(".grid-stack-placeholder").each(function(){
                var el = $(this);
                locked = el.find(".lock-widget i").hasClass("fa-lock");
                grid.movable(el, !locked);
                grid.locked(el, locked);
                grid.resizable(el, !locked);
            });
        });
    },
    /**
     * Setup Add Dashboard Button Binds
     * @method setupAddDashboard
     */
    setupAddDashboard: function() {
        var $this = this;
        $("#create_dashboard").click(function() {
            //make sure there is something in the name
            if ($("#dashboard_name").val().trim() === "") {
                //if empty then return back and focus on name
                UCP.showAlert(_("You must set a dashboard name!"),'warning', function() {
                    $("#dashboard_name").focus();
                });
            } else {
                //show loading screen while we save this dashboard
                $this.activateFullLoading();

                $.post( UCP.ajaxUrl, {module: "Dashboards", command: "add", name: $("#dashboard_name").val()}, function( data ) {
                    if (!data.status) {
                        UCP.showAlert(data.message,'warning');
                    } else {
                        var select = $("#all_dashboards li").length;
                        var new_dashboard_html = '<li class="menu-order dashboard-menu" data-id="'+data.id+'"><a data-dashboard>'+$("#dashboard_name").val()+'</a> <div class="dashboard-actions" data-dashboard_id="'+data.id+'"><i class="fa fa-unlock-alt lock-dashboard" aria-hidden="true"></i><i class="fa fa-pencil edit-dashboard" aria-hidden="true"></i><i class="fa fa-times remove-dashboard" aria-hidden="true"></i></div></li>';
                        $("#all_dashboards").append(new_dashboard_html);

                        dashboards[data.id] = null;

                        $(document).trigger("addDashboard",[data.id]);

                        if(!select) {
                            $("#all_dashboards li a").click();
                        }

                        //hide modal we are done
                        $("#add_dashboard").modal("hide");
                    }
                }).fail(function(jqXHR, textStatus, errorThrown) {
                    UCP.showAlert(textStatus,'warning');
                }).always(function() {
                    $this.deactivateFullLoading();
                });
            }
        });

        //dashboard tab click
        $(document).on("click",".dashboard-menu a[data-dashboard]", function(e) {
            //stop default browser actions
            e.preventDefault();
            e.stopPropagation();

            var gridstack = $(".grid-stack").data('gridstack'),
                id = $(this).parents(".dashboard-menu").data("id"),
                popstate = $(this).data("popstate");

            popstate = (typeof popstate !== "undefined") ? popstate : false;
            //we are on this dashboard. So do nothing
            if($this.activeDashboard == id) {
                return;
            }

            //remove active from any dashboard tab
            $(".dashboard-menu").removeClass("active");
            //remove the click block from all
            $(".dashboards a[data-dashboard]").removeClass("pjax-block");
            //add click block to this one
            $(this).addClass("pjax-block");
            //activate our tab
            $(".dashboard-menu[data-id='"+id+"']").addClass("active");
            //push browser history (pjax like) only if we aren't in a popstate event
            if(!popstate) {
                history.pushState({ activeDashboard: id }, $(this).text(), "?dashboard="+id);
            } else {
                $(this).data("popstate",false);
            }
            //set tab title
            $("title").text(_("User Control Panel") + " - " + $(this).text());
            //set our active dashboard
            $this.activeDashboard = id;

            if(typeof gridstack !== "undefined") {
                //destroy the grid (which also deletes the elements!)
                gridstack.destroy(true);
            }

            //add back grid container
            $("#module-page-widgets").html('<div class="grid-stack" data-dashboard_id="'+id+'">');

            //setup grid
            gridstack = $this.setupGridStack();

            //load widgets
            $this.activateFullLoading();
            var resave = false;
            async.each(dashboards[id], function(widget, callback) {
                //uppercase the module rawname
                var cased = widget.rawname.modularize();
                if(typeof allWidgets[cased] === "undefined") {
                    callback();
                    return;
                }
                //get loading html
                var widget_html = $this.activateWidgetLoading();
                //TODO: fix this
                widget.resizable = true;
                if(!widget.id.match(/^[0-9A-F]{8}-[0-9A-F]{4}-4[0-9A-F]{3}-[89AB][0-9A-F]{3}-[0-9A-F]{12}$/i)) {
                    widget.id = uuid.v4();
                    resave = true;
                }
                //get widget content
                var full_widget_html = $this.widget_layout(widget.id, widget.widget_module_name, widget.name, widget.widget_type_id, widget.rawname, widget.has_settings, widget_html, widget.resizable, widget.locked);
                //get max/min size of this widget
                var min_size_x = (typeof allWidgets[cased].list[widget.widget_type_id].minsize !== "undefined" && typeof allWidgets[cased].list[widget.widget_type_id].minsize.width !== "undefined") ? allWidgets[cased].list[widget.widget_type_id].minsize.width : null;
                var min_size_y = (typeof allWidgets[cased].list[widget.widget_type_id].minsize !== "undefined" && typeof allWidgets[cased].list[widget.widget_type_id].minsize.height !== "undefined") ? allWidgets[cased].list[widget.widget_type_id].minsize.height : null;
                var max_size_x = (typeof allWidgets[cased].list[widget.widget_type_id].maxsize !== "undefined" && typeof allWidgets[cased].list[widget.widget_type_id].maxsize.width !== "undefined") ? allWidgets[cased].list[widget.widget_type_id].maxsize.width : null;
                var max_size_y = (typeof allWidgets[cased].list[widget.widget_type_id].maxsize !== "undefined" && typeof allWidgets[cased].list[widget.widget_type_id].maxsize.height !== "undefined") ? allWidgets[cased].list[widget.widget_type_id].maxsize.height : null;
                //is this widget resizable?
                var resizable = (typeof allWidgets[cased].list[widget.widget_type_id].resizable !== "undefined") ? allWidgets[cased].list[widget.widget_type_id].resizable : true;

                //now add the widget
                gridstack.addWidget($(full_widget_html), widget.size_x, widget.size_y, widget.col, widget.row, false, min_size_x, max_size_x, min_size_y, max_size_y);

                //set resizable
                setTimeout(function() {
                    gridstack.resizable($(".grid-stack-item[data-id="+widget.id+"]"), !widget.locked);
                });

                //set locked/or not
                gridstack.movable($(".grid-stack-item[data-id="+widget.id+"]"), !widget.locked);
                gridstack.locked($(".grid-stack-item[data-id="+widget.id+"]"), widget.locked);

                //get widget content
                $.post( UCP.ajaxUrl,
                    {
                        module: "Dashboards",
                        command: "getwidgetcontent",
                        id: widget.widget_type_id,
                        rawname: widget.rawname,
                        uuid: widget.id
                    },
                    function( data ) {
                        //set the content from what we got
                        $(".grid-stack .grid-stack-item[data-id="+widget.id+"] .widget-content").html(data.html);
                        //execute module method
                        UCP.callModuleByMethod(widget.rawname,"displayWidget",widget.id,$this.activeDashboard);
                        //execute resize module method
                        setTimeout(function() {
                            UCP.callModuleByMethod(widget.rawname,"resize",widget.id,$this.activeDashboard);
                        },100);

                        //trigger event
                        $(document).trigger("post-body.widgets",[ widget.id, $this.activeDashboard ]);
                    }
                ).done(function() {
                    callback(); //trigger callback to async
                }).fail(function(jqXHR, textStatus, errorThrown) {
                    callback(textStatus); //trigger error to async
                });
            }, function(err) {
                if(err) {
                    //show error because there was an error
                    UCP.showAlert(err,'danger');
                } else {
                    //hide loading window
                    $this.deactivateFullLoading();
                    //bind grid events
                    $this.bindGridChanges();
                    //execute module methods
                    UCP.callModulesByMethod("showDashboard",$this.activeDashboard);
                    //trigger all widgets loaded event
                    $(document).trigger("post-body.widgets",[ null, $this.activeDashboard ]);
                    if(resave) {
                        $this.saveLayoutContent();
                    }
                }
            });
        });
    }
});

var XmppC = UCPMC.extend({
    init: function() {
        this.socket = null;
        this.jid = null;
        this.roster = {};
        this.icon = "fa fa-comments-o";
        this.typing = {};
        this.enabled = false;
        this.connecting = false;
        this.online = false;
        this.initalizing = {};
        var Xmpp = this;
        $(document).on("post-body.simplewidgetsettings", function(event, widget_id) {
            $("#xmpp-mails-enable").change(function() {
                var mailsNotification = ($(this).is(":checked")) ? 1 : 0;
                $.post(UCP.ajaxUrl + "?module=xmpp&command=mail", {"xmpp-mails-enable" : mailsNotification}, function(res) {
                    if (!res.status) {
                        UCP.showAlert(res.message, 'danger', function() {
                            console.error('Error saving' + res.message);
                        });
                    } else {
                        return false;
                    }

                });
            });
        });
        $(document).on("chatWindowAdded", function(event, windowId, module, object) {
            if (module == "Xmpp") {
                Xmpp.initalizing[object.data("from")] = false;
                object.on("click", function() {
                    object.find(".title-bar").css("background-color", "");
                });
                var ea = object.find("textarea").emojioneArea()[0].emojioneArea;
                ea.on("keyup", function(editor, event) {
                    if (event.keyCode == 13) {
                        Xmpp.sendMessage(windowId, object.data("from"), ea.getText());
                        ea.setText(" ");
                    }
                });
                ea.on("input propertychange", function(event) {
                    Xmpp.sendState(object.data("from"), "composing");
                    if (typeof Xmpp.typing[object.data("from")] !== "undefined") {
                        clearTimeout(Xmpp.typing[object.data("from")]);
                        delete Xmpp.typing[object.data("from")];
                    }
                    Xmpp.typing[object.data("from")] = setTimeout( function() {
                        Xmpp.sendState(object.data("from"), "paused");
                    }, 1000);
                });
                object.find(".cancelExpand").click(function() {
                    Xmpp.sendState(object.data("from"), "gone");
                });
            }
        });

        $(window).bind("presenceStateChange", function() {
            Xmpp.sendEvent("setPresence", Presencestate.menu.presence);
        });
    },
    displaySimpleWidget: function(widget_id) {
        var clone = $(".widget-extra-menu[data-id="+widget_id+"] .clone"),
            roster = $(".widget-extra-menu[data-id="+widget_id+"] .roster"),
            $this = this;
        $.each(this.roster, function(k,v) {
            var user = clone.clone();
            user.removeClass("hidden clone").addClass("user").attr("data-jid",v.user).data("jid",v.user);
            user.find(".name").text(v.name);
            user.find("i").css("color",(v.show == "available") ? "green" : "grey");
            user.click(function() {
                if(!$this.initalizing[v.user]) {
                    $this.initalizing[v.user] = true;
                    $this.initiateChat(v.user);
                }
            });
            roster.append(user);
        });
        $(".widget-extra-menu[data-id="+widget_id+"] .status span").text((this.online ? _("Connected") : _("Offline")));
    },
    contactClickInitiate: function(user) {
        this.initiateChat(decodeURIComponent(user));
    },
    contactClickOptions: function(type) {
        if (type != "xmpp" || this.jid === null) {
            return false;
        }
        return [ { text: _("Start XMPP"), function: "contactClickInitiate", type: "xmpp" } ];
    },
    replaceContact: function(contact) {
        if (UCP.validMethod("Contactmanager", "lookup")) {
            contact = contact.length == 11 ? contact.substring(1) : contact;
            var entry = UCP.Modules.Contactmanager.lookup(contact);
            if (entry !== null && entry !== false) {
                return entry.displayname;
            }
        }
        return contact;
    },
    initiateChat: function(to) {
        var Xmpp = this,
            user = to.split("@");
        user[1] = (typeof user[1] !== "undefined") ? user[1] : Xmpp.jid._domain;
        if (to === "") {
            alert(_("Need a valid recipient"));
            return false;
        } else if (user[0] == this.jid.user && user[1] == this.jid._domain) {
            alert(_("Recursively sending to yourself is not allowed!"));
            return;
        }
        if(!$(".message-box [data-id='"+encodeURIComponent(user[0] + "@" + user[1])+"']").length) {
            var name = Xmpp.roster[user[0] + "@" + user[1]].name;
            UCP.addChat("Xmpp", encodeURIComponent(user[0] + "@" + user[1]), Xmpp.icon, user[0] + "@" + user[1], Xmpp.jid.user + "@" + user[1], '<div class="from"><strong>F:</strong> '+name+'</div><br/><div class="to"><strong>T:</strong> '+Xmpp.jid.user+'</div>');
            UCP.closeDialog();
        } else {
            Xmpp.initalizing[user[0] + "@" + user[1]] = false;
        }

    },
    sendState: function(to, state) {
        switch (to) {
            case "active":
            case "composing":
            case "paused":
            case "inactive":
            case "gone":
                break;
        }
        this.sendEvent("composing", { to: to, state: state });
    },
    addUser: function(user) {
        this.sendEvent("addUser", user);
        this.sendEvent("subscribe", user);
    },
    removeUser: function(user) {
        this.sendEvent("removeUser", user);
        this.sendEvent("unsubscribe", user);
        //this.sendEvent("unsubscribed", user);
    },
    authorizeUser: function(user) {
        this.sendEvent("subscribed", user);
    },
    unauthorizeUser: function(user) {
        this.sendEvent("unsubscribed", user);
    },
    probe: function(user) {
        this.sendEvent("probe", user);
    },
    sendMessage: function(windowId, to, message) {
        var Xmpp = this,
            id = Math.floor((Math.random() * 100000) + 1);
        UCP.addChatMessage(windowId, id, message, false, false, 'out');
        if (typeof Xmpp.typing[decodeURIComponent(windowId)] !== "undefined") {
            clearTimeout(Xmpp.typing[decodeURIComponent(windowId)]);
            delete Xmpp.typing[decodeURIComponent(windowId)];
        }
        this.sendEvent("message", {
            to: to,
            message: emojione.unifyUnicode(message),
            id: id
        });
    },
    sendEvent: function(key, value) {
        if (this.socket !== null && this.socket.connected) {
            this.socket.emit(key, value);
        }
    },
    disconnect: function() {
        var Xmpp = this,
            listeners = [ "disconnect",
                "connect",
                "online",
                "offline",
                "message",
                "roster",
                "typing",
                "updatePresence",
                "subscribe",
                "unsubscribe",
                "subscribed",
                "unsubscribed" ];
        if (this.socket !== null) {
            $.each(listeners, function(i, v) {
                Xmpp.socket.removeAllListeners(v);
            });
        }
        $(".message-box[data-module='Xmpp'] .response textarea").prop("disabled", true);
        $(".custom-widget[data-widget_rawname=xmpp] a i").css("color", "red");
        Xmpp.connecting = false;
    },
    login: function() {
        if(this.socket !== null) {
            this.sendEvent("login",{ username: $("input[name=username]").val(), password: $("input[name=password]").val() });
        }
        UCP.closeDialog();
    },
    addSimpleWidget: function(widget_id) {
        this.connect();
    },
    connect: function(username, password) {
        var Xmpp = this;

        if (typeof Xmpp.staticsettings === "undefined") {
            $(document).bind("staticSettingsFinished", function( event ) {
                Xmpp.enabled = Xmpp.staticsettings.enabled;
                if (Xmpp.socket === null) {
                    Xmpp.connect(username, password);
                }
            });
            return;
        } else {
            Xmpp.enabled = Xmpp.staticsettings.enabled;
        }

        if (Xmpp.connecting || !this.enabled || Xmpp.socket) {
            return;
        }

        if(!$(".custom-widget[data-widget_rawname=xmpp]").length) {
            return;
        }

        Xmpp.connecting = true;
        try {
            UCP.wsconnect("xmpp", function(socket) {
                if (socket === false) {
                    Xmpp.socket = null;
                    return false;
                } else {
                    Xmpp.socket = socket;
                    Xmpp.sendEvent("login",{ username: username, password: password });
                    Xmpp.socket.on("disconnect", function(socket) {
                        $(".message-box[data-module='Xmpp'] .response textarea").prop("disabled", true);
                        $(".custom-widget[data-widget_rawname=xmpp] a i").css("color", "red");
                    });
                    Xmpp.socket.on("connect", function(socket) {
                        Xmpp.sendEvent("login",{ username: username, password: password });
                    });
                    Xmpp.socket.on("prompt", function() {
                        console.log("prompt");
                        UCP.showDialog(_("XMPP Credentials"), _("Please enter your username and password to login to the XMPP server")+"<br/><label>" + _("Username") + ":</label><br/>" +
                            '<input type="text" class="form-control" name="username" value=""></br>' +
                            "<label>" + _("Password") + ":</label><br/>" +
                            '<input type="password" class="form-control" name="password" value=""></br>',
                            '<button class="btn btn-default" onclick="UCP.Modules.Xmpp.login();return false;">'+_("Login")+"</button>"
                        );
                    });
                    Xmpp.socket.on("online", function(data) {
                        Xmpp.online = true;
                        $(document).bind("logOut", function( event ) {
                            Xmpp.sendEvent("logout");
                        });
                        Xmpp.jid = data.jid;
                        $(".message-box[data-module='Xmpp'] .response textarea").prop("disabled", false);
                        $(".custom-widget[data-widget_rawname=xmpp] a i").css("color", "green");
                        if (typeof UCP.Modules.Presencestate !== "undefined" && typeof UCP.Modules.Presencestate.menu.presence !== "undefined") {
                            Xmpp.sendEvent("setPresence", UCP.Modules.Presencestate.menu.presence);
                        }
                    });
                    Xmpp.socket.on("roster", function(data) {
                        $.each(data, function(i, v) {
                            Xmpp.roster[v.user] = v;
                            if (v.subscription == "to" || v.subscription == "both") {
                                //Xmpp.sendEvent("getPresence", v.user);
                            } else if (v.subscription == "from") {
                                //console.log(v);
                            } else if (v.subscription == "none") {
                                //console.log(v);
                            }
                        });
                    });
                    Xmpp.socket.on("subscribe", function(data) {
                        console.log(data.username + " will you subscribe?");
                        //Xmpp.sendEvent("subscribed", data.username + "@" + data.host);
                    });
                    Xmpp.socket.on("unsubscribe", function(data) {
                        console.log(data.username + " will you unsubscribe?");
                        //Xmpp.sendEvent("unsubscribed", data.username + "@" + data.host);
                    });
                    Xmpp.socket.on("subscribed", function(data) {
                        console.log(data.username + " I have subscribed");
                        //Xmpp.sendEvent("subscribe", data.username + "@" + data.host);
                    });
                    Xmpp.socket.on("unsubscribed", function(data) {
                        console.log(data.username + " I have unsubscribed");
                        //Xmpp.sendEvent("unsubscribe", data.username + "@" + data.host);
                    });
                    Xmpp.socket.on("updatePresence", function(data) {
                        var contact = data.username + "@" + data.host,
                            el = null,
                            h = null;
                        if (typeof Xmpp.roster[contact] !== "undefined") {
                            Xmpp.roster[contact].show = data.show;
                            Xmpp.roster[contact].status = data.status;
                            if ((contact != Xmpp.jid.user + "@" + Xmpp.jid._domain) && data.show != "unavailable") {
                                console.log("online");
                            } else if ((contact != Xmpp.jid.user + "@" + Xmpp.jid._domain) && data.show == "unavailable") {
                                console.log("offline");
                            }
                            /*
							if ((contact != Xmpp.jid.user + "@" + Xmpp.jid._domain) && data.show != "unavailable") {
								if (!$('#xmpp-menu .contact[data-contact="' + encodeURIComponent(contact) + '"]').length) {
									$("#xmpp-menu .breaker").after("<li class=\"contact\" data-contact=\"" + encodeURIComponent(contact) + "\"><a data-contact=\"" + encodeURIComponent(contact) + "\"><i class=\"fa fa-circle\"></i>" + Xmpp.replaceContact(contact) + "</a></li>");
									h = $("#xmpp-menu").outerHeight() + 30;
									$("#xmpp-menu").data("hidden", h);
									$("#xmpp-menu").css("top", "-" + h + "px");
								}
								el = $("#xmpp-menu .contact[data-contact='" + encodeURIComponent(contact) + "']");
								el.off("click");
								el.click(function() {
									Xmpp.initiateChat(decodeURIComponent($(this).data("contact")));
								});
								switch (data.show) {
									case "available":
									case "chat":
										el.find("i").css("color", "green");
									break;
									case "dnd":
										el.find("i").css("color", "red");
									break;
									case "away":
									case "xa":
										el.find("i").css("color", "yellow");
									break;
								}
							} else if ((contact != Xmpp.jid.user + "@" + Xmpp.jid._domain) && data.show == "unavailable") {
								if ($('#xmpp-menu .contact[data-contact="' + encodeURIComponent(contact) + '"]').length > 0) {
									$('#xmpp-menu .contact[data-contact="' + encodeURIComponent(contact) + '"]').fadeOut("fast", function() {
										$(this).remove();
										var h = $("#xmpp-menu").outerHeight() + 30;
										$("#xmpp-menu").data("hidden", h);
										$("#xmpp-menu").css("top", "-" + h + "px");
									});
								}
							}
							*/
                        }
                    });
                    Xmpp.socket.on("offline", function(data) {
                        Xmpp.online = false;
                        $(".message-box[data-module='Xmpp'] .response textarea").prop("disabled", true);
                        $(".custom-widget[data-widget_rawname=xmpp] a i").css("color", "red");
                    });
                    Xmpp.socket.on("message", function(data) {
                        var fhost = data.from.host.split("/"),
                            thost = data.to.host.split("/"),
                            hostdisplay = (Xmpp.jid._domain != fhost) ? "@" + fhost[0] : '',
                            fjid = data.from.username + "@" + fhost[0],
                            tjid = data.to.username + "@" + thost[0],
                            windowid = encodeURIComponent(data.from.username + "@" + Xmpp.jid._domain),
                            name = Xmpp.roster[fjid].name,
                            Notification = new Notify(sprintf(_("New Message from %s"), name), {
                                body: emojione.unifyUnicode(data.message),
                                icon: "modules/Sms/assets/images/comment.png",
                                timeout: 3
                            });
                        UCP.addChat("Xmpp", windowid, Xmpp.icon, data.from.username + "@" + fhost[0], data.to.username + "@" + thost[0], '<div class="from"><strong>F:</strong> '+name+'</div><br/><div class="to"><strong>T:</strong> '+data.to.username+'</div>', data.id, data.message, false, false, 'in');
                        if (UCP.notify) {
                            Notification.show();
                        }
                        $(".message-box[data-id='" + windowid + "'] .response-status span").fadeOut("fast");
                    });
                    Xmpp.socket.on("typing", function(data) {
                        var host = data.from.host.split("/"),
                            windowid = encodeURIComponent(data.from.username + "@" + host[0]);
                        if ($(".message-box[data-id='" + windowid + "']").length > 0) {
                            if (data.typing) {
                                $(".message-box[data-id='" + windowid + "'] .response-status").html("<span>" + sprintf(_("%s is typing..."), Xmpp.replaceContact(data.from.username + "@" + host[0])) + "</span>");
                            } else {
                                $(".message-box[data-id='" + windowid + "'] .response-status span").fadeOut("fast");
                            }
                        }
                    });
                }
            });
        } catch (err) {}
    }
});

/**
 * Documentation https://wiki.freepbx.org/pages/viewpage.action?pageId=71271742
 * @type {[type]}
 */
var ZuluC = UCPMC.extend({
    init: function(){
        if(typeof Cookies === "undefined") {
            return;
        }
        var $this = this;
        this.connected = false;
        this.config = {}
        this.uuid = null

        this.phone = null;
        this.activeCalls = {};
        this.activeCallId = null;
        this.answering = false;
        this.userBlocked = false;
        this.silenced = false;
        this.autoRegister = false;
        this.displayState = null;
        this.state = null;
        this.timerObject = null;
        this.contacts = null;
        this.interactions = null;
        this.publicInteractions = null;
        this.token = null;
        this.myName = null;
        this.simpleWidgetIDContacts = null;
        this.simpleWidgetIDRooms = null;
        this.errorZuluServer = false;
        this.authenticationFailed = false;
        this.zuluAccess = true;
        this.callBinds = [
            "progress",
            "accepted",
            "rejected",
            "failed",
            "terminated",
            "cancel",
            "refer",
            "replaced",
            "dtmf",
            "muted",
            "unmuted",
            "bye",
            "addStream"
        ];

        this.callOptions = {
            "media": {
                "constraints": {
                    "audio": true,
                    "video": false
                },
                "render": {
                    "remote": null
                }
            }
        };

        this.notification = null;
        var st = Cookies.get("zulu-silenced");
        st = (st === "1") ? true : false;
        this.silence(st);

        var rg = Cookies.get("zulu-register");
        this.autoRegister = (typeof rg === "undefined" || rg === "1") ? true : false;


        this.zuluSocket = null
        this.credentials = {
            token: null
        }

        $(document).ajaxError(function( event, request, settings ) {
            UCP.showAlert("Error requesting page " + settings.url,'danger');
        });

        $(document).on("post-body.simplewidgetsettings", function(event, widget_id) {
            if(widget_id === 'user') {
                $("#zulu-gen-qr").click(function() {
                    var self = this
                    $(self).prop("disabled",true);
                    $(self).text(_("Generating..."));
                    $.post( UCP.ajaxUrl+'?module=zulu&command=generateQR',"json")
                        .done(function(data) {
                            if(data.status) {
                                $("#zulu-qr-code").html(data.qrcode);
                            } else {
                                UCP.showAlert(data.message,'warning')
                                $(self).prop("disabled",false);
                                $(self).text(_('Generate QR Code'));
                            }
                        })
                });
                $("input[name='zulu_enable_callStatus']").change(function() {
                    $this.setCallStatus($(this).val()).then(() => {})
                        .catch(err => {
                            UCP.showAlert(err,'danger')
                        })
                });
            }
        });

        //event for chat window added to screen
        // https://wiki.freepbx.org/pages/viewpage.action?pageId=71271742#DevelopingforUCP14+-chatWindowAdded
        $(document).on("chatWindowAdded", function(event, windowId, module, object) {
            if (module == "Zulu") {
                object.on("click", function() {
                    object.find(".title-bar").css("background-color", "");
                });
                var from = object.data("from"),
                    to = object.data("to"),
                    cwindow = $(".message-box[data-id=\"" + windowId + "\"] .window");
                var ea = object.find("textarea").emojioneArea()[0].emojioneArea;
                ea.on("keyup", function(editor, event) {
                    if (event.keyCode == 13) {
                        //$(".message-box[data-id=\"" + windowId + "\"] .response .emojionearea-editor").addClass("hidden");
                        var interactionId = cwindow.data('interaction-id')
                        var text = ea.getText()
                        var chatCommand = {
                            id: Math.random(),
                            command: 'push',
                            type: 'sendMessage',
                            text: text,
                            interactionId: interactionId
                        }
                        $(".message-box[data-id='" + windowId + "'] textarea").val("");
                        ea.setText(" ");
                        $(".message-box[data-id='" + windowId + "'] .response-status").html(_("Sending..."));
                        $this.socketSendJSON(chatCommand)
                        //$(".message-box[data-id=\"" + windowId + "\"] .response .emojionearea-editor").removeClass("hidden");
                        //$(".message-box[data-id=\"" + windowId + "\"] .response .emojionearea-editor").focus();
                    }
                });
            }
        });
    },
    startChat: function() {

    },
    /**
     * This method is called when a client logs in to UCP
     * Username and Password are only populated on inital login
     * refreshes after login will have username and password as null
     * @method
     * @param  {[type]} username [description]
     * @param  {[type]} password [description]
     * @return {[type]}          [description]
     */
    connect: function(username, password) {
        if(typeof Cookies === "undefined") {
            return;
        }
        var $this = this
        $.post( UCP.ajaxUrl+'?module=zulu&command=generateTempZuluToken',"json")
            .done(function(data) {
                if(data.status) {
                    $this.login(data.token)
                } else {
                    $this.zuluAccess = false
                }
            })
    },
    /**
     * This method is called when the browser detects no internet connection
     * @method
     * @return {[type]} [description]
     */
    disconnect: function() {
        if(typeof Cookies === "undefined") {
            return;
        }
        if (this.phone !== null &&
            this.phone.isConnected()) {
            this.phone.stop();
        }
    },
    displaySimpleWidgetSettings: function(widget_id) {
        var $this = this;
        switch(widget_id) {
            case "phone":
                var st = Cookies.get("zulu-silenced");
                st = (st === "1") ? true : false;

                $("#zulu-silence-switch").prop("checked",st);

                $("#zulu-silence-switch").bootstrapToggle('destroy');
                $("#zulu-silence-switch").bootstrapToggle({
                    on: _("Enable"),
                    off: _("Disable")
                });

                $("#zulu-disconnect-switch").prop("checked",!this.autoRegister);

                $("#zulu-disconnect-switch").bootstrapToggle('destroy');
                $("#zulu-disconnect-switch").bootstrapToggle({
                    on: _("Enable"),
                    off: _("Disable")
                });

                if(this.phone === null) {
                    $("#zulu-silence-switch").bootstrapToggle('disable');
                    $("#zulu-disconnect-switch").bootstrapToggle('disable');
                    return;
                }

                $("#zulu-silence-switch").change(function() {
                    $this.silence();
                });
                $("#zulu-disconnect-switch").change(function(e) {
                    $this.toggleRegister();
                });
                break;
            case "chatlist":
            case "roomList":
                break;
        }
    },
    chatWindowBinds: function(cwindow,windowid, contactid) {
        var cwindow = $(".message-box[data-id=\"" + windowid + "\"] .window");
        cwindow.data('interaction-id', windowid)
        cwindow.data('interaction-to', contactid)
        console.log('bound');
    },
    /**
     * https://wiki.freepbx.org/pages/viewpage.action?pageId=71271742#DevelopingforUCP14+-displaySimpleWidget
     * @method
     * @param  {[type]} widget_id [description]
     * @return {[type]}           [description]
     */
    displaySimpleWidget: function(widget_id) {
        var $this = this;
        var widget = $(".custom-widget[data-widget_id='"+widget_id+"']");
        switch(widget.data("widget_type_id")) {
            case "chatList":
                $this.simpleWidgetIDContacts = widget_id;
                var contentBox = $(".widget-extra-menu[data-id='"+widget_id+"'] .small-widget-content")
                if(!this.zuluAccess) {
                    contentBox.append("<div data-id='zulu-error'>User does not have access to Zulu</div>")
                }
                else if(this.errorZuluServer) {
                    contentBox.append("<div data-id='zulu-error'>Websocket connection to zulu failed</div>")
                }
                else if(this.authenticationFailed) {
                    contentBox.append("<div data-id='zulu-error'>Failed zulu authentication</div>")
                }
                else if(this.contacts) {
                    this.displayContacts().then(() => {
                    })
                        .catch(err => {
                            UCP.showAlert(err,'danger')
                        })
                } else {
                    contentBox.append("<div data-id='loading'>Loading...</div>")
                }
                break;
            case "roomList":
                $this.simpleWidgetIDRooms = widget_id;
                var contentBox = $(".widget-extra-menu[data-id='"+widget_id+"'] .small-widget-content")
                if(!this.zuluAccess) {
                    contentBox.append("<div data-id='zulu-error'>User does not have access to Zulu</div>")
                }
                else if(this.errorZuluServer) {
                    contentBox.append("<div data-id='zulu-error'>Websocket connection to zulu failed</div>")
                }
                else if(this.authenticationFailed) {
                    contentBox.append("<div data-id='zulu-error'>Failed zulu authentication</div>")
                }
                else if(this.interactions && this.publicInteractions) {
                    this.displayRooms().then(() => {
                    })
                        .catch(err => {
                            UCP.showAlert(err,'danger')
                        })
                } else {
                    contentBox.append("<div data-id='loading'>Loading...</div>")
                }
                break;
            case "phone":
                var contentBox = $(".widget-extra-menu[data-id='"+widget_id+"'] .small-widget-content")
                if(!this.zuluAccess) {
                    contentBox.append("<div data-id='zulu-error'>User does not have access to Zulu</div>")
                } else {
                    $("#menu_zulu_phone .status span").text(this.displayState);

                    if(this.phone === null) {
                        $("#menu_zulu_phone input.dialpad").prop("disabled",true);
                        return;
                    }

                    if(this.state == "hold") {
                        this.switchState('accepted');
                        this.switchState('hold');
                    } else {
                        this.switchState(this.state);
                    }

                    if(typeof this.phone === "object" && this.phone !== null && this.phone.isRegistered()) {
                        $("#menu_zulu_phone .action").prop("disable",false);
                    }

                    $("#menu_zulu_phone .keypad td").click(function() {
                        var text = $("#menu_zulu_phone .dialpad").val() + $(this).data("num"),
                            button = $("#menu_zulu_phone button.action");
                        if ($this.state == "registered" || $this.state == "accepted") {
                            if ($this.state == "registered") {
                                $( "#menu_zulu_phone .message").text("To: " + text);
                            }
                            $("#menu_zulu_phone .dialpad").val(text);
                            $this.DTMF($(this).data("num"));
                            button.prop("disabled", false);
                            $("#menu_zulu_phone .message-container").textfill();
                        }
                    });

                    $("#menu_zulu_phone .clear-input").click(function() {
                        var button = $("#menu_zulu_phone button.action");
                        $("#menu_zulu_phone .dialpad").val("");
                        if ($this.state == "registered") {
                            $( "#menu_zulu_phone .message").text("");
                            button.prop("disabled", true);
                        }
                    });
                    $("#menu_zulu_phone .dialpad").on('keyup paste', function() {
                        var button = $("#menu_zulu_phone button.action"),
                            text = $("#menu_zulu_phone .dialpad").val();
                        if ($(this).val().length === 0 && ($this.state == "accepted" || $this.state == "registered")) {
                            $( "#menu_zulu_phone .message").text("");
                            button.prop("disabled", true);
                        } else {
                            $( "#menu_zulu_phone .message").text("To: " + text);
                            $this.DTMF(text.slice(-1));
                            button.prop("disabled", false);
                        }
                        $("#menu_zulu_phone .message-container").textfill();
                    });
                    $("#menu_zulu_phone button.action").click(function() {
                        switch ($this.state) {
                            case "registered":
                                $this.call($("#menu_zulu_phone .dialpad").val());
                                break;
                            case "hold":
                            case "accepted":
                                $this.hangup();
                                break;
                            case "invite":
                                $this.answer();
                                break;
                        }
                    });
                    $("#menu_zulu_phone button.secondaction").click(function() {
                        switch ($this.state) {
                            case "hold":
                            case "accepted":
                                $this.toggleHold();
                                break;
                            case "invite":
                                $this.hangup();
                                break;
                        }
                    });
                    $("#menu_zulu_phone .message-container").textfill();
                }
                break;
        }
    },
    /**
     * Widget is deletec
     * @method
     * @param  {[type]} widget_id [description]
     * @return {[type]}           [description]
     */
    deleteSimpleWidget: function(widget_id) {
        if($(".custom-widget[data-widget_id='"+widget_id+"']").data("widget_type_id") === "phone" && this.phone !== null) {
            this.disconnect();
        }
    },
    connectPhone: function() {
        if ((typeof this.staticsettings !== "undefined") &&
            this.staticsettings.enabled &&
            Modernizr.getusermedia &&
            this.phone !== null &&
            !this.phone.isConnected()) {
            this.phone.start();
        }
    },
    login: function(token) {
        this.credentials.token = token
        //do websocket login here
        this.zuluSocket = new WebSocket("wss://"+window.location.host.split(':')[0]+":8002");
        this.zuluSocket.onopen = this.socketOpen.bind(this)
        this.zuluSocket.onmessage = this.socketOnmessage.bind(this)
        this.zuluSocket.onclose = this.socketOnclose.bind(this)
        this.zuluSocket.onerror = this.socketOnerror.bind(this)
    },
    getContacts: function() {
        return new Promise((resolve, reject) => {
            $.ajax({
                url: "https://" + window.location.host.split(':')[0] + ":8002/api/contact",
                type: "GET",
                headers: {
                    'X-Auth-Token': this.token
                }
            })
                .done(function(data) {
                    return resolve(data)
                })
        });
    },
    getInteractions: function() {
        return new Promise((resolve, reject) => {
            $.ajax({
                url: "https://" + window.location.host.split(':')[0] + ":8002/api/v2/interaction",
                type: "GET",
                headers: {
                    'X-Auth-Token': this.token
                }
            })
                .done(function(data) {
                    return resolve(data.rows);
                })
        })
    },
    getPublicInteractions: function() {
        return new Promise((resolve, reject) => {
            $.ajax({
                url: "https://" + window.location.host.split(':')[0] + ":8002/api/interaction/group/public",
                type: "GET",
                headers: {
                    'X-Auth-Token': this.token
                }
            })
                .done(function(data) {
                    return resolve(data)
                })
        })
    },
    createInteraction: function(contactID) {
        return new Promise((resolve, reject) => {
            var data = {
                'members' : {
                    'contact': [contactID]
                }
            }
            $.ajax({
                url: "https://" + window.location.host.split(':')[0] + ":8002/api/interaction/interaction",
                type: "POST",
                headers: {
                    'X-Auth-Token': this.token
                },
                data: JSON.stringify(data),
                contentType: "application/json",
                dataType: "json"
            })
                .done(function(interaction) {
                    return resolve(interaction.id)
                })
        })
    },
    setCallStatus: function(value) {
        return new Promise((resolve, reject) => {
            if(value === 'true') {
                value = true
            } else if(value === 'false') {
                value = false
            } else if(value !== 'inherit' && value !== 'callerid') {
                return reject(new Error('Invalid parameter value'))
            }
            data = {
                'enable_callStatus': value
            }
            $.ajax({
                url: "https://" + window.location.host.split(':')[0] + ":8002/api/user/callstatus",
                type: "PUT",
                headers: {
                    'X-Auth-Token': this.token
                },
                data: JSON.stringify(data),
                contentType: "application/json",
                dataType: "json"
            })
                .done(function(result) {
                    if(result.status === true) {
                        return resolve()
                    } else {
                        return reject(new Error(result.message))
                    }
                })
        })
    },
    joinRoom: function(interactionid) {
        return new Promise((resolve, reject) => {
            let interaction = this.interactions.find(o => o.id === interactionid)
            if(interaction) {
                return resolve()
            } else {
                $.ajax({
                    url: "https://" + window.location.host.split(':')[0] + ":8002/api/interaction/" + interactionid + "/member",
                    type: "POST",
                    headers: {
                        'X-Auth-Token': this.token
                    },
                    contentType: "application/json",
                    dataType: "json"
                })
                    .done(function(data) {
                        if(data.status) {
                            return resolve()
                        } else{
                            return reject(new Error(data.message))
                        }
                    })
            }
        })
    },
    getDisplayName: function(contactuuid) {
        return new Promise((resolve, reject) => {
            var displayName = ''
            var found = false
            async.each(this.contacts, function(contact, callback) {
                if(contact.id === contactuuid) {
                    displayName = contact.displayName
                    found = true
                }
                callback()
            }, function(err) {
                if(err) {
                    return reject(err)
                }
                else {
                    if(found) {
                        return resolve(displayName)
                    }
                    else {
                        return resolve(null)
                    }
                }
            })
        })
    },
    getInteractionID: function(contactuuid) {
        return new Promise((resolve, reject) => {
            var interactionID = null
            async.each(this.interactions, function(interaction, callback) {
                if(interaction.contacts[0] === contactuuid && interaction.type === 'direct') {
                    interactionID = interaction.id
                }
                callback()
            }, function(err) {
                if(err) {
                    return reject(err)
                }
                else {
                    return resolve(interactionID)
                }
            })
        })
    },
    displayContacts: function(contactname='') {
        var $this = this;
        return new Promise((resolve, reject) => {
            if(!$this.simpleWidgetIDContacts) {
                return resolve()
            }
            var contentBox = $(".widget-extra-menu[data-id='"+$this.simpleWidgetIDContacts+"'] .small-widget-content")
            if($("div[data-id='loading']").length) {
                $(".widget-extra-menu[data-id='"+$this.simpleWidgetIDContacts+"'] .small-widget-content div[data-id='loading']").remove()
            }
            if($("div[data-id='zulu-error']").length) {
                $(".widget-extra-menu[data-id='"+$this.simpleWidgetIDContacts+"'] .small-widget-content div[data-id='zulu-error']").remove()
            }
            if(!$("div[data-id='searchBox']").length) {
                contentBox.append('<div data-id="searchBox"><input type="text" class="zulu-search"></div>')
                $('.zulu-search').on('input', function() {
                    $('.zulu-contact').remove()
                    $this.displayContacts($(this).val()).then(() => {})
                        .catch(err => {
                            UCP.showAlert(err,'danger')
                        })
                })
            }
            contactname = contactname.toLowerCase()
            async.each($this.contacts, function(contact, callback) {
                let searchName = contact.displayName.toLowerCase()
                if(contact.id !== $this.uuid && ((contactname !== '' && searchName.includes(contactname)) || (contactname === '' && contact.chatConnected))) {
                    let style = ''
                    if(contact.chatConnected) {
                        style = 'style="color:green"'
                    }
                    contentBox.append('<div data-id="'+contact.id+'" data-name="'+contact.displayName
                        +'" class="zulu-contact clickable"><i class="fa fa-user" '+style+'></i> '+contact.displayName+'</div>')
                }
                callback()
            }, function(err) {
                if(err) {
                    return reject(err)
                } else {
                    $(document).off("click",".zulu-contact");
                    $(document).on("click",".zulu-contact",function() {
                        console.log("Load ucpchat for user "+$(this).data('id'))
                        var contactid = $(this).data('id');
                        $this.getInteractionID(contactid).then((interactionid) => {
                            if(interactionid === null) {
                                return $this.createInteraction(contactid)
                            }
                            else {
                                return Promise.resolve(interactionid)
                            }
                        })
                            .then((interactionid) => {
                                var windowid = interactionid
                                UCP.addChat(
                                    'Zulu',
                                    windowid,
                                    'fa fa-comments',
                                    $this.myName,
                                    $(this).data('name'),
                                    $(this).data('name'),
                                    undefined,
                                    undefined,
                                    function() {
                                        var cwindow = $(".message-box[data-id=\"" + windowid + "\"] .window");
                                        $this.chatWindowBinds(cwindow, windowid, contactid)
                                    }
                                )
                            }).catch((err) => {
                            UCP.showAlert(err,'danger')
                        })
                    })
                    return resolve()
                }
            })
        })
    },
    displayRooms: function(roomname='') {
        var $this = this;
        return new Promise((resolve, reject) => {
            if(!$this.simpleWidgetIDRooms) {
                return resolve()
            }
            var contentBox = $(".widget-extra-menu[data-id='"+$this.simpleWidgetIDRooms+"'] .small-widget-content")
            if($("div[data-id='loading']").length) {
                $(".widget-extra-menu[data-id='"+$this.simpleWidgetIDRooms+"'] .small-widget-content div[data-id='loading']").remove()
            }
            if($("div[data-id='zulu-error']").length) {
                $(".widget-extra-menu[data-id='"+$this.simpleWidgetIDRooms+"'] .small-widget-content div[data-id='zulu-error']").remove()
            }
            if(!$("div[data-id='searchRoom']").length) {
                contentBox.append('<div data-id="searchRoom"><input type="text" class="zulu-roomSearch"></div>')
                $('.zulu-roomSearch').on('input', function() {
                    $('.zulu-room').remove()
                    $this.displayRooms($(this).val()).then(() => {})
                        .catch(err => {
                            UCP.showAlert(err,'danger')
                        })
                })
            }
            roomname = roomname.toLowerCase()
            let loop
            if(roomname !== '') {
                loop = $this.interactions.concat($this.publicInteractions)
            } else {
                loop = $this.interactions
            }
            async.each(loop, function(interaction, callback) {
                let interactionTopic = (interaction.topic) ? interaction.topic.toLowerCase() : ''
                if(interaction.type !== 'direct' && ((roomname !== '' && interactionTopic.includes(roomname)) || (roomname === ''))) {
                    let icon
                    let style
                    let objInteraction = $this.interactions.find(o => o.id === interaction.id)
                    if(objInteraction) {
                        style = 'style="color:green"'
                    }
                    if(interaction.type === 'public') {
                        icon = '<i class="fa fa-hashtag"></i>'
                    } else {
                        icon = '<i class="fa fa-lock"></i>'
                    }
                    if(!$(".zulu-room[data-id='"+interaction.id+"']").length) {
                        contentBox.append('<div data-id="'+interaction.id+'" data-name="'+interaction.topic
                            +'" class="zulu-room clickable"><i class="fa fa-users" ' + style + '></i> '+interaction.topic+' ' + icon +'</div>')
                    }
                }
                callback()
            }, function(err) {
                if(err) {
                    return reject(err)
                } else {
                    $(document).off("click",".zulu-room");
                    $(document).on("click",".zulu-room",function() {
                        let interactionid = $(this).data('id');
                        $this.joinRoom(interactionid).then(() => {
                            if($(".zulu-room[data-id='"+interactionid+"']").length) {
                                $("div[data-id='"+interactionid+"'] i.fa-users").css('color', 'green')
                            }
                            var windowid = interactionid
                            UCP.addChat(
                                'Zulu',
                                windowid,
                                'fa fa-comments',
                                $this.myName,
                                $(this).data('name'),
                                $(this).data('name'),
                                undefined,
                                undefined,
                                function() {
                                    var cwindow = $(".message-box[data-id=\"" + windowid + "\"] .window");
                                    $this.chatWindowBinds(cwindow, windowid, null)
                                }
                            )
                        }).catch((err) => {
                            UCP.showAlert(err,'danger')
                        })
                    })
                    return resolve()
                }
            })
        })
    },
    displayError: function(errMessage) {
        if(this.simpleWidgetIDContacts) {
            var contentBox = $(".widget-extra-menu[data-id='"+this.simpleWidgetIDContacts+"'] .small-widget-content")
            contentBox.append("<div data-id='zulu-error'>"+errMessage+"</div>")
        }
    },
    socketOpen: function(event) {
        let loginCommand = {
            command: 'login',
            data: {
                token: this.credentials.token,
                auth: "token",
                lastconnected: null,
                clientversion: "3.1",
                clienttype: "ucp"
            }
        }

        return this.socketSendJSON(loginCommand)
    },
    socketOnmessage: function(event) {
        var data = JSON.parse(event.data)
        var $this = this
        if(!this.connected && typeof data.type !== 'undefined' && data.type == "auth") {
            this.connected = true;
            this.config = data.config
            this.token = data.token
            this.uuid = data.uuid
            this.getContacts().then((contacts) => {
                this.contacts = contacts;
                return this.getInteractions();
            })
                .then((interactions) => {
                    this.interactions = interactions;
                    return this.getPublicInteractions();
                })
                .then((publicInteractions) => {
                    this.publicInteractions = publicInteractions;
                    return this.getDisplayName(this.uuid);
                })
                .then((displayName) => {
                    this.myName = (displayName === null) ? '' : displayName;
                    return this.displayContacts();
                })
                .then(() => {
                    return this.displayRooms()
                })
                .catch((err) => {
                    UCP.showAlert(err,'danger')
                });
            return
        }
        if(this.connected && data.subscription === 'stream' && data.data.add.type === 'CHAT_MESSAGE') {
            //HERE YOU RECEIVE A NEW STREAM NOTIFICATION
            var direction = (data.data.add.contact !== this.uuid) ? 'in' : 'out';
            var cname = null
            var windowid = data.data.add.interaction_id
            this.getDisplayName(data.data.add.contact).then((displayName) => {
                if(displayName === null) {
                    return this.getContacts()
                } else {
                    cname = displayName
                    return Promise.resolve(this.contacts)
                }
            })
                .then((contacts) => {
                    this.contacts = contacts
                    if(cname === null) {
                        return this.getDisplayName(data.data.add.contact)
                    }
                    else {
                        return Promise.resolve(cname)
                    }
                })
                .then((displayName) => {
                    let objInteraction = this.interactions.find(o => o.id === data.data.add.interaction_id)
                    if(objInteraction) {
                        let name
                        let text
                        let notificationText
                        let contactName = (displayName === null) ? 'Unknown' : displayName
                        if(objInteraction.type === 'direct') {
                            name = contactName
                            text = emojione.shortnameToImage(data.data.add.body.text)
                            notificationText = emojione.unifyUnicode(data.data.add.body.text)
                        } else {
                            name = objInteraction.topic
                            if(direction === 'in') {
                                text = "<b>" + contactName + ":</b> " + emojione.shortnameToImage(data.data.add.body.text)
                            } else {
                                text = emojione.shortnameToImage(data.data.add.body.text)
                            }
                            notificationText = contactName + ": " + emojione.unifyUnicode(data.data.add.body.text)
                        }
                        var Notification = new Notify(sprintf(_("New Message from %s"), name), {
                            body: notificationText,
                            icon: "modules/Sms/assets/images/comment.png",
                            timeout: 3
                        });

                        if(direction === 'out') {
                            $(".message-box[data-id='" + windowid + "'] .response-status").html("");
                        }

                        //https://wiki.freepbx.org/pages/viewpage.action?pageId=71271742#DevelopingforUCP14+-UCP.addChat
                        UCP.addChat(
                            "Zulu",
                            windowid,
                            "fa fa-comments-o",
                            name,
                            this.myName,
                            name,
                            data.data.add.id,
                            text,
                            function() {
                                var cwindow = $(".message-box[data-id=\"" + windowid + "\"] .window");
                                $this.chatWindowBinds(cwindow, windowid, data.data.add.contact)
                            },
                            true,
                            direction
                        );
                        if (UCP.notify && direction === 'in') {
                            Notification.show();
                        }
                    }
                }).catch((err) => {
                $(".message-box[data-id='" + windowid + "'] .response-status").html(err);
                UCP.showAlert(err,'danger')
            })
        }
        if(this.connected && data.subscription === 'kicked_interaction') {
            let objInteraction = this.interactions.find(o => o.id === data.data.add.id)
            if(objInteraction) {
                let index = this.interactions.indexOf(objInteraction)
                this.interactions.splice(index,1)
            }
            if(this.simpleWidgetIDRooms !== null) {
                if($(".zulu-room[data-id='"+data.data.add.id+"']").length) {
                    let searchVal = $('.zulu-roomSearch').val()
                    if(!searchVal) {
                        searchVal = ''
                    }
                    if(searchVal === '') {
                        $(".widget-extra-menu[data-id='"+this.simpleWidgetIDRooms+"'] .small-widget-content div[data-id='"+data.data.add.id+"']").remove()
                    } else {
                        $("div[data-id='"+data.data.add.id+"'] i.fa-users").css('color', '')
                    }
                }
            }
        }
        if(this.connected && data.subscription === 'interaction') {
            let objInteraction = this.interactions.find(o => o.id === data.data.add.id)
            if(objInteraction) {
                let index = this.interactions.indexOf(objInteraction)
                this.interactions.splice(index,1)
                this.interactions.push(data.data.add)
            } else {
                this.interactions.push(data.data.add)
                if(this.simpleWidgetIDRooms !== null && data.data.add.type !== 'direct') {
                    let searchVal = $('.zulu-roomSearch').val()
                    if(!searchVal) {
                        searchVal = ''
                    }
                    let compare = data.data.add.topic.toLowerCase()
                    searchVal = searchVal.toLowerCase()
                    if(searchVal === '' || compare.includes(searchVal)) {
                        if(!$(".zulu-room[data-id='"+data.data.add.id+"']").length) {
                            let icon
                            if(data.data.add.type === 'public') {
                                icon = '<i class="fa fa-hashtag"></i>'
                            } else {
                                icon = '<i class="fa fa-lock"></i>'
                            }
                            var contentBox = $(".widget-extra-menu[data-id='"+this.simpleWidgetIDRooms+"'] .small-widget-content")
                            contentBox.append('<div data-id="'+data.data.add.id+'" data-name="'+data.data.add.topic
                                +'" class="zulu-room clickable"><i class="fa fa-users" style="color:green"></i> '+data.data.add.topic+' ' + icon +'</div>')
                        }
                    }
                }
            }
        }
        if(this.connected && data.subscription === 'public_interaction') {
            let objInteraction = this.publicInteractions.find(o => o.id === data.data.add.id)
            if(objInteraction) {
                let index = this.publicInteractions.indexOf(objInteraction)
                this.publicInteractions.splice(index,1)
                this.publicInteractions.push(data.data.add)
            } else {
                this.publicInteractions.push(data.data.add)
                if(this.simpleWidgetIDRooms !== null) {
                    let searchVal = $('.zulu-roomSearch').val()
                    if(!searchVal) {
                        searchVal = ''
                    }
                    let compare = data.data.add.topic.toLowerCase()
                    searchVal = searchVal.toLowerCase()
                    if(searchVal !== '' && compare.includes(searchVal)) {
                        if(!$(".zulu-room[data-id='"+data.data.add.id+"']").length) {
                            var contentBox = $(".widget-extra-menu[data-id='"+this.simpleWidgetIDRooms+"'] .small-widget-content")
                            contentBox.append('<div data-id="'+data.data.add.id+'" data-name="'+data.data.add.topic
                                +'" class="zulu-room clickable"><i class="fa fa-users" ></i> '+data.data.add.topic+' <i class="fa fa-hashtag"></i></div>')
                        }
                    }
                }
            }
        }
        if(this.connected && data.action === 'chat::user-connection' && data.contactId !== this.uuid) {
            var name = null
            this.getDisplayName(data.contactId).then((displayName) => {
                if(displayName === null) {
                    return this.getContacts()
                }
                else {
                    name = displayName
                    return Promise.resolve(this.contacts)
                }
            })
                .then((contacts) => {
                    this.contacts = contacts
                    if(name === null) {
                        return this.getDisplayName(data.contactId)
                    }
                    else {
                        return Promise.resolve(name)
                    }
                })
                .then((displayName) => {
                    name = displayName
                    let searchVal = $('.zulu-search').val()
                    if(!searchVal) {
                        searchVal = ''
                    }
                    searchVal = searchVal.toLowerCase()
                    let compare = name.toLowerCase()
                    let contactElement = this.contacts.findIndex(function(element) {
                        return element.id === data.contactId
                    })
                    if(contactElement !== -1) {
                        if(data.state === 'connected') {
                            this.contacts[contactElement].chatConnected = true
                        }
                        if(data.state === 'disconnected') {
                            this.contacts[contactElement].chatConnected = false
                        }
                    }
                    if(this.simpleWidgetIDContacts !== null) {
                        if(data.state === 'connected') {
                            if(searchVal === '' || compare.includes(searchVal)) {
                                if(!$(".zulu-contact[data-id='"+data.contactId+"']").length) {
                                    var contentBox = $(".widget-extra-menu[data-id='"+this.simpleWidgetIDContacts+"'] .small-widget-content")
                                    contentBox.append('<div data-id="'+data.contactId+'" data-name="'+name
                                        +'" class="zulu-contact clickable"><i class="fa fa-user" style="color:green"></i> '+name+'</div>')
                                } else {
                                    $("div[data-id='"+data.contactId+"'] i.fa-user").css('color', 'green')
                                }
                            }
                        }
                        if(data.state === 'disconnected') {
                            if(searchVal === '' || !compare.includes(searchVal)) {
                                if($(".zulu-contact[data-id='"+data.contactId+"']").length) {
                                    $(".widget-extra-menu[data-id='"+this.simpleWidgetIDContacts+"'] .small-widget-content div[data-id='"+data.contactId+"']").remove()
                                }
                            } else {
                                if($(".zulu-contact[data-id='"+data.contactId+"']").length) {
                                    $("div[data-id='"+data.contactId+"'] i.fa-user").css('color', '')
                                }
                            }
                        }
                    }
                })
                .catch((err) => {
                    UCP.showAlert(err,'danger')
                })
        }
    },
    socketOnclose: function(event) {
        this.connected = false;
        if(!this.authenticationFailed) {
            this.authenticationFailed = true;
            this.displayError('Failed zulu authentication')
        }
        console.log("close")
    },
    socketOnerror: function(event) {
        console.log("error")
        if(!this.errorZuluServer) {
            this.errorZuluServer = true;
            this.displayError('Websocket connection to zulu failed')
        }
    },
    socketSendRawMessage: function(message) {
        this.zuluSocket.send(message);
    },
    socketSendJSON: function(json) {
        this.socketSendRawMessage(JSON.stringify(json));
    },
    addSimpleWidget: function(widget_id) {
        if($(".custom-widget[data-widget_id='"+widget_id+"']").data("widget_type_id") === "phone") {
            this.initiatePhoneLibrary();
        }
    },
    engineEvent: function(type, event) {
        console.log("Engine " + type);
        switch (type){
            case "invite":
                this.manageSession(event,"inbound");
                this.switchState("invite");
                break;
            case "registered":
                this.switchState("registered");
                break;
            case "unregistered":
                this.switchState("unregistered");
                break;
            case "registrationFailed":
                this.switchState("registrationfailed");
                break;
            case "connected":
                this.switchState("connected");
                break;
            case "disconnected":
                this.switchState("disconnected");
                break;
            case "connecting":
                this.switchState("connecting");
                break;
            case "registering": //custom event type
                this.switchState("registering");
                break;
        }
    },
    setDisplayState: function(state) {
        this.displayState = state;
        $("#menu_zulu_phone .status span").text(this.displayState);
    },
    playRing: function() {
        if(!this.silenced) {
            $("#ringtone").trigger("play");
        }
    },
    stopRing: function() {
        $("#ringtone").trigger("pause");
        $("#ringtone").trigger("load");
    },
    manageSession: function(session, direction) {
        var Zulu = this,
            id,
            displayName,
            status,
            cnum,
            cnam,
            call = session;

        id = Math.floor((Math.random() * 100000) + 1);
        // If the session exists with active call reject it.
        // TODO this can be useful for call waiting
        if (this.activeCallId) {
            call.terminate();
            return false;
        }

        // If this is a new session create it
        if (!this.activeCallId) {
            this.activeCallId = id;
            this.activeCalls[id] = call;
        }

        cnum = this.activeCalls[id].remoteIdentity.uri.user;
        cnam = this.activeCalls[this.activeCallId].remoteIdentity.displayName || "";
        displayName = (cnam !== "") ? cnam + " <" + cnum + ">" : cnum;
        $("#menu_zulu_phone .contactDisplay .contactImage").css("background-image",'url("?quietmode=1&module=Zulu&command=cimage&did='+cnum+'")');
        Zulu.answering = false;
        if (direction === "inbound") {
            if (UCP.notify) {
                this.notification = new Notify(sprintf(_("Incoming call from %s"), displayName), {
                    body: _("Click this window to answer or close this window to ignore"),
                    icon: "modules/Zulu/assets/images/no_user_logo.png", //TODO: get the user logo
                    notifyClose: function() {
                        if (Zulu.answering) {
                            Zulu.answering = false;
                        } else {
                            Zulu.hangup();
                        }
                    },
                    notifyClick: function() {
                        Zulu.answering = true;
                        Zulu.answer();
                        $(".custom-widget[data-widget_rawname=zulu]").click();
                        Zulu.notification.close();
                    }
                });
                this.notification.show();
            }
        }

        $.each(this.callBinds, function(i, v) {
            Zulu.activeCalls[Zulu.activeCallId].on(v, function(data, cause) {
                Zulu.sessionEvent(v, data, cause);
            });
        });
    },
    sessionEvent: function(type, data, cause) {
        console.log("Session " + type);
        switch (type){
            case "terminated":
                this.switchState("terminated");
                this.endCall(data, cause);
                break;
            case "accepted":
                this.switchState("accepted");
                this.startCall(data);
                break;
            case "progress":
                this.switchState("progress");
                break;
            case "dtmf":
                this.switchState("dtmf");
                break;
            case "muted":
                this.switchState("muted");
                break;
            case "unmuted":
                this.switchState("unmuted");
                break;
        }
    },
    endCall: function(message, cause) {
        this.activeCalls[this.activeCallId] = null;
        this.activeCallId = null;
        if (this.notification !== null) {
            this.notification.close();
        }
        if(typeof cause !== "undefined" && cause === SIP.C.causes.USER_DENIED_MEDIA_ACCESS) {
            this.userBlocked = true;
        }
        $("#menu_zulu_phone .btn-primary").prop("disabled", false);
        this.stopRing();
    },
    startCall: function(event) {
        if (this.notification !== null) {
            this.notification.close();
        }
        this.stopRing();
    },
    silence: function(state) {
        state = (typeof state !== "undefined") ? state : !this.silenced;
        if(!$("#zulu-silence").length) {
            $(".custom-widget[data-widget_rawname=zulu] .fa-phone").after('<i id="zulu-silence" class="fa fa-ban fa-stack-2x hidden"></i>');
        }
        if(state) {
            this.stopRing();
            $("#zulu-silence").removeClass("hidden");
            $("#zulu-silence .fa-check").removeClass("hidden");
        } else {
            $("#zulu-silence").addClass("hidden");
            $("#zulu-silence .fa-check").addClass("hidden");
        }
        Cookies.set("zulu-silenced",(state ? "1" : "0"));
        this.silenced = state;
    },
    call: function(number) {
        if (this.phone.isConnected() && !this.userBlocked) {
            $("#menu_zulu_phone .btn-primary").prop("disabled", true);
            var session = this.phone.invite(number, this.callOptions);
            this.manageSession(session,"outbound");
        } else if(this.phone.isConnected() && this.userBlocked) {
            alert(_("Unable to start call. Please allow the WebRTC session in your browser and refresh"));
        }
    },
    answer: function() {
        if (this.activeCallId !== null) {
            this.answering = true;
            this.activeCalls[this.activeCallId].accept(this.callOptions);
        }
    },
    toggleHold: function() {
        if (this.activeCallId !== null) {
            var call = this.activeCalls[this.activeCallId],
                holds = this.activeCalls[this.activeCallId].isOnHold();
            if (!holds.local) {
                this.switchState("hold");
                call.hold();
            } else {
                this.switchState("unhold");
                call.unhold();
            }
        }
    },
    DTMF: function(num) {
        if (this.state == "accepted" && this.activeCallId !== null) {
            this.activeCalls[this.activeCallId].dtmf(num);
        }
    },
    hangup: function() {
        if ((this.state == "accepted" || this.state == "invite") && this.activeCallId !== null) {
            this.activeCalls[this.activeCallId].terminate();
        }
        this.stopRing();
    },
    switchState: function(t) {
        var button = $("#menu_zulu_phone button.action"),
            secondbutton = $("#menu_zulu_phone button.secondaction"),
            input = $("#menu_zulu_phone input.dialpad"),
            type = (typeof t !== "undefined" && t !== null) ? t : "registered",
            $this = this;
        this.state = type;
        button.data("type", type);
        switch (type){
            case "dtmf":
                this.state = "accepted";
                break;
            case "invite":
                $(".custom-widget[data-widget_rawname=zulu] .fa-phone").addClass("shake");
                this.playRing();
                $("#menu_zulu_phone .activeCallSession .keypad").hide();
                $("#menu_zulu_phone .activeCallSession .input-container").hide();
                $("#menu_zulu_phone .contactDisplay").show();
                secondbutton.removeClass().addClass("btn btn-danger secondaction").text("Ignore");
                $("#menu_zulu_phone .actions .right").show();
                button.removeClass().addClass("btn btn-success action").text("Answer");
                button.prop("disabled", false);
                break;
            case "hold":
                secondbutton.removeClass().addClass("btn btn-success secondaction").text("UnHold");
                secondbutton.css("background-color","orange");
                if(!$("#zulu-hold").length) {
                    $(".custom-widget[data-widget_rawname=zulu] .fa-phone").after('<i id="zulu-hold" class="fa fa-pause fa-stack-2x blink hidden"></i>');
                }
                $("#zulu-hold").removeClass("hidden");
                break;
            case "unhold":
                secondbutton.removeClass().addClass("btn btn-success secondaction").text("Hold");
                secondbutton.css("background-color","");
                if($("#zulu-hold").length) {
                    $("#zulu-hold").addClass("hidden");
                }

                this.state = "accepted";
                break;
            case "accepted":
                this.stopRing();
                $(".custom-widget[data-widget_rawname=zulu] .fa-phone").removeClass("shake");
                $("#menu_zulu_phone .contactDisplay").hide();
                $("#menu_zulu_phone .activeCallSession .keypad").show();
                $("#menu_zulu_phone .activeCallSession .input-container").show();
                secondbutton.removeClass().addClass("btn btn-success secondaction").text("Hold");
                secondbutton.css("color","");
                $("#menu_zulu_phone .actions .right").show();

                input.prop("disabled", false);
                button.prop("disabled", false);
                button.removeClass().addClass("btn btn-danger action").text("Hangup");
                $("#menu_zulu_phone .contact-info").addClass("in");
                $("#zulu-timer-container").remove();
                clearInterval(this.timerObject);
                $('#zulu-disconnect-switch').bootstrapToggle('disable');
                var updateTimer = function() {
                    if($this.activeCallId === null) {
                        clearInterval($this.timerObject);
                        $("#menu_zulu_phone .contact-info").removeClass("in");
                        $('#zulu-disconnect-switch').bootstrapToggle('enable');
                        return;
                    }
                    //
                    var start = moment($this.activeCalls[$this.activeCallId].startTime);
                    var end = moment();
                    var duration = moment.duration(end.diff(start));

                    var padLeft = function(nr){
                        return Array(2-String(nr).length+1).join('0')+nr;
                    };

                    var time = padLeft(duration.hours())+":"+padLeft(duration.minutes())+":"+padLeft(duration.seconds());

                    if($("#menu_zulu_phone .contact-info .timer").is(":visible")) {
                        $("#menu_zulu_phone .contact-info .timer").text(time);
                    } else {
                        if(!$("#zulu-timer-container").length) {
                            $(".custom-widget[data-widget_rawname=zulu] .fa-phone").after('<div id="zulu-timer-container"><div class="timer">'+time+'</div></div>');
                        } else {
                            $("#zulu-timer-container .timer").text(time);
                        }
                    }
                };
                updateTimer();
                this.timerObject = setInterval(updateTimer,1000);

                var cnam = this.activeCalls[this.activeCallId].remoteIdentity.displayName || "",
                    cnum = this.activeCalls[this.activeCallId].remoteIdentity.uri.user,
                    displayName = (cnam !== "") ? cnam + " <" + cnum + ">" : cnum;
                $("#menu_zulu_phone .contact-info .contact").text(displayName);
                break;
            case "terminated":
                this.stopRing();
                $("#menu_zulu_phone .actions .right").hide();
                $(".custom-widget[data-widget_rawname=zulu] .fa-phone").removeClass("shake");
                $("#menu_zulu_phone .activeCallSession .keypad").show();
                $("#menu_zulu_phone .activeCallSession .input-container").show();
                $("#menu_zulu_phone .contactDisplay").hide();
                button.removeClass().addClass("btn btn-primary action").text("Call");
                $("#menu_zulu_phone .contact-info .contact").text("");
                this.state = "registered";
                break;
            case "registered":
                $(".custom-widget[data-widget_rawname=zulu] .fa-phone").removeClass("registering");
                this.setDisplayState(_("Registered"));
                $(".custom-widget[data-widget_rawname=zulu] .fa-phone").css("color", "green");
                input.prop("disabled", false);
                input.val("");
                $("#menu_zulu_phone .keypad").removeClass("disable");
                button.prop("disabled", true);
                $("#menu_zulu_phone .actions .right").hide();
                button.removeClass().addClass("btn btn-primary action").text("Call");
                break;
            case "unregistered":
                this.setDisplayState(_("Unregistered"));
                $(".custom-widget[data-widget_rawname=zulu] .fa-phone").removeClass("registering");
                $(".custom-widget[data-widget_rawname=zulu] .fa-phone").css("color", "yellow");
                $("#menu_zulu_phone .keypad").addClass("disable");
                input.prop("disabled", true);
                input.val("");
                break;
            case "registrationfailed":
                this.setDisplayState(_("Registration Failed"));
                $(".custom-widget[data-widget_rawname=zulu] .fa-phone").removeClass("registering");
                $("#zulu-dc a span").text(_("Connect Phone"));
                $(".custom-widget[data-widget_rawname=zulu] .fa-phone").css("color", "red");
                $("#menu_zulu_phone .keypad").addClass("disable");
                input.prop("disabled", true);
                input.val("");
                break;
            case "connected":
                this.setDisplayState(_("Unregistered"));
                $(".custom-widget[data-widget_rawname=zulu] .fa-phone").removeClass("connecting");
                $(".custom-widget[data-widget_rawname=zulu] .fa-phone").css("color", "yellow");
                break;
            case "disconnected":
                this.setDisplayState(_("Disconnected"));
                $(".custom-widget[data-widget_rawname=zulu] .fa-phone").removeClass("connecting");
                $(".custom-widget[data-widget_rawname=zulu] .fa-phone").removeClass("registering");
                $(".custom-widget[data-widget_rawname=zulu] .fa-phone").css("color", "red");
                $("#menu_zulu_phone .keypad").addClass("disable");
                input.prop("disabled", true);
                input.val("");
                break;
            case "connecting":
                this.setDisplayState(_("Connecting to socket..."));
                $(".custom-widget[data-widget_rawname=zulu] .fa-phone").css("color", "red");
                $(".custom-widget[data-widget_rawname=zulu] .fa-phone").addClass("connecting");
                $(".custom-widget[data-widget_rawname=zulu] .fa-phone").removeClass("registering");
                break;
            case "registering": //custom event type
                this.setDisplayState(_("Registering..."));
                $(".custom-widget[data-widget_rawname=zulu] .fa-phone").addClass("registering");
                break;
        }
    },
    register: function() {
        if(!this.phone.isConnected()) {
            this.connectPhone();
        }
        if (this.phone !== null &&
            !this.phone.isRegistered()) {
        }
        this.phone.register();
    },
    unregister: function() {
        if(!this.phone.isConnected()) {
            throw "Phone is not connected, nothing to register";
        }
        if (this.phone !== null &&
            this.phone.isRegistered()) {
        }
        this.phone.unregister();
    },
    toggleRegister: function() {
        if(!this.phone.isConnected()) {
            return; //nope
        }
        if($(".custom-widget[data-widget_rawname=zulu] .fa-phone").hasClass("registering")) {
            return; //we are already doing something
        }
        if(!this.phone.isRegistered()) {
            this.register();
            Cookies.set("zulu-register",1);
        } else {
            this.unregister();
            Cookies.set("zulu-register",0);
        }

    },
    initiatePhoneLibrary: function() {
        var $this = this,
            ver = "0.7.7";

        if(typeof SIP === "object") {
            $this.loadPhone();
            return;
        } else {
            if(!$("html").hasClass("getusermedia")) {
                $(".custom-widget[data-widget_rawname=zulu] .fa-phone").css("color", "red");
                this.setDisplayState(_("Not supported in this browser"));
                console.warn("WebRTC is not supported in this browser");
                return;
            }

            if(document.location.protocol !== "https:") {
                $(".custom-widget[data-widget_rawname=zulu] .fa-phone").css("color", "red");
                this.setDisplayState(_("Only supported over HTTPS"));
                console.warn("WebRTC is not supported in non-SSL mode");
                return;
            }

            if(!$(".custom-widget[data-widget_rawname=zulu]").length) {
                $(".custom-widget[data-widget_rawname=zulu] .fa-phone").css("color", "red");
                console.warn("WebRTC Widget has not been added");
                return;
            }

            if(typeof moduleSettings.Zulu === "undefined") {
                $(".custom-widget[data-widget_rawname=zulu] .fa-phone").css("color", "red");
                console.warn("WebRTC is not configured properly");
                return;
            }

            if(!moduleSettings.Zulu.enabled) {
                $(".custom-widget[data-widget_rawname=zulu] .fa-phone").css("color", "red");
                console.warn(moduleSettings.Zulu.message);
                this.setDisplayState(moduleSettings.Zulu.message);
                return;
            }

            $.getScript("modules/Zulu/assets/jssiplibs/sip-" + ver + ".min.js")
                .done(function( script, textStatus ) {
                    $this.loadPhone()
                }).fail(function( jqxhr, settings, exception ) {
                //could not load script, remove button
            });
        }
    },
    loadPhone: function() {
        var $this = this;
        $("#footer").append("<audio id=\"audio_remote\" autoplay=\"autoplay\" />");
        $("#footer").append("<audio id=\"ringtone\"><source src=\"modules/Zulu/assets/sounds/ring.mp3\" type=\"audio/mpeg\"></audio>");
        $this.callOptions.media.render.remote = document.getElementById('audio_remote');
        $this.phone = new SIP.UA(
            {
                "wsServers": moduleSettings.Zulu.settings.wsservers.replace('%sip_server%',window.location.host.split(':')[0]),
                "uri": moduleSettings.Zulu.settings.uri.replace('%sip_server%',window.location.host.split(':')[0]),
                "password": moduleSettings.Zulu.settings.password,
                "log": {
                    "builtinEnabled": false,
                    "level": moduleSettings.Zulu.settings.log
                },
                "register": $this.autoRegister,
                "hackWssInTransport": true,
                "stunServers": moduleSettings.Zulu.settings.iceServers,
                "iceCheckingTimeout": moduleSettings.Zulu.settings.gatheringTimeout,
                // The rtcpMuxPolicy option is being considered for removal and may be removed no earlier than M60, around August 2017.
                // If you depend on it, please see https://www.chromestatus.com/features/5654810086866944 for more details.
                // https://nimblea.pe/monkey-business/2017/01/19/webrtc-asterisk-and-chrome-57/
                // https://issues.asterisk.org/jira/browse/ASTERISK-26732
                "rtcpMuxPolicy": "negotiate",
                "userAgentString": "Zulu"
            }
        );

        var binds = [
            "connected",
            "disconnected",
            "registered",
            "unregistered",
            "registrationFailed",
            "invite",
            "message",
            "connecting"
        ];
        $.each(binds, function(i, v) {
            $this.phone.on(v, function(e) {
                $this.engineEvent(v, e);
            });
        });

        $this.connectPhone();
    }
});

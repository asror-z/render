window['__jsonp_ymaps_combine_10111415161718192021222324252627282940414243444546474849606162636468717273747576777879818384858690919293949596979899$*,!.O.C)47q8s1.1,1z.V$b$c_78w,c)2):8t)A1-1J1:)!(,1Q)C05$d2b2e$a9Z2c_38x,O,6)i1i1))H.y016X)G)O,T)z).,k2a_51W)I0$06(@)(,D7h)c)e)F)u)j.A)))*,x,E,B,K,F7p)d,L,y,G,H$I0a0f0g0l0o0m0r0s0A0C0B0D4U0L0G0H0N0Y1c1n1o1r1p1t1A1w1x1B1G1P1R1S1T1V1$1!1q2d2g2h2f2x2B2C2D2F2G2H2*2:2Z3a3d3e3f3g2z2Q2J2i2q2j2)3m3p3r4H4v4w4x4y4K4L4(4:4Q5i5Z6o5Q6f6a6b6c6e6g6l6p6h6K6L6M6N6O6P6U6W6Y6R6,6:6@7a7e9Y7,7S7T7V7W7X7$7*7(7)7;7:8o8p8r8u8v8y-c-d-k8)9F8C9R9T9S9U$7$!4V4W4X_W-o-!-w-Y-1_2_64Y_-0E,u__.f.k.m.n.o.p.v.w_Z.K.H.N(S(X(2(6(q(i(Z)v)w)Y)60c0b0h)r,)0d)J0e0k0p7Y0Q0z:C0u0y,a0T084S0M1Z1I!h_X0K0W0O0P001O1m1v1b1f1s1d1u037Q1a:80I0Z1y!C,i:u1K1M1F1E:D(h1h(H1U1X,v1(1@7A7w,q_V.b:v2A0-2P)n2O2N2T2M2U)m2R2S2_2W2$2(2L)-2V,e2I2-2X2!3b2Y2.2K2@2,3k3s4t*v(;)D)33l3o0!4G_4)g,l_0_Y4A4D4E4B4F4C0*4u04)q(:4!4$4-4.4*4_4,4z)U5z0q6m6n5J5I0i6d6k6V*L6H);)f)l0J6T6S8b:j0.0;,N6;6j6q6i)h7b9W9!9z9@9i7.7U7R7j)k():w:x)@,7$(7P0).s$e7!)7:I7_7-'](
    [
        ['10', function (ym) {
            ym.modules.define("data.Aggregator", ["util.defineClass", "data.Manager"], function (t, e, i) {
                function s(t) {
                    s.superclass.constructor.call(this, t), this._children = {};
                    for (var e in t) t.hasOwnProperty(e) && this._testDataManager(t[e]) && this.addChild(e, t[e])
                }

                e(s, i, {
                    singleSet: function (t, e) {
                        var i = this._parsePath(t);
                        if (i) {
                            if (i.postfix) return void i.child.set(i.postfix, e);
                            this.removeChild(t, i.child)
                        }
                        s.superclass.singleSet.call(this, t, e), this._testDataManager(e) && this.addChild(t, e)
                    }, singleUnset: function (t) {
                        var e = this._parsePath(t);
                        if (e) {
                            if (e.postfix) return void e.child.unset(e.postfix);
                            this.removeChild(t, e.child)
                        }
                        s.superclass.singleUnset.call(this, t)
                    }, unsetAll: function () {
                        return this._clearAll(), s.superclass.unsetAll.call(this), this
                    }, get: function (t, e) {
                        var i = this._parsePath(t);
                        return i ? i.postfix ? i.child.get(i.postfix, e) : i.child : s.superclass.get.call(this, t, e)
                    }, destroy: function () {
                        this._clearAll(), s.superclass.destroy.call(this)
                    }, addChild: function (t, e) {
                        this._children[t] = e, e.events.add("change", this.fireChangeEvent, this)
                    }, removeChild: function (t, e) {
                        e.events.remove("change", this.fireChangeEvent, this), delete this._children[t]
                    }, _testDataManager: function (t) {
                        return t && "function" == typeof t.get && t.events && "function" == typeof t.events.add
                    }, _parsePath: function (t) {
                        var e, i, s = t.indexOf(".");
                        if (s != -1 ? (e = t.slice(0, s), i = t.slice(s + 1)) : e = t, this._children.hasOwnProperty(e)) return {
                            child: this._children[e],
                            postfix: i
                        }
                    }, _clearAll: function () {
                        for (var t in this._children) this._children.hasOwnProperty(t) && this._children[t].events.remove("change", this.fireChangeEvent, this);
                        this._children = {}
                    }
                }), t(s)
            });
        }],
        ['11', function (ym) {
            ym.modules.define("data.Manager", ["util.defineClass", "util.extend", "data.BaseManager", "util.array", "util.safeAccess"], function (t, e, n, a, i, s) {
                function h(t) {
                    h.superclass.constructor.call(this), this._data = t || {}, this._preventInputChange = !!t
                }

                e(h, a, {
                    singleSet: function (t, e) {
                        var n = t.split("."), a = n.pop(), i = s(this._data, n);
                        if ("undefined" != typeof i) this._preventInputChange && (i = this._checkInputChange(i)), i[a] = e, this.fireChangeEvent(); else if (ym.env.debug) throw new Error("data.Manager: некорректный путь к данным: " + t)
                    }, _checkInputChange: function (t) {
                        return t == this._data && (t = this._data = n({}, this._data), this._preventInputChange = !1), t
                    }, singleUnset: function (t) {
                        var e = t.split("."), n = e.pop(), a = s(this._data, e);
                        if ("undefined" != typeof a) this._preventInputChange && (a = this._checkInputChange(a)), delete a[n], this.fireChangeEvent(); else if (ym.env.debug) throw new Error("data.Manager: некорректный путь к данным: " + t)
                    }, unsetAll: function () {
                        return this._data = {}, this.fireChangeEvent(), this
                    }, setAll: function (t) {
                        return this._data = t, this._preventInputChange = !0, this.fireChangeEvent(), this
                    }, get: function (t, e) {
                        var n = s(this._data, t);
                        return "undefined" != typeof n ? n : e
                    }, getAll: function () {
                        return this._data
                    }
                }), t(h)
            });
        }],
        ['14', function (ym) {
            ym.modules.define("data.Sync", ["util.defineClass"], function (s, t) {
                function n(s, t) {
                    function n(s) {
                        return function () {
                            this._sync(s)
                        }
                    }

                    this._managers = s, this._keys = t ? t.slice() : null, this._subscriptions = [];
                    for (var i = 0, e = s.length; i < e; i++) {
                        var r = s[i], h = r.events.group().add("change", n(r), this);
                        this._subscriptions.push(h)
                    }
                    this._onSync = !1, this._sync(s[0])
                }

                t(n, {
                    destroy: function () {
                        for (var s = 0, t = this._subscriptions.length; s < t; s++) this._subscriptions[s].removeAll();
                        this._subscriptions = null, this._managers = null
                    }, _sync: function (s) {
                        if (!this._onSync) {
                            var t = this._keys ? this._getAll(s) : s.getAll();
                            this._onSync = !0;
                            for (var n = 0, i = this._managers.length; n < i; n++) {
                                var e = this._managers[n];
                                e != s && (this._keys ? this._setAll(e, t) : e.setAll(t))
                            }
                            this._onSync = !1
                        }
                    }, _getAll: function (s) {
                        for (var t = {}, n = 0, i = this._keys.length; n < i; ++n) {
                            var e = this._keys[n];
                            t[e] = s.get(e)
                        }
                        return t
                    }, _setAll: function (s, t) {
                        s.freeze();
                        for (var n = 0, i = this._keys.length; n < i; ++n) {
                            var e = this._keys[n];
                            s.set(e, t[e])
                        }
                        s.unfreeze()
                    }
                }), s(n)
            });
        }],
        ['15', function (ym) {
            ym.modules.define("domEvent.Base", ["util.defineClass", "Event"], function (t, a, e) {
                function o(t, a) {
                    o.superclass.constructor.call(this, t), this._dataKey = "domEventData" + a
                }

                a(o, e, {
                    callMethod: function (t) {
                        return this.get(t).apply(this.originalEvent, Array.prototype.slice.call(arguments, 1))
                    }, stopImmediatePropagation: function () {
                        var t = this._getPropagatedData();
                        t.immediatePropagationStopped = !0, t.propagationStopped = !0
                    }, isImmediatePropagationStopped: function () {
                        return this._getPropagatedData().immediatePropagationStopped
                    }, stopPropagation: function () {
                        this._getPropagatedData().propagationStopped = !0
                    }, isPropagationStopped: function () {
                        return this._getPropagatedData().propagationStopped
                    }, preventDefault: function () {
                        this._getPropagatedData().defaultPrevented = !0
                    }, isDefaultPrevented: function () {
                        return this._getPropagatedData().defaultPrevented
                    }, allowMapEvent: function () {
                        this._getPropagatedData().mapEventAllowed = !0
                    }, disallowMapEvent: function () {
                        this._getPropagatedData().mapEventAllowed = !1
                    }, isMapEventAllowed: function () {
                        return this._getPropagatedData().mapEventAllowed
                    }, _getPropagatedData: function () {
                        var t = this.get("propagatedData");
                        return t[this._dataKey] || (t[this._dataKey] = {})
                    }
                }), t(o)
            });
        }],
        ['16', function (ym) {
            ym.modules.define("DomEvent", ["util.defineClass", "domEvent.Base", "domEvent.overrideStorage", "component.event.Cacher"], function (e, t, c, n, h) {
                function i(e, t) {
                    i.superclass.constructor.call(this, e, t), this._cache = {type: t || e.type}, this._cacher = null
                }

                t(i, c, {
                    get: function (e) {
                        return this._cacher || (this._cacher = new h(this, this._cache, n)), this._cacher.get(e)
                    }, clone: function (e) {
                        return new i(e, this._cache.type)
                    }
                }), e(i)
            });
        }],
        ['17', function (ym) {
            ym.modules.define("domEvent.override.common", ["domEvent.overrideStorage", "util.eventId", "util.instantCache"], function (e, t, n, a) {
                function r(e, t) {
                    var n = e.originalEvent, a = 0, r = 0;
                    "wheel" == n.type && (r = -n.deltaY, a = n.deltaX), "mousewheel" == n.type && "undefined" != typeof n.wheelDeltaY && (r = n.wheelDeltaY, a = n.wheelDeltaX), t.set("delta", r), t.set("deltaY", r), t.set("deltaX", a)
                }

                function d(e, t) {
                    return i(e, t), e.get("pageX")
                }

                function o(e, t) {
                    return i(e, t), e.get("pageY")
                }

                function l(e, t) {
                    return [e.get("pageX"), e.get("pageY")]
                }

                function i(e, t) {
                    var n = e.originalEvent, a = n.pageX, r = n.pageY;
                    "undefined" == typeof a && (a = n.clientX, r = n.clientY, s && (a += (s.scrollLeft || 0) - (s.clientLeft || 0), r += (s.scrollTop || 0) - (s.clientTop || 0)), m && (a += m.scrollLeft || 0, r += m.scrollTop || 0)), t.set("pageX", a), t.set("pageY", r)
                }

                function g(e, t) {
                    var n = c(e, t);
                    return n.target
                }

                function u(e, t) {
                    var n = c(e, t);
                    return n.relatedTarget
                }

                function c(e, t) {
                    var n = e.originalEvent, a = n.target || n.srcElement, r = n.relatedTarget || null;
                    if (a && 3 == a.nodeType && (a = a.parentNode), !n.relatedTarget && n.fromElement && (r = n.fromElement == a ? n.toElement : n.fromElement), "Gecko" == f.engine && n.relatedTarget) try {
                        -n.relatedTarget.nodeType
                    } catch (d) {
                        r = null
                    }
                    return t.set("target", a), t.set("relatedTarget", r), {target: a, relatedTarget: r}
                }

                var f = ym.env.browser, p = function (e, t) {
                    return r(e, t), e.get("delta")
                }, v = function (e, t) {
                    return r(e, t), e.get("deltaX")
                };
                t.add("delta", p).add("deltaY", p).add("deltaX", v);
                var s = document.documentElement, m = document.body;
                t.add("pageX", d).add("pageY", o).add("position", l), t.add("propagatedData", function (e, t) {
                    var r = e.originalEvent, d = n.get(r), o = a.get(d);
                    return o || a.add(d, o = {}), o
                }), t.add("activeMouseButton", function (e) {
                    var t = e.originalEvent, n = -1;
                    if (void 0 != t.buttons) {
                        var a = t.buttons;
                        n = 0, 4 & a ? n = 3 : 2 & a ? n = 2 : 1 & a && (n = 1)
                    } else n = t.hasOwnProperty("which") ? t.which : -1;
                    return n
                }), t.add("target", g).add("relatedTarget", u), e(!0)
            });
        }],
        ['18', function (ym) {
            ym.modules.define("domEvent.overrideStorage", ["util.Storage"], function (e, o) {
                e(new o)
            });
        }],
        ['19', function (ym) {
            ym.modules.define("domEvent.managerComponent.mouseLeaveEnterDispatcher", ["DomEvent", "system.browser"], function (e, r, n) {
                var t = !0;
                e({
                    setEnabled: function (e) {
                        t = e
                    }, fire: function (e, n, a, o) {
                        if (t) {
                            var m, f = e.params.htmlElement;
                            for (m = a.relatedTarget; m && m != f;) try {
                                m = m.parentNode
                            } catch (i) {
                                return !1
                            }
                            if (m != f) return o || (o = r), e.fire(n, new o(a, n)), !0
                        }
                        return !1
                    }
                })
            });
        }],
        ['20', function (ym) {
            ym.modules.define("geometry.component.pixelGeometryGeodesic.rectangle", ["geometry.component.pixelGeometryGeodesic.lineString", "geometry.component.pixelGeometryGeodesic.storage", "geometry.pixel.LineString", "geometry.pixel.Polygon"], function (e, o, n, t, i) {
                function r(e, n) {
                    var r = e.getBounds(), g = new t([r[0], [r[1][0], r[0][1]], r[1], [r[0][0], r[1][1]], r[0]]),
                        m = o(g, n);
                    return new i([m.getCoordinates()])
                }

                n.add("Rectangle", r), e(r)
            });
        }],
        ['21', function (ym) {
            ym.modules.define("geometry.component.pixelGeometryGeodesic.storage", ["util.Storage"], function (e, o) {
                e(new o)
            });
        }],
        ['22', function (ym) {
            ym.modules.define("geometry.component.PixelGeometryShift", ["util.pixelBounds", "geometry.component.anchor"], function (t, o, i) {
                function e(t, o, e, n, r, s) {
                    var a = i.getAnchor(t, o, s), l = a - t, u = r - (n + l), h = Math.ceil(e / s) || 1,
                        c = Math.round(u / (h * s)), f = Math.round(l / s);
                    return c && (f += c * h), f
                }

                function n(t, o) {
                    for (var i, e = 1 / 0, n = 0; n < 4; ++n) {
                        var r = [o[0] - t[n][0], o[1] - t[n][1]], s = r[0] * r[0] + r[1] * r[1];
                        s < e && (e = s, i = n)
                    }
                    return i
                }

                var r = function () {
                };
                r.prototype = {
                    calculateShift: function (t, i, r) {
                        var s = t.getBounds(), a = i.isCycled(), l = [0, 0];
                        if (s && (a[0] || a[1])) {
                            var u = o.getCenter(s), h = o.getSize(s), c = r.getGlobalPixelCenter(), f = c, g = u,
                                m = Math.pow(2, 8 + r.getZoom());
                            if (this.lastPosition && (h[0] > 0 || h[1] > 0)) {
                                var P = [[s[0][0] + this.lastPosition[0] * m, s[0][1] + this.lastPosition[1] * m], [s[1][0] + this.lastPosition[0] * m, s[1][1] + this.lastPosition[1] * m]],
                                    d = [[P[0][0], P[0][1]], [P[1][0], P[0][1]], [P[1][0], P[1][1]], [P[0][0], P[1][1]]],
                                    v = [[s[0][0], s[0][1]], [s[1][0], s[0][1]], [s[1][0], s[1][1]], [s[0][0], s[1][1]]],
                                    p = n(d, c);
                                f = d[p], g = v[p]
                            }
                            l = [a[0] ? e(g[0], f[0], h[0], u[0], c[0], m) : 0, a[1] ? e(g[1], f[1], h[1], u[1], c[1], m) : 0]
                        }
                        return this.lastPosition = l, l
                    }
                }, t(r)
            });
        }],
        ['23', function (ym) {
            ym.modules.define("geometry.component.pixelGeometrySimplification.lineString", ["graphics.generator.simplify2", "geometry.component.pixelGeometrySimplification.storage"], function (e, i, n) {
                var t = {
                    prepare: function (e) {
                        var n = e.getCoordinates(), t = e.getMetaData().originalIndexes || [];
                        return e.clone(null, {simplificatorCache: i(n, t)})
                    }, apply: function (e, i, n) {
                        var t = e.getMetaData(), o = t.simplificatorCache, a = i.simplification || 1,
                            r = 1 / Math.pow(2, n + (a === !0 ? 1 : a)), l = o(r);
                        return e.clone(l.points, null, {originalIndexes: l.indexes, removedPoints: l.removed})
                    }
                };
                n.add("LineString", t), e(t)
            });
        }],
        ['24', function (ym) {
            ym.modules.define("geometry.component.pixelGeometrySimplification.polygon", ["graphics.generator.simplify2", "geometry.component.pixelGeometrySimplification.storage"], function (e, i, o) {
                var n = {
                    prepare: function (e, o) {
                        for (var n = e.getCoordinates(), t = [], a = e.getMetaData(), r = a.originalIndexes || [], l = o.simplificationFixedPoints || [], c = a.intersectionFixedPoints || [], p = 0, m = n.length; p < m; p++) t[p] = i(n[p], r[p], (l[p] || []).concat(c[p]));
                        return e.clone(null, null, {simplificatorCache: t})
                    }, apply: function (e, i, o) {
                        for (var n = e.getMetaData(), t = n.simplificatorCache || [], a = i.simplification || 1, r = 1 / Math.pow(2, o + (a === !0 ? 1 : a)), l = [], c = [], p = [], m = 0, s = t.length; m < s; m++) {
                            var g = t[m](r);
                            l[m] = g.points, c[m] = g.indexes, p[m] = g.removed
                        }
                        return e.clone(l, null, {originalIndexes: c, removedPoints: p})
                    }
                };
                o.add("Polygon", n), e(n)
            });
        }],
        ['25', function (ym) {
            ym.modules.define("geometry.component.pixelGeometrySimplification.storage", ["util.Storage"], function (e, o) {
                e(new o)
            });
        }],
        ['26', function (ym) {
            ym.modules.define("geometry.component.pixelGetClosest", [], function (e) {
                e(function (e, o) {
                    var t = e.getMap();
                    if ("undefined" == typeof t) throw new Error("geometry.component.pixelGetClosest: Для нахождения ближайшей точки геометрия должна быть добавлена на карту.");
                    for (var i = e.getPixelGeometry({
                        simplification: !1,
                        pixelRendering: "static",
                        geodesic: e.options.get("geodesic")
                    }), n = 256 * Math.pow(2, t.getZoom()), l = e.options.get("projection"), s = l.isCycled(), r = l.toGlobalPixels(o, t.getZoom()), c = [[s[0] ? -1 : 0, s[1] ? -1 : 0], [s[0] ? 1 : 0, s[1] ? 1 : 0]], g = null, p = null, a = c[0][0]; a <= c[1][0]; a++) for (var d = c[0][1]; d <= c[1][1]; d++) p = i.getClosest([r[0] + a * n, r[1] + d * n]), (!g || p.distance < g.distance) && (g = p);
                    return g
                })
            });
        }],
        ['27', function (ym) {
            ym.modules.define("geometry.component.pointInPolygon", [], function (n) {
                function r(n, r, e, f) {
                    for (var i = !1, u = f ? t : o, a = "nonZero" == e, h = 0, m = r.length; h < m && !(u(n, r[h], a) && (i = !i, i && a)); h++) ;
                    return i
                }

                function t(n, r) {
                    for (var t, o, f, i, u = r[r.length - 1], a = 0, h = r.length; a < h; a++) if (f = i, t = o || [n[0] - u[0], n[1] - u[1]], o = [n[0] - r[a][0], n[1] - r[a][1]], (t[0] != o[0] || t[1] != o[1]) && (i = e(t, o), i != f && "undefined" != typeof f)) return !1;
                    return !0
                }

                function e(n, r) {
                    return n[0] * r[1] - n[1] * r[0] > 0
                }

                function o(n, r, t) {
                    for (var e = 0, o = 0, f = r.length; o < f; o++) if (r[o][0] == n[0] && r[o][1] == n[1]) return 1;
                    var i = r[f - 1];
                    for (o = 0; o < f; o++) {
                        var u = r[o];
                        if (i[1] == u[1] && i[1] == n[1] && n[0] > Math.min(i[0], u[0]) && n[0] < Math.max(i[0], u[0])) return 1;
                        if (n[1] > Math.min(i[1], u[1]) && n[1] <= Math.max(i[1], u[1]) && n[0] <= Math.max(i[0], u[0]) && i[1] != u[1]) {
                            var a = (n[1] - i[1]) * (u[0] - i[0]) / (u[1] - i[1]) + i[0];
                            if (a == n[0]) return 1;
                            (i[0] == u[0] || n[0] <= a) && (e += t ? u[1] - i[1] < 0 ? -1 : 1 : e ? -1 : 1)
                        }
                        i = u
                    }
                    return e
                }

                n(r)
            });
        }],
        ['28', function (ym) {
            ym.modules.define("geometry.component.renderFlow.stageGeodesic", ["geometry.component.pixelGeometryGeodesic.storage"], function (e, o) {
                e(function (e, t) {
                    if (!t.geodesic) return e;
                    if (!this._geodesic && (this._geodesic = o.get(e.getType()), ym.env.debug && !this._geodesic)) throw new Error("geometry.component.renderFlow.stageGeodesic: Не найден перобразователь для геометрии " + e.getType());
                    return this._geodesic(e, t.projection)
                })
            });
        }],
        ['29', function (ym) {
            ym.modules.define("geometry.component.renderFlow.stageScale", [], function (t) {
                t({
                    onActionEnd: function (t) {
                        return t.get("target").getZoom() != this._lastZoom
                    }, apply: function (t, o, e) {
                        var n = this.getMap().getZoom(), a = t;
                        return n > 0 && (a = t.scale(Math.pow(2, n))), e || (this._lastZoom = n), a
                    }
                })
            });
        }],
        ['40', function (ym) {
            ym.modules.define("geoObject.Hint", ["util.defineClass", "Hint", "event.Manager", "geoObject.optionMapper", "component.sharedEntity.captor.Popup", "option.Manager", "projection.idle", "map.addon.hint", "util.component", "util.preset", "util.pixelBounds", "util.extend", "vow", "popup.managerStorage", "popup.component.checkEmptiness"], function (e, t, o, n, i, s, a, r, c, h, p, u, _, g, l, d) {
                function b(e) {
                    this._geoObject = e, this.events = new n({context: this}), this._setupCaptor(), this._setupListeners()
                }

                t(b, h.createProxyMethods(function () {
                    return this._captor
                }, ["close", "isOpen", "getOverlay", "getOverlaySync", "autoPan", "getOwner", "getPosition", "getData", "setOptions", "getOptions"]), {
                    destroy: function () {
                        this._clearListeners(), this._clearCaptor()
                    }, isEmpty: function (e, t, o) {
                        var n = this._specifyData(t);
                        return n.options = new a(o || {}, this._geoObject.options, "hint"), d(this._geoObject.getMap(), "hint", this._specifyPosition(e, o && o.projection), n)
                    }, open: function (e, t, o) {
                        return this._captor.open(this._specifyPosition(e, o && o.projection), this._specifyData(t), o)
                    }, setPosition: function (e) {
                        return this._captor.setPosition(this._specifyPosition(e))
                    }, setData: function (e) {
                        return this._captor.setData(this._specifyData(e))
                    }, _setupCaptor: function () {
                        var e = this._geoObject.getMap(), t = e && c.get(e);
                        this._captor = new s(this, this._geoObject, "hint", t), this._captor.events.add("capture", function () {
                            this.close(!0)
                        }, this)
                    }, _clearCaptor: function () {
                        this._captor.destroy(), this._captor = null
                    }, _setupListeners: function () {
                        this._geoObject.events.add("mapchange", this._onMapChange, this).add("mouseenterdefaultaction", this._onGeoObjectMouseEnter, this).add(["dragstart", "balloonopen"], this._disable, this).add(["dragend", "balloonclose"], this._enable, this)
                    }, _clearListeners: function () {
                        this._geoObject.events.remove(["dragend", "balloonclose"], this._enable, this).remove(["dragstart", "balloonopen"], this._disable, this).remove("mouseenterdefaultaction", this._onGeoObjectMouseEnter, this).remove("mapchange", this._onMapChange, this)
                    }, _onGeoObjectMouseEnter: function (e) {
                        this._openAndHandleMouse(e.get("originalEvent").get("globalPixels"))
                    }, _onGeoObjectMouseMove: function (e) {
                        return this._captor.setPosition(this._specifyPosition(e.get("globalPixels"), r))
                    }, _onGeoObjectMouseLeave: function (e) {
                        this._closeAndUnhandleMouse()
                    }, _openAndHandleMouse: function (e) {
                        this._tryOpenOnHover(e).then(function () {
                            this._geoObject.events.add("mousemove", this._onGeoObjectMouseMove, this).add("mouseleave", this._onGeoObjectMouseLeave, this)
                        }, this)
                    }, _closeAndUnhandleMouse: function (e) {
                        this.close(e), this._geoObject.events.remove("mousemove", this._onGeoObjectMouseMove, this).remove("mouseleave", this._onGeoObjectMouseLeave, this)
                    }, _disable: function () {
                        this._disabled = !0, this._closeAndUnhandleMouse(!0)
                    }, _enable: function (e) {
                        var t = this._geoObject;
                        t.state.get("active") || t.state.get("drag") || (this._disabled = !1, t.getMap() && this._openAndHandleMouse())
                    }, _onMapChange: function () {
                        this._geoObject.getMap() ? this._setupSharingManager() : this.close(!0)
                    }, _setupSharingManager: function () {
                        this._captor.setSharingManager(c.get(this._geoObject.getMap()))
                    }, _tryOpenOnHover: function (e) {
                        var t = g.defer(), o = g.defer(), n = {projection: r};
                        return this._disabled || !this._geoObject.options.get("openHintOnHover", !0) ? t.reject() : this._geoObject.options.get("openEmptyHint", !1) ? t.resolve() : this.isEmpty(e, null, n).then(function (e) {
                            e ? t.reject() : t.resolve()
                        }, t.reject, t), t.promise().then(function () {
                            this._geoObject.state.get("hover") ? (o.resolve(), this.open(e, null, n)) : o.reject()
                        }, this), o.promise()
                    }, _specifyPosition: function (e, t) {
                        return e ? (t || this._geoObject.options.get("projection")).toGlobalPixels(e, this._geoObject.getMap().getZoom()) : u.getCenter(this._geoObject.geometry.getPixelGeometry().getBounds())
                    }, _specifyData: function (e) {
                        var t = this._geoObject;
                        return {
                            geometry: t.geometry,
                            properties: t.properties,
                            state: t.state,
                            geoObject: t,
                            userData: e
                        }
                    }
                }), l.add("geoObject#hint", b), i.setRule({name: "hint", rule: "prefixed"}).setRule({
                    name: "hint",
                    key: ["projection"],
                    rule: "plain"
                }), e(b)
            });
        }],
        ['41', function (ym) {
            ym.modules.define("geoObject.metaOptions", ["interactivityModel.geoObject", "map.metaOptions"], function (e, t, o) {
                o.set("geoObjectInteractivityModel", t.geoObject), e({})
            });
        }],
        ['42', function (ym) {
            ym.modules.define("geoObject.optionMapper", ["option.Mapper"], function (e, o) {
                e(new o)
            });
        }],
        ['43', function (ym) {
            ym.modules.define("geoObject.Sequence", ["util.defineClass", "geoObject.abstract.Sequence", "event.globalize", "Event"], function (e, t, n, s, c) {
                function a(e, t) {
                    a.superclass.constructor.call(this, e, t), this.events.addController(i), this.events.fire("create", new c({
                        type: "create",
                        target: this
                    }))
                }

                var i = s(a);
                t(a, n), e(a)
            });
        }],
        ['44', function (ym) {
            ym.modules.define("geoObject.view.component.Dragger", ["util.fireWithBeforeEvent", "util.DraggerWithAutoPan", "util.Dragger", "Event", "pane.EventsPane", "util.matrix.2d"], function (t, e, s, i, o, n, r) {
                function g(t, e, o, n, r) {
                    this._geoObject = t, this._events = e, this._state = o, this._geometry = n, this._cursor = null, this._options = r, this._geoObjectListener = this._geoObject.events.group().add("mousedown", a, this), this._geoObject.options.get("useAutoPanInDragging", !0) ? this._dragger = new s({
                        disableBrowserBehavior: !0,
                        useMapMargin: this._geoObject.options.get("useMapMarginInDragging", !0)
                    }, t.getMap()) : this._dragger = new i({disableBrowserBehavior: !0}), this._draggerEvents = this._dragger.events.group().add("start", h, this).add("move", c, this).add("stop", u, this)
                }

                function a(t) {
                    var e = t.get("domEvent");
                    t.get("target") == this._geoObject && 0 == e.get("button") && (this._dragger.start(e), t.preventDefault())
                }

                function h(t) {
                    e(this._events, {
                        type: "dragstart",
                        target: this._geoObject,
                        domEvent: t.get("domEvent"),
                        position: t.get("position")
                    }, {context: this, successCallback: p, preventCallback: d})
                }

                function p(t) {
                    if (this._state.set("drag", !0), this._geoObject.options.get("setMapCursorInDragging")) {
                        var e = this._geoObject.getMap().panes.findUpper(n);
                        this._cursor = e.cursors.push("grabbing")
                    }
                    this._options.onDragStart && this._options.onDragStart.call(this._options.context), this._events.fire(t.type, t)
                }

                function d(t) {
                    this._dragger.stop(t.domEvent)
                }

                function c(t) {
                    e(this._events, {
                        type: "drag",
                        target: this._geoObject,
                        pixelOffset: t.get("delta"),
                        domEvent: t.get("domEvent"),
                        position: t.get("position")
                    }, {context: this, successCallback: _, mutableFields: ["pixelOffset"]})
                }

                function _(t) {
                    var e = r.translate([], r.identity(), t.pixelOffset);
                    this._geometry.applyProjectedTransformation(e), this._events.fire(t.type, new o({transformation: e}, new o(t)))
                }

                function u(t) {
                    this._state.get("drag") && (this._state.unset("drag"), this._cursor && (this._cursor.remove(), this._cursor = null), this._options.onDragStop && this._options.onDragStop.call(this._options.context), this._events.fire("dragend", new o({
                        type: "dragend",
                        target: this._geoObject,
                        domEvent: t.get("domEvent"),
                        position: t.get("position")
                    })))
                }

                g.prototype = {
                    destroy: function () {
                        this._geoObjectListener.removeAll(), this._dragger.stop(), this._draggerEvents.removeAll()
                    }
                }, t(g)
            });
        }],
        ['45', function (ym) {
            ym.modules.define("geoObject.view.component.hoverDispatcher", ["util.defineClass", "util.Associate", "MapEvent"], function (e, t, o, n) {
                function s(e) {
                    this._map = e, this._object = null
                }

                t(s, {
                    setObject: function (e, t) {
                        this._object && this._unhoverObject(t), this._object = e, t.get("domEvent").get("propagatedData").processedByHoverDispatcher = !0, this._object && this._hoverObject(t)
                    }, setLastEvent: function (e) {
                        e.get("domEvent").get("propagatedData").processedByHoverDispatcher = !0
                    }, _hoverObject: function (e) {
                        this._object.state.set("hover", !0), this._object.events.fire("hover", new n({
                            type: "hover",
                            target: this._object,
                            map: this._map
                        }, e)), this._map.container.events.add(["mouseenter", "mousemove"], this._onContainerMouseEvent, this)
                    }, _unhoverObject: function (e) {
                        this._object.state.set("hover", !1), this._object.events.fire("unhover", new n({
                            type: "unhover",
                            target: this._object,
                            map: this._map
                        }, e)), this._map.container.events.remove(["mouseenter", "mousemove"], this._onContainerMouseEvent, this)
                    }, _onContainerMouseEvent: function (e) {
                        e.get("domEvent").get("propagatedData").processedByHoverDispatcher || (this._unhoverObject(e), this._object = null)
                    }
                }), e(new o(function (e) {
                    return new s(e)
                }))
            });
        }],
        ['46', function (ym) {
            ym.modules.define("geoObject.view.component.OverlayEventMappingTable", ["util.defineClass", "MapEvent", "geoObject.view.component.hoverDispatcher"], function (e, t, n, a) {
                function g(e) {
                    this._geoObject = e
                }

                function i(e) {
                    var t = a.get(this._geoObject.getMap());
                    return t.setObject(this._geoObject, e), this._defaultMapping(e)
                }

                function o(e) {
                    return a.get(this._geoObject.getMap()).setLastEvent(e), this._defaultMapping(e)
                }

                function p(e) {
                    return a.get(this._geoObject.getMap()).setObject(null, e), this._defaultMapping(e)
                }

                function c(e) {
                    return new n({
                        type: e.get("type"),
                        target: this._geoObject,
                        map: this._geoObject.getMap(),
                        domEvent: e.get("domEvent"),
                        originalEvent: e
                    }, e)
                }

                t(g, {
                    geometrychange: !1,
                    propertieschange: !1,
                    optionschange: !1,
                    datachange: !1,
                    mapchange: !1,
                    emptinesschange: !1,
                    shapechange: !1,
                    mouseenter: i,
                    mousemove: o,
                    mouseleave: p,
                    "*": c,
                    _hoverMapping: i,
                    _defaultMapping: c
                }), e(g)
            });
        }],
        ['47', function (ym) {
            ym.modules.define("geoObject.view.overlayMapping", ["util.extend", "util.Storage"], function (e, n, t) {
                function i(e, n) {
                    return n + e.slice(0, 1).toUpperCase() + e.slice(1)
                }

                function r(e, n) {
                    return [i(e, n), e]
                }

                var o = new t, u = {key: ["projection"], rule: "plain"},
                    a = ["icons", "cursor", "interactivityModel", "pane", "eventsPane", "shadowsPane", "interactive"];
                o.setupMapping = function (e, t, i) {
                    var r = this.get(i);
                    if (r) for (var o = 0, u = r.length; o < u; o++) e.setRule(n({name: t}, r[o]))
                }, o.add("Point", [u, {
                    rule: function (e) {
                        return i(e, "icon")
                    }
                }, {
                    key: a, rule: function (e) {
                        return r(e, "icon")
                    }
                }]), o.add("MultiGeometry", [{
                    key: ["layout", "template", "color"], rule: function (e) {
                        return r(e, "icon")
                    }
                }]), e(o)
            });
        }],
        ['48', function (ym) {
            ym.modules.define("geoObject.View", ["util.defineClass", "vow", "util.array", "util.callbackChunker", "util.cancelableCallback", "constants.zIndex", "option.Manager", "option.Mapper", "Monitor", "geoObject.view.component.Dragger", "geoObject.view.overlayMapping", "overlay.storage", "event.Mapper", "geoObject.view.component.OverlayEventMappingTable"], function (e, t, i, r, s, n, a, o, l, h, _, v, p, c, g) {
                function y(e, t, i, r, n, o, l) {
                    this._geoObject = e, this._geometry = t, this._properties = i, this._options = r, this._events = n, this._state = o, this._map = l, this._overlays = [], this._oldOverlay = this._overlays[0] || null, this._overlayData = null, this._overlayOptionManager = null, this._overlayRequireCallback = null, this._overlayDeferred = null, this._overlaysDeferred = null, this._chunker = s.get(l), this._chunkerCallbackId = NaN;
                    var h = t && "Point" == t.getType();
                    this._optionMonitor = r.getMonitor({
                        visible: !0,
                        draggable: !1,
                        interactiveOptions: h,
                        interactiveZIndex: h,
                        zIndex: a.overlay,
                        zIndexActive: h ? a.activePoint : a.active,
                        zIndexDrag: a.drag,
                        zIndexHover: a.hover
                    }), this._zIndexOptionName = "", t ? (this._setupVisible(), this._optionMonitor.get("visible") && this._initOverlayListeners(), this._startOverlayCreating()) : this._overlayRejectMessageFunc = y.GeoObjectIsHiddenError
                }

                y.GeoObjectIsHiddenError = function () {
                    return new Error("GeoObject is not visible")
                }, y.GeoObjectRemovedFromMapError = function () {
                    return new Error("GeoObject was removed from map")
                }, y.OverlayWasntFoundError = function () {
                    return new Error("Overlay wasn't found")
                }, t(y, {
                    getOverlay: function () {
                        return this._overlayDeferred || (this._overlayDeferred = i.defer(), this._overlayRejectMessageFunc ? this._overlayDeferred.reject(this._overlayRejectMessageFunc()) : this._overlays.length > 0 && this._overlayDeferred.resolve(this._overlays[0])), this._overlayDeferred.promise()
                    }, getOverlaySync: function () {
                        return this._overlays[0] || null
                    }, getOverlays: function () {
                        return this._overlaysDeferred || (this._overlaysDeferred = i.defer(), this._overlayRejectMessageFunc ? this._overlaysDeferred.reject(this._overlayRejectMessageFunc()) : this._overlays.length > 0 && this._overlaysDeferred.resolve(this._overlays)), this._overlaysDeferred.promise()
                    }, getOverlaysSync: function () {
                        return this._overlays.slice()
                    }, destroy: function () {
                        this._geometry && (this._clearDraggable(), this._clearPixelGeometryChangeListener(), this._rejectOverlayDeferreds(y.GeoObjectRemovedFromMapError), this._clearOverlays(), this._clearOverlayOptionManager(), this._overlayData = null, this._clearZIndex(), this._clearVisible(), this._clearOverlayClassListener())
                    }, _initOverlayListeners: function () {
                        this._overlayListenersInited || (this._overlayListenersInited = !0, this._pixelGeometry = this._geometry.getPixelGeometry(), this._setupOverlayClassListener(), this._setupPixelGeometryChangeListener())
                    }, _startOverlayCreating: function () {
                        this._overlayDeferred = null, this._overlaysDeferred = null, this._constructOverlays()
                    }, _clearOverlays: function () {
                        this._overlayDeferred = null, this._overlaysDeferred = null;
                        for (var e = 0, t = this._overlays.length; e < t; e++) this._clearOverlay(this._overlays[e]);
                        this._overlays = [], t > 0 && this._fireOverlayChange()
                    }, _constructOverlays: function () {
                        if (!this._geometry.getBounds() || !this._optionMonitor.get("visible")) return void this._rejectOverlayDeferreds(y.GeoObjectIsHiddenError);
                        this._overlayRejectMessageFunc = null;
                        var e = this._getOverlayOptionKey(this._pixelGeometry.getType()), t = this._options.get(e);
                        if ("string" == typeof t) {
                            var i = t;
                            if (t = p.get(i), "undefined" == typeof t) return this._overlayRequireCallback = n.create(function (e) {
                                this._overlayRequireCallback = null, this._createOverlay(e)
                            }, this), void p.require([i]).spread(this._overlayRequireCallback, function () {
                                this._rejectOverlayDeferreds(y.OverlayWasntFoundError)
                            }, this)
                        }
                        this._createOverlay(t)
                    }, _createOverlay: function (e) {
                        this._overlayClass = e, this._options.get("syncOverlayInit", !1) ? this._setupOverlay() : this._chunkerCallbackId = this._chunker.addCallback(function () {
                            this._chunkerCallbackId = NaN, this._setupOverlay()
                        }, this)
                    }, _resolveOverlayDeferreds: function () {
                        this._overlayDeferred && this._overlayDeferred.resolve(this._overlays[0]), this._overlaysDeferred && this._overlaysDeferred.resolve(this._overlays)
                    }, _rejectOverlayDeferreds: function (e) {
                        this._clearAsyncOperations(), this._overlayRejectMessageFunc = e, this._overlayDeferred && this._overlayDeferred.reject(e()), this._overlaysDeferred && this._overlaysDeferred.reject(e())
                    }, _clearAsyncOperations: function () {
                        this._overlayRequireCallback && (this._overlayRequireCallback.cancel(), this._overlayRequireCallback = null), this._chunkerCallbackId && (this._chunker.removeCallback(this._chunkerCallbackId), this._chunkerCallbackId = NaN)
                    }, _setupOverlay: function () {
                        var e = new this._overlayClass(this._geometry.getPixelGeometry(), this._getOverlayData());
                        this._setupDraggable(), e.options.set("zIndex", this._getZIndex()), this._setupOverlayOptionManager();
                        var t = e.options.getName();
                        this._overlayOptionNames.hasOwnProperty(t) || (this._overlayOptionNames[t] = null, v.setupMapping(this._overlayOptionMapper, t, e.getGeometry().getType())), e.options.setParent(this._overlayOptionManager), e.setMap(this._map), e.events.setParent(new c(this._events, new g(this._geoObject))), this._overlays.push(e), this._resolveOverlayDeferreds(), this._fireOverlayChange()
                    }, _clearOverlay: function (e) {
                        e.events.setParent(null), e.setMap(null), e.options.setParent(null)
                    }, _getOverlayData: function () {
                        return this._overlayData || (this._overlayData = {
                            geometry: this._geometry,
                            properties: this._properties,
                            state: this._state,
                            geoObject: this._geoObject
                        })
                    }, _getOverlayOptionKey: function (e) {
                        return e.charAt(0).toLowerCase() + e.substring(1) + "Overlay"
                    }, _fireOverlayChange: function () {
                        var e = this._oldOverlay, t = this._overlays[0] || null;
                        this._oldOverlay = t, this._events.fire("overlaychange", {overlay: t, oldOverlay: e})
                    }, _setupInteractiveOptions: function () {
                        this._optionMonitor.add("interactiveOptions", this._onInteractiveOptionsChange, this), this._optionMonitor.get("interactiveOptions") && (this._setupStateMonitor(this._updateStateMapping), this._setupStateMapping())
                    }, _clearInteractiveOptions: function () {
                        this._optionMonitor.get("interactiveOptions") && (this._clearStateMapping(), this._clearStateMonitor(this._updateStateMapping)), this._optionMonitor.remove("interactiveOptions", this._onInteractiveOptionsChange, this)
                    }, _onInteractiveOptionsChange: function (e) {
                        e ? (this._setupStateMonitor(this._updateStateMapping), this._setupStateMapping()) : (this._clearStateMapping(), this._clearStateMonitor(this._updateStateMapping))
                    }, _setupStateMapping: function () {
                        this._stateOptionMapper = new l, this._stateOptionManager = new o(null, this._options, "stateMapping", this._stateOptionMapper), this._overlayOptionManager.setParent(this._stateOptionManager), this._stateOptionMapper.setRule({
                            name: "overlayMapping",
                            rule: this._stateMappingRule.bind(this)
                        })
                    }, _clearStateMapping: function () {
                        this._overlayOptionManager && this._overlayOptionManager.setParent(this._options), this._stateOptionMapper = null, this._stateOptionManager = null
                    }, _stateMappingRule: function (e) {
                        var t = [];
                        return this._stateMonitor.get("active") && t.push(l.addPrefix("active", e)), this._stateMonitor.get("drag") && t.push(l.addPrefix("drag", e)), this._stateMonitor.get("hover") && t.push(l.addPrefix("hover", e)), t.length ? (t.push(e), t) : e
                    }, _updateStateMapping: function () {
                        this._stateOptionMapper && this._stateOptionMapper.fireChange()
                    }, _setupVisible: function () {
                        this._optionMonitor.add("visible", this._onVisibleChange, this)
                    }, _clearVisible: function () {
                        this._optionMonitor.remove("visible", this._onVisibleChange, this)
                    }, _onVisibleChange: function (e) {
                        e ? (this._initOverlayListeners(), this._startOverlayCreating()) : (this._rejectOverlayDeferreds(y.GeoObjectIsHiddenError), this._clearOverlays())
                    }, _setupOverlayClassListener: function () {
                        this._overlayClassOptionKey = this._getOverlayOptionKey(this._pixelGeometry.getType()), this._optionMonitor.add(this._overlayClassOptionKey, this._onOverlayClassChange, this)
                    }, _clearOverlayClassListener: function () {
                        this._overlayListenersInited && this._overlayClassOptionKey && this._optionMonitor.remove(this._overlayClassOptionKey, this._onOverlayClassChange, this)
                    }, _onOverlayClassChange: function () {
                        this._clearAsyncOperations(), this._clearOverlays(), this._clearOverlayOptionManager(), this._startOverlayCreating()
                    }, _setupPixelGeometryChangeListener: function () {
                        this._geometry.events.add("pixelgeometrychange", this._onPixelGeometryChange, this)
                    }, _clearPixelGeometryChangeListener: function () {
                        this._overlayListenersInited && this._geometry.events.remove("pixelgeometrychange", this._onPixelGeometryChange, this)
                    }, _onPixelGeometryChange: function () {
                        if (this._optionMonitor.get("visible")) {
                            var e = this._geometry.getPixelGeometry(), t = this._geometry.getBounds(),
                                i = e.getType() != this._pixelGeometry.getType();
                            if (!t) return this._rejectOverlayDeferreds(y.GeoObjectIsHiddenError), void this._clearOverlays();
                            if (i) return this._rejectOverlayDeferreds(y.GeoObjectIsHiddenError), this._clearOverlays(), this._clearOverlayClassListener(), this._pixelGeometry = this._geometry.getPixelGeometry(), this._startOverlayCreating(), void this._setupOverlayClassListener();
                            if (!this._overlays.length) return void (this._overlayRequireCallback || this._chunkerCallbackId || (this._rejectOverlayDeferreds(y.GeoObjectIsHiddenError), this._startOverlayCreating()));
                            for (var r = 0, s = this._overlays.length; r < s; r++) this._overlays[r].setGeometry(e)
                        }
                    }, _setupOverlayOptionManager: function () {
                        this._overlayOptionManager || (this._overlayOptionNames = {}, this._overlayOptionMapper = new l, this._overlayOptionManager = new o(null, this._options, "overlayMapping", this._overlayOptionMapper), this._setupInteractiveOptions())
                    }, _clearOverlayOptionManager: function () {
                        this._overlayOptionManager && (this._clearInteractiveOptions(), this._overlayOptionManager.setParent(null), this._overlayOptionManager = null)
                    }, _setupDraggable: function () {
                        this._draggableInited || (this._draggableInited = !0, this._optionMonitor.add("draggable", this._onDraggableChange, this), this._optionMonitor.get("draggable") && this._setupDragger())
                    }, _clearDraggable: function () {
                        this._draggableInited && (this._optionMonitor.get("draggable") && this._clearDragger(), this._optionMonitor.remove("draggable", this._onDraggableChange, this))
                    }, _onDraggableChange: function (e) {
                        e ? this._setupDragger() : this._clearDragger()
                    }, _setupDragger: function () {
                        this._draggerComponent = new _(this._geoObject, this._events, this._state, this._geometry, {
                            onDragStart: this._onDragStart,
                            onDragStop: this._onDragStop,
                            context: this
                        })
                    }, _clearDragger: function () {
                        this._draggerComponent && this._draggerComponent.destroy()
                    }, _onDragStart: function () {
                        var e = this._overlays;
                        if (e) for (var t = 0, i = e.length; t < i; t++) e[t].options.set("cursor", "grabbing")
                    }, _onDragStop: function () {
                        var e = this._overlays;
                        if (e) for (var t = 0, i = e.length; t < i; t++) e[t].options.unset("cursor")
                    }, _setupZIndex: function () {
                        this._optionMonitor.add("interactiveZIndex", this._onInteractiveZIndexChange, this), this._optionMonitor.get("interactiveZIndex") && this._setupStateMonitor(this._updateZIndexOptionName), this._setupZIndexOptionName(this._getZIndexOptionName())
                    }, _clearZIndex: function () {
                        this._zIndexOptionName && (this._clearZIndexOptionName(), this._optionMonitor.get("interactiveZIndex") && this._clearStateMonitor(this._updateZIndexOptionName), this._optionMonitor.remove("interactiveZIndex", this._onInteractiveZIndexChange, this))
                    }, _onInteractiveZIndexChange: function (e) {
                        e ? this._setupStateMonitor(this._updateZIndexOptionName) : this._clearStateMonitor(this._updateZIndexOptionName), this._updateZIndexOptionName()
                    }, _setupStateMonitor: function (e) {
                        this._stateMonitor || (this._stateMonitor = new h(this._state), this._stateMonitor.add(["active", "drag", "hover"], this._onStateChange, this), this._stateMonitorListeners = []), this._stateMonitorListeners.push(e)
                    }, _clearStateMonitor: function (e) {
                        if (this._stateMonitor) {
                            var t = r.indexOf(this._stateMonitorListeners, e);
                            t != -1 && this._stateMonitorListeners.splice(t, 1), !this._stateMonitorListeners.length && this._stateMonitor && (this._stateMonitor.destroy(), this._stateMonitor = null)
                        }
                    }, _onStateChange: function () {
                        for (var e = 0, t = this._stateMonitorListeners.length; e < t; e++) this._stateMonitorListeners[e].call(this)
                    }, _updateZIndexOptionName: function () {
                        var e = this._getZIndexOptionName();
                        this._zIndexOptionName != e && (this._clearZIndexOptionName(), this._setupZIndexOptionName(e), this._updateOverlaysZIndex())
                    }, _setupZIndexOptionName: function (e) {
                        this._zIndexOptionName = e, this._optionMonitor.add(e, this._updateOverlaysZIndex, this)
                    }, _clearZIndexOptionName: function () {
                        this._optionMonitor.remove(this._zIndexOptionName, this._updateOverlaysZIndex, this), this._zIndexOptionName = null
                    }, _updateOverlaysZIndex: function () {
                        if (this._overlays) for (var e = this._getZIndex(), t = 0, i = this._overlays.length; t < i; t++) this._overlays[t].options.set("zIndex", e)
                    }, _getZIndex: function () {
                        return this._setupZIndex(), this._getZIndex = this._zIndexGetter, this._zIndexGetter()
                    }, _zIndexGetter: function () {
                        return this._optionMonitor.get(this._zIndexOptionName)
                    }, _getZIndexOptionName: function () {
                        if (this._stateMonitor) {
                            if (this._stateMonitor.get("active")) return "zIndexActive";
                            if (this._stateMonitor.get("drag")) return "zIndexDrag";
                            if (this._stateMonitor.get("hover")) return "zIndexHover"
                        }
                        return "zIndex"
                    }
                }), e(y)
            });
        }],
        ['49', function (ym) {
            ym.modules.define("geoQuery", ["GeoQueryResult", "yandex.counter"], function (e, u, n) {
                function o(e) {
                    return n.countByKey("modulesUsage", "geoQuery"), new u(e)
                }

                e(o)
            });
        }],
        ['60', function (ym) {
            ym.modules.define("layer.tile.storage", ["util.Storage"], function (e, t) {
                e(new t)
            });
        }],
        ['61', function (ym) {
            ym.modules.define("layer.tileContainer.CanvasContainer", ["util.defineClass", "collection.Item", "layer.tile.storage", "layer.tileContainer.storage", "layer.tile.CanvasTile", "util.dom.element", "util.dom.style", "util.tile.Storage", "util.math.areEqual", "util.math.areEqualPaths", "util.hd", "util.pixelBounds"], function (e, t, i, s, n, r, l, a, o, h, d, _, v) {
                var u = ym.env.browser, c = u.isMobile || u.isTablet, f = function (e, t) {
                    f.superclass.constructor.call(this, t), this._layer = e, this._canvas = null, this._viewport = null, this.tiles = null
                };
                t(f, i, {
                    onAddToMap: function () {
                        this._canvas = this._createElement(), this._canvasContext = this._canvas.getContext("2d"), this._layer.getElement().appendChild(this._canvas), this.tiles && this._viewport && this.setTileZoom(this.tiles.getTileZoom())
                    }, onRemoveFromMap: function (e) {
                        l.remove(this._canvas), this.tiles && (this._tilesEvents.removeAll(), this._tilesEvents = null, this._freeTiles()), this._freeOldTiles(), this._canvas = null, this._canvasContext = null
                    }, setTileZoom: function (e, t) {
                        this._freeOldTiles(), t && (this._viewport = t);
                        var i = this.getMap();
                        if (i && this._setDimensions(), this.tiles) {
                            this._tilesEvents.removeAll();
                            var s = this.tiles.getTileZoom();
                            if (i && s != e && !this.options.get("tileTransparent")) {
                                this._oldTiles = this.tiles;
                                var n = [];
                                this._oldTiles.each(function (e, t) {
                                    e.isReady() || (e.destroy(), n.push(t))
                                });
                                for (var r = 0, l = n.length; r < l; r++) this._oldTiles.remove(n[r]);
                                this._renderTiles(this._oldTiles, !1)
                            } else this._freeTiles()
                        }
                        if (this.tiles = new o(e), this._tilesEvents = this.tiles.events.group().add("tileloaderror", function (e) {
                            this.events.fire("tileloaderror", e)
                        }, this).add("ready", function () {
                            this.events.fire("ready"), this._freeOldTiles()
                        }, this).add("tileready", function (e) {
                            this.events.fire("tileready", e)
                        }, this), i) {
                            var r, l, a = this.tiles, h = this._getTileRange(), d = this._getTilesDiff(a, h);
                            for (r = 0, l = d.added.length; r < l; r++) {
                                var _ = d.added[r], v = this.getTile(_, e, _[2]);
                                this.tiles.add(_, v), this._renderTile(v, _, e, !this.options.get("tileTransparent"))
                            }
                            this._setPosition()
                        }
                    }, setViewport: function (e) {
                        var t = this._viewport;
                        this._viewport = e;
                        var i, s, n = this.tiles, r = this._getTileRange(), l = this._getTilesDiff(this.tiles, r);
                        if (!d(this._viewport, t) || l.removed.length || l.added.length) {
                            for (i = 0, s = l.removed.length; i < s; i++) {
                                var a = n.get(l.removed[i]);
                                a && (n.remove(l.removed[i]), a.destroy())
                            }
                            for (i = 0, s = l.added.length; i < s; i++) {
                                var o = l.added[i], a = this.getTile(o, n.getTileZoom(), o[2]);
                                n.add(o, a)
                            }
                            this._renderAtViewport()
                        }
                    }, redraw: function (e) {
                        if (this.getMap()) {
                            var t, i = this.tiles.getTileZoom(), s = !1, n = !1;
                            if (e && (s = e.reload, n = !this.options.get("tileTransparent") && e.animate, t = e.updateBounds ? v.fromPoints(e.updateBounds) : null), this._clearCanvas(), this._oldTiles && this._renderTiles(this._oldTiles, !1), this.tiles.each(function (e, r) {
                                var l = !t || v.containsPoint(t, r);
                                return s && l ? (this.tiles.remove(r), void e.destroy()) : void this._renderTile(e, r, i, n && l)
                            }, this), s) for (var r = this._getTilesDiff(this.tiles, this._getTileRange()), l = 0, a = r.added.length; l < a; l++) {
                                var o = r.added[l], h = this.getTile(o, i, o[2]);
                                this.tiles.add(o, h), this._renderTile(h, o, i, n)
                            }
                        }
                    }, _renderTiles: function (e, t) {
                        var i = e.getTileZoom();
                        e.each(function (e, s) {
                            this._renderTile(e, s, i, t)
                        }, this)
                    }, _renderTile: function (e, t, i, s) {
                        e.renderAt(this._canvasContext, this._currentCanvasSize, this._numberToClientBounds(t, i), s)
                    }, _freeOldTiles: function () {
                        this._oldTiles && (this._oldTiles.each(function (e) {
                            e.destroy()
                        }), this._oldTiles.removeAll(), this._oldTiles = null)
                    }, _renderAtViewport: function () {
                        this._setDimensions(), this._setPosition(), this._oldTiles && this._renderTiles(this._oldTiles, !1), this._renderTiles(this.tiles, !1)
                    }, _createElement: function () {
                        var e = l.create({tagName: "canvas", css: {position: "absolute"}});
                        return c && "iOS" == u.osFamily && (e.patch = {transform: {offset: [0, 0], use3D: !0}}), e
                    }, getTile: function (e, t, i) {
                        var n = this.options.get("tileClass", "default#canvas"), r = this._layer.getTileUrl(e, t);
                        return "string" == typeof n && (n = s.get(n)), new n(r, this.options, {
                            priority: i,
                            tileNumber: e,
                            tileZoom: t,
                            restrictedTileNumber: this._layer.restrict(e, t)
                        })
                    }, _freeTiles: function () {
                        this.tiles.each(function (e) {
                            e.destroy()
                        }), this.tiles.removeAll(), this.tiles = null
                    }, _getTileRange: function () {
                        var e = this.tiles.getTileZoom();
                        return [this._layer.clientPixelsToNumber(this._viewport[0], e), this._layer.clientPixelsToNumber(this._viewport[1], e)]
                    }, _getTilesDiff: function (e, t) {
                        var i, s, n = {added: [], removed: []}, r = t[0], l = t[1], a = l[0] - r[0], o = l[1] - r[1],
                            h = a + o, d = h / a, _ = h / o, v = Math.round(r[0] + a / 2), u = Math.round(r[1] + o / 2);
                        for (i = r[0]; i <= l[0]; i++) for (s = r[1]; s <= l[1]; s++) e.get([i, s]) || n.added.push([i, s, h - Math.max(d * Math.abs(v - i), _ * Math.abs(u - s))]);
                        return e.each(function (e, t) {
                            t = [parseInt(t[0]), parseInt(t[1])], (t[0] < r[0] || t[0] > l[0] || t[1] < r[1] || t[1] > l[1]) && n.removed.push(t)
                        }), n
                    }, _numberToClientBounds: function (e, t) {
                        var i = this._viewport[0], s = this._layer.numberToClientBounds(e, t);
                        return [[s[0][0] - i[0], s[0][1] - i[1]], [s[1][0] - i[0], s[1][1] - i[1]]]
                    }, _clearCanvas: function () {
                        this._canvasContext.clearRect(0, 0, this._currentCanvasSize[0], this._currentCanvasSize[1])
                    }, _setPosition: function () {
                        var e = [Math.round(this._viewport[0][0]), Math.round(this._viewport[0][1])];
                        a.setPosition(this._canvas, e)
                    }, _setDimensions: function () {
                        var e = v.getSize(this._viewport);
                        if (this._currentCanvasSize && h(e, this._currentCanvasSize)) this._clearCanvas(); else {
                            this._currentCanvasSize = e, a.setSize(this._canvas, this._currentCanvasSize);
                            var t = _.getPixelRatio(), i = _.getBackingStorePixelRatio(this._canvasContext), s = t / i;
                            s = s < 1 ? 1 : s, s > 1 && s < 1.5 && (s = 2), a.attr(this._canvas, {
                                width: this._currentCanvasSize[0] * s,
                                height: this._currentCanvasSize[1] * s
                            }), 1 != s && this._canvasContext.scale(s, s)
                        }
                    }
                }), n.add("default#canvas", f), e(f)
            });
        }],
        ['62', function (ym) {
            ym.modules.define("layer.tileContainer.DomContainer", ["util.defineClass", "util.dom.element", "util.dom.style", "util.tile.Storage", "collection.Item", "layer.tile.storage", "layer.tileContainer.storage", "util.pixelBounds", "util.css", "layer.tile.DomTile"], function (e, t, i, s, l, o, r, n, a, h) {
                function d(e, t) {
                    d.superclass.constructor.call(this, t), this._layer = e, this._viewport = null
                }

                t(d, o, {
                    onAddToMap: function () {
                        var e = {
                            css: {position: "absolute"},
                            position: [0, 0],
                            parentNode: this.getParent().getElement()
                        };
                        this._element = i.create(e), this.tiles && this._viewport && this._arrange()
                    }, onRemoveFromMap: function (e) {
                        this._arrangeTimeout && (window.clearTimeout(this._arrangeTimeout), this._arrangeTimeout = null), i.remove(this._element), this.tiles && (this.tiles.events.remove("ready", this._onTilesReady, this), this.tiles.events.remove("tileloaderror", this._onTileLoadError, this), this._freeTiles()), this._freeOldTiles(), this._element = null
                    }, getTile: function (e, t, i) {
                        var s, l = this._layer.getTileUrl(e, t), o = this.options.get("tileClass", "default#dom");
                        if (l) s = o; else {
                            var n = this.options.get("notFoundTile", null);
                            "string" != typeof n && n ? s = n : (l = n, s = o)
                        }
                        return "string" == typeof s && (s = r.get(s)), new s(l, this.options, {
                            priority: i,
                            tileNumber: e,
                            tileZoom: t,
                            restrictedTileNumber: this._layer.restrict(e, t)
                        })
                    }, _onTileLoadError: function (e) {
                        this.events.fire("tileloaderror", e)
                    }, _onTilesReady: function () {
                        this.events.fire("ready"), this._freeOldTiles()
                    }, _freeTiles: function () {
                        this.tiles.each(function (e) {
                            e.destroy()
                        }), this.tiles.removeAll(), this.tiles = null
                    }, _freeOldTiles: function () {
                        this._oldTiles && (this._oldTiles.each(function (e) {
                            e.destroy()
                        }), this._oldTiles.removeAll(), this._oldTiles = null)
                    }, setTileZoom: function (e, t) {
                        if (this._freeOldTiles(), this.tiles) if (this.tiles.events.remove("ready", this._onTilesReady, this), this.tiles.events.remove("tileloaderror", this._onTileLoadError, this), !this.options.get("tileTransparent") && this.getMap() && Math.abs(this.tiles.getTileZoom() - e) <= 3) {
                            this._oldTiles = this.tiles;
                            var i = [];
                            this._oldTiles.each(function (e, t) {
                                e.isReady() || (e.destroy(), i.push(t))
                            });
                            for (var s = 0, o = i.length; s < o; s++) this._oldTiles.remove(i[s]);
                            this._drawTiles(this._oldTiles, this._element)
                        } else this._freeTiles();
                        t && (this._viewport = t), this.tiles = new l(e), this.tiles.events.add("ready", this._onTilesReady, this), this.tiles.events.add("tileloaderror", this._onTileLoadError, this), this.getMap() && this._arrange(!0)
                    }, setViewport: function (e) {
                        this._viewport = e, this.getMap() && (this._arrangeTimeout || (this._arrangeTimeout = window.setTimeout(function () {
                            this._arrangeTimeout = null, this._arrange()
                        }.bind(this), 250)))
                    }, _arrange: function (e) {
                        var t, i, l = this.tiles.getTileZoom(), o = this.tiles,
                            r = this._getTilesDiff(o, this._getTileRange()), n = this._element;
                        if (r.removed.length || r.added.length) {
                            for (s.css(n, {visibility: "hidden"}), t = 0, i = r.removed.length; t < i; t++) {
                                var a = o.get(r.removed[t]);
                                a && (o.remove(r.removed[t]), a.destroy())
                            }
                            for (t = 0, i = r.added.length; t < i; t++) {
                                var h = r.added[t];
                                a = this.getTile(h, l, h[2]), this.tiles.add(h, a), a.renderAt(n, this._layer.numberToClientBounds(h, l), e)
                            }
                            s.css(n, {visibility: ""})
                        }
                    }, redraw: function (e) {
                        if (this.getMap()) {
                            var t, i = this.tiles.getTileZoom(), s = !1, l = !1;
                            if (e && (s = e.reload, l = !this.options.get("tileTransparent") && e.animate, t = e.updateBounds ? a.fromPoints(e.updateBounds) : null), this._oldTiles && this._drawTiles(this._oldTiles, this._element, l), this.tiles.each(function (e, o) {
                                var r = !t || a.containsPoint(t, o);
                                r && (s ? (this.tiles.remove(o), e.destroy()) : e.renderAt(this._element, this._layer.numberToClientBounds(o, i), l))
                            }, this), s) for (var o = this._getTilesDiff(this.tiles, this._getTileRange()), r = 0, n = o.added.length; r < n; r++) {
                                var h = o.added[r], d = this.getTile(h, i, h[2]);
                                this.tiles.add(h, d), d.renderAt(this._element, this._layer.numberToClientBounds(h, i), l)
                            }
                        }
                    }, _drawTiles: function (e, t, i) {
                        var s = e.getTileZoom();
                        e.each(function (e, l) {
                            e.renderAt(t, this._layer.numberToClientBounds(l, s), i)
                        }, this)
                    }, _getTileRange: function () {
                        return [this._layer.clientPixelsToNumber(this._viewport[0], this.tiles.getTileZoom()), this._layer.clientPixelsToNumber(this._viewport[1], this.tiles.getTileZoom())]
                    }, _getTilesDiff: function (e, t) {
                        var i, s, l = {added: [], removed: []}, o = t[0], r = t[1], n = r[0] - o[0], a = r[1] - o[1],
                            h = n + a, d = h / n, u = h / a, _ = Math.round(o[0] + n / 2), T = Math.round(o[1] + a / 2);
                        for (i = o[0]; i <= r[0]; i++) for (s = o[1]; s <= r[1]; s++) e.get([i, s]) || l.added.push([i, s, h - Math.max(d * Math.abs(_ - i), u * Math.abs(T - s))]);
                        return e.each(function (e, t) {
                            (t[0] < o[0] || t[0] > r[0] || t[1] < o[1] || t[1] > r[1]) && l.removed.push(t)
                        }), l
                    }
                }), n.add("default#dom", d), e(d)
            });
        }],
        ['63', function (ym) {
            ym.modules.define("layer.tileContainer.storage", ["util.AsyncStorage"], function (e, n) {
                e(new n)
            });
        }],
        ['64', function (ym) {
            ym.modules.define("layout.Base", ["util.defineClass", "Event", "event.Manager", "domEvent.manager", "constants.mapDomEvents"], function (e, t, n, i, s, r) {
                function a(e, t) {
                    this._parameters = t || {}, this._data = e, this._parentElement = null, this.events = new i({context: this});
                    var n = !1;
                    this.events.addController({
                        onBeforeEventFiring: function (e, t) {
                            if ("mouseenter" == t) {
                                if (n) return !1;
                                n = !0
                            } else if ("mouseleave" == t) {
                                if (!n) return !1;
                                n = !1
                            }
                        }
                    })
                }

                t(a, {
                    isEmpty: function () {
                        return !0
                    }, setData: function (e) {
                        this._data = e, this.rebuild()
                    }, getData: function () {
                        return this._data
                    }, getParameters: function () {
                        return this._parameters
                    }, setParameters: function (e) {
                        this._parameters != e && (this.clear(), this._parameters = e, this.build())
                    }, setParentElement: function (e) {
                        if (this._parentElement != e) {
                            var t = this._parentElement;
                            t && this.clear(), this._parentElement = e, this._parentElement && this.build(), this.events.fire("parentelementchange")
                        }
                    }, getParentElement: function () {
                        return this._parentElement
                    }, build: function () {
                        this._parameters.disableDomEventListening || s.add(this._parentElement, r, this.onDomEvent, this)
                    }, clear: function () {
                        this._parameters.disableDomEventListening || s.remove(this._parentElement, r, this.onDomEvent, this)
                    }, rebuild: function () {
                        this._parentElement && (this.clear(), this.build())
                    }, destroy: function () {
                    }, onDomEvent: function (e) {
                        var t = e.get("type"), i = e.get("propagatedData");
                        i.firedAs || (i.firedAs = {}), i.firedAs[t] || ("mouseenter" != t && "mouseleave" != t && (i.firedAs[t] = !0), this.events.fire(t, new n({
                            type: t,
                            target: this,
                            domEvent: e
                        }, e)))
                    }
                }), e(a)
            });
        }],
        ['68', function (ym) {
            ym.modules.define("layout.component.clientBounds", ["util.dom.style"], function (e, n) {
                e(function (e, t) {
                    if (!e) {
                        if (ym.env.debug) throw new Error("layout.component.clientBounds: Верхний элемент макета не был передан.");
                        return [[0, 0], [0, 0]]
                    }
                    if (!e.parentNode) return [[0, 0], [0, 0]];
                    t || (t = e);
                    var o = e.offsetParent != e.parentNode.offsetParent,
                        r = n.getSize(t, {includePadding: !0, includeBorder: !0}), d = n.getOffset(e, o),
                        f = n.getOffset(e.parentNode, o), u = [d[0] - f[0], d[1] - f[1]],
                        i = [u[0] + r[0], u[1] + r[1]];
                    return [u, i]
                })
            });
        }],
        ['71', function (ym) {
            ym.modules.define("map.Balloon", ["util.defineClass", "Balloon", "component.sharedEntity.manager.Popup", "sharedEntity.proxy.Balloon", "event.Manager", "map.optionMapper", "option.Manager", "option.Router", "util.component", "vow", "popup.managerStorage"], function (t, n, e, o, i, s, r, a, p, h, u, l) {
                function f(t) {
                    this._map = t, this.events = new s({context: this}), this._balloon = new e(t), this._balloon.options.setParent(this._map.options), this._sharingManager = new o(this, this._balloon, this._map, i), this._forkOptions = new a
                }

                n(f, h.createProxyMethods(function () {
                    return this._sharingManager
                }, ["capture", "open", "close", "isOpen", "getOverlay", "getOverlaySync", "autoPan", "getOwner", "setPosition", "getPosition", "setData", "getData", "setOptions", "getOptions"]), {
                    destroy: function () {
                        this.capture(null), this._balloon.destroy()
                    }, capture: function (t) {
                        var n = this._sharingManager.capture(t);
                        return n.then(this._reset, this), n
                    }, open: function (t, n, e) {
                        t = t || this._map.getCenter();
                        var o = u.defer(), i = function (t) {
                            o.reject(t)
                        };
                        return this._sharingManager.perform("open", [t, n, e], this, function (t) {
                            u.resolve(!t[2] || this.setOptions(t[2])).then(function () {
                                o.resolve(this._sharingManager.getEntity().open(t[0], t[1]))
                            }, i, this)
                        }, i), o.promise()
                    }, setOptions: function (t) {
                        var n = u.defer();
                        return this._sharingManager.perform("setOptions", [t], this, function (t) {
                            this._addForkOptions(), this._forkOptions.freeze().unsetAll().set(t[0]).unfreeze(), n.resolve()
                        }, function (t) {
                            n.reject(t)
                        }), n.promise()
                    }, getOptions: function () {
                        return this._sharingManager.perform("getOptions", null, this, function () {
                            return this._addForkOptions(), this._forkOptions
                        })
                    }, autoPan: function () {
                        return this._sharingManager.perform("autoPan")
                    }, _addForkOptions: function () {
                        var t = this._balloon.options.getParent();
                        t && "function" == typeof t.spliceParents ? t.indexOfParent(this._forkOptions) == -1 && t.spliceParents(0, 0, this._forkOptions) : this._balloon.options.setParent(new p(this._forkOptions, t))
                    }, _reset: function () {
                        this.getOwner() == this._map && this._balloon.options.setParent(this._map.options), this._forkOptions.unsetAll()
                    }
                }), l.add("map#balloon", f), t(f)
            });
        }],
        ['72', function (ym) {
            ym.modules.define("map.behavior.Manager", ["util.defineClass", "behavior.storage", "map.behavior.optionMapper", "map.GeneralCollection", "component.collection.ParentCollection", "error", "map.behavior.metaOptions"], function (e, o, t, i, r, n, a) {
                var s = function (e, o, t) {
                    s.superclass.constructor.call(this, e, t, "behaviors", i), this._parentCollection = new n(this, {
                        onAdd: {
                            callback: this._onAdd,
                            context: this
                        }, onRemove: {callback: this._onRemove, context: this}
                    }), this._behaviors = {};
                    for (var r = [].concat(o), a = 0, h = r.length; a < h; a++) for (var l = this._resolveBehaviors(r[a]), v = 0, c = l.length; v < c; v++) l[v].enable()
                };
                o(s, r, {
                    enable: function (e) {
                        "string" == typeof e && (e = [e]);
                        for (var o = 0, t = e.length; o < t; o++) {
                            var i = this._resolveBehavior(e[o]);
                            i && i.enable()
                        }
                        return this
                    }, disable: function (e) {
                        "string" == typeof e && (e = [e]);
                        for (var o = 0, t = e.length; o < t; o++) {
                            var i = this._resolveBehavior(e[o]);
                            i && i.disable()
                        }
                        return this
                    }, isEnabled: function (e) {
                        var o = this._resolveBehavior(e);
                        return o && o.isEnabled()
                    }, get: function (e) {
                        return this._resolveBehavior(e)
                    }, _resolveBehaviors: function (e) {
                        var o, t = [];
                        if ("default" == e) for (var i = this.getMap().options.get("defaultBehaviors") || [], r = 0, n = i.length; r < n; r++) o = this._resolveBehavior(i[r]), o && t.push(o); else o = this._resolveBehavior(e), o && t.push(o);
                        return t
                    }, _resolveBehavior: function (e) {
                        var o = this._behaviors[e];
                        if (!o) {
                            var i = t.get(e);
                            i ? (o = this._behaviors[e] = new i, this._parentCollection.add(o)) : a.warn("Warning", 'map.Behaviors: behavior "' + e + '" does not exist')
                        }
                        return o
                    }, _onAdd: function (e) {
                        this.events.fire("add", {child: e})
                    }, _onRemove: function (e) {
                        this.events.fire("remove", {child: e})
                    }
                }), e(s)
            });
        }],
        ['73', function (ym) {
            ym.modules.define("map.behavior.metaOptions", ["map.metaOptions", "behavior.DblClickZoom", "behavior.Drag", "behavior.LeftMouseButtonMagnifier", "behavior.MultiTouch", "behavior.RightMouseButtonMagnifier", "behavior.ScrollZoom"], function (o, i) {
                i.set({
                    defaultBehaviors: ["drag", "rightMouseButtonMagnifier", "dblClickZoom", "multiTouch", "scrollZoom"],
                    dragCursor: "grab",
                    dragActionCursor: "grabbing"
                }), o(!0)
            });
        }],
        ['74', function (ym) {
            ym.modules.define("map.behavior.optionMapper", ["option.Mapper"], function (e, o) {
                e(new o)
            });
        }],
        ['75', function (ym) {
            ym.modules.define("map.behavior.ScrollZoomController", ["util.defineClass", "Monitor"], function (o, t, i) {
                function s(o) {
                    this._map = o, this._mapStateMonitor = new i(o.state).add("vectorEnabled", this._setupScrollZoom, this), this._oldOptions = null, this._setupScrollZoom()
                }

                t(s, {
                    destroy: function () {
                        this._mapStateMonitor.removeAll()
                    }, _setupScrollZoom: function () {
                        this._map.state.get("vectorEnabled") ? (this._oldOptions = {
                            scrollZoomSmooth: this._map.options.get("scrollZoomSmooth"),
                            avoidFractionalZoom: this._map.options.get("avoidFractionalZoom")
                        }, "undefined" == typeof this._oldOptions.scrollZoomSmooth && this._map.options.set({
                            scrollZoomSmooth: !0,
                            avoidFractionalZoom: !1
                        })) : this._oldOptions && (this._map.options.set(this._oldOptions), this._oldOptions = null, this._map.options.get("avoidFractionalZoom") && this._map.setZoom(Math.floor(this._map.getZoom() + .01)))
                    }
                }), o(s)
            });
        }],
        ['76', function (ym) {
            ym.modules.define("map.Container", function (e) {
                e.env.lang.slice(0, 2);
                return ["util.defineClass", "util.extend", "event.Manager", "domEvent.manager", "Monitor", "util.math.areEqual", "util.math.restrict", "util.fireWithBeforeEvent", "util.dom.style", "util.dom.element", "util.dom.viewport", "util.dom.className", "util.css", "util.hd", "system.browser", "meta", "yandex.counter", "util.scheduler.strategy.Asap", "util.fullscreen.Manager", "map.css"]
            }, function (e, t, i, s, n, o, a, l, r, h, u, d, p, _, c, m, f, y, g, v) {
                function z(e, t) {
                    if ("string" == typeof e && (e = document.getElementById(e)), ym.env.debug && (!e || 1 != e.nodeType)) throw new Error("map.Container.constructor: Не удалось получить HTML-элемент контейнера.");
                    this._parentElement = e, this._map = t, this._mapOptionsMonitor = new o(t.options), this.events = new s({context: this}), this._mapOptionsMonitor.add("autoFitToViewport", this._onAutoFitModeChange, this).add("autoFitToViewportDelay", this._onAutoFitDelayChange, this).add("backgroundVisible", this._onBackgroundVisibleChange, this, {defaultValue: !0}).add("extendedLayoutResolver", this._onExtendedLayoutResolverChange, this), this._size = h.getSize(e), this._mapSize = this._size, this._detailsSize = [0, 0];
                    var i = [_.addPrefix("map"), _.addPrefix("i-ua_js_yes")];
                    if (this._mapOptionsMonitor.get("backgroundVisible") && i.push(E), "pointer" == m.eventMapper && i.push(_.addPrefix("touch-action-none")), i.push(_.addPrefix("islets_map-lang-" + x)), this._element = u.create({
                        parentNode: e,
                        className: _.addPrefix("map"),
                        size: this._size
                    }), this._mapElement = u.create({
                        parentNode: this._element,
                        className: i.join(" "),
                        size: this._mapSize
                    }), this._detailsElement = u.create({css: {display: "block"}}), this._calcMapOffset(), this._fullscreenManager = new v(this._element), this._fullscreenManager.options.setParent(t.options), this._fullscreenManager.events.add("fullscreenenter", this._onFullscreenEnter, this).add("fullscreenexit", this._onFullScreenExit, this).add("fullscreenreposition", this._onFullscreenReposition, this), this._setupAutoFit(), this._oldWindowSize = d.getSize(), this._windowListeners = n.group(window), this._documentListeners = n.group(document), this._windowListeners.add("resize", this._onWindowResize, this), this._layoutMode = null, this._extended = this._oldExtended = !1, ym.supports.printPatchNeeded) {
                        var a = _.addPrefix("patched-for-print-preload");
                        this._windowListeners.add("beforeprint", function () {
                            p.add(this._element, a), new g(function () {
                                p.remove(this._element, a)
                            }, this).start()
                        }, this)
                    }
                    y.countByKey("modulesUsage", ["mapDpr", Math.round(c.getPixelRatio()), m.platform, y.versionPrefix].join("."))
                }

                function w(e) {
                    return e.toString().replace(/\./g, "_")
                }

                function S(e, t) {
                    return [l(e[0], 0, t[0]), l(e[1], 0, t[1])]
                }

                var E = _.addPrefix("map-bg"), x = f.languageCode;
                t(z, {
                    getParentElement: function () {
                        return this._parentElement
                    }, getContainerElement: function () {
                        return this._element
                    }, getDetailsElement: function () {
                        return this._detailsElement
                    }, getMapElement: function () {
                        return this._mapElement
                    }, getMapSize: function () {
                        return this._mapSize
                    }, getMapOffset: function () {
                        return this._calcMapOffset(), this._mapOffset
                    }, enableExtendedLayout: function () {
                        this._extended = !0, this.fitToViewport()
                    }, disableExtendedLayout: function () {
                        this._extended = !1, this.fitToViewport()
                    }, isExtendedLayoutEnabled: function () {
                        return this._extended
                    }, getExtendedLayoutMode: function () {
                        return this._extended ? this._layoutMode.mode : null
                    }, fitToViewport: function (e) {
                        if (document.body.contains(this._parentElement)) {
                            var t, i = this._layoutMode, s = null, n = !1, o = this._oldExtended != this._extended,
                                l = this._size;
                            if (this._fullscreenManager.isInFullscreen()) t = this._fullscreenManager.getSize(); else {
                                var r = this._parentElement.style.getPropertyValue("overflow-x"),
                                    u = this._parentElement.style.getPropertyValue("overflow-y"),
                                    d = this._parentElement.style.getPropertyPriority("overflow-x"),
                                    p = this._parentElement.style.getPropertyPriority("overflow-y");
                                this._parentElement.style.setProperty("overflow-x", "hidden", "important"), this._parentElement.style.setProperty("overflow-y", "hidden", "important"), t = h.getSize(this._parentElement), this._parentElement.style.setProperty("overflow-x", r, d), this._parentElement.style.setProperty("overflow-y", u, p)
                            }
                            if (this._extended) {
                                var _ = this._map.options.get("extendedLayoutResolver"), c = i || {};
                                s = _(t), n = s.mode != c.mode || s.mapHeight != c.mapHeight || s.mapWidth != c.mapWidth || !a(s.mapSize || [0, 0], c.mapSize || [0, 0])
                            }
                            (!a(l, t) || n || o) && (this._isNullSize && (this._isNullSize = !1, this._logSize()), this._size = t, h.setSize(this._element, t), this._layoutMode = s, this._positionLayout(e), (n || o) && this.events.fire("extendedlayoutchange", {oldExtendedLayoutMode: i}), o && (this.events.fire("extendedlayouttoggle"), this._oldExtended = this._extended))
                        }
                    }, enterFullscreen: function () {
                        this._fullscreenManager.enterFullscreen()
                    }, _onFullscreenEnter: function () {
                        this.events.fire("fullscreenenter"), this.fitToViewport(), y.countByKey("modulesUsage", "fullscreen.enter")
                    }, exitFullscreen: function () {
                        this._fullscreenManager.exitFullscreen()
                    }, _onFullScreenExit: function () {
                        r(this.events, {
                            type: "fullscreenexit",
                            target: this
                        }, {successCallback: this._onFullScreenExitSuccess, context: this})
                    }, isFullscreen: function () {
                        return this._fullscreenManager.isInFullscreen()
                    }, setupVisibilityTests: function () {
                        this._visibilityCheckInterval = window.setInterval(this._performVisibilityCheck.bind(this), 1e3)
                    }, getFullscreenManager: function () {
                        return this._fullscreenManager
                    }, _positionLayout: function (e) {
                        var t = this._mapSize, s = this._mapOffset, n = null, o = {
                            showMap: !0,
                            showDetails: !1,
                            detailsSize: this._size,
                            mapSize: this._size,
                            mapStyle: {position: "", zIndex: 0}
                        };
                        if (this._extended) {
                            var a = z._MODES[this._layoutMode.mode];
                            n = a(this._size, this._layoutMode), n.showDetails = !0
                        } else n = {mapSize: this._size, showDetails: !1};
                        var l = i({}, o, n);
                        l.showMap ? p.remove(this._mapElement, _.addPrefix("display-none")) : p.add(this._mapElement, _.addPrefix("display-none")), l.showDetails ? this._detailsElement.parentNode || this._element.insertBefore(this._detailsElement, this._mapElement) : this._detailsElement.parentNode && this._detailsElement.parentNode.removeChild(this._detailsElement), this._mapSize = l.mapSize, this._detailsSize = l.detailsSize, h.setSize(this._mapElement, this._mapSize), h.css(this._mapElement, l.mapStyle), h.setSize(this._detailsElement, this._detailsSize), this._calcMapOffset(), this.events.fire("sizechange", {
                            oldSize: t,
                            newSize: this._mapSize,
                            oldOffset: s,
                            newOffset: this._mapOffset,
                            preservePixelPosition: Boolean(e)
                        })
                    }, _performVisibilityCheck: function () {
                        var e = h.checkVisibility(this._element);
                        "unable" == e ? this.teardownVisibilityTests() : "visible" == e && (this.teardownVisibilityTests(), y.countByKey("map", ["visible", y.versionPrefix, ym.env.browser.platform].join(".")), this._map.copyrights.checkVisibility())
                    }, teardownVisibilityTests: function () {
                        this._visibilityCheckInterval && window.clearInterval(this._visibilityCheckInterval)
                    }, destroy: function () {
                        this.teardownVisibilityTests(), this._windowListeners.removeAll(), this._documentListeners.removeAll(), this._fullscreenManager.destroy(), u.remove(this._element), this._mapOptionsMonitor.destroy(), this._clearAutoFit()
                    }, _onFullScreenExitSuccess: function (e) {
                        this.fitToViewport(), this.events.fire(e.type, e)
                    }, _onFullscreenReposition: function () {
                        this.fitToViewport()
                    }, _setupAutoFit: function () {
                        var e = this._mapOptionsMonitor.get("autoFitToViewport"), t = this.getSize(), i = a(t, [0, 0]);
                        i && (this._isNullSize = !0), this._logSize(), (i && "ifNull" == e || "always" == e) && (this._autoFitIntervalID = setInterval(function () {
                            this._checkAutoFit()
                        }.bind(this), this._mapOptionsMonitor.get("autoFitToViewportDelay")))
                    }, _onAutoFitModeChange: function (e) {
                        this._clearAutoFit(), "none" != e && this._setupAutoFit()
                    }, _onAutoFitDelayChange: function () {
                        this._clearAutoFit(), this._setupAutoFit()
                    }, _clearAutoFit: function () {
                        this._autoFitIntervalID && (clearInterval(this._autoFitIntervalID), this._autoFitIntervalID = null)
                    }, _checkAutoFit: function () {
                        this.fitToViewport(), a(this.getSize(), [0, 0]) || "ifNull" != this._mapOptionsMonitor.get("autoFitToViewport") || this._clearAutoFit()
                    }, _onWindowResize: function () {
                        var e = d.getSize();
                        a(e, this._oldWindowSize) || (this._oldWindowSize = e, this.fitToViewport())
                    }, _onBackgroundVisibleChange: function (e) {
                        e ? p.add(this._element, E) : p.remove(this._element, E)
                    }, _onExtendedLayoutResolverChange: function (e) {
                        this.fitToViewport()
                    }, _logSize: function () {
                        y.countByKey("modulesUsage", ["mapSize", w(this._size[0]) + "x" + w(this._size[1]), m.platform, y.versionPrefix].join("."))
                    }, _calcMapOffset: function () {
                        this._mapOffset = h.getOffset(this._mapElement, !0)
                    }
                }), z.prototype.getElement = z.prototype.getMapElement, z.prototype.getSize = z.prototype.getMapSize, z.prototype.getOffset = z.prototype.getMapOffset, z._MODES = {
                    nomap: function (e, t) {
                        return {showMap: !1, detailsSize: e}
                    }, hsplit: function (e, t) {
                        var i = l(t.mapWidth, 0, e[0]);
                        return {
                            mapSize: [i, e[1]],
                            detailsSize: [e[0] - i, e[1]],
                            mapStyle: {position: "absolute", right: 0, bottom: 0}
                        }
                    }, vsplit: function (e, t) {
                        var i = l(t.mapHeight, 0, e[1]);
                        return {mapSize: [e[0], i], detailsSize: [e[0], e[1] - i]}
                    }, minimap: function (e, t) {
                        return {
                            mapSize: S(t.mapSize, e),
                            detailsSize: e,
                            mapStyle: {position: "absolute", right: 0, bottom: 0, zIndex: 1e4}
                        }
                    }
                }, e(z)
            });
        }],
        ['77', function (ym) {
            ym.modules.define("map.Converter", [], function (t) {
                var e = function (t) {
                    this._map = t, this._listeners = t.events.group().add("destroy", this._onDestroy, this)
                };
                e.prototype = {
                    _onDestroy: function () {
                        this._listeners.removeAll()
                    }, pageToGlobal: function (t) {
                        var e = this._map.container.getOffset(), n = this._map.container.getSize(),
                            i = [n[0] / 2, n[1] / 2], o = this._map.action.getCurrentState().globalPixelCenter;
                        return [o[0] + t[0] - e[0] - i[0], o[1] + t[1] - e[1] - i[1]]
                    }, globalToPage: function (t) {
                        var e = this._map.container.getOffset(), n = this._map.container.getSize(),
                            i = [n[0] / 2, n[1] / 2], o = this._map.action.getCurrentState().globalPixelCenter;
                        return [t[0] - o[0] + e[0] + i[0], t[1] - o[1] + e[1] + i[1]]
                    }
                }, t(e)
            });
        }],
        ['78', function (ym) {
            ym.modules.define("map.copyrights.counter", ["util.id"], function (e, t) {
                var r = {}, n = {};
                e({
                    create: function (e, t) {
                        var o, c = !!n[e];
                        if (n[e] = t, c) for (var i in r) r.hasOwnProperty(i) && (o = r[i][e], o && o.copyrights.setCopyrights(t))
                    }, increment: function (e, o, c) {
                        var i, u = t.get(o);
                        c = c || 1, r[u] = r[u] || {}, i = r[u], i[e] ? i[e].counter += c : i[e] = {
                            counter: c,
                            copyrights: o.copyrights.add(n[e])
                        }
                    }, decrement: function (e, n, o) {
                        var c, i = t.get(n), u = r[i];
                        o = o || 1, u && u[e] && (c = u[e], c.counter -= o, c.counter <= 0 && (c.copyrights.remove(), delete r[i][e]))
                    }
                })
            });
        }],
        ['79', function (ym) {
            ym.modules.define("map.copyrights.Layout", ["templateLayoutFactory", "copyright.layout.html", "Monitor", "domEvent.manager", "localization.common.current", "util.array", "util.nodeSize", "util.dom.element", "util.dom.className", "util.dom.style", "util.css", "meta.internal", "yandex.state.associate", "yandex.counter", "system.browser"], function (t, i, e, s, o, a, n, r, l, h, d, p, g, _, c, u) {
                function y(t, i, e) {
                    i ? h.add(t, e) : h.remove(t, e)
                }

                var m = g.meta, f = {
                    FOG: p.addPrefix("copyright_fog_yes"),
                    WHITE_THEME: p.addPrefix("copyright_color_white"),
                    EN_LOGO: p.addPrefix("copyright__logo_lang_en"),
                    POSITION_LEFT: p.addPrefix("copyright_float_left"),
                    VISIBLE_NO: p.addPrefix("copyright_logo_no"),
                    PROVIDES_VISIBLE_NO: p.addPrefix("copyright_providers_no"),
                    UA_VISIBLE_NO: p.addPrefix("copyright_ua_no")
                }, E = i.createClass(e, {
                    build: function () {
                        E.superclass.build.call(this);
                        var t = this.getParentElement(), i = this.getData(), e = m.languageCode;
                        this._copyrightsElement = l.findByPrefixedClass(t, "copyright"), this._logoLinkElement = l.findByPrefixedClass(t, "copyright__logo"), this._legendElement = l.findByPrefixedClass(t, "copyright__text"), this._linkElement = l.findByPrefixedClass(t, "copyright__link"), this._linkElement.textContent = "large" == i.state.get("size") ? a.Copyrights.agreement : a.Copyrights.agreementCompact, this._yandexState = _.get(i.map), this._update(), "ru" != e && "uk" != e && h.add(this._logoLinkElement, f.EN_LOGO), d.patch(this._logoLinkElement, {printBackground: d.value(this._logoLinkElement, "backgroundImage", !0).replace(/^\s*url\(['"]?/, "").replace(/['"]?\)$/, "")}), this._setupListeners()
                    }, clear: function () {
                        this._clearListeners(), E.superclass.clear.call(this)
                    }, checkVisibility: function () {
                        if (this.getData().map.options.get("copyrightUaVisible", !0)) {
                            var t = d.checkVisibility(l.findByPrefixedClass(this._copyrightsElement, "copyright__link"));
                            "blocked" == t && c.countByKey("violators", "copyrightsHidden." + ym.env.browser.platform)
                        }
                    }, _setupListeners: function () {
                        var t = this.getData(), i = t.data, e = t.map;
                        this._stateMonitor = new s(t.state).add("size", this.rebuild, this), this._monitor = new s(i).add("copyrights", this._updateCopyrights, this).add("bright", this._updateColor, this).add("logo", this._updateLogoVisible, this).add("float", this._updatePosition, this), this._mapListener = e.events.group().add("sizechange", this._updateView, this), this._mapOptionsMonitor = new s(e.options).add("copyrightProvidersVisible", this._updateProvidersVisible, this).add("copyrightUaVisible", this._updateUaVisible, this), this._logoLinkListeners = o.group(this._logoLinkElement).add(["mouseenter", "click"], function () {
                            this._logoLinkElement.href = this._yandexState.buildLink()
                        }, this).add("click", function () {
                            c.countByKey("distribution", ["mapsLogo", u.platform, c.versionPrefix].join("."))
                        }, this)
                    }, _clearListeners: function () {
                        this._stateMonitor.destroy(), this._monitor.destroy(), this._mapOptionsMonitor.destroy(), this._mapListener.removeAll(), this._logoLinkListeners.removeAll()
                    }, _update: function () {
                        var t = this.getData(), i = t.data, e = t.map.options;
                        this._updateCopyrights(i.get("copyrights")), this._updateColor(i.get("bright")), this._updatePosition(i.get("float")), this._updateLogoVisible(i.get("logo")), this._updateProvidersVisible(e.get("copyrightProvidersVisible", !0)), this._updateUaVisible(e.get("copyrightUaVisible", !0))
                    }, _updateCopyrights: function (t) {
                        var i = "";
                        n.isArray(t) ? t.length > 0 && (i = t.join(", ")) : "string" == typeof t && (i = t), l.html(this._legendElement, i), this._updateView()
                    }, _updateLogoVisible: function (t) {
                        y(this._copyrightsElement, !t, f.VISIBLE_NO)
                    }, _updateProvidersVisible: function (t) {
                        t || g.isYandex || c.countByKey("violators", "providerOptionUsed." + ym.env.browser.platform), y(this._copyrightsElement, !t, f.PROVIDES_VISIBLE_NO)
                    }, _updateUaVisible: function (t) {
                        t || g.isYandex || c.countByKey("violators", "uaOptionUsed." + ym.env.browser.platform), y(this._copyrightsElement, !t, f.UA_VISIBLE_NO)
                    }, _updateColor: function (t) {
                        y(this._copyrightsElement, !t, f.WHITE_THEME)
                    }, _updatePosition: function (t) {
                        y(this._copyrightsElement, "left" == t, f.POSITION_LEFT)
                    }, _updateView: function (t) {
                        d.css(this._copyrightsElement, {width: null});
                        var i = this._copyrightsElement, e = r.computeByContent(i), s = e.width, o = s,
                            a = this._getParentOffset(),
                            n = "undefined" == typeof t ? this.getData().map.container.getSize()[0] : t.get("newSize")[0];
                        if (s >= n) {
                            o = Math.max(0, n - a);
                            var l = window.getComputedStyle(i), h = parseInt(l.marginLeft) + parseInt(l.marginRight);
                            d.css(i, {width: o - h + "px"})
                        }
                        y(i, s >= n, f.FOG), this.getData().state.set("copyrightsWidth", o)
                    }, _getParentOffset: function () {
                        var t = this.getParentElement(), i = d.values(t, ["left", "right"]), e = 0;
                        if ("auto" != i.left || "auto" != t.right) for (var s in i) if (i.hasOwnProperty(s)) {
                            var o = parseInt(i[s], 10);
                            isNaN(o) || (e += o)
                        }
                        return e
                    }
                });
                t(E)
            });
        }],
        ['81', function (ym) {
            ym.modules.define("multiRouter.model.component.EmptyPointController", ["util.defineClass", "util.extend", "util.array", "util.string"], function (e, t, r, s, i) {
                function n(e, t) {
                    this._request = this.filterRequest(e), this._paramsLength = a(this._request.params), this._json = t
                }

                function a(e) {
                    var t = 0;
                    for (var r in e) e.hasOwnProperty(r) && t++;
                    return t
                }

                t(n, {
                    setJsonCache: function (e, t) {
                        this._json = e, this._request = this.filterRequest(t), this._paramsLength = a(this._request.params)
                    }, getJsonCache: function (e) {
                        e = this.filterRequest(e);
                        var t = this._arePointsEqual(e.points) && this._areParamsEqual(e.params);
                        return t ? this._json : null
                    }, filterRequest: function (e) {
                        for (var t, s, n, a = e.points, o = 0, u = a.length; o < u; o++) t ? i.trim(a[o]) ? t.push(a[o]) : n.push(o) : i.trim(a[o]) || (t = a.slice(0, o), n = [o]);
                        if (n) {
                            s = e.params.viaIndexes.slice().sort();
                            for (var o = n.length - 1; o >= 0; o--) {
                                for (var p = s.length - 1; s[p] > n[o];) s[p]--, p--;
                                s[p] == n[o] && s.splice(p, 1)
                            }
                        }
                        return t ? {points: t, params: r({}, e.params, {viaIndexes: s})} : e
                    }, completeJson: function (e, t) {
                        var n = e.features[0].features, a = e.features[1].features, o = 0, u = 0;
                        n = n.slice(), a = a.slice();
                        for (var p = 0, f = t.points.length; p < f; p++) {
                            var l = t.points[p], h = s.indexOf(t.params.viaIndexes, p);
                            if (h == -1) {
                                if (i.trim(l)) {
                                    var m = n[o];
                                    n[o] = r({}, m, {properties: r({}, m.properties, {index: o})})
                                } else n.splice(o, 0, this._getEmptyWayPointJson(o));
                                o++
                            } else if ("auto" == t.params.routingMode) {
                                if (i.trim(l)) {
                                    var c = a[u];
                                    a[u] = r({}, c, {properties: r({}, c.properties, {index: u})})
                                } else a.splice(u, 0, this._getEmptyViaPointJson(u));
                                u++
                            }
                        }
                        return e = r({}, e, {features: e.features.slice()}), e.features[0] = r({}, e.features[0], {features: n}), e.features[1] = r({}, e.features[1], {features: a}), e
                    }, _arePointsEqual: function (e) {
                        var t = this._request.points;
                        if (e.length != t.length) return !1;
                        for (var r = !0, s = 0, i = t.length; s < i; s++) if (e[s] != t[s]) {
                            r = !1;
                            break
                        }
                        return r
                    }, _areParamsEqual: function (e) {
                        var t = this._request.params, r = 0, s = !0;
                        for (var i in e) if (e.hasOwnProperty(i)) {
                            if (e[i] != t[i]) {
                                s = !1;
                                break
                            }
                            r++
                        }
                        return s && (s = this._paramsLength == r), s
                    }, _getEmptyWayPointJson: function (e) {
                        return {
                            type: "Feature",
                            properties: {index: e, request: ""},
                            geometry: {type: "Point", coordinates: null}
                        }
                    }, _getEmptyViaPointJson: function (e) {
                        return {type: "Feature", properties: {index: e}, geometry: {type: "Point", coordinates: null}}
                    }
                }), e(n)
            });
        }],
        ['83', function (ym) {
            ym.modules.define("multiRouter.model.component.ReferencePointManager", ["util.defineClass", "multiRouter.referencePointUtils"], function (e, t, n) {
                function i(e, t) {
                    this._referencePoints = e, this._changeCallback = t, this._requests = [], this._calcRequests(), this._setupPoints()
                }

                t(i, {
                    setPoint: function (e, t) {
                        this._clearPoint(e), this._referencePoints[e] = t, this._calcRequest(e), this._setupPoint(e), this._callChangeCallback()
                    }, setPoints: function (e) {
                        this._clearPoints(), this._referencePoints = e, this._calcRequests(), this._setupPoints(), this._callChangeCallback()
                    }, getPoints: function () {
                        return this._referencePoints
                    }, getRequests: function () {
                        return this._requests
                    }, destroy: function () {
                        this._clearPoints()
                    }, _setupPoints: function () {
                        for (var e = 0, t = this._referencePoints.length; e < t; e++) this._setupPoint(e)
                    }, _setupPoint: function (e) {
                        var t = this._referencePoints[e], i = this._getPointListeningParams(t, n.getPointType(t));
                        i && i.target.events.add(i.eventName, this._onPointChange, this)
                    }, _clearPoints: function () {
                        for (var e = 0, t = this._referencePoints.length; e < t; e++) this._clearPoint(e)
                    }, _clearPoint: function (e) {
                        var t = this._referencePoints[e], i = this._getPointListeningParams(t, n.getPointType(t));
                        i && i.target.events.remove(i.eventName, this._onPointChange, this)
                    }, _calcRequests: function () {
                        this._requests = [];
                        for (var e = 0, t = this._referencePoints.length; e < t; e++) this._calcRequest(e)
                    }, _calcRequest: function (e) {
                        this._requests[e] = n.getPointRequest(this._referencePoints[e])
                    }, _getPointListeningParams: function (e, t) {
                        var n = null;
                        return "geometry" == t ? n = {
                            target: e,
                            eventName: "change"
                        } : "geoObject" == t && (n = {target: e.geometry, eventName: "change"}), n
                    }, _onPointChange: function (e) {
                        this._callChangeCallback()
                    }, _callChangeCallback: function () {
                        this._changeCallback.callback.call(this._changeCallback.context)
                    }
                }), e(i)
            });
        }],
        ['84', function (ym) {
            ym.modules.define("multiRoute.model.component.RequestQueue", ["util.defineClass", "util.id", "util.cancelableCallback"], function (e, t, s, i) {
                function a(e, t, s) {
                    this._requestCallback = e, this._cancelCallback = t, this._context = s, this._requests = []
                }

                t(a, {
                    push: function (e, t, a, c) {
                        var l = s.gen(), n = i.create(function () {
                            this._finalizeRequest(l), t.apply(c, arguments)
                        }, this), u = i.create(function () {
                            this._finalizeRequest(l), a.apply(c, arguments)
                        }, this);
                        this._requestCallback.call(this._context, e, n, u), this._requests.push({
                            id: l,
                            requestData: e,
                            successHandler: n,
                            errorHandler: u
                        })
                    }, clear: function () {
                        for (var e = 0, t = this._requests.length; e < t; e++) this._cancelRequest(this._requests[e]);
                        this._requests = []
                    }, _finalizeRequest: function (e) {
                        for (var t = 0, s = 0, i = this._requests.length; s < i; s++) {
                            var a = this._requests[s];
                            if (t++, a.id == e) break;
                            this._cancelRequest(a)
                        }
                        this._requests.splice(0, t)
                    }, _cancelRequest: function (e) {
                        e.successHandler.cancel(), e.errorHandler.cancel(), this._cancelCallback.call(this._context, e.requestData)
                    }
                }), e(a)
            });
        }],
        ['85', function (ym) {
            ym.modules.define("multiRoute.model.component.RequestSieve", ["util.defineClass"], function (t, i) {
                function e(t, i, e) {
                    this._timeout = t, this._callback = i, this._context = e, this._lastRequest = null, this._timeoutId = NaN, this._bindedTimeoutCallback = this._timeoutCallback.bind(this)
                }

                i(e, {
                    process: function () {
                        this._lastRequest = arguments, this._timeoutId || (this._timeoutId = setTimeout(this._bindedTimeoutCallback, 0))
                    }, setTimeout: function (t) {
                        this._timeout = Math.min(t, 1e10)
                    }, getTimeout: function () {
                        return this._timeout
                    }, stop: function () {
                        this._timeoutId && (clearTimeout(this._timeoutId), this._timeoutId = NaN)
                    }, _timeoutCallback: function () {
                        if (this._timeoutId = NaN, this._lastRequest) {
                            var t = this._lastRequest;
                            this._lastRequest = null, this._timeoutId = setTimeout(this._bindedTimeoutCallback, this._timeout), this._callback.apply(this._context, t)
                        }
                    }
                }), t(e)
            });
        }],
        ['86', function (ym) {
            ym.modules.define("multiRouter.model.component.ServiceController", ["util.defineClass", "util.extend", "util.array", "multiRouter.service", "multiRouter.referencePointUtils", "multiRoute.model.common.emptyJson", "multiRouter.model.component.ReferencePointManager", "multiRoute.model.component.RequestSieve", "multiRoute.model.component.RequestQueue", "multiRouter.model.component.EmptyPointController", "vow", "util.coordinates.convert", "yandex.taxi.fetchRouteInfo", "yandex.taxi.constructLink", "yandex.taxi.helper"], function (e, t, s, n, i, r, o, a, c, u, l, h, _, f, d, p) {
                function v(e, t, n) {
                    this._referencePointManager = new a(e, {
                        callback: this._referencePointsChangeCallback,
                        context: this
                    }), this._params = s({}, R, t), this._callbacks = n, this._serviceMode = this._params.serviceMode, this._oldRequest = this._createActualRequest(), this._referencePointIndexes = null;
                    var i = this._params.requestSendInterval;
                    i = "auto" == i ? g : i, "manual" === this._serviceMode ? this._serviceRequestSieve = {
                        process: function () {
                        }, setTimeout: function () {
                        }, getTimeout: function () {
                            return 0
                        }, stop: function () {
                        }
                    } : this._serviceRequestSieve = new c(i, this._sendRequestCallback, this), this._serviceRequestQueue = new u(this._makeRequestCallback, this._cancelRequestCallback, this), this._emptyPointController = new l({
                        points: [],
                        params: {}
                    }, o), this._prevSnap = this._params.snap, this._fireWayPointsChange = !1, this._fireViaPointsChange = !1, this._fireRoutesChange = !1, this._initFlag = !1, this._oldRequest.points.length && (this._initFlag = !0, this._serviceRequestSieve.process())
                }

                function m(e) {
                    var t = e.properties.waypoints;
                    if (t && t.length > 1) {
                        var s = _(t[0].coordinates, "longlat", ym.env.coordinatesOrder),
                            n = _(t[1].coordinates, "longlat", ym.env.coordinatesOrder);
                        return f(s, n).then(function (t) {
                            var i = p.getCheapestOption(t);
                            return i ? (e.properties.taxi = {
                                routeInfo: t,
                                cheapest: i,
                                link: d(s, n)
                            }, e) : (e.features[2].features = [], e)
                        })["catch"](function (e) {
                            return h.reject("error-taxi-request")
                        })
                    }
                    return h.resolve(e)
                }

                var R = {
                    reverseGeocoding: !1,
                    routingMode: "auto",
                    serviceMode: "auto",
                    viaIndexes: [],
                    avoidTrafficJams: !1,
                    results: 3,
                    searchCoordOrder: ym.env.coordinatesOrder,
                    boundedBy: null,
                    strictBounds: !1,
                    requestSendInterval: "auto"
                }, g = 333;
                t(v, {
                    getServiceMode: function () {
                        return this._serviceMode
                    }, setReferencePoints: function (e, t, s) {
                        "undefined" != typeof t && (this._params.viaIndexes = t), s && (this._serviceRequestQueue.clear(), this._serviceRequestSieve.stop()), this._referencePointManager.setPoints(e)
                    }, setReferencePoint: function (e, t) {
                        this._referencePointManager.setPoint(e, t)
                    }, getReferencePoints: function () {
                        return this._referencePointManager.getPoints()
                    }, getReferencePointIndexes: function () {
                        return this._referencePointIndexes || (this._referencePointIndexes = this._calcReferencePointIndexes())
                    }, setParams: function (e, t, n) {
                        this._params = t ? s({}, this._params, e) : s({}, R, e), this._referencePointIndexes = null;
                        var i = this._params.requestSendInterval;
                        this._serviceRequestSieve.setTimeout("auto" == i ? g : i), (n || this._params.snap != this._prevSnap) && (this._serviceRequestQueue.clear(), this._serviceRequestSieve.stop()), this._serviceRequestSieve.process(), this._requestChangeCallback()
                    }, getParams: function () {
                        return this._params
                    }, destroy: function () {
                        this._serviceRequestQueue.clear(), this._serviceRequestSieve.stop()
                    }, _referencePointsChangeCallback: function () {
                        this._referencePointIndexes = null, this._serviceRequestSieve.process(), this._requestChangeCallback()
                    }, _calcReferencePointIndexes: function () {
                        for (var e = [], t = [], s = 0, i = this._referencePointManager.getPoints().length; s < i; s++) {
                            var r = n.indexOf(this._params.viaIndexes, s) == -1 ? e : t;
                            r.push(s)
                        }
                        return {way: e, via: t}
                    }, _requestChangeCallback: function () {
                        var e = this._oldRequest, t = this._createActualRequest();
                        this._oldRequest = t, this._callbacks.onRequestChange && this._callbacks.onRequestChange(e, t)
                    }, _createActualRequest: function () {
                        return {
                            referencePoints: this._referencePointManager.getPoints(),
                            points: this._referencePointManager.getRequests(),
                            params: s({}, this._params)
                        }
                    }, _sendRequestCallback: function () {
                        var e = this._params.snap, t = "auto" == this._params.routingMode, s = this._initFlag,
                            n = +new Date, i = this._createActualRequest();
                        this._prevSnap = e, this._initFlag = !1, this._serviceRequestQueue.push(i, function (i) {
                            "auto" == this._params.requestSendInterval && this._serviceRequestSieve.setTimeout((this._serviceRequestSieve.getTimeout() + (+new Date - n)) / 2), this._successRequestCallback(i, "rough" == e, s, t)
                        }, this._failRequestCallback, this), this._callbacks.onRequestSend && this._callbacks.onRequestSend(i)
                    }, _makeRequestCallback: function (e, t, s) {
                        var n, r = this._emptyPointController.filterRequest(e),
                            o = this._emptyPointController.getJsonCache(r), a = r != e;
                        o ? (a && (o = this._emptyPointController.completeJson(o, e)), n = h.resolve(o)) : (n = i.route(r.points, r.params), a && (n = n.then(function (t) {
                            return this._emptyPointController.setJsonCache(t, r), this._emptyPointController.completeJson(t, e)
                        }, this))), this._callbacks.onRequestLoading && (n = this._callbacks.onRequestLoading(n)), "taxi" == this._params.routingMode && (n = n.then(m)), n.done(t, s)
                    }, _cancelRequestCallback: function (e) {
                        this._callbacks.onRequestCancel && this._callbacks.onRequestCancel(e)
                    }, _successRequestCallback: function (e, t, s, n) {
                        e = this._fixConsistency(e, n), this._callbacks.onRequestSuccess && this._callbacks.onRequestSuccess(e, t, s)
                    }, _failRequestCallback: function (e) {
                        this._callbacks.onRequestFail && this._callbacks.onRequestFail(e)
                    }, _coordMakers: {
                        "null": function () {
                            return null
                        }, string: function () {
                            return null
                        }, coords: function (e) {
                            return e
                        }, geometry: function (e) {
                            return e.getCoordinates()
                        }, geoObject: function (e) {
                            return e.geometry.getCoordinates()
                        }
                    }, _fixConsistency: function (e, t) {
                        var s = this.getReferencePointIndexes().via, n = e.features[1].features;
                        if (s.length && !n.length && t) for (var i = 0, o = s.length; i < o; i++) {
                            var a = s[i], c = this._referencePointManager.getPoints()[a], u = r.getPointType(c);
                            n.push({
                                type: "Feature",
                                properties: {index: i, request: r.getPointRequest(c)},
                                geometry: {type: "Point", coordinates: this._coordMakers[u](c)}
                            })
                        }
                        return e
                    }
                }), e(v)
            });
        }],
        ['90', function (ym) {
            ym.modules.define("ObjectManager", ["util.defineClass", "BaseObjectManager", "event.Manager", "objectManager.ObjectCollection", "objectManager.ClusterCollection", "objectManager.component.View", "component.child.MapChild", "objectManager.component.ObjectControllerAddon", "util.extend", "Event", "yandex.counter"], function (e, t, n, o, s, r, i, a, l, c, d, h) {
                var u = function (e) {
                    this.events = new o({context: this}), this._mapChildComponent = new a({
                        onMapChange: {
                            callback: this._onMapChange,
                            context: this
                        }, onParentChange: {callback: this._onParentChange, context: this}
                    }), this._objectsEditingEventManager = new o, this._clustersEditingEventManager = new o, this.objects = new s(this, this._objectsEditingEventManager), this.clusters = new r(this, this._clustersEditingEventManager), u.superclass.constructor.call(this, e, {
                        objects: this.objects,
                        clusters: this.clusters,
                        events: this.events,
                        addDisplayedObjects: {callback: this._addObjects, context: this},
                        removeDisplayedObjects: {callback: this._removeObjects, context: this},
                        removeAll: {callback: this._removeAllObjects, context: this}
                    }), this._objectControllerAddon = new l(this), this._view = null, h.countByKey("modulesUsage", "objectManager.create")
                };
                t(u, n, {
                    getMap: function () {
                        return this._mapChildComponent.getMap()
                    }, getParent: function () {
                        return this._mapChildComponent.getParent()
                    }, setParent: function (e) {
                        return this._mapChildComponent.setParent(e), this
                    }, add: function (e) {
                        return this.objects.add(e), this
                    }, remove: function (e) {
                        return this.objects.remove(e), this
                    }, removeAll: function () {
                        return this.objects.removeAll(), this
                    }, onAddToMap: function (e) {
                        this._setupView(), this._objectControllerAddon.setMap(e), this._objectControllerAddon.events.add("statechange", this._onObjectControllerStateChange, this).add("pixelboundschange", this._onObjectControllerBoundsChange, this), u.superclass.onAddToMap.call(this, e)
                    }, onRemoveFromMap: function (e) {
                        u.superclass.onRemoveFromMap.call(this, e), this._objectControllerAddon.events.remove("statechange", this._onObjectControllerStateChange, this).remove("pixelboundschange", this._onObjectControllerBoundsChange, this), this._objectControllerAddon.setMap(null), this._clearView()
                    }, getObjectState: function (e) {
                        var t = u.superclass.getObjectState.call(this, e),
                            n = this._objectControllerAddon.getController(), o = n && n.getObjectState(e);
                        return o && (t = c(t, o)), t
                    }, getBounds: function () {
                        return this._objectControllerAddon.getController() ? this._objectControllerAddon.getController().getBounds() : null
                    }, getPixelBounds: function () {
                        return this._objectControllerAddon.getController() ? this._objectControllerAddon.getController().getPixelBounds() : null
                    }, _setupView: function () {
                        this._view = new i(this, this._objectsEditingEventManager, this._clustersEditingEventManager)
                    }, _clearView: function () {
                        this._view.destroy()
                    }, _onMapChange: function (e, t) {
                        e && this.onRemoveFromMap(e), t && this.onAddToMap(t), this.events.fire("mapchange", {
                            oldMap: e,
                            newMap: t
                        })
                    }, _onParentChange: function (e, t) {
                        t && this.options.setParent(t.options), t || this.options.setParent(null), this.events.fire("parentchange", {
                            oldParent: e,
                            newParent: t
                        })
                    }, _addObjects: function (e) {
                        this._objectControllerAddon.getController().add(e)
                    }, _removeObjects: function (e) {
                        this._objectControllerAddon.getController().remove(e)
                    }, _removeAllObjects: function () {
                        this._objectControllerAddon.getController().removeAll()
                    }, _onObjectControllerStateChange: function (e) {
                        var t = e.get("removedClusters"), n = e.get("addedClusters");
                        t && t.length && this._clustersEditingEventManager.fire("remove", new d({
                            target: this,
                            type: "remove",
                            clusters: t
                        })), n && n.length && this._clustersEditingEventManager.fire("add", new d({
                            target: this,
                            type: "add",
                            clusters: n
                        })), this._fireStateChange({
                            added: e.get("added"),
                            removed: e.get("removed"),
                            addedClusters: e.get("addedClusters"),
                            removedClusters: e.get("removedClusters"),
                            update: e.get("update"),
                            sync: e.get("sync")
                        })
                    }, _onObjectControllerBoundsChange: function () {
                        this.events.fire("pixelboundschange")
                    }, _fireStateChange: function (e) {
                        this.events.fire("statechange", {
                            added: e.added || [],
                            removed: e.removed || [],
                            addedClusters: e.addedClusters || [],
                            removedClusters: e.removedClusters || [],
                            update: e.update || [],
                            sync: e.sync
                        })
                    }
                }), e(u)
            });
        }],
        ['91', function (ym) {
            ym.modules.define("RemoteObjectManager", ["util.defineClass", "event.Manager", "BaseObjectManager", "objectManager.component.ReloadOnZoomChangeController", "objectManager.component.View", "objectManager.ObjectCollection", "objectManager.ClusterCollection", "component.child.MapChild", "objectManager.component.ObjectControllerAddon", "objectManager.component.TileSource", "Event", "objectManager.component.Filter", "util.extend", "yandex.counter"], function (t, e, s, n, r, o, l, i, a, d, c, u, h, _, g) {
                var C = function (t, e) {
                    this.events = new s({context: this}), this._mapChildComponent = new a({
                        onMapChange: {
                            callback: this._onMapChange,
                            context: this
                        }, onParentChange: {callback: this._onParentChange, context: this}
                    }), this._objectsEditingEventManager = new s, this._clustersEditingEventManager = new s, this.objects = new l(this, this._objectsEditingEventManager), this.clusters = new i(this, this._clustersEditingEventManager), this._tileSource = new c(this), C.superclass.constructor.call(this, e, {
                        objects: this.objects,
                        clusters: this.clusters,
                        events: this.events,
                        addDisplayedObjects: {callback: this._addObjects, context: this},
                        removeDisplayedObjects: {callback: this._removeObjects, context: this},
                        removeAll: {callback: this._removeAllObjects, context: this}
                    }), this._view = null, this._dataLoadController = null, this._dataLoadControllerListener = null, this._urlTemplate = t, this._objectControllerAddon = new d(this, {clusteringDisabled: !0}), this._clusterFilter = null, g.countByKey("modulesUsage", "remoteObjectManager.create")
                };
                e(C, n, {
                    setUrlTemplate: function (t) {
                        this._urlTemplate = t
                    }, getUrlTemplate: function () {
                        return this._urlTemplate
                    }, getTileUrl: function (t) {
                        return this._tileSource.getTileUrl(t)
                    }, getPadding: function (t) {
                        return this._tileSource.getPadding(t)
                    }, getMap: function () {
                        return this._mapChildComponent.getMap()
                    }, getParent: function () {
                        return this._mapChildComponent.getParent()
                    }, setParent: function (t) {
                        return this._mapChildComponent.setParent(t), this
                    }, onAddToMap: function (t) {
                        this._startClusterCollectionListening(), this._objectControllerAddon.setMap(t), this._objectControllerAddon.events.add("statechange", this._onObjectControllerStateChange, this), this._setupView(), this._setupDataLoadController(), C.superclass.onAddToMap.call(this, t)
                    }, onRemoveFromMap: function (t) {
                        C.superclass.onRemoveFromMap.call(this, t), this._clearDataLoadController(), this._clearView(), this._objectControllerAddon.events.remove("statechange", this._onObjectControllerStateChange, this), this._objectControllerAddon.setMap(null), this._stopClusterCollectionListening()
                    }, setFilter: function (t) {
                        t != this._clusterFilterFunction && (this._clusterFilter && this._clearClusterFilter(), this._clusterFilterFunction = t, t && this._setupClusterFilter()), C.superclass.setFilter.call(this, t)
                    }, getFilter: function () {
                        return C.superclass.getFilter.call(this)
                    }, getBounds: function () {
                        return this._dataLoadController && (this.objects.getLength() || this.clusters.getLength()) ? this._dataLoadController.getBounds() : null
                    }, getPixelBounds: function () {
                        return this._dataLoadController ? this._dataLoadController.getPixelBounds() : null
                    }, getObjectState: function (t) {
                        var e = C.superclass.getObjectState.call(this, t),
                            s = this._objectControllerAddon.getController(), n = s && s.getObjectState(t);
                        return n && (e = _(e, n)), e
                    }, reloadData: function () {
                        this._dataLoadController && this._dataLoadController.reloadData()
                    }, _setupDataLoadController: function () {
                        this._dataLoadController = new r(this), this._dataLoadControllerListener = this._dataLoadController.events.group().add("statechange", this._onDataLoadControllerStateChange, this).add("pixelboundschange", this._onDataLoadControllerBoundsChange, this).add("error", this._onDataLoadControllerError, this)
                    }, _clearDataLoadController: function () {
                        this._dataLoadControllerListener.removeAll(), this._dataLoadController.destroy()
                    }, _startClusterCollectionListening: function () {
                        this._clusterCollectionListener = this.clusters.events.group().add("clustersadd", this._onClustersAdd, this).add("clustersremove", this._onClustersRemove, this)
                    }, _onClustersAdd: function (t) {
                        var e = t.get("clusters"), s = [];
                        if (this._clusterFilter && this._clusterFilter.add(e), this._clusterFilter) for (var n = 0, r = e.length; n < r; n++) this._clusterFilter.isFilteredOut(e[n]) || s.push(e[n]); else s = e;
                        this._addDisplayedClusters(s)
                    }, _onClustersRemove: function (t) {
                        var e = t.get("clusters"), s = [];
                        if (this._clusterFilter) for (var n = 0, r = e.length; n < r; n++) this._clusterFilter.isFilteredOut(e[n]) || s.push(e[n]); else s = e;
                        this._clusterFilter && this._clusterFilter.remove(e), this._removeDisplayedClusters(s)
                    }, _stopClusterCollectionListening: function () {
                        this._clusterCollectionListener.removeAll()
                    }, _onDataLoadControllerStateChange: function (t) {
                        var e = t.get("removed"), s = t.get("added");
                        e && e.length && this._removeExpiredObjects(e), s && s.length && this._addLoadedObjects(s)
                    }, _onDataLoadControllerBoundsChange: function () {
                        this.events.fire("pixelboundschange")
                    }, _onDataLoadControllerError: function (t) {
                        this.events.fire("dataloaderror", t)
                    }, _setupView: function () {
                        this._view = new o(this, this._objectsEditingEventManager, this._clustersEditingEventManager)
                    }, _clearView: function () {
                        this._fireStateChange({
                            removed: this.objects.getAll(),
                            removedClusters: this.clusters.getAll()
                        }), this._view.destroy()
                    }, _removeExpiredObjects: function (t) {
                        var e = this._getClustersAndFeatures(t);
                        this.objects.remove(e.features), this._clustersEditingEventManager.fire("remove", new u({
                            target: this,
                            type: "remove",
                            clusters: e.clusters
                        }))
                    }, _addLoadedObjects: function (t) {
                        var e = this._getClustersAndFeatures(t);
                        this.objects.add(e.features), this._clustersEditingEventManager.fire("add", new u({
                            target: this,
                            type: "add",
                            clusters: e.clusters
                        }))
                    }, _getClustersAndFeatures: function (t) {
                        for (var e = [], s = [], n = 0, r = t.length; n < r; n++) "Feature" == t[n].type ? s.push(t[n]) : "Cluster" == t[n].type && e.push(t[n]);
                        return {clusters: e, features: s}
                    }, _fireStateChange: function (t) {
                        this.events.fire("statechange", {
                            added: t.added || [],
                            removed: t.removed || [],
                            addedClusters: t.addedClusters || [],
                            removedClusters: t.removedClusters || [],
                            update: t.update || [],
                            sync: t.sync
                        })
                    }, _onMapChange: function (t, e) {
                        t && this.onRemoveFromMap(t), e && this.onAddToMap(e), this.events.fire("mapchange", {
                            oldMap: t,
                            newMap: e
                        })
                    }, _onParentChange: function (t, e) {
                        e && this.options.setParent(e.options), this.events.fire("parentchange", {
                            oldParent: t,
                            newParent: e
                        }), e || this.options.setParent(null)
                    }, _addObjects: function (t) {
                        this._objectControllerAddon.getController().add(t)
                    }, _removeObjects: function (t) {
                        this._objectControllerAddon.getController().remove(t)
                    }, _removeAllObjects: function () {
                        this._objectControllerAddon.getController().removeAll()
                    }, _onObjectControllerStateChange: function (t) {
                        this._fireStateChange({
                            added: t.get("added"),
                            removed: t.get("removed"),
                            addedClusters: t.get("addedClusters"),
                            removedClusters: t.get("removedClusters"),
                            update: t.get("update"),
                            sync: t.get("sync")
                        })
                    }, _setupClusterFilter: function () {
                        this._clusterFilter = new h(this._clusterFilterFunction), this._clusterFilter.add(this.clusters.getAll()), this.getMap() && this._removeDisplayedClusters(this._clusterFilter.getFilteredObjects())
                    }, _clearClusterFilter: function () {
                        this.getMap() && this._addDisplayedClusters(this._clusterFilter.getFilteredObjects()), this._clusterFilter.destroy(), this._clusterFilter = null
                    }, _addDisplayedClusters: function (t) {
                        this._objectControllerAddon.getController().add(t)
                    }, _removeDisplayedClusters: function (t) {
                        this._objectControllerAddon.getController().remove(t)
                    }
                }), t(C)
            });
        }],
        ['92', function (ym) {
            ym.modules.define("objectManager.ClusterCollection", ["util.defineClass", "ReadOnlyCollection", "objectManager.OverlayCollection", "objectManager.clusterCollection.optionMapper", "objectManager.clusterCollection.overlayOptionMapper", "event.Manager", "event.Mapper", "Event", "objectManager.OverlayMappingTable", "option.Manager", "data.Manager", "event.globalize", "util.extend", "theme.islands.cluster.metaOptions"], function (e, t, s, n, r, i, o, a, l, d, v, h, c, g) {
                var u = function (e, t) {
                    this._clusterEditingEventManager = new o, u.superclass.constructor.call(this, this._clusterEditingEventManager), this._objectManager = e, this.options.setMapper(r), this.options.setName("clusterCollection"), this.options.events.add("change", function () {
                        this.events.fire("optionschange")
                    }, this), this.events.addController(y), this.state = new h, this._clustersById = {}, this._overlayEditingEventManager = new o, this.overlays = new n(this._overlayEditingEventManager), this.overlays.options.setMapper(i), this.overlays.options.setParent(this.options), this.overlays.events.setParent(new a(this.events, new d(this))), this._editingEventManager = t, this._editingEventManager.add("add", this._onClustersAdd, this).add("remove", this._onClustersRemove, this).add("removeall", this._onClustersRemoveAll, this).add("addoverlay", this._onOverlayAdd, this).add("removeoverlay", this._onOverlayRemove, this).add("removealloverlays", this._onOverlayRemoveAll, this), this.events.fire("create")
                }, y = c(u);
                t(u, s, {
                    getById: function (e) {
                        return this._clustersById[e] || null
                    }, getObjectManager: function () {
                        return this._objectManager
                    }, setClusterOptions: function (e, t) {
                        var s = this.getById(e);
                        return s && (s.options = s.options ? g(s.options, t) : t, this.events.fire("clusteroptionschange", {objectId: e})), this
                    }, setClusterProperties: function (e, t) {
                        var s = this.getById(e);
                        s && (s.properties = s.properties ? g(s.properties, t) : t, this.events.fire("clusterpropertieschange", {objectId: e}))
                    }, onChildAdd: function (e) {
                        var t = new l({type: "add", target: this, child: e, objectId: e.id});
                        this.events.fire("add", t)
                    }, onChildRemove: function (e) {
                        var t = new l({type: "remove", target: this, child: e, objectId: e.id});
                        this.events.fire("remove", t)
                    }, _onClustersAdd: function (e) {
                        for (var t = e.get("clusters"), s = 0, n = t.length; s < n; s++) this._clustersById[t[s].id] = t[s], this._clusterEditingEventManager.fire("add", new l({
                            type: "add",
                            target: this,
                            object: t[s]
                        }));
                        this.events.fire("clustersadd", new l({clusters: t, target: this, type: "clustersadd"}))
                    }, _onClustersRemove: function (e) {
                        for (var t = e.get("clusters"), s = this._getIdsArray(t), n = this._getAddedObjectsById(s), r = 0, i = n.length; r < i; r++) delete this._clustersById[n[r].id], this._clusterEditingEventManager.fire("remove", new l({
                            target: this,
                            type: "remove",
                            object: n[r]
                        }));
                        this.events.fire("clustersremove", new l({clusters: n, target: this, type: "clustersremove"}))
                    }, _onClustersRemoveAll: function () {
                        this._clustersById = {}, this._clusterEditingEventManager.fire("removeall")
                    }, _getAddedObjectsById: function (e) {
                        for (var t = [], s = 0, n = e.length; s < n; s++) this._clustersById[e[s]] && t.push(this._clustersById[e[s]]);
                        return t
                    }, _getIdsArray: function (e) {
                        for (var t = [], s = 0, n = e.length; s < n; s++) t.push("undefined" != typeof e[s].id ? e[s].id : e[s]);
                        return t
                    }, _onOverlayAdd: function (e) {
                        this._overlayEditingEventManager.fire("add", new l({
                            type: "add",
                            target: this,
                            overlay: e.get("overlay"),
                            objectId: e.get("objectId")
                        }))
                    }, _onOverlayRemove: function (e) {
                        this._overlayEditingEventManager.fire("remove", new l({
                            type: "remove",
                            target: this,
                            overlay: e.get("overlay"),
                            objectId: e.get("objectId")
                        }))
                    }, _onOverlayRemoveAll: function (e) {
                        this._overlayEditingEventManager.fire("removeall")
                    }
                }), e(u)
            });
        }],
        ['93', function (ym) {
            ym.modules.define("objectManager.clusterCollection.optionMapper", ["option.Mapper"], function (e, o) {
                e(new o)
            });
        }],
        ['94', function (ym) {
            ym.modules.define("objectManager.clusterCollection.overlayOptionMapper", ["option.Mapper"], function (e, l) {
                function r(e, l) {
                    return l + e.slice(0, 1).toUpperCase() + e.slice(1)
                }

                var n = new l;
                n.setRule({
                    name: "overlay.html.Placemark", rule: function (e, l) {
                        return [r(e, "clusterIcon"), r(e, "cluster"), r(e, "icon")]
                    }
                }), n.setRule({
                    name: "overlay.Placemark", rule: function (e, l) {
                        return [r(e, "clusterIcon"), r(e, "cluster"), r(e, "icon")]
                    }
                }), n.setRule({
                    name: "overlay.html.Placemark",
                    key: "projection",
                    rule: "plain"
                }), n.setRule({name: "overlay.Placemark", key: "projection", rule: "plain"}), e(n)
            });
        }],
        ['95', function (ym) {
            ym.modules.define("objectManager.ObjectCollection", ["util.defineClass", "component.collection.BaseCollection", "objectManager.OverlayCollection", "objectManager.objectCollection.optionMapper", "objectManager.parseData", "event.Manager", "event.Mapper", "objectManager.OverlayMappingTable", "Event", "option.Manager", "event.globalize", "util.extend"], function (e, t, n, o, i, s, r, a, c, h, d, l, v) {
                var g = function (e, t) {
                    this._objectManager = e, this.events = new r({context: this}), this.events.addController(p), this.options = new d, this.options.events.add("change", function () {
                        this.events.fire("optionschange")
                    }, this), this.options.setMapper(i), this.options.setName("objectCollection"), this._collectionComponent = new n({
                        onAdd: {
                            callback: this._onAdd,
                            context: this
                        }, onRemove: {callback: this._onRemove, context: this}
                    }), this._objectsById = {}, this._overlayEditingEventManager = new r, this.overlays = new o(this._overlayEditingEventManager), this.overlays.options.setParent(this.options), this.overlays.events.setParent(new a(this.events, new c(this))), this._editingEventManager = t, this._editingEventManager.add("addoverlay", this._onOverlayAdd, this).add("removeoverlay", this._onOverlayRemove, this).add("removealloverlays", this._onOverlayRemoveAll, this), this.events.fire("create")
                }, p = l(g);
                t(g, {
                    getObjectManager: function () {
                        return this._objectManager
                    }, add: function (e) {
                        var t = s(e);
                        return t = this._getNewObjects(t), this._addObjects(t), this
                    }, remove: function (e) {
                        var t = this._getIdsArray(e), n = this._getAddedObjectsById(t);
                        return this._removeObjects(n), this
                    }, removeAll: function () {
                        var e = this.getAll();
                        return this._objectsById = {}, this._collectionComponent.removeAll(), this.events.fire("objectsremove", new h({
                            type: "objectsremove",
                            target: this,
                            objects: e
                        })), this
                    }, getById: function (e) {
                        return this._objectsById[e] || null
                    }, getLength: function () {
                        return this._collectionComponent.getLength()
                    }, getIterator: function () {
                        return this._collectionComponent.getIterator()
                    }, each: function (e, t) {
                        this._collectionComponent.each(e, t)
                    }, getAll: function () {
                        for (var e, t = this.getIterator(), n = []; (e = t.getNext()) != t.STOP_ITERATION;) n.push(e);
                        return n
                    }, setObjectOptions: function (e, t) {
                        var n = this.getById(e);
                        return n && (n.options = n.options ? v(n.options, t) : t, this.events.fire("objectoptionschange", {objectId: e})), this
                    }, setObjectProperties: function (e, t) {
                        var n = this.getById(e);
                        n && (n.properties = n.properties ? v(n.properties, t) : t, this.events.fire("objectpropertieschange", {objectId: e}))
                    }, _getNewObjects: function (e) {
                        for (var t = [], n = 0, o = e.length; n < o; n++) this.getById(e[n].id) || t.push(e[n]);
                        return t
                    }, _addObjects: function (e) {
                        for (var t = 0, n = e.length; t < n; t++) this._objectsById[e[t].id] = e[t], this._collectionComponent.add(e[t]);
                        this.events.fire("objectsadd", new h({type: "objectsadd", target: this, objects: e}))
                    }, _removeObjects: function (e) {
                        for (var t = 0, n = e.length; t < n; t++) delete this._objectsById[e[t].id], this._collectionComponent.remove(e[t]);
                        this.events.fire("objectsremove", new h({type: "objectsremove", target: this, objects: e}))
                    }, _getIdsArray: function (e) {
                        for (var t = s(e), n = [], o = 0, i = t.length; o < i; o++) "undefined" != typeof t[o].id ? n.push(t[o].id) : n.push(t[o]);
                        return n
                    }, _getAddedObjectsById: function (e) {
                        for (var t = [], n = 0, o = e.length; n < o; n++) e[n] in this._objectsById && t.push(this._objectsById[e[n]]);
                        return t
                    }, _onAdd: function (e) {
                        this.events.fire("add", new h({type: "add", target: this, child: e, objectId: e.id}))
                    }, _onRemove: function (e) {
                        this.events.fire("remove", new h({type: "remove", target: this, child: e, objectId: e.id}))
                    }, _onOverlayAdd: function (e) {
                        this._overlayEditingEventManager.fire("add", new h({
                            type: "add",
                            target: this,
                            overlay: e.get("overlay"),
                            objectId: e.get("objectId")
                        }))
                    }, _onOverlayRemove: function (e) {
                        this._overlayEditingEventManager.fire("remove", new h({
                            type: "remove",
                            target: this,
                            overlay: e.get("overlay"),
                            objectId: e.get("objectId")
                        }))
                    }, _onOverlayRemoveAll: function (e) {
                        this._overlayEditingEventManager.fire("removeall")
                    }
                }), e(g)
            });
        }],
        ['96', function (ym) {
            ym.modules.define("objectManager.objectCollection.optionMapper", ["option.Mapper"], function (e, o) {
                e(new o)
            });
        }],
        ['97', function (ym) {
            ym.modules.define("objectManager.objectCollection.overlayOptionMapper", ["option.Mapper"], function (e, o) {
                e(new o)
            });
        }],
        ['98', function (ym) {
            ym.modules.define("objectManager.OverlayMappingTable", ["util.defineClass", "Event"], function (n, t, e) {
                var i = function (n) {
                    this._context = n, this["*"] = this._defaultMappingFunction, this.add = this._addMappingFunction, this.remove = this._removeMappingFunction
                };
                t(i, {
                    _defaultMappingFunction: function (n) {
                        return new e({currentTarget: this._context}, n)
                    }, _addMappingFunction: function (n) {
                        return new e({type: "overlayadd", currentTarget: this._context}, n)
                    }, _removeMappingFunction: function (n) {
                        return new e({type: "overlayremove", currentTarget: this._context}, n)
                    }
                }), n(i)
            });
        }],
        ['99', function (ym) {
            ym.modules.define("objectManager.OverlayCollection", ["util.defineClass", "ReadOnlyCollection", "event.Manager", "Event", "option.Manager", "util.id", "constants.mapDomEvents", "objectManager.objectCollection.overlayOptionMapper", "geoObject.view.overlayMapping"], function (e, t, i, n, a, o, r, s, l, d) {
                for (var g = {}, v = 0, y = s.length; v < y; v++) g[s[v]] = !0;
                var h = function (e) {
                    this._overlayEditingEventManager = new n, h.superclass.constructor.call(this, this._overlayEditingEventManager), this.options.setMapper(l), this._overlaysById = {}, this._idsByOverlay = {}, this._controller = {onAfterEventFiring: this._onAfterObjectEventFiring.bind(this)}, this._editingEventManager = e, this._editingEventManager.add("add", this._onEditingManagerAddRequest, this).add("remove", this._onEditingManagerRemoveRequest, this).add("removeall", this._onEditingManagerRemoveAllRequest, this), this._mappingByOverlayName = {}
                };
                t(h, i, {
                    getById: function (e) {
                        return this._overlaysById[e] || null
                    }, getId: function (e) {
                        var t = this._idsByOverlay[r.get(e)];
                        return "undefined" == typeof t ? null : t
                    }, onChildAdd: function (e) {
                        this._mappingByOverlayName[e.options.getName()] || (this._mappingByOverlayName[e.options.getName()] = !0, d.setupMapping(l, e.options.getName(), e.getGeometry().getType())), e.events.addController(this._controller), this.events.fire("add", new a({
                            type: "add",
                            target: this,
                            overlay: e,
                            objectId: this.getId(e)
                        }))
                    }, onChildRemove: function (e) {
                        var t = this.getId(e), i = r.get(e);
                        e.events.removeController(this._controller), delete this._overlaysById[t], delete this._idsByOverlay[i], this.events.fire("remove", new a({
                            type: "remove",
                            target: this,
                            overlay: e,
                            objectId: t
                        }))
                    }, _onEditingManagerAddRequest: function (e) {
                        var t = e.get("overlay"), i = e.get("objectId");
                        this._idsByOverlay[r.get(t)] = i, this._overlaysById[i] = t, this._overlayEditingEventManager.fire("add", new a({
                            type: "add",
                            target: this,
                            object: t
                        }))
                    }, _onEditingManagerRemoveRequest: function (e) {
                        var t = e.get("overlay");
                        this._overlayEditingEventManager.fire("remove", new a({
                            type: "remove",
                            target: this,
                            object: t
                        }))
                    }, _onEditingManagerRemoveAllRequest: function () {
                        this._overlaysById = {}, this._idsByOverlay = {}, this._overlayEditingEventManager.fire("removeAll")
                    }, _onAfterObjectEventFiring: function (e, t, i) {
                        if (t in g && !i.isImmediatePropagationStopped()) {
                            var n = i.get("target");
                            this.events.fire(t, {
                                objectId: this.getId(n),
                                overlay: n,
                                pagePixels: i.get("pagePixels"),
                                clientPixels: i.get("clientPixels"),
                                globalPixels: i.get("globalPixels"),
                                coords: i.get("coords"),
                                domEvent: i.get("domEvent")
                            })
                        }
                    }
                }), e(h)
            });
        }],
        ['$*', function (ym) {
            ym.modules.define("package.system", ["vow", "theme.browser.current", "system.settings"], function (e) {
                e(!0)
            });
        }],
        [',!', function (ym) {
            ym.modules.define("vow", [], function (o) {
                o(ym.vow)
            });
        }],
        ['.O', function (ym) {
            ym.modules.define("theme.browser.current", function (e) {
                var r = e.env.browser, o = r.eventMapper, t = r.engine.toLowerCase(), n = {
                    webkit: "theme.browser.webkit",
                    blink: "theme.browser.webkit",
                    trident: "theme.browser.trident",
                    edge: "theme.browser.edge",
                    presto: "theme.browser.presto",
                    gecko: "theme.browser.gecko"
                }, i = ["util.extend", "map.metaOptions", "domEvent.override.common", "mapEvent.override.common"];
                return "pointer" == o ? i.push("domEvent.managerOverrides.pointers", "domEvent.multiPointer.override", "domEvent.pointer.override") : i.push("domEvent.managerOverrides.touches", "domEvent.multiTouch.override", "domEvent.touch.override"), t in n ? i.push(n[t]) : i.push("theme.browser.unknown"), i
            }, function (e, r, o) {
                for (var t = Array.prototype.slice.call(arguments, 5), n = {}, i = 0, m = t.length; i < m; i++) r(n, t[i]);
                o.set(n), e({})
            });
        }],
        ['.C', function (ym) {
            ym.modules.define("system.settings", [], function (e) {
                e({lang: ym.env.lang, coordOrder: ym.env.coordinatesOrder})
            });
        }],
        [')4', function (ym) {
            ym.modules.define("util.extend", function (e) {
                e(ym.utils.extend)
            });
        }],
        ['7q', function (ym) {
            ym.modules.define("map.metaOptions", ["option.Manager", "option.Mapper", "projection.wgs84Mercator", "meta.internal", "util.math.restrict"], function (e, t, o, n, i, a) {
                function r(e, t, o, n, i) {
                    var r = a((e - t) / (o - t), 0, 1);
                    return n + r * (i - n)
                }

                var p = new o, m = new t({}, null, null, p), u = i.suppressDistribution;
                m.mapper = p, m.set({
                    projection: n,
                    dragInertia: !0,
                    minZoom: 0,
                    maxZoom: 23,
                    dblClickTimeout: 400,
                    touchContextMenuTimeout: 400,
                    pointerContextMenuTimeout: 1e3,
                    avoidFractionalZoom: !0,
                    autoFitToViewport: "ifNull",
                    autoFitToViewportDelay: 200,
                    restrictMapArea: !1,
                    balloonManager: "map#balloon",
                    hintManager: "map#hint",
                    fullscreenZIndex: 1e4,
                    exitFullscreenByEsc: !0,
                    suppressMapOpenBlock: u,
                    extendedLayoutResolver: function (e) {
                        if (e[0] <= 600) return e[1] <= 270 ? {mode: "nomap"} : {
                            mode: "vsplit",
                            mapHeight: r(e[1], 270, 600, 100, 160)
                        };
                        if (e[1] <= 330) return {mode: "hsplit", mapWidth: r(e[0], 600, 800, 200, 330)};
                        var t = 280, o = (e[0] - t) / 2;
                        return {
                            mode: "minimap",
                            mapSize: [a(r(e[0], 600, 800, 200, 330), 0, o), r(e[1], 270, 600, 100, 160)]
                        }
                    }
                }), e(m)
            });
        }],
        ['8s', function (ym) {
            ym.modules.define("mapEvent.override.common", ["mapEvent.overrideStorage"], function (e, o) {
                function r(e) {
                    return e.originalEvent.position ? e.originalEvent.position : t(e, "page")
                }

                function t(e, o) {
                    var r = e.get("domEvent");
                    if (ym.env.debug && !r) throw new Error("MapEvent.getDomEventPixels: Не удалось получить DOM-событие");
                    return [r.get(o + "X"), r.get(o + "Y")]
                }

                o.add("coords", function (e) {
                    var o = e.get("map"), r = e.get("target"), t = (r.options || o.options).get("projection");
                    if (ym.env.debug) {
                        if (!t) throw new Error("MapEvent.coordsOverride: Не удалось получить проекцию");
                        if (!o) throw new Error("MapEvent.coordsOverride: У события нет ссылки на карту")
                    }
                    return t.fromGlobalPixels(e.get("globalPixels"), o.action.getCurrentState().zoom)
                }), ym.env.debug && o.add("coordPosition", function () {
                    throw new Error('MapEvent: Поле "coordPosition" не поддерживается, используйте "coords"')
                }), o.add("globalPixels", function (e) {
                    if (ym.env.debug) {
                        if (!e.get("pagePixels")) throw new Error("MapEvent.globalPixelsOverride: У события нет пиксельных координат");
                        if (!e.get("map")) throw new Error("MapEvent.globalPixelsOverride: У события нет ссылки на карту")
                    }
                    return e.get("map").converter.pageToGlobal(e.get("pagePixels"))
                }), o.add("globalPixelPosition", function () {
                    throw new Error('MapEvent: Поле "globalPixelPosition" не поддерживается, используйте "globalPixels"')
                }), o.add("position", r), o.add("pagePixels", r), o.add("clientPixels", function (e) {
                    return t(e, "client")
                }), e(!0)
            });
        }],
        ['1.', function (ym) {
            ym.modules.define("domEvent.managerOverrides.touches", ["util.data", "domEvent.managerOverrideStorage", "domEvent.TouchMapper"], function (t, e, o, u) {
                for (var a = function (t) {
                    o.add(t, {
                        start: function (e) {
                            c(e, t)
                        }, stop: function (e) {
                            r(e, t)
                        }
                    })
                }, n = ["mouseenter", "mouseleave", "mousemove", "mousedown", "mouseup", "wheel", "click", "dblclick", "contextmenu", "multitouchstart", "multitouchmove", "multitouchend"], c = function (t, o) {
                    var a = t.params, n = a.capture ? "touchDataWithCapture" : "touchData", c = a.htmlElement,
                        r = e.get(c, n);
                    r || (r = {
                        types: {},
                        count: 0,
                        touchMapper: new u(t)
                    }, e.add(c, n, r)), r.types[o] || (r.count || r.touchMapper.start(), r.types[o] = !0, r.count++)
                }, r = function (t, o) {
                    var u = t.params, a = u.capture ? "touchDataWithCapture" : "touchData", n = u.htmlElement,
                        c = e.get(n, a);
                    c && c.types[o] && (delete c.types[o], --c.count || (c.touchMapper.stop(), e.remove(n, a)))
                }, m = 0, p = n.length; m < p; m++) a(n[m]);
                t({})
            });
        }],
        ['1,', function (ym) {
            ym.modules.define("domEvent.multiTouch.override", ["domEvent.multiTouch.overrideStorage", "util.instantCache", "util.id", "util.array"], function (t, e, n, r, a) {
                function i(t) {
                    return function (e) {
                        var n = e.get("touches"), r = 0, i = 0;
                        return n && n.length && (a.each(n, function (e) {
                            r += e[t]
                        }), i += n.length, r /= i), r
                    }
                }

                for (var o = ["pageX", "pageY", "screenX", "screenY", "clientX", "clientY"], u = 0, d = o.length; u < d; u++) e.add(o[u], i(o[u]));
                e.add("position", function (t) {
                    return [t.get("pageX"), t.get("pageY")]
                }), e.add("propagatedData", function (t) {
                    var e = r.get(t.originalEvent), a = n.get(e);
                    return a || n.add(e, a = {}), a
                }), e.add("target", function (t) {
                    return t.get("touches")[0].target
                }), t({})
            });
        }],
        ['1z', function (ym) {
            ym.modules.define("domEvent.touch.override", ["domEvent.touch.overrideStorage", "util.instantCache", "util.id"], function (e, t, n, r) {
                function a(e) {
                    return function (t) {
                        var n = t.get("touches");
                        return n[0][e]
                    }
                }

                for (var o = ["pageX", "pageY", "screenX", "screenY", "clientX", "clientY"], i = 0, d = o.length; i < d; i++) t.add(o[i], a(o[i]));
                t.add("position", function (e) {
                    return [e.get("pageX"), e.get("pageY")]
                }), t.add("propagatedData", function (e) {
                    var t = r.get(e.originalEvent), a = n.get(t);
                    return a || n.add(t, a = {}), a
                }), t.add("target", function (e) {
                    return e.get("touches")[0].target
                }), e({})
            });
        }],
        ['.V', function (ym) {
            ym.modules.define("theme.browser.webkit", function (e) {
                var i = e.env.browser.isMobile || e.env.browser.isTablet,
                    n = "YandexBrowser" == e.env.browser.name && "Windows" == e.env.browser.osFamily;
                return [i || e.env.browser.isSafari || n ? "layer.tileContainer.DomContainer" : "layer.tileContainer.CanvasContainer"]
            }, function (e, i) {
                var n = ym.env.browser, o = n.isMobile || n.isTablet, r = n.osFamily, a = parseFloat(n.osVersion),
                    s = !o, l = "css2";
                "iOS" == r ? l = o ? "css2" : "css3-3d" : "Android" == r && (a >= 4.1 ? l = "css3-3d" : a >= 3 && (l = "css3")), e({
                    avoidFractionalZoom: !o,
                    tilesRoundingMethod: o ? "floor" : "round",
                    layerTilePositionEngine: l,
                    layerTileAnimateOpacity: s,
                    layerTileAnimationDuration: 250,
                    layerTileContainerClass: i,
                    groundPaneViewportMargin: n.isMobile ? 0 : 128,
                    layerLoadTilesInAction: !o
                })
            });
        }],
        ['$b', function (ym) {
            ym.modules.define("option.Manager", ["util.defineClass", "util.extend", "component.child.BaseChild", "option.presetStorage", "event.manager.Base", "Event", "option.manager.Monitor", "option.manager.LocalMonitor"], function (e, t, i, n, s, r, h, a, o) {
                var p = {}, _ = t(function (e, t, i, s) {
                    this._options = e || null, this._originalOptions = Boolean(this._options), this._baseItem = new n(this._parentChangeCallback, this), t && this._baseItem.setParent(t), this._name = i, this._mapper = null, this._cache = {}, this._frozen = !1, this._changed = !1, this._monitor = null, this.setMapper(s), this.events = new r
                }, {
                    setParent: function (e) {
                        return this._baseItem.setParent(e), this
                    }, getParent: function () {
                        return this._baseItem.getParent()
                    }, setName: function (e) {
                        this._name != e && (this._name = e, this._cache = {}, this._fire())
                    }, getName: function () {
                        return this._name
                    }, setMapper: function (e) {
                        this._getMapper() != e && (this._mapper && this._clearMapper(), this._mapper = e ? {
                            mapper: e,
                            active: !1
                        } : null, this.getParent() && (this._mapper && this._setupMapper(), this.events && this._fire()))
                    }, _getMapper: function () {
                        return this._mapper ? this._mapper.mapper : null
                    }, set: function (e, t) {
                        var i = e;
                        "string" == typeof e && (i = {}, i[e] = t);
                        var n = Object.keys(i), s = this._getOptionsForChanging(), r = !1;
                        i.hasOwnProperty("preset") && (this._cache = {});
                        for (var h = 0, a = n.length; h < a; ++h) e = n[h], t = i[e], s[e] !== t && (this._cache[e] = t, s[e] = t, r = !0);
                        return r && this._fire(), this
                    }, get: function (e, t) {
                        if ("preset" == e) return this.getNative(e) || t;
                        var i = this._cache[e];
                        if ("undefined" == typeof i) {
                            var n = this._find(e);
                            i = this._cache[e] = "undefined" == typeof n ? p : n
                        }
                        return i == p ? t : i
                    }, getNative: function (e) {
                        return this._options ? this._options[e] : void 0
                    }, getAll: function () {
                        return this._getOptionsForChanging()
                    }, resolve: function (e, t) {
                        if (this._mapper) {
                            var i, n = this._mapper.mapper.resolve(e, t);
                            if ("string" == typeof n) i = this.get(n); else for (var s = 0, r = n.length; s < r && (i = this.get(n[s]), "undefined" == typeof i); s++) ;
                            return i
                        }
                        return this.get(e)
                    }, unset: function (e) {
                        "string" == typeof e && (e = [e]);
                        for (var t = this._getOptionsForChanging(), i = !0, n = !1, s = 0, r = e.length; s < r; s++) {
                            var h = e[s];
                            t.hasOwnProperty(h) && (i && ("preset" == h ? (this._cache = {}, i = !1) : delete this._cache[h]), delete t[h], n = !0)
                        }
                        return n && this._fire(), this
                    }, unsetAll: function () {
                        return this._cache = {}, this._options = null, this._fire(), this
                    }, freeze: function () {
                        return this._frozen = !0, this
                    }, unfreeze: function () {
                        return this._frozen = !1, this._changed && (this._changed = !1, this._fire()), this
                    }, isFrozen: function () {
                        return this._frozen
                    }, getMonitor: function (e) {
                        var t = this._monitor || (this._monitor = new a(this));
                        return e ? new o(t, e) : t
                    }, _setupMapper: function () {
                        this._mapper.active || (this._mapper.mapper.events.add("rulechange", this._fire, this), this._mapper.active = !0)
                    }, _clearMapper: function () {
                        this._mapper.active && (this._mapper.mapper.events.remove("rulechange", this._fire, this), this._mapper.active = !1)
                    }, _find: function (e) {
                        var t;
                        return this._options && (t = this._options[e], "undefined" == typeof t && "undefined" != typeof this._options.preset && (t = this._resolvePreset(this._options.preset, e))), "undefined" == typeof t && this._parent && (t = this._parent.resolve(e, this._name)), t
                    }, _resolvePreset: function (e, t) {
                        var i;
                        if (e instanceof Array) for (var n = 0; n < e.length && (i = this._resolveKey(e[n], t), "undefined" == typeof i); n++) ; else i = this._resolveKey(e, t);
                        return i
                    }, _resolveKey: function (e, t) {
                        var i;
                        return e = s.get(e), "undefined" != typeof e && ("undefined" != typeof e[t] ? i = e[t] : "undefined" != typeof e.preset && (i = this._resolvePreset(e.preset, t))), i
                    }, _parentChangeCallback: function (e, t) {
                        this._cache = {}, e && e.events.remove("change", this._onParentChange, this), t && t.events.add("change", this._onParentChange, this), this._parent = t, t ? this._mapper && this._setupMapper() : this._mapper && this._clearMapper(), this.events && (this.events.fire("parentchange", {
                            target: this,
                            oldParent: e,
                            newParent: t
                        }), this._fire())
                    }, _onParentChange: function () {
                        this._cache = {}, this._fire()
                    }, _getOptionsForChanging: function () {
                        return this._options ? this._originalOptions && (this._options = i({}, this._options), this._originalOptions = !1) : this._options = {}, this._options
                    }, _fire: function () {
                        this._frozen ? this._changed = !0 : (this._monitor && this._monitor.checkChange(), this.events.fire("change", new h({
                            target: this,
                            type: "change"
                        })))
                    }
                });
                e(_)
            });
        }],
        ['$c', function (ym) {
            ym.modules.define("option.Mapper", ["event.Manager", "Event", "util.array"], function (e, n, t, l) {
                function r(e, n, t) {
                    if (l.isArray(t)) {
                        for (var r, a = 0, i = t.length; a < i; a++) {
                            var s = u(e, n, t[a]);
                            r ? "string" == typeof s ? r.push(s) : r = r.concat(s) : r = "string" == typeof s ? [s] : s.slice()
                        }
                        return r
                    }
                    return u(e, n, t)
                }

                function u(e, n, t) {
                    return "plain" == t ? e : "prefixed" == t ? a(e, n) : t(e, n)
                }

                function a(e, n) {
                    return n + e.slice(0, 1).toUpperCase() + e.slice(1)
                }

                var i = function (e) {
                    this._defaultRule = e || null, this._rules = {
                        nameRules: {},
                        keyRules: {},
                        keyNameRules: {}
                    }, this.events = new n
                };
                i.addPrefix = function (e, n) {
                    return n + e.slice(0, 1).toUpperCase() + e.slice(1)
                }, i.addOptionalPrefix = function (e, n) {
                    return [i.addPrefix(e, n), e]
                }, i.addOptionalPrefixForBalloonHint = function (e, n) {
                    return 0 == e.indexOf("balloon") || 0 == e.indexOf("hint") ? i.addOptionalPrefix(e, n) : i.addPrefix(e, n)
                }, i.prototype = {
                    setRule: function (e) {
                        e.rule || (e.rule = "plain");
                        for (var n = [].concat(e.key), l = [].concat(e.name), r = 0, u = n.length; r < u; r++) for (var a = 0, i = l.length; a < i; a++) this._applyRule(n[r], l[a], e.rule);
                        return this.events.fire("rulechange", new t({target: this, selector: e, rule: e.rule})), this
                    }, fireChange: function () {
                        this.events.fire("rulechange")
                    }, _applyRule: function (e, n, t) {
                        var l = this._rules;
                        n && e ? (l.keyNameRules[e] || (l.keyNameRules[e] = {}))[n] = t : n ? l.nameRules[n] = t : e && (l.keyRules[e] = t)
                    }, unsetRule: function (e) {
                        for (var n = [].concat(e.key), l = [].concat(e.name), r = 0, u = n.length; r < u; r++) for (var a = 0, i = l.length; a < i; a++) this._cleanRule(n[r], l[a]);
                        return this.events.fire("rulechange", new t({target: this, selector: e, rule: null})), this
                    }, _cleanRule: function (e, n) {
                        var t = this._rules;
                        n && e ? t.keyNameRules[e] && delete t.keyNameRules[e][n] : n ? delete t.nameRules[n] : e && delete t.keyRules[e]
                    }, resolve: function (e, n) {
                        var t = this._rules;
                        return t.keyNameRules[e] && t.keyNameRules[e][n] ? r(e, n, t.keyNameRules[e][n]) : t.nameRules[n] ? r(e, n, t.nameRules[n]) : t.keyRules[e] ? r(e, n, t.keyRules[e]) : this._defaultRule ? r(e, n, this._defaultRule) : e
                    }
                }, e(i)
            });
        }],
        ['_7', function (ym) {
            ym.modules.define("projection.wgs84Mercator", ["projection.GeoToGlobalPixels"], function (e, o) {
                e(new o({coordinatesOrder: ym.env.coordinatesOrder}))
            });
        }],
        ['8w', function (ym) {
            ym.modules.define("meta.internal", ["meta", "util.array"], function (e, t, i) {
                function n(e) {
                    return e.replace(".", "\\.")
                }

                var o = ["yandex", "яндекс"].join("|"),
                    a = i.map(["ru", "com", "by", "ua", "com.tr", "com.ua", "kz", "com.ge", "uz", "рф", "az", "com.am", "co.il", "by", "kz", "kg", "lv", "lt", "md", "tj", "tm", "fr", "ee"], n).join("|"),
                    s = ["auto.ru"].join("|"), r = new RegExp("(^|\\.)(" + o + ")\\.(" + a + ")$", "i"),
                    m = new RegExp("(^|\\.)(" + s + ")$", "i"),
                    u = new RegExp("(^|\\.)tech\\.(" + o + ")\\.(" + a + ")$", "i"),
                    c = r.test(location.hostname) || m.test(location.hostname), p = u.test(location.hostname),
                    l = !t.isEnterprise && "RU" == t.countryCode && (p || !c), d = !p && (t.isEnterprise || c);
                e({
                    meta: t,
                    isYandex: c,
                    isYandexTech: p,
                    displayAdvert: l,
                    suppressDistribution: d,
                    suppressTaxiDistribution: t.isEnterprise
                })
            });
        }],
        [',c', function (ym) {
            ym.modules.define("util.math.restrict", [], function (t) {
                var e = function (t, e, r) {
                    if (ym.env.debug) {
                        if ("undefined" == typeof t || null == t) throw new Error("util.math.restrict: не передан параметр value");
                        if ("undefined" == typeof e || null == e) throw new Error("util.math.restrict: не передан параметр min");
                        if ("undefined" == typeof r || null == r) throw new Error("util.math.restrict: не передан параметр max")
                    }
                    return Math.max(Math.min(t, r), e)
                };
                t(e)
            });
        }],
        [')2', function (ym) {
            ym.modules.define("util.eventId", ["util.id"], function (e, t) {
                var n = {
                    get: function (e) {
                        return t.get(e)
                    }
                };
                e(n)
            });
        }],
        ['):', function (ym) {
            ym.modules.define("util.instantCache", [], function (n) {
                var e, t = {}, i = function () {
                    t = {}, e = null
                }, u = {
                    add: function (n, u) {
                        t[n] = u, e || (e = window.setTimeout(i, 0))
                    }, get: function (n) {
                        return t[n]
                    }, remove: function (n) {
                        t[n] && delete t[n]
                    }
                };
                n(u)
            });
        }],
        ['8t', function (ym) {
            ym.modules.define("mapEvent.overrideStorage", ["util.Storage"], function (e, n) {
                e(new n)
            });
        }],
        [')A', function (ym) {
            ym.modules.define("util.data", ["util.id", "util.WeakMap"], function (t, e, i) {
                function s(t) {
                    return "string" == typeof t ? n[t] || (n[t] = {_uid: o++}) : t
                }

                var n = {}, o = 0;
                t({
                    _storage: new i, add: function (t, e, i) {
                        var n = s(t), o = this._storage.get(n);
                        o || (o = {list: {}, count: 0}, this._storage.set(n, o)), o.list[e] || o.count++, o.list[e] = i
                    }, get: function (t, e) {
                        var i = this._storage.get(s(t));
                        return i && i.list[e]
                    }, remove: function (t, e) {
                        var i = s(t), o = this._storage.get(i);
                        o && o.list[e] && (delete o.list[e], --o.count || ("string" == typeof t && delete n[t], this._storage.remove(i)))
                    }
                })
            });
        }],
        ['1-', function (ym) {
            ym.modules.define("domEvent.managerOverrideStorage", ["util.Storage"], function (e, n) {
                e(new n)
            });
        }],
        ['1J', function (ym) {
            ym.modules.define("domEvent.TouchMapper", ["util.extend", "DomEvent", "util.math.areEqual", "domEvent.managerComponent.mouseLeaveEnterDispatcher", "domEvent.Touch", "domEvent.MultiTouch", "map.metaOptions", "util.dom.event", "system.browser"], function (e, t, n, i, s, o, u, c, h, r) {
                function a() {
                    var e = !1, t = !1, n = function () {
                    }, i = {};
                    try {
                        return i = Object.defineProperty(i, "passive", {
                            get: function () {
                                e = !0
                            }
                        }), i = Object.defineProperty(i, "capture", {
                            get: function () {
                                t = !0
                            }
                        }), document.addEventListener("ymapstest", n, i), document.removeEventListener("ymapstest", n, i), e && t
                    } catch (s) {
                        return !1
                    }
                }

                function l(e) {
                    return v ? {capture: e, passive: !1} : e
                }

                var v = a(), m = 20, E = "iOS" != r.osFamily, d = 20, p = 1200,
                    _ = ["mouseenter", "mouseleave", "mousemove", "mousedown", "mouseup", "wheel", "click", "dblclick", "contextmenu"],
                    f = {
                        activeMappers: 0,
                        activeTouchSession: !1,
                        touchSessionEndTime: 0,
                        initTouchId: 0,
                        sessionStartPosition: null,
                        sessionEndPosition: null,
                        sessionEndTimeStamp: null
                    }, T = function (e) {
                        var t = e.touches;
                        if (1 == t.length || !f.initTouchId) {
                            var n = t[0];
                            f.initTouchId = n.identifier, f.sessionStartPosition = [n.clientX, n.clientY]
                        }
                        f.activeTouchSession = !0
                    }, S = function (e) {
                        for (var t = e.touches.length, n = e.changedTouches, i = 0, s = n.length; i < s; i++) {
                            var o = n[i];
                            if (o.identifier == f.initTouchId) {
                                f.sessionEndPosition = [o.clientX, o.clientY], f.sessionEndTimeStamp = e.timeStamp, f.initTouchId = 0;
                                break
                            }
                        }
                        0 == t && (f.touchSessionEndTime = +new Date, f.activeTouchSession = !1)
                    }, M = function (e, n) {
                        this.events = e, this._useCapture = this.events.params.capture, this._elementEventOptions = l(this._useCapture), this._documentEventOptions = l(!0), this.params = t({}, {
                            dblClickTimeout: c.get("dblClickTimeout", 500),
                            contextMenuTimeout: c.get("touchContextMenuTimeout", 400)
                        }, n), this._state = {}, this._listeners = null, this._elementTouchStartHandler = this._onTouchStart.bind(this), this._elementTouchMoveHandler = this._onTouchMove.bind(this), this._elementTouchEndHandler = this._onTouchEnd.bind(this), this._mouseEventsHandler = this._onMouseEvent.bind(this)
                    };
                M.prototype = {
                    start: function () {
                        this._state = {
                            initMouseEventSent: !1,
                            multiTouch: !1,
                            preventClick: !1,
                            mouseOver: !1,
                            previousEventType: "",
                            clickData: {}
                        }, r.isIE && (this._state.eventsWithoutHover = 0);
                        var e = this.events.params.htmlElement;
                        if (e.addEventListener("touchstart", this._elementTouchStartHandler, this._elementEventOptions), e.addEventListener("touchmove", this._elementTouchMoveHandler, this._elementEventOptions), e.addEventListener("touchend", this._elementTouchEndHandler, this._elementEventOptions), e.addEventListener("touchcancel", this._elementTouchEndHandler, this._elementEventOptions), E) {
                            for (var t = 0, n = _.length; t < n; t++) e.addEventListener(h.getActualName(_[t]), this._mouseEventsHandler, this._elementEventOptions);
                            0 == f.activeMappers++ && (document.addEventListener("touchstart", T, this._documentEventOptions), document.addEventListener("touchend", S, this._documentEventOptions), document.addEventListener("touchcancel", S, this._documentEventOptions))
                        }
                    }, stop: function () {
                        var e = this.events.params.htmlElement;
                        if (e.removeEventListener("touchstart", this._elementTouchStartHandler, this._elementEventOptions), e.removeEventListener("touchmove", this._elementTouchMoveHandler, this._elementEventOptions), e.removeEventListener("touchend", this._elementTouchEndHandler, this._elementEventOptions), e.removeEventListener("touchcancel", this._elementTouchEndHandler, this._elementEventOptions), E) {
                            0 == --f.activeMappers && (document.removeEventListener("touchstart", T, this._documentEventOptions), document.removeEventListener("touchend", S, this._documentEventOptions), document.removeEventListener("touchcancel", S, this._documentEventOptions), f.touchSessionEndTime = 0, f.sessionStartPosition = f.sessionEndPosition = null, f.sessionEndTimeStamp = null);
                            for (var t = 0, n = _.length; t < n; t++) e.removeEventListener(h.getActualName(_[t]), this._mouseEventsHandler, this._elementEventOptions)
                        }
                    }, _onTouchStart: function (e) {
                        this._state.previousEventType = "touch";
                        var t = this._state, n = e.touches, i = n.length;
                        t.initMouseEventSent || (t.initMouseEventSent = !0, this._fireMouseInitEvents(e), t.initTimestamp = e.timeStamp, t.touches = e.touches), i > 1 && (t.initMouseEventSent && !t.preventClick && (t.preventClick = !0), this._fireEndStartMultiTouchEvents(t.multiTouch ? e : null, e))
                    }, _onTouchMove: function (e) {
                        this._state.previousEventType = "touch";
                        var t = e.touches, n = this._state;
                        if (1 == t.length && f.sessionStartPosition) {
                            var s = t[0], o = [s.clientX, s.clientY];
                            if (i(f.sessionStartPosition, o, 3)) return
                        }
                        n.touches = e.touches, n.initMouseEventSent || this._onTouchStart(e), n.preventClick || (n.preventClick = !0), 1 == e.touches.length ? this._fireTouchEvent(e, "mousemove") : (n.multiTouch || this._fireEndStartMultiTouchEvents(null, e), this._fireMultiTouchEvent(e, "multitouchmove"))
                    }, _onTouchEnd: function (e) {
                        this._state.previousEventType = "touch";
                        var t = e.touches.length, n = this._state,
                            i = n.multiTouch || !n.initMouseEventSent && e.changedTouches.length > 0;
                        i && this._fireEndStartMultiTouchEvents(e, t > 1 ? e : null), 0 == t && (n.initTimestamp || (n.initTimestamp = e.timeStamp), n.touches || (n.touches = e.changedTouches), this._fireMouseEndEvents(e))
                    }, _fireEndStartMultiTouchEvents: function (e, t) {
                        e && this._fireMultiTouchEvent(e, "multitouchend");
                        var n = null != t;
                        n && this._fireMultiTouchEvent(t, "multitouchstart"), this._state.multiTouch = n
                    }, _fireMouseInitEvents: function (e) {
                        this._state.mouseOver || (this._state.mouseOver = !0, this._fireTouchEvent(e, "mouseenter")), this._fireTouchEvent(e, "mousemove"), this._fireTouchEvent(e, "mousedown")
                    }, _fireMouseEndEvents: function (e) {
                        var t = e.timeStamp, n = this._state, i = n.touches;
                        if (this._fireTouchEvent(e, "mouseup", i), "touchend" != e.type && (n.preventClick = !0), !n.preventClick) if (t - n.initTimestamp > this.params.contextMenuTimeout) this._fireTouchEvent(e, "contextmenu", i), n.clickData.time = null; else {
                            var s = i[0];
                            this._processClickEvent({
                                clickPos: [s.clientX, s.clientY],
                                time: e.timeStamp,
                                diff: m
                            }, function (t) {
                                this._fireTouchEvent(e, t, i)
                            })
                        }
                        this._fireTouchEvent(e, "mousemove", i), this._fireTouchEvent(e, "mouseleave", i), n.initMouseEventSent = n.preventClick = n.mouseOver = !1
                    }, _fireTouchEvent: function (e, t, n) {
                        n || (n = e.touches), this.events.fire(t, new o(e, t, n))
                    }, _fireMultiTouchEvent: function (e, t, n) {
                        n || (n = e.touches), this.events.fire(t, new u(e, t, n))
                    }, _onMouseEvent: function (e) {
                        var t = this._state.previousEventType, o = this._state, u = h.getIdealName(e.type);
                        if ("dblclick" != u) {
                            var c = "mouseenter" == u, a = "mouseleave" == u, l = new n(e, u);
                            if (a || !f.activeTouchSession && this._allowMouseEvent(e)) if (this._state.previousEventType = "mouse", c || a) o.mouseOver = c, s.fire(this.events, u, l.originalEvent), r.isIE && (o.eventsWithoutHover = 0); else {
                                if (r.isIE && !o.mouseOver && "mousemove" == u && 0 == o.eventsWithoutHover++) return;
                                "touch" == t && (o.mouseOver || (o.mouseOver = !0, s.fire(this.events, "mouseenter", e)));
                                var v = o.clickData;
                                if ("click" == u) {
                                    var m = [e.clientX, e.clientY], E = v.lastMouseDownPos;
                                    if (E && i(E, m, 0)) return void this._processClickEvent({
                                        clickPos: [e.clientX, e.clientY],
                                        time: e.timeStamp,
                                        diff: 1
                                    }, function (t) {
                                        this.events.fire(t, new n(e, t))
                                    })
                                } else "mousedown" == u && (v.lastMouseDownPos = [e.clientX, e.clientY]);
                                this.events.fire(u, l)
                            }
                        }
                    }, _allowMouseEvent: function (e) {
                        if (f.touchSessionEndTime > 0) {
                            if (f.sessionEndTimeStamp && e.timeStamp && f.sessionEndTimeStamp >= e.timeStamp) return !1;
                            var t = [e.clientX, e.clientY];
                            if (+new Date - f.touchSessionEndTime > p) f.touchSessionEndTime = 0, f.sessionStartPosition = f.sessionEndPosition = null, f.sessionEndTimeStamp = null; else if (f.sessionStartPosition && i(t, f.sessionStartPosition, d) || f.sessionEndPosition && i(t, f.sessionEndPosition, d)) return !1
                        }
                        return !0
                    }, _processClickEvent: function (e, t) {
                        var n = this._state, s = e.time, o = e.diff, u = e.clickPos;
                        n.clickData.time && s - n.clickData.time < this.params.dblClickTimeout ? (t.call(this, "click"), n.clickData.pos && i(n.clickData.pos, u, o) && t.call(this, "dblclick"), n.clickData.time = null) : (t.call(this, "click"), n.clickData.time = s), n.clickData.pos = u
                    }
                }, e(M)
            });
        }],
        ['1:', function (ym) {
            ym.modules.define("domEvent.multiTouch.overrideStorage", ["util.Storage"], function (e, o) {
                e(new o)
            });
        }],
        [')!', function (ym) {
            ym.modules.define("util.id", [], function (n) {
                var t = new function () {
                    function n() {
                        return (++i).toString()
                    }

                    var t = ("id_" + +new Date + Math.round(1e4 * Math.random())).toString(),
                        i = Math.round(1e4 * Math.random());
                    this.prefix = function () {
                        return t
                    }, this.gen = n, this.get = function (i) {
                        return i === window ? t : i[t] || (i[t] = n())
                    }
                };
                n(t)
            });
        }],
        ['(,', function (ym) {
            ym.modules.define("util.array", [], function (r) {
                var n = {
                    each: function (r, n, t) {
                        if ("undefined" == typeof r.length) {
                            for (var e in r) if (r.hasOwnProperty(e) && (t ? n.call(t, r[e], e) : n(r[e], e)) === !1) break
                        } else {
                            var o = 0, i = !0;
                            if (t) for (; o < r.length && i !== !1; o++) i = n.call(t, r[o], o); else for (; o < r.length && i !== !1; o++) i = n(r[o], o)
                        }
                    }, map: "function" == typeof Array.prototype.map ? function (r, n, t) {
                        return r.map(n, t)
                    } : function (r, n, t) {
                        for (var e = [], o = 0, i = r.length; o < i; o++) e[o] = t ? n.call(t, r[o], o, r) : n(r[o], o, r);
                        return e
                    }, reduce: "function" == typeof Array.prototype.reduce ? function (r, n, t) {
                        return r.reduce(n, t)
                    } : function (r, n, t) {
                        var e, o = Object(r), i = r.length >>> 0, f = 0;
                        if (arguments.length >= 3) e = arguments[2]; else {
                            for (; f < i && !(f in o);) f++;
                            if (f >= i) throw new TypeError("Reduce of empty array with no initial value");
                            e = o[f++]
                        }
                        for (; f < i; f++) f in o && (e = n(e, o[f], f, o));
                        return e
                    }, filter: "function" == typeof Array.prototype.filter ? function (r, n, t) {
                        return r.filter(n, t)
                    } : function (r, n, t) {
                        for (var e, o = [], i = 0, f = r.length; i < f; i++) e = t ? n.call(t, r[i], i, r) : n(r[i], i, r), e && o.push(r[i]);
                        return o
                    }, some: "function" == typeof Array.prototype.some ? function (r, n, t) {
                        return r.some(n, t)
                    } : function (r, n, t) {
                        for (var e = 0; e < r.length; e++) if (n.call(t, r[e], e, r)) return !0;
                        return !1
                    }, indexOf: "function" == typeof Array.prototype.indexOf ? function (r, n, t) {
                        return r.indexOf(n, t)
                    } : function (r, n, t) {
                        var e = t || 0, o = r.length;
                        for (e < 0 && (e += o), e < 0 && (e = 0); e < o; e++) if (r[e] === n) return e;
                        return -1
                    }, isArray: "function" == typeof Array.isArray ? Array.isArray : function (r) {
                        return "[object Array]" === Object.prototype.toString.call(r)
                    }, merge: function (r, n, t) {
                        for (var e = [], o = 0, i = 0, f = r.length, u = n.length; o < f && i < u;) t(r[o], n[i]) < 0 ? (e.push(r[o]), o++) : (e.push(n[i]), i++);
                        for (; o < f; o++) e.push(r[o]);
                        for (; i < u; i++) e.push(n[i]);
                        return e
                    }, remove: function (r, t) {
                        var e = n.indexOf(r, t);
                        return e != -1 && r.splice(e, 1), e
                    }, findIndex: "function" == typeof Array.prototype.findIndex ? function (r, n, t) {
                        return r.findIndex(n, t)
                    } : function (r, n, t) {
                        for (var e = -1, o = 0, i = r.length; o < i; o++) {
                            var f = r[o];
                            if (t ? n.call(t, f, o, r) : n(f, o, r)) {
                                e = o;
                                break
                            }
                        }
                        return e
                    }, find: "function" == typeof Array.prototype.find ? function (r, n, t) {
                        return r.find(n, t)
                    } : function (r, t, e) {
                        var o = n.findIndex(r, t, e);
                        return o == -1 ? void 0 : r[o]
                    }, quickSort: function (r, n) {
                        if (!r.length) return r;
                        n || (n = function (r, n) {
                            return r < n
                        });
                        for (var t = [], e = [], o = r[0], i = 1, f = r.length; i < f; i++) {
                            var u = r[i];
                            n(u, o) < 0 ? t.push(u) : e.push(u)
                        }
                        return this.quickSort(t, n).concat(o, this.quickSort(e, n))
                    }, findAfterValue: function (r, n) {
                        return 0 == r.length ? 0 : this._getPosition(r, 0, r.length - 1, n)
                    }, from: "function" == typeof Array.from ? Array.from : function (r, t, e) {
                        if (n.isArray(r)) return n.map(r.slice(), t, e);
                        for (var o = new Array(r.length), i = 0, f = r.length; i < f; i++) t ? o[i] = "undefined" == typeof e ? t(r[i], i) : t.call(e, r[i], i) : o[i] = r[i];
                        return o
                    }, equals: function (r, n, t) {
                        if (r.length != n.length) return !1;
                        t = t || function (r, n) {
                            return r === n
                        };
                        for (var e = 0, o = r.length; e < o; e++) if (!t(r[e], n[e])) return !1;
                        return !0
                    }, _getPosition: function (r, n, t, e) {
                        var o, i = r[n][0], f = r[t][0];
                        if (i >= e) return n;
                        if (f < e) return t + 1;
                        if (t - n == 1) return t;
                        if (o = n + Math.round((t - n) * (e - i) / (f - i)), o == n) {
                            do o++; while (r[o][0] < e && o < t);
                            return this._getPosition(r, o, t, e)
                        }
                        if (o == t) {
                            do o--; while (r[o][0] >= e && o > n);
                            return this._getPosition(r, n, o, e)
                        }
                        return r[o][0] < e ? this._getPosition(r, o, t, e) : this._getPosition(r, n, o, e)
                    }
                };
                r(n)
            });
        }],
        ['1Q', function (ym) {
            ym.modules.define("domEvent.touch.overrideStorage", ["util.Storage"], function (e, o) {
                e(new o)
            });
        }],
        [')C', function (ym) {
            ym.modules.define("util.defineClass", ["util.extend"], function (t, o) {
                function e(t, e, r) {
                    return t.prototype = (Object.create || function (t) {
                        function o() {
                        }

                        return o.prototype = t, new o
                    })(e.prototype), t.prototype.constructor = t, t.superclass = e.prototype, t.superclass.constructor = e, r && o(t.prototype, r), t.prototype
                }

                function r(t, r, n) {
                    var p = "function" == typeof r;
                    p && e(t, r);
                    for (var u = p ? 2 : 1, c = arguments.length; u < c; u++) o(t.prototype, arguments[u]);
                    return t
                }

                t(r)
            });
        }],
        ['05', function (ym) {
            ym.modules.define("component.child.BaseChild", [], function (t) {
                var n = function (t, n) {
                    this._oldParent = null, this._parent = null, this._parentChangeCallback = t, this._context = n
                };
                n.prototype = {
                    setParent: function (t) {
                        this._parent != t && (this._parent = t, this._parentChangeCallback && this._parentChangeCallback.call(this._context, this._oldParent, this._oldParent = this._parent))
                    }, getParent: function () {
                        return this._parent
                    }
                }, t(n)
            });
        }],
        ['$d', function (ym) {
            ym.modules.define("option.presetStorage", ["util.Storage"], function (e, o) {
                e(new o)
            });
        }],
        ['2b', function (ym) {
            ym.modules.define("event.manager.Base", ["util.defineClass", "util.array", "event.Group"], function (e, t, r, i) {
                function s(e) {
                    if (this.types = {}, this.typesCount = 0, this.params = e || {}, this.controllersHash = {}, this.params.controllers) for (var t = this.params.controllers, r = 0, i = t.length; r < i; r++) this._setupController(t[r]); else this.params.controllers = [];
                    this._onFire = {}, this._deletedOnFire = {}
                }

                t(s, {
                    add: function (e, t, r, i) {
                        if (i = +i || 0, "string" == typeof e) this._addListener(e, t, r, i); else for (var s = 0, n = e.length; s < n; s++) this._addListener(e[s], t, r, i);
                        return this
                    },
                    remove: function (e, t, r, i) {
                        if (i = +i || 0, "string" == typeof e) this._removeListener(e, t, r, i); else for (var s = 0, n = e.length; s < n; s++) this._removeListener(e[s], t, r, i);
                        return this
                    },
                    fire: function (e, t) {
                        var r = this.types[e];
                        if (r && !t.isPropagationStopped()) {
                            this._onFire.hasOwnProperty(e) ? this._onFire[e]++ : this._onFire[e] = 1;
                            var i = "undefined" != typeof r.priorityKeys;
                            if (i) for (var s = r.priorityKeys.length - 1; s >= 0; s--) this._callListeners(r[r.priorityKeys[s]], t); else this._callListeners(r, t);
                            var n = this._deletedOnFire[e];
                            if (n) {
                                if (r = this.types[e], i) {
                                    for (var s = 0, o = n.priorityKeys.length; s < o; s++) {
                                        var l = n.priorityKeys[s], h = r[l];
                                        this._removeDeletedOnFire(h, n[l]), h.length || this._clearPriority(e, l)
                                    }
                                    r.priorityKeys.length || this._clearType(e)
                                } else this._removeDeletedOnFire(r, n), r.length || this._clearType(e);
                                delete this._deletedOnFire[e]
                            }
                            --this._onFire[e] || delete this._onFire[e]
                        }
                        return this
                    },
                    _removeDeletedOnFire: function (e, t) {
                        for (var r, i = 0, s = t.length - 1; s >= 0; s -= 2) t[s] && (i += 2, r = s, s > 0) || i && (e.splice(r, i), i = 0)
                    },
                    _addListener: function (e, t, r, i) {
                        var s = !1, n = this.types[e], o = n;
                        if (n) {
                            if (ym.env.debug && e.length > 13 && e.lastIndexOf("defaultaction") == e.length - 13) throw new Error("event.manager.Base._addListener: Обработчик события по умолчанию " + e + " уже был добавлен ранее.");
                            if ("undefined" != typeof n.priorityKeys) n[i] || this._addPriority(n, i), o = n[i]; else if (i) {
                                var l = this._deletedOnFire[e];
                                l && (this._deletedOnFire[e] = {
                                    priorityKeys: [0],
                                    0: l
                                }), n = this.types[e] = {priorityKeys: [0], 0: n}, this._addPriority(n, i), o = n[i]
                            }
                        } else i ? (n = this.types[e] = {priorityKeys: [i]}, o = n[i] = []) : o = this.types[e] = [], s = !0, this.typesCount++;
                        o.push(t, r || null), s && this.controllersHash.onStartListening && this.callControllers("onStartListening", this, e)
                    },
                    _addPriority: function (e, t) {
                        e[t] = [];
                        for (var r = e.priorityKeys, i = 0, s = r.length; i < s && !(r[i] > t); i++) ;
                        r.splice(i, 0, t)
                    },
                    _removeListener: function (e, t, r, i) {
                        var s = this.types[e];
                        if (s) {
                            var n = "undefined" != typeof s.priorityKeys, o = s;
                            n && s[i] && (o = s[i]);
                            for (var l = -1, h = 0, a = o.length; h < a; h += 2) if (o[h] == t && o[h + 1] == r) {
                                l = h;
                                break
                            }
                            if (l != -1) if (this._onFire.hasOwnProperty(e)) {
                                o[l] = null;
                                var p = this._deletedOnFire[e];
                                p ? n && !p[i] && (p.priorityKeys.push(i), p = p[i] = []) : n ? (p = this._deletedOnFire[e] = {priorityKeys: [i]}, p = p[i] = []) : p = this._deletedOnFire[e] = [], p[l] = !0
                            } else 2 == a ? n ? (this._clearPriority(e, i), s.priorityKeys.length || this._clearType(e)) : this._clearType(e) : o.splice(l, 2)
                        }
                    },
                    _callListeners: function (e, t) {
                        for (var r = 0, i = e.length; r < i && !t.isImmediatePropagationStopped();) {
                            var s = e[r];
                            s && s.call(e[r + 1], t), r += 2
                        }
                    },
                    _clearPriority: function (e, t) {
                        for (var r = this.types[e], i = 0, s = r.priorityKeys.length; i < s; i++) if (r.priorityKeys[i] == t) {
                            r.priorityKeys.splice(i, 1);
                            break
                        }
                        delete this.types[e][t]
                    },
                    _clearType: function (e) {
                        delete this.types[e], this.typesCount--, this.controllersHash.onStopListening && this.callControllers("onStopListening", this, e)
                    },
                    controllerMethods: ["onStartListening", "onStopListening"],
                    callControllers: function (e, t, r, i) {
                        for (var s, n = this.controllersHash[e], o = 0, l = n.length; o < l && (s = n[o][e](t, r, i), s !== !1); o++) ;
                        return s
                    },
                    group: function () {
                        return new i(this)
                    },
                    addController: function (e) {
                        this.params.controllers.push(e), this._setupController(e)
                    },
                    _setupController: function (e) {
                        for (var t = this.controllerMethods, r = 0, i = t.length; r < i; r++) {
                            var s = t[r];
                            e[s] && (this.controllersHash[s] ? this.controllersHash[s].push(e) : this.controllersHash[s] = [e])
                        }
                    },
                    removeController: function (e) {
                        var t = r.indexOf(this.params.controllers, e);
                        if (t != -1) {
                            1 == this.params.controllers.length ? this.params.controllers.pop() : this.params.controllers.splice(t, 1);
                            for (var i = this.controllerMethods, s = 0, n = i.length; s < n; s++) {
                                var o = i[s];
                                if (e[o]) {
                                    var l = this.controllersHash[o];
                                    1 == l.length ? l[0] == e && l.pop() : (t = r.indexOf(l, e), t != -1 && l.splice(t, 1)), l.length || (this.controllersHash[o] = null)
                                }
                            }
                        } else if (ym.env.debug) throw new Error("event.Manager.removeController: контроллер не найден")
                    },
                    once: function (e, t, r, i) {
                        function s(n) {
                            this.remove(e, s, this, i), r ? t.call(r, n) : t(n)
                        }

                        return this.add(e, s, this, i), this
                    }
                }), e(s)
            });
        }],
        ['2e', function (ym) {
            ym.modules.define("Event", ["util.defineClass"], function (t, e) {
                function n(t, e) {
                    this.originalEvent = t || {}, this._sourceEvent = e || null, e ? (this._propagationStopped = e.isPropagationStopped(), this._immediatePropagationStopped = e.isImmediatePropagationStopped(), this._defaultPrevented = e.isDefaultPrevented(), this._mapEventAllowed = e.isMapEventAllowed()) : (this._propagationStopped = !1, this._immediatePropagationStopped = !1, this._defaultPrevented = !1, this._mapEventAllowed = !1)
                }

                e(n, {
                    getSourceEvent: function () {
                        return this._sourceEvent
                    }, get: function (t) {
                        return "undefined" == typeof this.originalEvent[t] && this._sourceEvent ? this._sourceEvent.get(t) : this.originalEvent[t]
                    }, callMethod: function (t) {
                        return "undefined" == typeof this.originalEvent[t] && this._sourceEvent ? this._sourceEvent.callMethod.apply(this._sourceEvent, arguments) : this.originalEvent[t].apply(this.originalEvent, Array.prototype.slice.call(arguments, 1))
                    }, stopImmediatePropagation: function () {
                        this._sourceEvent && (this._sourceEvent.stopImmediatePropagation(), this._sourceEvent.stopPropagation()), this._immediatePropagationStopped = !0, this._propagationStopped = !0
                    }, isImmediatePropagationStopped: function () {
                        return this._immediatePropagationStopped
                    }, stopPropagation: function () {
                        this._sourceEvent && this._sourceEvent.stopPropagation(), this._propagationStopped = !0
                    }, isPropagationStopped: function () {
                        return this._propagationStopped
                    }, preventDefault: function () {
                        this._sourceEvent && this._sourceEvent.preventDefault(), this._defaultPrevented = !0
                    }, isDefaultPrevented: function () {
                        return this._defaultPrevented
                    }, allowMapEvent: function () {
                        this._sourceEvent && this._sourceEvent.allowMapEvent(), this._mapEventAllowed = !0
                    }, disallowMapEvent: function () {
                        this._sourceEvent && this._sourceEvent.disallowMapEvent(), this._mapEventAllowed = !1
                    }, isMapEventAllowed: function () {
                        return this._mapEventAllowed
                    }, clone: function (t) {
                        return new n(t, this.getSourceEvent())
                    }
                }), t(n)
            });
        }],
        ['$a', function (ym) {
            ym.modules.define("option.manager.Monitor", ["util.defineClass"], function (e, t) {
                function i(e) {
                    this._optionManger = e, this._listeners = [], this._values = {}, this._nameCounters = {}, this._onCheckCounter = 0, this._needTrim = !1, this._trimTimeoutId = 0
                }

                function s(e, t, i) {
                    return e == r ? i && "undefined" != typeof i[t] ? i[t] : n : e
                }

                var n, r = {};
                t(i, {
                    add: function (e, t, i, s) {
                        if (this._listeners.push(e, t, i, s), "string" == typeof e) this._addName(e); else for (var n = 0, r = e.length; n < r; n++) this._addName(e[n]);
                        return this
                    }, remove: function (e, t, i, s) {
                        var n = this._searchListener(e, t, i, s);
                        if (n != -1) if (this._listeners[n] = null, this._needTrim = !0, "string" == typeof e) this._removeName(e); else for (var r = 0, h = e.length; r < h; r++) this._removeName(e[r]);
                        return this._tryTrimListeners(), this
                    }, get: function (e, t) {
                        return s(this._values[e], e, t)
                    }, checkChange: function () {
                        this._onCheckCounter++;
                        for (var e = {}, t = 0, i = this._listeners.length; t < i; t += 4) this._listeners[t] && this._checkListener(this._listeners[t], this._listeners[t + 1], this._listeners[t + 2], this._listeners[t + 3], e);
                        this._onCheckCounter--, this._tryTrimListeners()
                    }, _checkListener: function (e, t, i, n, r) {
                        if ("string" == typeof e) {
                            this._updateNameValue(e, r);
                            var h = s(this._values[e], e, n), a = s(r[e], e, n);
                            a != h && this._callNameListener(t, i, h, a)
                        } else {
                            this._updateNameValues(e, r);
                            for (var _ = this._fixUndefForNames(this._values, e, n), o = this._fixUndefForNames(r, e, n), u = 0, l = e.length; u < l; u++) if (o[e[u]] != _[e[u]]) {
                                this._callNameListener(t, i, _, o);
                                break
                            }
                        }
                    }, _updateNameValue: function (e, t) {
                        "undefined" == typeof t[e] && (t[e] = this._values[e], this._values[e] = this._resolveNameValue(e))
                    }, _updateNameValues: function (e, t) {
                        for (var i = 0, s = e.length; i < s; i++) this._updateNameValue(e[i], t)
                    }, _callNameListener: function (e, t, i, s) {
                        t ? e.call(t, i, s) : e(i, s)
                    }, _searchListener: function (e, t, i, s) {
                        for (var n = 0, r = this._listeners.length; n < r; n += 4) if (this._compareNames(this._listeners[n], e) && this._listeners[n + 1] == t && this._listeners[n + 2] == i && this._listeners[n + 3] == s) return n;
                        return -1
                    }, _addName: function (e) {
                        this._nameCounters[e] ? this._nameCounters[e]++ : (this._nameCounters[e] = 1, this._values[e] = this._resolveNameValue(e))
                    }, _removeName: function (e) {
                        this._nameCounters[e]--, this._nameCounters[e] || delete this._values[e]
                    }, _resolveNameValue: function (e) {
                        return this._optionManger.get(e, r)
                    }, _compareNames: function (e, t) {
                        var i = typeof e;
                        if (i == typeof t) {
                            if ("string" == i) return e == t;
                            var s = e.length;
                            if (s == t.length) {
                                for (var n = 0; n < s; n++) if (e[n] != t[n]) return !1;
                                return !0
                            }
                        }
                        return !1
                    }, _tryTrimListeners: function () {
                        this._onCheckCounter || !this._needTrim || this._trimTimeoutId || (this._trimTimeoutId = setTimeout(function () {
                            this._needTrim = !1, this._trimTimeoutId = 0, this._trimListeners()
                        }.bind(this), 0))
                    }, _trimListeners: function () {
                        for (var e = [], t = 0, i = this._listeners.length; t < i; t += 4) this._listeners[t] && e.push(this._listeners[t], this._listeners[t + 1], this._listeners[t + 2], this._listeners[t + 3]);
                        this._listeners = e
                    }, _fixUndefForNames: function (e, t, i) {
                        for (var n = {}, r = 0, h = t.length; r < h; r++) {
                            var a = t[r];
                            n[a] = s(e[a], a, i)
                        }
                        return n
                    }
                }), e(i)
            });
        }],
        ['9Z', function (ym) {
            ym.modules.define("option.manager.LocalMonitor", ["util.defineClass"], function (t, i) {
                function e(t, i) {
                    this._monitor = t, this._defaultValues = i
                }

                i(e, {
                    add: function (t, i, e) {
                        return this._monitor.add(t, i, e, this._defaultValues), this
                    }, remove: function (t, i, e) {
                        return this._monitor.remove(t, i, e, this._defaultValues), this
                    }, get: function (t) {
                        return this._monitor.get(t, this._defaultValues)
                    }
                }), t(e)
            });
        }],
        ['2c', function (ym) {
            ym.modules.define("event.Manager", ["util.defineClass", "event.manager.Base", "Event", "util.extend"], function (t, e, n, i, r) {
                function s(t) {
                    s.superclass.constructor.call(this, t)
                }

                e(s, n, {
                    controllerMethods: ["onAfterEventFiring", "onBeforeEventFiring", "onStartListening", "onStopListening"],
                    setParent: function (t) {
                        return this.params.parent = t, this
                    },
                    getParent: function () {
                        return this.params.parent
                    },
                    fire: function (t, e) {
                        if (e && "function" == typeof e.get || (e = this.createEventObject(t, e, this.params.context)), !e.isPropagationStopped()) {
                            var n;
                            if (this.controllersHash.onBeforeEventFiring && (n = this.callControllers("onBeforeEventFiring", this, t, e)), n !== !1) {
                                e.isImmediatePropagationStopped() || s.superclass.fire.call(this, t, e), this.params.parent && !e.isPropagationStopped() && this.params.parent.fire(t, e);
                                var i = this.params.context;
                                if (e.get("target") == i && !e.isDefaultPrevented()) {
                                    var r, o = t + "defaultaction";
                                    this.controllersHash.onBeforeEventFiring && (r = this.getDefaultActionEvent(e, o, i), n = this.callControllers("onBeforeEventFiring", this, o, r)), n !== !1 && this.types[o] && (r || (r = this.getDefaultActionEvent(e, o, i)), s.superclass.fire.call(this, o, r)), this.controllersHash.onAfterEventFiring && (r || (r = this.getDefaultActionEvent(e, o, i)), this.callControllers("onAfterEventFiring", this, o, r))
                                }
                                this.controllersHash.onAfterEventFiring && this.callControllers("onAfterEventFiring", this, t, e)
                            }
                        }
                        return this
                    },
                    createEventObject: function (t, e, n) {
                        var s = {type: t, target: n};
                        return new i(e ? r(s, e) : s)
                    },
                    getDefaultActionEvent: function (t, e, n) {
                        return new i({type: e, target: n, originalEvent: t})
                    }
                }), t(s)
            });
        }],
        ['_3', function (ym) {
            ym.modules.define("projection.GeoToGlobalPixels", ["projection.Mercator", "coordSystem.geo", "util.math.cycleRestrict"], function (o, e, t, r) {
                o(function (o) {
                    function i(o) {
                        var e = o.getRadius();
                        if (e > h) return !1;
                        if (o.options.get("geodesic")) {
                            var r = o.getCoordinates();
                            if (t.getDistance(r, n(r)) <= e) return !1
                        }
                        return !0
                    }

                    function n(o) {
                        return "longlat" == ym.env.coordinatesOrder ? [o[0], o[1] > 0 ? 90 : -90] : [o[0] > 0 ? 90 : -90, o[1]]
                    }

                    var l = o && o.radius || 6378137, a = 2 * Math.PI * l, s = o.e || .0818191908426, c = s * s,
                        u = 1 - Math.sqrt(1 - c), h = (1 - u) * l, f = 1 / a, d = a / 2, G = 0, P = 180 / Math.PI,
                        b = 256 * f, m = o && "latlong" == o.coordinatesOrder;
                    this._mercator = new e(o), this.fromGlobalPixels = function (o, e) {
                        if (ym.env.debug) {
                            if (!o) throw new Error("GeoToGlobalPixels.fromGlobalPixels: не передан параметр vector");
                            if ("undefined" == typeof e) throw new Error("GeoToGlobalPixels.fromGlobalPixels: не передан параметр zoom")
                        }
                        e != G && (b = Math.pow(2, e + 8) * f, G = e);
                        var t = this._globalPixelXToGeo(o[0], e), r = this._mercator.yToLatitude(d - o[1] / b);
                        return m ? [r, t] : [t, r]
                    }, this.toGlobalPixels = function (o, e) {
                        if (ym.env.debug) {
                            if (!o) throw new Error("GeoToGlobalPixels.toGlobalPixels: не передан параметр point");
                            if ("undefined" == typeof e) throw new Error("GeoToGlobalPixels.toGlobalPixels: не передан параметр zoom")
                        }
                        e != G && (b = Math.pow(2, e + 8) * f, G = e);
                        var t = this._mercator.geoToMercator(o);
                        return [(d + t[0]) * b, (d - t[1]) * b]
                    }, this.distanceToGlobalPixels = function (o, e, t) {
                        if (ym.env.debug) {
                            if (!o) throw new Error("GeoToGlobalPixels.distanceToGlobalPixels: не передан параметр point");
                            if ("undefined" == typeof t) throw new Error("GeoToGlobalPixels.distanceToGlobalPixels: не передан параметр zoom")
                        }
                        var r = a * Math.cos(o[m ? 0 : 1] * Math.PI / 180) / Math.pow(2, t + 8);
                        return Math.abs(e / r)
                    }, this.getWorldGlobalPixelSize = function (o) {
                        var e = Math.pow(2, o + 8);
                        return [e, e]
                    }, this.isCycled = function () {
                        return [!0, !1]
                    }, this.getCoordSystem = function () {
                        return t
                    }, this._globalPixelXToGeo = function (o, e) {
                        return r(Math.PI * o / Math.pow(2, e + 7) - Math.PI, -Math.PI, Math.PI) * P
                    }, this.isGeometryValid = function (o) {
                        switch (o.getType()) {
                            case"Circle":
                                return i(o)
                        }
                        return !0
                    }
                })
            });
        }],
        ['8x', function (ym) {
            ym.modules.define("meta", [], function (e) {
                e({
                    version: ym.env.version,
                    coordinatesOrder: ym.env.coordinatesOrder,
                    mode: ym.env.debug ? "debug" : "release",
                    languageCode: ym.env.languageCode,
                    countryCode: ym.env.countryCode,
                    ns: ym.ns,
                    isEnterprise: !!ym.env.enterprise
                })
            });
        }],
        [',O', function (ym) {
            ym.modules.define("util.Storage", [], function (t) {
                var n = function () {
                    this.hash = {}
                };
                n.prototype = {
                    add: function (t, n) {
                        return this.hash[t] = n, this
                    }, get: function (t) {
                        return "string" == typeof t || t instanceof String ? this.hash[t] : t
                    }, remove: function (t) {
                        return delete this.hash[t], this
                    }
                }, t(n)
            });
        }],
        [',6', function (ym) {
            ym.modules.define("util.WeakMap", ["util.defineClass", "util.id"], function (e, t, i) {
                if ("undefined" == typeof WeakMap) {
                    var n = function () {
                        this._id = "__ymaps_WeakMap__" + i.get(this)
                    };
                    return t(n, {
                        set: function (e, t) {
                            var i = e[this._id];
                            return i && i[0] === e ? i[1] = t : Object.defineProperty(e, this._id, {
                                value: [e, t],
                                writable: !0
                            }), this
                        }, get: function (e) {
                            var t;
                            return (t = e[this._id]) && t[0] === e ? t[1] : void 0
                        }, remove: function (e) {
                            var t = e[this._id];
                            if ("undefined" == typeof t) return !1;
                            var i = t[0] === e;
                            return t[0] = t[1] = void 0, i
                        }, "delete": function (e) {
                            return this.remove(e)
                        }, has: function (e) {
                            var t = e[this._id];
                            return "undefined" != typeof t && t[0] === e
                        }
                    }), e(n)
                }
                var r = function () {
                    this._storage = new window.WeakMap
                };
                t(r, {
                    set: function (e, t) {
                        return this._storage.set(e, t), this
                    }, get: function (e) {
                        return this._storage.get(e)
                    }, remove: function (e) {
                        return this._storage["delete"](e)
                    }, "delete": function (e) {
                        return this.remove(e)
                    }, has: function (e) {
                        return this._storage.has(e)
                    }
                }), e(r)
            });
        }],
        [')i', function (ym) {
            ym.modules.define("util.math.areEqual", [], function (a) {
                a(function (a, t, e) {
                    return e = e || 1e-9, Math.abs(t[0] - a[0]) < e && Math.abs(t[1] - a[1]) < e
                })
            });
        }],
        ['1i', function (ym) {
            ym.modules.define("domEvent.Touch", ["util.defineClass", "domEvent.Base", "domEvent.touch.overrideStorage", "component.event.Cacher"], function (e, t, c, n, h) {
                function o(e, t, c) {
                    o.superclass.constructor.call(this, e, t), this._cache = {
                        type: t || e.type,
                        button: 0,
                        touches: c
                    }, this._cacher = null
                }

                t(o, c, {
                    get: function (e) {
                        return this._cacher || (this._cacher = new h(this, this._cache, n)), this._cacher.get(e)
                    }, clone: function (e) {
                        return new o(e, this._cache.type, this._cache.touches)
                    }
                }), e(o)
            });
        }],
        ['1)', function (ym) {
            ym.modules.define("domEvent.MultiTouch", ["util.defineClass", "domEvent.Base", "domEvent.multiTouch.overrideStorage", "component.event.Cacher"], function (e, t, c, h, n) {
                function i(e, t, c) {
                    i.superclass.constructor.call(this, e, t), this._cache = {
                        type: t || "multi" + e.type,
                        touches: c
                    }, this._cacher = null
                }

                t(i, c, {
                    get: function (e) {
                        return this._cacher || (this._cacher = new n(this, this._cache, h)), this._cacher.get(e)
                    }, clone: function (e) {
                        return new i(e, this._cache.type, this._cache.touches)
                    }
                }), e(i)
            });
        }],
        [')H', function (ym) {
            ym.modules.define("util.dom.event", ["system.browser"], function (e, n) {
                var t = {}, i = {};
                if (i.wheel = "Gecko" == n.engine || n.isIE && n.documentMode >= 9 ? "wheel" : "mousewheel", t.mousewheel = "wheel", i.mouseenter = "mouseover", i.mouseleave = "mouseout", t.mouseover = "mouseenter", t.mouseout = "mouseleave", "WebKit" == n.engine) i.transitionend = "webkitTransitionEnd", t.webkitTransitionEnd = "transitionend"; else if ("Presto" == n.engine) {
                    var o = function (e, n) {
                            for (var t = 0, i = Math.min(e.length, n.length); t < i;) {
                                if (e[t] > n[t]) return 1;
                                if (e[t] < n[t]) return -1;
                                t++
                            }
                            return 0
                        },
                        r = o(n.engineVersion.split(".").map(parseInt), [2, 10, 254]) >= 0 ? "otransitionend" : "oTransitionEnd";
                    i.transitionend = r, t[r] = "transitionend"
                }
                if ("MSIE" == n.name && 10 == n.documentMode || "IEMobile" == n.name && n.engineVersion < 7) for (var s = ["pointerdown", "pointerup", "pointercancel", "pointermove", "pointerover", "pointerout", "pointerenter", "pointerleave", "gotpointercapture", "lostpointercapture"], a = function (e) {
                    var n = e.split("pointer");
                    return "MS" + (n[0].length > 0 ? n[0][0].toUpperCase() + n[0].slice(1) : "") + "Pointer" + n[1][0].toUpperCase() + n[1].slice(1)
                }, u = 0, l = s.length; u < l; u++) {
                    var m = s[u], r = a(m);
                    i[m] = r, t[r] = m
                }
                var p = {};
                ("MSIE" == n.name && 10 == n.documentMode || "IEMobile" == n.name && n.engineVersion < 7) && (p[2] = "touch", p[3] = "pen", p[4] = "mouse"), !("hidden" in document) && "webkitHidden" in document && (i.visibilitychange = "webkitvisibilitychange", t.webkitvisibilitychange = "visibilitychange"), e({
                    getActualName: function (e) {
                        return "string" == typeof i[e] ? i[e] : e
                    }, getIdealName: function (e) {
                        return "string" == typeof t[e] ? t[e] : e
                    }, getIdealPointerType: function (e) {
                        var n = e.pointerType;
                        return p.hasOwnProperty(n) ? p[n] : n
                    }
                })
            });
        }],
        ['.y', function (ym) {
            ym.modules.define("system.browser", [], function (e) {
                e(ym.env.browser)
            });
        }],
        ['01', function (ym) {
            ym.modules.define("collection.Item", ["event.Manager", "option.Manager", "component.child.MapChild"], function (n, t, e, o) {
                function a(n) {
                    this.options = this.createOptionManager(n), this.events = new t({context: this}), this._itemImplementation = new o({
                        onParentChange: {
                            callback: this._onParentChange,
                            context: this
                        }, onMapChange: {callback: this._onMapChange, context: this}
                    }), this.options.events.add("change", function (n) {
                        this.events.fire("optionschange")
                    }, this)
                }

                a.prototype = {
                    getParent: function () {
                        return this._itemImplementation.getParent()
                    }, setParent: function (n) {
                        return this._itemImplementation.setParent(n), this
                    }, getMap: function () {
                        return this._itemImplementation.getMap()
                    }, onAddToMap: function (n) {
                    }, onRemoveFromMap: function (n) {
                    }, createOptionManager: function (n) {
                        return new e(n)
                    }, _onParentChange: function (n, t) {
                        this.events.fire("parentchange", {newParent: t, oldParent: n})
                    }, _onMapChange: function (n, t) {
                        n && this.onRemoveFromMap(n), t && this.onAddToMap(t), this.events.fire("mapchange", {
                            newMap: t,
                            oldMap: n
                        })
                    }
                }, n(a)
            });
        }],
        ['6X', function (ym) {
            ym.modules.define("layer.tile.CanvasTile", ["event.Manager", "option.Manager", "util.imageLoader", "util.scheduler.strategy.Processing", "util.dom.element", "localization.common.current", "layer.tile.storage", "util.cancelableCallback", "util.cancellation.Token"], function (e, t, i, n, s, r, a, o, l, h) {
                var d = a.layer.tileNotFound, _ = {}, c = function (e, s, r) {
                    return this.options = s.get && "function" == typeof s.get ? s : new i(s), this.events = new t({context: this}), this._error = !1, this._ready = !1, this._loaded = !1, this._rendered = !1, this._image = null, this._imageSize = [0, 0], this._context = null, this._clientPixelBounds = null, this._queuedTs = ym.performance.now(), this._loadedTs = void 0, this._renderedTs = void 0, this._readyTs = void 0, this._renderOptions = r || {}, this._url = e, this._imagePreprocessingCallbacks = null, this._loadingImageUrl = null, e ? void ("object" == typeof e && e.template && e.template.tileLoader ? this._runTileLoader() : (this._loadingImageUrl = e, n.load({
                        url: e,
                        priority: this._renderOptions.priority,
                        channel: "tiles",
                        crossOrigin: this.options.get("crossOrigin", !1),
                        decode: this.options.get("decode", !1)
                    }, this._onTileImageLoad, this))) : (this._error = !0, void this._processUrlLoadingError())
                };
                c.prototype = {
                    renderAt: function (e, t, i, n) {
                        this._clientPixelBounds = i, this._context = e, this._canvasSize = t, this._renderOptions.tileTransparent = this.options.get("tileTransparent"), this._renderOptions.animate = n && this.options.get("tileAnimateOpacity"), this._loaded && this._draw(), this._rendered = !0
                    }, getTimestamps: function () {
                        return {
                            queued: this._queuedTs,
                            loaded: this._loadedTs,
                            rendered: this._renderedTs,
                            ready: this._readyTs
                        }
                    }, getInfo: function () {
                        return {
                            url: "string" == typeof this._url ? this._url : null,
                            number: this._renderOptions.tileNumber.slice(0, 2),
                            zoom: this._renderOptions.tileZoom,
                            priority: this._renderOptions.priority
                        }
                    }, destroy: function () {
                        this._imageSource = null, this._loaded || n.cancel(this._loadingImageUrl, this._loadingImageUrl == this._url ? this._onTileImageLoad : this._onNotFoundTileLoad, this), this._imagePreprocessingCallbacks && (this._imagePreprocessingCallbacks.onSuccess.cancel(), this._imagePreprocessingCallbacks.onFail.cancel()), this._animation && this._animation.stop(), this._cancellationToken && (this._cancellationToken.cancel(), this._cancellationToken.close())
                    }, isReady: function () {
                        return this._ready
                    }, _onTileImageLoad: function (e, t, i) {
                        if (!this._loaded) if (this._error = !t, this._error) this._processUrlLoadingError(i); else {
                            var n = this.options.get("imagePreprocessor");
                            n ? this._preprocessImage(e, n) : this._setupImageSource(e)
                        }
                    }, _preprocessImage: function (e, t) {
                        this._imagePreprocessingCallbacks = {
                            onSuccess: l.create(this._setupImageSource, this),
                            onFail: l.create(this._processUrlLoadingError, this)
                        }, t(e, {
                            tileNumber: this._renderOptions.tileNumber,
                            tileZoom: this._renderOptions.tileZoom
                        }).then(this._imagePreprocessingCallbacks.onSuccess, this._imagePreprocessingCallbacks.onFail)
                    }, _processUrlLoadingError: function (e) {
                        if (e && this.events.fire("loaderror", {url: e.url}), this._renderOptions.tileTransparent) this._onReady(); else {
                            var t = this.options.get("notFoundTile");
                            "string" == typeof t ? (this._loadingImageUrl = t, n.load({
                                url: t,
                                priority: this._renderOptions.priority
                            }, this._onNotFoundTileLoad, this)) : this._setupImageSource(this._createDefaultErrorCanvas())
                        }
                    }, _onNotFoundTileLoad: function (e, t) {
                        this._setupImageSource(t ? e : this._createDefaultErrorCanvas())
                    }, _setupImageSource: function (e) {
                        this._loaded = !0, this._loadedTs = ym.performance.now(), this._imageSource = e, this._imageSize = [this._imageSource.naturalWidth || this._imageSource.width, this._imageSource.naturalHeight || this._imageSource.height], this._renderOptions.imageSize = this._imageSize, this._rendered && this._draw()
                    }, _runTileLoader: function () {
                        var e = this;
                        this._cancellationToken = new h, this._url.template.tileLoader({
                            priority: this._renderOptions.priority,
                            lang: ym.env.lang,
                            number: this._url.urlTemplateData.tileNumber,
                            zoom: this._url.urlTemplateData.zoom,
                            scale: this._url.urlTemplateData.scale
                        }, this._cancellationToken).then(function (t) {
                            e._onTileImageLoad(t.target, !0)
                        })["catch"](function () {
                            e._onTileImageLoad(null, !1)
                        })
                    }, _draw: function () {
                        if (this._animation && (this._animation.stop(), this._animation = null), this._error && this._renderOptions.tileTransparent) return void this._onReady();
                        var e = this.options.get("tileAnimationDuration", 350), t = 0;
                        this._renderOptions.animate && e ? (this._animation = new s(function (e) {
                            var i = e.progress, n = t ? (1 - i / t) / (1 - 1 / t) : i;
                            1 == i ? (n = 1, this._animation.stop(), this._animation = null) : t = i, this._context.globalAlpha = n, this._drawImage(), 1 == n && this._onReady()
                        }, this, {duration: e}), this._animation.start()) : (this._context.globalAlpha = 1, this._drawImage(), this._onReady())
                    }, _drawImage: function () {
                        var e = this._getIntersection();
                        if (e) {
                            var t = e[0], i = e[1];
                            this._context.drawImage(this._imageSource, Math.round(t[0][0]), Math.round(t[0][1]), Math.round(t[1][0] - t[0][0]), Math.round(t[1][1] - t[0][1]), Math.round(i[0][0]), Math.round(i[0][1]), Math.round(i[1][0] - i[0][0]), Math.round(i[1][1] - i[0][1])), this._renderedTs || (this._renderedTs = ym.performance.now())
                        }
                    }, _getIntersection: function () {
                        if (!this._clientPixelBounds) return null;
                        var e = this._canvasSize[0] < 1 || this._canvasSize[1] < 1 || this._imageSize[0] < 1 || this._imageSize[1] < 1,
                            t = [this._clientPixelBounds[0].slice(), this._clientPixelBounds[1].slice()],
                            i = t[1][0] <= 0 || t[1][1] <= 0 || t[0][0] >= this._canvasSize[0] || t[0][1] >= this._canvasSize[1];
                        if (e || i) return null;
                        var n = [[0, 0], this._imageSize.slice()],
                            s = [this._imageSize[0] / (t[1][0] - t[0][0]), this._imageSize[1] / (t[1][1] - t[0][1])],
                            r = [[Math.min(t[0][0], 0), Math.min(t[0][1], 0)], [Math.max(t[1][0] - this._canvasSize[0], 0), Math.max(t[1][1] - this._canvasSize[1], 0)]];
                        return t[0][0] -= r[0][0], n[0][0] -= Math.round(s[0] * r[0][0]), t[0][1] -= r[0][1], n[0][1] -= Math.round(s[1] * r[0][1]), t[1][0] -= r[1][0], n[1][0] -= Math.round(s[0] * r[1][0]), t[1][1] -= r[1][1], n[1][1] -= Math.round(s[1] * r[1][1]), n[0][0] == n[1][0] || n[0][1] == n[1][1] || t[0][0] == t[1][0] || t[0][1] == t[1][1] ? null : [n, t]
                    }, _createDefaultErrorCanvas: function () {
                        var e = this.options.get("tileSize", [256, 256]), t = e.join("x");
                        if (_[t]) return _[t];
                        var i = r.create({tagName: "canvas", css: {position: "absolute"}}), n = e[0], s = e[1],
                            a = i.getContext("2d"), o = d.split("<br/>"), l = 15, h = o.length,
                            c = Math.round((s - (h - 1) * l) / 2), u = Math.round(n / 2);
                        i.width = n, i.height = s, a.fillStyle = "rgb(190, 190, 190)", a.font = "10px Arial", a.textBaseline = "middle", a.textAlign = "center", a.fillRect(0, 0, n, s), a.fillStyle = "rgb(0, 0, 0)";
                        for (var g = 0, m = o.length; g < m; g++) a.fillText(o[g], u, c + g * l);
                        return _[t] = i
                    }, _onReady: function () {
                        this._ready = !0, this._readyTs = ym.performance.now(), this.events.fire("ready")
                    }
                }, o.add("default#canvas", c), e(c)
            });
        }],
        [')G', function (ym) {
            ym.modules.define("util.dom.element", ["util.dom.style", "util.dom.className", "system.browser"], function (e, t, n, r) {
                function s(e) {
                    return "string" != typeof e.className
                }

                function a(e) {
                    return Array.prototype.slice.call(e)
                }

                function i(e) {
                    e.style.cssText = e.getAttribute("data-ymaps-style"), e.removeAttribute("data-ymaps-style")
                }

                var l, o = ym.supports.csp.isSupported ? ym.env.server.params.csp : null, m = {
                    create: function (e) {
                        e = e || {};
                        var n = "string" == typeof e ? e : e.tagName || "ymaps",
                            r = e.namespace ? document.createElementNS(e.namespace, n) : document.createElement(n);
                        return e.className && (r.className = e.className), e.attr && t.attr(r, e.attr), e.css && t.css(r, e.css), e.patch && t.patch(r, e.patch), e.size && t.setSize(r, e.size), e.position && t.setPosition(r, e.position), e.html && (e.flags && e.flags.styleConvert || o && o.data_style ? this.html(r, e.html, e.flags || !0) : this._setHtml(r, e.html, !0)), e.parentNode && e.parentNode.appendChild(r), r
                    }, remove: function (e) {
                        e.parentNode && e.parentNode.removeChild(e)
                    }, destroy: function (e) {
                        l.appendChild(e), l.innerHTML = ""
                    }, _setHtml: function (e, t, n) {
                        if ("undefined" == typeof t) return e.innerHTML;
                        if (ym.env.debug && !n) {
                            for (var r = e, s = e.ownerDocument; r && r != s;) r = r.parentNode;
                            if (r != s) throw new Error("util.dom.element.html: попытка переопределить innerHTML у элемента, не добавленного в документ")
                        }
                        return e.innerHTML = t, null
                    }, html: function (e, t, n) {
                        if ("undefined" == typeof t) return e.innerHTML;
                        if (t = String(t), ym.env.debug && o && (!n || !n.styleConvert) && !o.data_style) {
                            var r = t.match(/ style=/i);
                            if (r && r.length > 0) throw new Error("util.dom.element.html: попытка записи inline-style при активной CSP")
                        }
                        if (o && (n && n.styleConvert || o.data_style)) {
                            o.data_style && (t = t.replace(/ style=/gi, " data-ymaps-style=")), this._setHtml(e, t, n), e.innerHTML = t;
                            var s = m.find(e, "[data-ymaps-style]", !0);
                            s.length && s.forEach(i)
                        } else this._setHtml(e, t, n);
                        return null
                    }, find: function (e, t, n) {
                        return n ? a(e.querySelectorAll(t)) : e.querySelector(t)
                    }, findByClassName: function (e, t, n) {
                        var r, s;
                        return e.getElementsByClassName ? (r = e.getElementsByClassName(t), s = n ? a(r) : r[0]) : s = m.find(e, "." + t, n), s
                    }, findByPrefixedClass: function (e, t, n) {
                        var r = ym.env.cssPrefix + t;
                        return m.findByClassName(e, r, n)
                    }, isNode: function (e) {
                        return e && "number" == typeof e.nodeType && "string" == typeof e.nodeName
                    }, isHTMLElement: function (e) {
                        return e && 1 === e.nodeType && "string" == typeof e.nodeName && !s(e)
                    }, isChildElement: function (e, t) {
                    }, hasParentWithClass: function (e, t) {
                        for (var r = e.parentNode; r && r != document;) {
                            if (n.has(r, t)) return !0;
                            r = r.parentNode
                        }
                        return !1
                    }
                };
                l = m.create(), e(m)
            });
        }],
        [')O', function (ym) {
            ym.modules.define("util.dom.style", ["util.dom.className", "util.css", "system.browser", "util.array"], function (e, t, r, n, o) {
                function a(e, t, r, n) {
                    switch (t) {
                        case"selectable":
                            k.selectable(e, r), i(e, "selectable", r, !0);
                            break;
                        case"zIndex":
                            e.style.zIndex = r;
                            break;
                        case"scaledBackground":
                            k.backgroundImage(e, r);
                            break;
                        case"transform":
                            k.transform(e, r, r.use3D);
                            break;
                        case"opacity":
                            k.opacity(e, r);
                            break;
                        case"printBackground":
                            k.printBackground(e, r);
                            break;
                        default:
                            n || i(e, t, r)
                    }
                }

                function i(e, t, r, n) {
                    var o = b(t);
                    return o ? ("undefined" == typeof r ? (e.style.removeAttribute && e.style.removeAttribute(o, !1), e.style.removeProperty && e.style.removeProperty(o)) : e.style[o] = r, !0) : !n && a(e, t, r, !0)
                }

                function d(e) {
                    return e.style["box-sizing"] || "content-box"
                }

                function l(e, t) {
                    for (var r, n = Object.keys(t), o = n.length; o--;) r = n[o], "undefined" == typeof t[r] ? e.removeAttribute(r) : e.setAttribute(r, t[r])
                }

                function s(e, t) {
                    for (var r, n = Object.keys(t), o = n.length; o--;) r = n[o], i(e, r, t[r])
                }

                function u(e) {
                    var t = 32760;
                    return (n.isMobile || n.isTablet) && (t = 7e3), Math.max(Math.min(e, t), -t)
                }

                var n = ym.env.browser, c = ["paddingLeft", "paddingRight", "paddingTop", "paddingBottom"],
                    f = ["borderLeftWidth", "borderRightWidth", "borderTopWidth", "borderBottomWidth"], p = c.concat(f),
                    g = document.defaultView, b = ym.supports.css.checkProperty, m = n.chrome ? "1px" : "0",
                    y = "Gecko" == n.engine, v = function (e) {
                        e.preventDefault()
                    }, h = {}, k = {
                        backgroundImage: function (e, t) {
                            t ? (e.style.backgroundRepeat = "no-repeat", e.style.backgroundSize = "100% 100%", o.isArray(t) || (t = [t]), e.style.backgroundImage = "url(" + t.join("), url(") + ")") : (e.style.backgroundRepeat = "", e.style.backgroundSize = "", e.style.backgroundImage = "")
                        }, selectable: function (e, n) {
                            n ? (e.removeEventListener("selectstart", v), h.attr(e, {unselectable: void 0}), t.remove(e, r.addPrefix("user-selection-none"))) : (e.addEventListener("selectstart", v), h.attr(e, {unselectable: "on"}), t.add(e, r.addPrefix("user-selection-none")))
                        }, transform: function (e, t, r) {
                            e.style[ym.supports.css.checkProperty("transform")] = this.getTransformValue(t, r)
                        }, getTransformValue: function (e, t) {
                            var r = e.offset || ["0", "0"], n = e.scale, o = e.rotate, a = typeof n;
                            return "undefined" == a ? n = ["1", "1"] : "string" != a && "number" != a || (n = [n, n]), r[0] = u(r[0]), r[1] = u(r[1]), (t && ym.env.browser.css3DTransform ? "translate3d(" + r[0] + "px," + r[1] + "px, " + m + ")" : "translate(" + r[0] + "px," + r[1] + "px)") + "scale(" + n[0] + "," + n[1] + ")" + (o ? "rotate(" + o + ")" : "")
                        }, opacity: function (e, t) {
                            e.style.opacity = t
                        }, printBackground: function (e, n) {
                            if (ym.supports.printPatchNeeded) {
                                var o = r.addPrefix("patched-for-print");
                                n ? (e.style.listStyleImage = "url(" + n + ")", t.add(e, o)) : (t.remove(e, o), e.style.listStyleImage = "")
                            }
                        }
                    };
                h = {
                    attr: l, css: s, setPosition: function (e, t) {
                        e.style.left = u(Math.round(t[0])) + "px", e.style.top = u(Math.round(t[1])) + "px"
                    }, setSize: function (e, t, r) {
                        var n = t[0], o = t[1];
                        if (e.parentNode) {
                            var a = d(e), i = r && r.includePadding, l = r && r.includeBorder;
                            if ("content-box" == a && i || "content-box" != a && !i) {
                                var s = h.value(e, "paddingLeft") + h.value(e, "paddingRight"),
                                    u = h.value(e, "paddingTop") + h.value(e, "paddingBottom");
                                i && (s *= -1, u *= -1), n += s, o += u
                            }
                            if ("border-box" == a && !l || "border-box" != a && l) {
                                var c = h.value(e, "borderLeftWidth") + h.value(e, "borderRightWidth"),
                                    f = h.value(e, "borderTopWidth") + h.value(e, "borderBottomWidth");
                                l && (c *= -1, f *= -1), n += c, o += f
                            }
                        }
                        e.style.width = (n < 0 ? 0 : n) + "px", e.style.height = (o < 0 ? 0 : o) + "px"
                    }, getSize: function (e, t) {
                        var r = !t || !t.includePadding, n = !t || !t.includeBorder, o = e.offsetWidth,
                            a = e.offsetHeight;
                        if (e.parentNode) {
                            var i;
                            if (r && n ? i = p : r ? i = c : n && (i = f), i) {
                                var d = this.values(e, i);
                                "paddingLeft" in d && (o -= d.paddingLeft + d.paddingRight, a -= d.paddingTop + d.paddingBottom), "borderLeftWidth" in d && (o -= d.borderLeftWidth + d.borderRightWidth, a -= d.borderTopWidth + d.borderBottomWidth)
                            }
                        }
                        return [o < 0 ? 0 : o, a < 0 ? 0 : a]
                    }, getOffset: function (e, t) {
                        var r = 0, n = 0;
                        if (t) if (e.getBoundingClientRect) var o = e.getBoundingClientRect(), a = e.ownerDocument.body,
                            i = e.ownerDocument.documentElement, d = i.clientTop || a.clientTop || 0,
                            l = i.clientLeft || a.clientLeft || 0,
                            r = (y ? Math.round(o.left) : o.left) + (window.self.pageXOffset || i.scrollLeft || a.scrollLeft) - l,
                            n = (y ? Math.round(o.top) : o.top) + (window.self.pageYOffset || i.scrollTop || a.scrollTop) - d; else for (; e && e.offsetParent;) r += e.offsetLeft, n += e.offsetTop, e = e.offsetParent; else r = e.offsetLeft, n = e.offsetTop;
                        return [r, n]
                    }, value: function (e, t, r) {
                        var n, o = g.getComputedStyle(e, null);
                        return o ? (n = o.getPropertyValue(t.replace(/[A-Z]/g, "-$&").toLowerCase()), r ? n : parseInt(n, 10)) : null
                    }, values: function (e, t) {
                        var r = {}, n = g.getComputedStyle(e, null);
                        if (!n) return {};
                        for (var o = 0, a = t.length; o < a; o++) {
                            var i = t[o];
                            r[i] = parseInt(n.getPropertyValue(i.replace(/[A-Z]/g, "-$&").toLowerCase()), 10)
                        }
                        return r
                    }, checkVisibility: function (e) {
                        try {
                            if (document.elementFromPoint && e.getBoundingClientRect) {
                                var t = e.getBoundingClientRect(),
                                    r = document.elementFromPoint(Math.round((t.left + t.right) / 2), Math.round((t.top + t.bottom) / 2));
                                if (null === r) return "invisible";
                                for (; r && r != e;) r = r.parentNode ? r.parentNode : null;
                                return r ? "visible" : "blocked"
                            }
                            return "unable"
                        } catch (n) {
                            return "unable"
                        }
                    }, patch: function (e, t) {
                        for (var r in t) if (t.hasOwnProperty(r)) {
                            var n = t[r];
                            a(e, r, n)
                        }
                    }, scaledBackgroundImage: k.backgroundImage
                }, e(h)
            });
        }],
        [',T', function (ym) {
            ym.modules.define("util.tile.Storage", ["event.Manager"], function (e, i) {
                function t(e) {
                    this._tileZoom = e, this._rows = {}, this._pendingTilesNumber = 0, this.events = new i({context: this})
                }

                t.prototype = {
                    getTileZoom: function () {
                        return this._tileZoom
                    }, get: function (e) {
                        var i = this._rows[e[0]];
                        return i ? i.list[e[1]] : null
                    }, add: function (e, i) {
                        var t = this._rows[+e[0]] || (this._rows[+e[0]] = {list: {}, count: 0});
                        t.list[+e[1]] = i, t.count++, i.isReady() || (i.events.add("ready", this._onTileReady, this), i.events.add("loaded", this._onTileLoaded, this), i.events.add("loaderror", this._onTileLoadError, this), this._pendingTilesNumber++), this.events.fire("tileadd")
                    }, remove: function (e) {
                        var i = this._rows[e[0]];
                        if (i && i.list[e[1]]) {
                            var t = i.list[e[1]];
                            t.isReady() || (t.events.remove("ready", this._onTileReady, this), t.events.remove("loaded", this._onTileLoaded, this), t.events.remove("loaderror", this._onTileLoadError, this), --this._pendingTilesNumber || this.events.fire("ready")), i.list[e[1]] = null, --i.count || (this._rows[e[0]] = null, delete this._rows[e[0]]), this.events.fire("tileremove")
                        }
                    }, removeAll: function () {
                        this.each(function (e) {
                            e.isReady() || (e.events.remove("ready", this._onTileReady, this), e.events.remove("loaded", this._onTileLoaded, this), e.events.remove("loaderror", this._onTileLoadError, this))
                        }, this), this._rows = {}, this._pendingTilesNumber = 0, this.events.fire("ready"), this.events.fire("tileremoveall")
                    }, each: function (e, i) {
                        for (var t in this._rows) if (this._rows[+t] && this._rows.hasOwnProperty(t)) {
                            var s = this._rows[+t].list;
                            for (var r in s) s[+r] && s.hasOwnProperty(r) && e.call(i, s[r], [+t, +r])
                        }
                    }, getPendingTilesNumber: function () {
                        return this._pendingTilesNumber
                    }, getTotalTilesNumber: function () {
                        var e = 0;
                        for (var i in this._rows) e += this._rows[i].count;
                        return e
                    }, _onTileReady: function (e) {
                        var i = e.get("target");
                        i.events.remove("ready", this._onTileReady, this), i.events.remove("loaded", this._onTileLoaded, this), i.events.remove("loaderror", this._onTileLoadError, this), --this._pendingTilesNumber || this.events.fire("ready"), this.events.fire("tileready", {tile: i})
                    }, _onTileLoaded: function (e) {
                        this.events.fire("statechange")
                    }, _onTileLoadError: function (e) {
                        this.events.fire("tileloaderror", e)
                    }
                }, e(t)
            });
        }],
        [')z', function (ym) {
            ym.modules.define("util.math.areEqualPaths", ["util.math.areEqual"], function (t, e) {
                t(function n(t, r, u, a, l) {
                    if (t.length == r.length) {
                        for (var i = 0; i < t.length; i++) {
                            var f = u ? n(t[i], r[i], u - 1, a, l) : a ? e(t[i], r[i], l) : t[i][0] == r[i][0] && t[i][1] == r[i][1];
                            if (!f) return !1
                        }
                        return !0
                    }
                    return !1
                })
            });
        }],
        [').', function (ym) {
            ym.modules.define("util.hd", [], function (e) {
                var t = ym.env.browser;
                e({
                    getPixelRatio: function () {
                        return Math.max(1, window.devicePixelRatio || screen.deviceXDPI && screen.deviceXDPI / 96 || 1)
                    }, getLimitedPixelRatio: function () {
                        var e = this.getPixelRatio();
                        return t.isMobile ? Math.min(2, e) : t.isTablet ? Math.min(2.5, e) : e
                    }, getRatioFactors: function () {
                        var e = this.getPixelRatio(), t = 1, i = e * t,
                            a = {ratio: e, realRatio: Math.min(e, Math.ceil(2 * i) / 2)};
                        return a.perfect = a.realRatio == e, a
                    }, getBackingStorePixelRatio: function (e) {
                        return e.webkitBackingStorePixelRatio || e.mozBackingStorePixelRatio || e.msBackingStorePixelRatio || e.oBackingStorePixelRatio || e.backingStorePixelRatio || 1
                    }, selectValue: function (e) {
                        if ("object" == typeof e) {
                            var t = this.selectRatio(e);
                            if (e[t]) return e[t]
                        }
                        return e
                    }, selectRatio: function (e) {
                        if ("object" != typeof e) return 1;
                        var t, i, a, o = this.getPixelRatio();
                        if (o > 1) {
                            for (var r in e) if (e.hasOwnProperty(r)) {
                                if (a = parseFloat(r), "undefined" == typeof t && (t = a), a == o) return a;
                                i = a - o, i > 0 ? Math.abs(t - o) > i && (t = a) : a > t && (t = a)
                            }
                            return t
                        }
                        return 1
                    }
                })
            });
        }],
        [',k', function (ym) {
            ym.modules.define("util.pixelBounds", ["util.array", "util.margin"], function (n, t, e) {
                var r = {
                    fromPoints: function (n) {
                        var t;
                        if (n.length) {
                            for (var e, r = n[0].slice(0), a = r.slice(0), i = 0, u = n.length; u; ++i, --u) e = n[i], r[0] > e[0] && (r[0] = e[0]), r[1] > e[1] && (r[1] = e[1]), a[0] < e[0] && (a[0] = e[0]), a[1] < e[1] && (a[1] = e[1]);
                            t = [r, a]
                        } else t = null;
                        return t
                    }, fromBounds: function (n) {
                        if (1 == n.length) return this.clone(n[0]);
                        var e = [[1 / 0, 1 / 0], [-(1 / 0), -(1 / 0)]];
                        return t.each(n, function (n) {
                            e[0][0] = Math.min(e[0][0], n[0][0]), e[1][0] = Math.max(e[1][0], n[1][0]), e[0][1] = Math.min(e[0][1], n[0][1]), e[1][1] = Math.max(e[1][1], n[1][1])
                        }), e
                    }, clone: function (n) {
                        return [[n[0][0], n[0][1]], [n[1][0], n[1][1]]]
                    }, getCenter: function (n) {
                        return [.5 * (n[0][0] + n[1][0]), .5 * (n[0][1] + n[1][1])]
                    }, getSize: function (n) {
                        return [Math.abs(n[1][0] - n[0][0]), Math.abs(n[1][1] - n[0][1])]
                    }, areIntersecting: function (n, t) {
                        var e = r.getCenter(n), a = r.getCenter(t), i = e[0] - a[0], u = e[1] - a[1], o = r.getSize(n),
                            c = r.getSize(t);
                        return Math.abs(i) < .5 * (o[0] + c[0]) && Math.abs(u) < .5 * (o[1] + c[1])
                    }, getIntersection: function (n, t) {
                        var e = null;
                        return this.areIntersecting(n, t) && (e = [[Math.max(n[0][0], t[0][0]), Math.max(n[0][1], t[0][1])], [Math.min(n[1][0], t[1][0]), Math.min(n[1][1], t[1][1])]]), e
                    }, containsPoint: function (n, t) {
                        return t[0] >= n[0][0] && t[0] <= n[1][0] && t[1] >= n[0][1] && t[1] <= n[1][1]
                    }, containsBounds: function (n, t) {
                        return n[0][0] <= t[0][0] && n[1][0] >= t[1][0] && n[0][1] <= t[0][1] && n[1][1] >= t[1][1]
                    }, fit: function (n, t, r) {
                        var a = [0, 0], i = t[0], u = t[1], o = e.correct(r),
                            c = [[i[0] + Number(o[3]), i[1] + Number(o[0])], [u[0] - Number(o[1]), u[1] - Number(o[2])]];
                        return n[0][0] < c[0][0] ? a[0] = c[0][0] - n[0][0] : n[1][0] > c[1][0] && (a[0] = Math.max(c[1][0] - n[1][0], c[0][0] - n[0][0])), n[0][1] < c[0][1] ? a[1] = c[0][1] - n[0][1] : n[1][1] > c[1][1] && (a[1] = Math.max(c[1][1] - n[1][1], c[0][1] - n[0][1])), a[0] || a[1] ? a : null
                    }
                };
                n(r)
            });
        }],
        ['2a', function (ym) {
            ym.modules.define("event.Group", ["util.defineClass"], function (e, s) {
                function t(e) {
                    this.events = e, this._listeners = []
                }

                s(t, {
                    add: function (e, s, t, i) {
                        if ("string" == typeof e) this._listeners.push(e, s, t, i); else for (var n = 0, r = e.length; n < r; n++) this._listeners.push(e[n], s, t, i);
                        return this.events.add(e, s, t, i), this
                    }, remove: function (e, s, t, i) {
                        if ("string" == typeof e) this._removeListener(e, s, t, i); else for (var n = 0, r = e.length; n < r; n++) this._removeListener(e[n], s, t, i);
                        return this
                    }, removeAll: function () {
                        for (var e = 0, s = this._listeners.length; e < s; e += 4) this.events.remove(this._listeners[e], this._listeners[e + 1], this._listeners[e + 2], this._listeners[e + 3]);
                        return this._listeners = [], this
                    }, getLength: function () {
                        return this._listeners.length / 4
                    }, _removeListener: function (e, s, t, i) {
                        for (var n = 0, r = this._listeners.length; n < r; n += 4) if (this._listeners[n] == e && this._listeners[n + 1] == s && this._listeners[n + 2] == t && this._listeners[n + 3] == i) {
                            this._listeners.splice(n, 4), this.events.remove(e, s, t, i);
                            break
                        }
                    }
                }), e(t)
            });
        }],
        ['_5', function (ym) {
            ym.modules.define("projection.Mercator", ["util.math.restrict", "util.math.cycleRestrict"], function (t, a, i) {
                t(function (t) {
                    var n = t && t.radius || 6378137, o = t && "undefined" != typeof t.e ? t.e : .0818191908426,
                        e = t && "latlong" == t.coordinatesOrder, h = o * o, r = h * h, u = r * h, M = r * r, s = 1 / n,
                        c = h / 2 + 5 * r / 24 + u / 12 + 13 * M / 360, d = 7 * r / 48 + 29 * u / 240 + 811 * M / 11520,
                        f = 7 * u / 120 + 81 * M / 1120, l = 4279 * M / 161280, T = Math.PI / 180, I = 180 / Math.PI;
                    this.mercatorToGeo = function (t) {
                        var a = this.xToLongitude(t[0]), i = this.yToLatitude(t[1]);
                        return e ? [i, a] : [a, i]
                    }, this.geoToMercator = function (t) {
                        return [this.longitudeToX(t[e ? 1 : 0]), this.latitudeToY(t[e ? 0 : 1])]
                    }, this.xToLongitude = function (t) {
                        return i(t * s, -Math.PI, Math.PI) * I
                    }, this.yToLatitude = function (t) {
                        var a = .5 * Math.PI - 2 * Math.atan(1 / Math.exp(t * s)),
                            i = a + c * Math.sin(2 * a) + d * Math.sin(4 * a) + f * Math.sin(6 * a) + l * Math.sin(8 * a);
                        return i * I
                    }, this.longitudeToX = function (t) {
                        var a = i(t * T, -Math.PI, Math.PI);
                        return n * a
                    }, this.latitudeToY = function (t) {
                        var i = 1e-10, e = a(t, -90 + i, 90 - i) * T, h = o * Math.sin(e),
                            r = Math.tan(.25 * Math.PI + .5 * e),
                            u = Math.pow(Math.tan(.25 * Math.PI + .5 * Math.asin(h)), o), M = r / u;
                        return n * Math.log(M)
                    }
                })
            });
        }],
        ['1W', function (ym) {
            ym.modules.define("coordSystem.geo", ["util.math.cycleRestrict"], function (t, a) {
                var n = ym.env.coordinatesOrder, h = function (t) {
                        return t < 0 ? -1 : t > 0 ? 1 : 0
                    }, M = 6378137, s = .00669437999014, i = 1 - Math.sqrt(1 - s), o = (1 - i) * M, c = 1e-10,
                    e = function (t) {
                        return t * t
                    }, r = function (t) {
                        return Math.abs(t - h(t) * Math.PI / 2) < c ? h(t) * Math.PI / 2 : Math.atan((1 - i) * Math.tan(t))
                    }, l = function (t) {
                        return [t[1], t[0]]
                    }, P = function (t) {
                        return Math.max(Math.min(t, 89.999), -89.999)
                    }, u = {
                        solveDirectProblem: function (t, s, e) {
                            "longlat" == n && (t = l(t), s = l(s)), t[0] = P(t[0]);
                            var r = t[0] * Math.PI / 180, u = t[1] * Math.PI / 180,
                                d = Math.sqrt(s[0] * s[0] + s[1] * s[1]), I = s[0] / d, v = s[1] / d,
                                f = (1 - i) * Math.tan(r), g = h(Math.cos(r)) * Math.sqrt(1 / (1 + f * f)),
                                m = Math.sqrt(1 - g * g) * h(f), D = Math.atan2(f, I), b = g * v, q = (1 - b) * (1 + b),
                                p = q * (M * M / (o * o) - 1),
                                y = 1 + p * (4096 + p * (-768 + p * (320 - 175 * p))) / 16384,
                                w = p * (256 + p * (-128 + p * (74 - 47 * p))) / 1024, x = function (t) {
                                    var h, M = e * t, s = M / (o * y), r = D + s / 2, P = Math.cos(2 * r), d = 0, f = 0;
                                    do {
                                        var p = w * Math.sin(s) * (P + .25 * w * (Math.cos(s) * (-1 + 2 * P * P) - 1 / 6 * w * P * (-3 + 4 * Math.sin(s) * Math.sin(s)) * (-3 + 4 * P * P))),
                                            h = p - f;
                                        f = p, s = M / (o * y) + p, d++
                                    } while (Math.abs(h) > c && d < 10);
                                    var x = m * Math.sin(s) - g * Math.cos(s) * I,
                                        F = Math.atan2(m * Math.cos(s) + g * Math.sin(s) * I, (1 - i) * Math.sqrt(b * b + x * x)),
                                        O = Math.atan2(Math.sin(s) * v, g * Math.cos(s) - m * Math.sin(s) * I),
                                        R = i / 16 * q * (4 + i * (4 - 3 * q)),
                                        S = O - (1 - R) * i * b * (s + R * Math.sin(s) * (P + R * Math.cos(s) * (-1 + 2 * P * P))),
                                        j = Math.atan2(b, -m * Math.sin(s) + g * Math.cos(s) * I),
                                        k = [180 * F / Math.PI, a(180 * (u + S) / Math.PI, -180, 180)],
                                        z = [Math.cos(j), Math.sin(j)];
                                    return {point: "longlat" == n ? l(k) : k, direction: "longlat" == n ? l(z) : z}
                                }, F = x(1);
                            return {
                                startPoint: "longlat" == n ? l(t) : t,
                                startDirection: "longlat" == n ? l(s) : s,
                                endPoint: F.point,
                                endDirection: F.direction,
                                distance: e,
                                pathFunction: x
                            }
                        }, solveInverseProblem: function (t, s, u) {
                            var d, I = this.solveDirectProblem;
                            if (t == s || t[0] == s[0] && t[1] == s[1]) d = {
                                startPoint: t,
                                startDirection: [1, 1],
                                endPoint: s,
                                endDirection: [1, 1],
                                distance: 0
                            }; else {
                                "longlat" == n && (t = l(t), s = l(s)), t[0] = P(t[0]), s[0] = P(s[0]);
                                var v, f = t[0] * Math.PI / 180, g = s[0] * Math.PI / 180,
                                    m = (s[1] - t[1]) * Math.PI / 180, D = r(f), b = r(g), q = m, p = q, y = 0, w = [],
                                    x = [], F = 0;
                                if (0 == f && 0 == g) {
                                    var O = a(s[1] - t[1], u ? -360 : -180, u ? 360 : 180);
                                    w = x = [0, O > 0 ? 1 : -1], F = 2 * Math.PI * M / 360 * Math.abs(O)
                                } else {
                                    var R, S, j, k, z, A, B;
                                    do R = Math.sqrt(e(Math.cos(b) * Math.sin(q)) + e(Math.cos(D) * Math.sin(b) - Math.sin(D) * Math.cos(b) * Math.cos(q))), S = Math.sin(D) * Math.sin(b) + Math.cos(D) * Math.cos(b) * Math.cos(q), z = u ? 2 * Math.PI - Math.atan2(R, S) : Math.atan2(R, S), j = Math.cos(D) * Math.cos(b) * Math.sin(q) / Math.sin(z), k = 1 - e(j), A = Math.cos(z) - 2 * Math.sin(D) * Math.sin(b) / k, B = i / 16 * k * (4 + i * (4 - 3 * k)), q = Math.min(Math.max(m + (1 - B) * i * j * (z + B * Math.sin(z) * (A + B * Math.cos(z) * (-1 + 2 * A * A))), -2 * Math.PI), 2 * Math.PI), v = Math.abs(p - q), p = q, y++; while (v > c && y < 10);
                                    var C = k * (M * M - o * o) / (o * o),
                                        E = 1 + C * (4096 + C * (-768 + C * (320 - 175 * C))) / 16384,
                                        G = C * (256 + C * (-128 + C * (74 - 47 * C))) / 1024,
                                        H = G * Math.sin(z) * (A + .25 * G * (Math.cos(z) * (-1 + 2 * A * A) - 1 / 6 * G * A * (-3 + 4 * Math.sin(z) * Math.sin(z)) * (-3 + 4 * A * A))),
                                        J = Math.atan2(Math.cos(b) * Math.sin(q), Math.cos(D) * Math.sin(b) - Math.sin(D) * Math.cos(b) * Math.cos(q)),
                                        K = Math.atan2(Math.cos(D) * Math.sin(q), -Math.sin(D) * Math.cos(b) + Math.cos(D) * Math.sin(b) * Math.cos(q));
                                    F = o * E * (z - H), u && (J -= h(J - Math.PI) * Math.PI, K -= h(K - Math.PI) * Math.PI), w = [Math.cos(J), Math.sin(J)], x = [Math.cos(K), Math.sin(K)]
                                }
                                d = {
                                    startPoint: "longlat" == n ? l(t) : t,
                                    startDirection: "longlat" == n ? l(w) : w,
                                    endPoint: "longlat" == n ? l(s) : s,
                                    endDirection: "longlat" == n ? l(x) : x,
                                    distance: F
                                }
                            }
                            return d.pathFunction = function (t) {
                                var a = I(d.startPoint, d.startDirection, d.distance * t);
                                return {point: a.endPoint, direction: a.endDirection}
                            }, d
                        }, getDistance: function (t, a) {
                            return this.solveInverseProblem(t, a).distance
                        }
                    };
                u.distance = u.getDistance, t(u)
            });
        }],
        [')I', function (ym) {
            ym.modules.define("util.math.cycleRestrict", [], function (e) {
                e(function (e, t, r) {
                    if (ym.env.debug) {
                        if ("undefined" == typeof e || null == e) throw new Error("util.math.cycleRestrict: не передан параметр value");
                        if ("undefined" == typeof t || null == t) throw new Error("util.math.cycleRestrict: не передан параметр min");
                        if ("undefined" == typeof r || null == r) throw new Error("util.math.cycleRestrict: не передан параметр max")
                    }
                    return e == Number.POSITIVE_INFINITY ? r : e == Number.NEGATIVE_INFINITY ? t : e - Math.floor((e - t) / (r - t)) * (r - t)
                })
            });
        }],
        ['0$', function (ym) {
            ym.modules.define("component.event.Cacher", [], function (e) {
                function t(e, t, n) {
                    this._cache = t, this._overrideStorage = n, this._event = e, this._cacheManager = null
                }

                function n(e) {
                    return {
                        set: function (t, n) {
                            e[t] = n
                        }
                    }
                }

                var i = {};
                t.prototype = {
                    get: function (e) {
                        var t = this._cache, r = t[e];
                        if ("undefined" == typeof r) {
                            var a = this._overrideStorage.get(e), c = this._event;
                            if (a && !this._cacheManager && (this._cacheManager = n(t)), r = a ? a(c, this._cacheManager) : c.originalEvent[e], "undefined" == typeof r) return void (t[e] = i);
                            t[e] = r
                        }
                        return r == i ? void 0 : r
                    }
                }, e(t)
            });
        }],
        ['06', function (ym) {
            ym.modules.define("component.child.MapChild", ["component.child.BaseChild"], function (t, a) {
                var n = function (t) {
                    this._oldMap = null, this._map = null, this._callbacks = t, this._baseItem = new a(this._parentChangeCallback, this)
                }, e = "mapchange";
                n.prototype = {
                    setParent: function (t) {
                        this._baseItem.setParent(t)
                    }, getParent: function () {
                        return this._baseItem.getParent()
                    }, getMap: function () {
                        return this._map
                    }, _parentChangeCallback: function (t, a) {
                        t && t.events.remove(e, this._onMapChange, this), this._setupMap(null);
                        var n = this._callbacks.onParentChange;
                        n && n.callback.call(n.context, t, a), this._setupMap(a && a.getMap()), a && a.events.add(e, this._onMapChange, this)
                    }, _setupMap: function (t) {
                        if (this._map != t) {
                            this._map = t;
                            var a = this._callbacks.onMapChange;
                            a && a.callback.call(a.context, this._oldMap, this._oldMap = this._map)
                        }
                    }, _onMapChange: function (t) {
                        this._setupMap(t.get("newMap"))
                    }
                }, t(n)
            });
        }],
        ['(@', function (ym) {
            ym.modules.define("util.AsyncStorage", ["util.defineClass", "util.Storage", "system.nextTick", "vow", "util.id"], function (e, t, s, i, r, n) {
                var o = {NOT_RESOLVED: "NOT_RESOLVED", IN_RESOLVING: "IN_RESOLVING", RESOLVED: "RESOLVED"},
                    u = function (e) {
                        u.superclass.constructor.call(this), this._modulesSystemKey = e, this._declareHash = {}, this._requireQueue = [], this._waitingForNextTick = !1
                    };
                u.createKeyNotFoundError = function (e) {
                    return new Error('The key "' + e + "\" isn't declared")
                }, t(u, s, {
                    define: function (e, t, s, i) {
                        if ("function" == typeof t && (i = s, s = t, t = []), this._modulesSystemKey) {
                            for (var r = [], u = 0, a = t.length; u < a; u++) r.push({
                                key: t[u],
                                storage: this._modulesSystemKey
                            });
                            ym.modules.define({
                                key: e,
                                storage: this._modulesSystemKey,
                                name: n.get(this) + "_" + e + "_" + this._modulesSystemKey,
                                depends: r,
                                context: i,
                                declaration: s
                            })
                        } else this._declareHash[e] = {
                            key: e,
                            depends: t,
                            callback: s,
                            context: i,
                            state: o.NOT_RESOLVED,
                            waitingForResolving: []
                        };
                        return this
                    }, add: function (e, t) {
                        return this._modulesSystemKey ? ym.modules.defineSync({
                            key: e,
                            storage: this._modulesSystemKey,
                            name: n.get(this) + "_" + e + "_" + this._modulesSystemKey,
                            module: t
                        }) : u.superclass.add.call(this, e, t), this
                    }, get: function (e, t) {
                        var s = u.superclass.get.call(this, e);
                        return !s && this._modulesSystemKey ? ym.modules.requireSync({
                            modules: [{
                                key: e,
                                storage: this._modulesSystemKey
                            }], data: t
                        }) : s
                    }, isDefined: function (e) {
                        return this._modulesSystemKey ? this._isDefinedInModulesSystem(e) : this._isDefinedInStorage(e)
                    }, require: function (e, t, s, i) {
                        var n, o = r.defer(), a = o.promise(), l = [];
                        if (3 == arguments.length && "function" != typeof s && (i = s, s = null), "string" == typeof e) e = [e]; else if (!e.hasOwnProperty("length") && "object" == typeof e) {
                            var c = e;
                            e = c.keys, t = c.successCallback, s = c.errorCallback, i = c.context, n = c.data
                        }
                        for (var d = 0, h = e.length; d < h; d++) {
                            var y = e[d];
                            this._modulesSystemKey ? this._isDefinedInModulesSystem(y) ? l.push({
                                key: y,
                                storage: this._modulesSystemKey
                            }) : o.reject(u.createKeyNotFoundError(y)) : this._isDefinedInStorage(y) || o.reject(u.createKeyNotFoundError(y))
                        }
                        return a.isRejected() || (l.length > 0 ? ym.modules.require({
                            modules: l,
                            data: n
                        }).done(function (t) {
                            this._addRequireToQueue(e, o)
                        }, function (e) {
                            o.reject(e)
                        }, this) : this._addRequireToQueue(e, o)), (t || s) && a.done(function (e) {
                            t && t.apply(i, e)
                        }, function (e) {
                            s && s.call(i, e)
                        }), a
                    }, _isDefinedInStorage: function (e) {
                        return !!this.get(e) || this._declareHash.hasOwnProperty(e)
                    }, _isDefinedInModulesSystem: function (e) {
                        return this._modulesSystemKey && ym.modules.isDefined({key: e, storage: this._modulesSystemKey})
                    }, _addRequireToQueue: function (e, t) {
                        this._waitingForNextTick || (this._waitingForNextTick = !0, this._bindOnNextTick || (this._bindOnNextTick = this._onNextTick.bind(this)), i(this._bindOnNextTick)), this._requireQueue.push({
                            keys: e,
                            defer: t
                        })
                    }, _onNextTick: function () {
                        this._waitingForNextTick = !1;
                        var e = this._requireQueue.slice();
                        this._requireQueue = [];
                        for (var t = 0, s = e.length; t < s; t++) this._processRequire(e[t])
                    }, _processRequire: function (e) {
                        for (var t = e.keys, s = t.length, i = new Array(s), r = this._createRequireCallback(e, s, i), n = 0, o = s; n < o; n++) this._processKey(t[n], r, n)
                    }, _createRequireCallback: function (e, t, s) {
                        return function (i, r) {
                            s[i] = r, --t || e.defer.resolve(s)
                        }
                    }, _processKey: function (e, t, s) {
                        var i = this.get(e);
                        if ("undefined" == typeof i) {
                            var r = this._declareHash[e];
                            if (r.state == o.NOT_RESOLVED && this._resolveKey(r), r.state == o.IN_RESOLVING) return void r.waitingForResolving.push({
                                callback: t,
                                number: s
                            });
                            i = this.get(e)
                        }
                        t(s, i)
                    }, _resolveKey: function (e) {
                        e.state = o.IN_RESOLVING;
                        var t = e.depends;
                        0 == t.length ? e.callback.call(e.context, this._createProvideCallback(e)) : this.require(t, function () {
                            var t = Array.prototype.slice.call(arguments, 0);
                            t.unshift(this._createProvideCallback(e)), e.callback.apply(e.context, t)
                        }, this)
                    }, _createProvideCallback: function (e) {
                        return function (t) {
                            e.state = o.RESOLVED, this.add(e.key, t);
                            for (var s = e.waitingForResolving, i = 0, r = s.length; i < r; i++) {
                                var n = s[i];
                                n.callback(n.number, t)
                            }
                            s = []
                        }.bind(this)
                    }
                }), e(u)
            });
        }],
        [')(', function (ym) {
            ym.modules.define("util.imageLoader", ["util.imageLoaderComponent.config", "util.imageLoaderComponent.Channel", "util.scheduler.manager", "util.scheduler.strategy.Raf"], function (e, n, a, o) {
                function t(e) {
                    return "string" == typeof e && 0 === e.indexOf("data:")
                }

                var i = Object.create(null), r = 0, l = new Image, s = {}, u = [], c = {
                    _getChannel: function (e, o) {
                        if ("default" === e && o && t(o)) return this._getChannel("dataURI", o);
                        if (!s[e]) {
                            if (!n[e]) return this._getChannel("default", o);
                            s[e] = new a(n[e]), u.push(s[e].events.group().add("requestload", this._onChannelLoadRequest, this))
                        }
                        return s[e]
                    }, load: function (e, n, a) {
                        var o = "string" == typeof e ? {url: e} : e, t = o.url, l = o.priority || 0,
                            s = o.channel || "default", u = o.decode || !1, c = Boolean(o.crossOrigin);
                        if (i[t]) return void i[t].callbacks.push([n, a || null]);
                        var d = this._getChannel(s, t);
                        i[t] = {
                            callbacks: [[n, a || null]],
                            url: t,
                            channel: d,
                            crossOrigin: c,
                            decode: u,
                            image: null,
                            loading: !1
                        }, d.addToQueue({url: t, priority: l, index: r++})
                    }, cancel: function (e, n, a) {
                        if (e && i[e]) {
                            var o = i[e];
                            a = a || null;
                            for (var t = 0, r = o.callbacks.length; t < r; t++) if (o.callbacks[t][0] == n && o.callbacks[t][1] == a) {
                                o.callbacks.splice(t, 1), 0 == o.callbacks.length && (o.loading && o.image && (o.image.onload = null, o.image.onerror = null), o.channel.cancelLoading(e), delete i[e]);
                                break
                            }
                        }
                    }, clear: function () {
                        i = {}, r = 0, s = {};
                        for (var e = 0, a = u.length; e < a; e++) u[e].removeAll();
                        u = [], o.unschedule("timeout", this._resolveExpiredRequests, this, n.requestTimeout)
                    }, _onChannelLoadRequest: function (e) {
                        var n = e.get("url"), a = i[n];
                        a.channel = e.get("target"), this._performLoad(n)
                    }, _performLoad: function (e) {
                        var n = i[e];
                        n.loading = !0, n.loadStartTime = +new Date, this._setTaskForCacheCheck(), this._loadImage(e, n)
                    }, _setTaskForCacheCheck: function () {
                        o.schedule("timeout", this._resolveExpiredRequests, this, n.requestTimeout)
                    }, _loadImage: function (e, n) {
                        return "string" != typeof e ? void this._onReady(e, !1) : (n.image = new Image, n.crossOrigin && (n.image.crossOrigin = "Anonymous"), n.image.onload = this._onLoad.bind(this, e), n.image.onerror = this._onError.bind(this, e), void (n.image.src = e))
                    }, _onLoad: function (e) {
                        this._onReady(e, !0)
                    }, _onError: function (e) {
                        this._onReady(e, !1)
                    }, _onReady: function (e, n) {
                        function a(n) {
                            if (i[e]) {
                                var a = i[e];
                                a.channel.onReady(e), delete i[e];
                                for (var o = a.callbacks, r = n ? t : l, s = n ? null : {
                                    url: e,
                                    response: t
                                }, u = 0, c = o.length; u < c; u++) o[u][0].call(o[u][1], r, n, s)
                            }
                        }

                        var o = i[e], t = o.image;
                        n && t && t.decode && o.decode ? t.decode().then(function () {
                            a(!0)
                        }, function () {
                            a(!1)
                        }) : a(n)
                    }, _resolveExpiredRequests: function () {
                        var e = +new Date - n.requestTimeout;
                        for (var a in i) i[a].loading && i[a].loadStartTime < e && this._onReady(i[a].url, !1);
                        for (var a in i) i[a].loading && this._setTaskForCacheCheck()
                    }
                };
                e(c)
            });
        }],
        [',D', function (ym) {
            ym.modules.define("util.scheduler.strategy.Processing", ["util.defineClass", "util.scheduler.strategy.Base", "util.scheduler.timescheduler", "util.scheduler.strategy.storage"], function (t, e, i, s, r) {
                function a(t, e, i) {
                    if (a.superclass.constructor.call(this, t, e, i), this.startTime = 0, this.endTime = 0, this.duration = +(i.duration || i), this.completeCallback = i.onComplete, ym.env.debug && (+this.duration <= 0 || isNaN(+this.duration))) throw new Error("schedule: передан не верный duration(" + this.duration + ")")
                }

                e(a, i, {
                    start: function () {
                        s.add(this.execute, this)
                    }, execute: function (t) {
                        if (this.isStopped()) return !1;
                        this.endTime ? t = Math.min(t, this.endTime) : (this.startTime = t, this.endTime = t + this.duration);
                        var e = t - this.startTime, i = {
                            passed: e,
                            duration: this.duration,
                            progress: e / this.duration,
                            currentTime: t,
                            self: this
                        };
                        return this.options.params = i, a.superclass.execute.call(this, !0), t < this.endTime || (this.reportTaskComplete(), this.completeCallback && (this.options.context ? this.completeCallback.call(this.options.context) : this.completeCallback()), !1)
                    }
                }), r.add("processing", a), t(a)
            });
        }],
        ['7h', function (ym) {
            ym.modules.define("localization.common.current", function (n) {
                return ["localization.common." + n.env.lang.substr(0, 2)]
            }, function (n, o) {
                n(o || {})
            });
        }],
        [')c', function (ym) {
            ym.modules.define("util.cancelableCallback", [], function (n) {
                var c = {
                    create: function (n, c) {
                        var e = function () {
                            if (n) {
                                var e = arguments, l = e.length;
                                0 == l ? n.call(c) : 1 == l ? n.call(c, e[0]) : 2 == l ? n.call(c, e[0], e[1]) : n.apply(c, e)
                            }
                        };
                        return e.cancel = function () {
                            n = c = null
                        }, e.isActive = function () {
                            return !!n
                        }, e
                    }, createPromiseHandler: function (n, c, e, l) {
                        return c = this.create(c, l), e = this.create(e, l), n.done(c, e), {
                            cancel: function () {
                                c.cancel(), e.cancel(), c = e = l = null
                            }, isActive: function () {
                                return !!c
                            }
                        }
                    }
                };
                n(c)
            });
        }],
        [')e', function (ym) {
            ym.modules.define("util.cancellation.Token", ["util.defineClass", "util.cancellation.Error"], function (n, t, e) {
                function s() {
                    this.cancellationRequested = !1, this._subs = []
                }

                t(s, {
                    register: function (n) {
                        return this._subs.push(n), {
                            unregister: function () {
                                var t = this._subs.indexOf(n);
                                t !== -1 && this._subs.splice(t, 1)
                            }
                        }
                    }, cancel: function () {
                        this.cancellationRequested || (this._subs.forEach(function (n) {
                            n()
                        }), this.cancellationRequested = !0)
                    }, throwIfCancellationRequested: function () {
                        throw new e
                    }, close: function () {
                        this._subs = []
                    }
                }), n(s)
            });
        }],
        [')F', function (ym) {
            ym.modules.define("util.dom.className", function (s) {
                var t = {
                    has: function (s, t) {
                        return s.classList.contains(t)
                    }, add: function (s, n) {
                        for (var a = n.split(" "), e = 0; e < a.length; ++e) s.classList.add(a[e]);
                        return t
                    }, remove: function (s, n) {
                        for (var a = n.split(" "), e = 0; e < a.length; ++e) s.classList.remove(a[e]);
                        return t
                    }, toggle: function (s, n, a) {
                        var e = 3 == arguments.length ? a : !s.classList.has(n);
                        return e ? s.classList.add(n) : s.classList.remove(n), t
                    }
                };
                s(t)
            });
        }],
        [')u', function (ym) {
            ym.modules.define("util.css", [], function (e) {
                e({
                    addPrefix: function (e) {
                        return ym.env.cssPrefix + e
                    }
                })
            });
        }],
        [')j', function (ym) {
            ym.modules.define("util.margin", ["util.array"], function (r, e) {
                var a = {
                    correct: function (r) {
                        var a;
                        if (e.isArray(r)) switch (r.length) {
                            case 1:
                                a = [r[0], r[0], r[0], r[0]];
                                break;
                            case 2:
                                a = [r[0], r[1], r[0], r[1]];
                                break;
                            case 3:
                                a = [r[0], r[1], r[2], r[1]];
                                break;
                            default:
                                a = [r[0], r[1], r[2], r[3]]
                        } else a = [r, r, r, r];
                        for (var c = 0; c < 4; c++) a[c] = a[c] || 0;
                        return a
                    }, sum: function (r) {
                        var c;
                        return e.each(r, function (r) {
                            r = a.correct(r), c ? (c[0] += r[0], c[1] += r[1], c[2] += r[2], c[3] += r[3]) : c = r
                        }), c
                    }
                };
                r(a)
            });
        }],
        ['.A', function (ym) {
            ym.modules.define("system.nextTick", [], function (e) {
                e(ym.utils.nextTick)
            });
        }],
        ['))', function (ym) {
            ym.modules.define("util.imageLoaderComponent.config", ["util.extend"], function (i, e) {
                var o = ym.env.browser, t = o.isMobile || o.isTablet,
                    a = {loadLimit: t ? 4 : 16, maxAtomicLoads: t ? 2 : 8};
                i({
                    "default": a,
                    tiles: a,
                    dataURI: e({}, a, {loadLimit: 8 * a.loadLimit, maxAtomicLoads: 8 * a.maxAtomicLoads}),
                    requestTimeout: t ? 6e4 : 3e4
                })
            });
        }],
        [')*', function (ym) {
            ym.modules.define("util.imageLoaderComponent.Channel", ["util.defineClass", "util.scheduler.manager", "util.scheduler.world", "event.Manager", "util.array", "util.scheduler.strategy.Asap"], function (e, i, t, n, u, s) {
                function o(e) {
                    return n.isInSmoothMode() ? Math.ceil(.5 * e) : e
                }

                function h(e, i) {
                    return e.priority == i.priority ? e.index - i.index : i.priority - e.priority
                }

                var a = 8, r = function (e) {
                    this.events = new u({context: this}), this._queueNeedsSort = !1, this._queue = [], this._loading = {}, this._loadingNumber = 0, this._settings = e
                };
                i(r, {
                    addToQueue: function (e) {
                        this._queue.push(e), this._scheduleLoading(), this._queueNeedsSort = !0
                    }, cancelLoading: function (e) {
                        if (this._loading[e]) return this._loadingNumber--, void delete this._loading[e];
                        var i = s.findIndex(this._queue, function (i) {
                            return i.url == e
                        });
                        i != -1 && this._queue.splice(i, 1)
                    }, onReady: function (e) {
                        this._loading[e] ? (this._loadingNumber--, delete this._loading[e]) : this.cancelLoading(e), this._scheduleLoading()
                    }, _scheduleLoading: function () {
                        t.schedule("asap", this._continueLoading, this)
                    }, _continueLoading: function () {
                        var e = Math.min(this._queue.length, o(this._settings.loadLimit) - this._loadingNumber);
                        if (!(e <= 0)) {
                            var i = 0, t = o(this._settings.maxAtomicLoads), n = +new Date;
                            this._queueNeedsSort && (this._queue.sort(h), this._queueNeedsSort = !1);
                            for (var u = this._queue[0].priority, s = 0; s < e && s < t && !(Math.abs(u - this._queue[s].priority) > .5) && !(+new Date - n > a); s++) this.events.fire("requestload", {url: this._queue[s].url}), this._loading[this._queue[s].url] = !0, this._loadingNumber++, i++;
                            i && this._queue.splice(0, i), i < e && this._scheduleLoading()
                        }
                    }
                }), e(r)
            });
        }],
        [',x', function (ym) {
            ym.modules.define("util.scheduler.manager", ["util.id", "util.scheduler.strategy.storage", "util.scheduler.strategy.Timeout"], function (e, t, r, u) {
                function n(e) {
                    var t = "string" == typeof e ? r.get(e) || r.get("scheduled") : e;
                    if (ym.env.debug && !t) throw new Error("util.scheduler.manager.schedule: не передан strategy или " + e + " не определен");
                    return t
                }

                var l = {}, d = {
                    schedule: function (e, t, r, u, c) {
                        if (ym.env.debug && !t) throw new Error("imports.schedule: не передан callback");
                        var o = n(e), i = d.getScheduleId(o, t, r), s = l[i];
                        if (s) return s;
                        var g = new o(t, r, u);
                        return g.onComplete = function () {
                            delete l[i], c && c.onComplete && c.onComplete(i)
                        }, g.scheduleId = i, l[i] = g, g.start(), g
                    }, unschedule: function (e, t, r) {
                        var u = d.getScheduleId(e, t, r), n = l[u];
                        return !!n && (n.stop(), !0)
                    }, getScheduleId: function (e, r, u) {
                        return e = n(e), t.get(e) + t.get(r) + (u ? t.get(u) : "null")
                    }, isScheduled: function (e, t, r) {
                        var u = d.getScheduleId(e, t, r);
                        return l[u] || !1
                    }
                };
                e(d)
            });
        }],
        [',E', function (ym) {
            ym.modules.define("util.scheduler.strategy.Raf", ["util.defineClass", "util.scheduler.strategy.Base", "util.scheduler.strategy.storage"], function (t, e, n, s) {
                function i(t, e, n) {
                    i.superclass.constructor.call(this, t, e, n)
                }

                function o() {
                    l = null;
                    var t = +new Date, e = 0, n = a, s = u;
                    a = [], u = [];
                    for (var i = 0, h = n.length; i < h && (n[i].execute(), e++, !(+new Date - t > d)); ++i) ;
                    for (var i = 0, h = s.length; i < h && (s[i].execute(), e++, !(+new Date - t > d)); ++i) ;
                    r(n, s, e), l || !a.length && !u.length || (l = c(o))
                }

                function r(t, e, n) {
                    return n < t.length ? void (a = t.slice(n).concat(e, a)) : (n -= t.length, void (n < e.length && (a = u.slice(n).concat(a))))
                }

                var a = [], u = [], l = null,
                    c = window.requestAnimationFrame || window[ym.env.browser.cssPrefix.toLowerCase() + "RequestAnimationFrame"],
                    h = !0, d = 1 / 0;
                c || (h = !1, c = function (t) {
                    return setTimeout(t, 25)
                }), e(i, n, {
                    start: function () {
                        var t = this.options ? this.options.params : null;
                        return t && !h && t.strictMode ? void this.execute() : (l || (l = c(o)), void (this.options && this.options.params && this.options.params.tailExecution ? u.push(this) : a.push(this)))
                    }
                }), s.add("raf", i), t(i)
            });
        }],
        [',B', function (ym) {
            ym.modules.define("util.scheduler.strategy.Base", ["util.scheduler.strategy.storage"], function (t) {
                function e(t, e, o) {
                    this.options = {callback: t, context: e, params: o}, this.completed = !1, this.stopped = !1
                }

                e.prototype = {
                    reportTaskComplete: function () {
                        this.onComplete && this.onComplete.call(this), this.completed = !0
                    }, execute: function (t) {
                        return t || this.reportTaskComplete(), this.isStopped() || this.options.callback.call(this.options.context, this.options.params), this.options.callback
                    }, start: function () {
                        throw new Error("StrategyBase.start: не определен")
                    }, stop: function () {
                        this.stopped = !0, this.reportTaskComplete()
                    }, isStopped: function () {
                        return this.stopped
                    }, isCompleted: function () {
                        return this.completed
                    }
                }, t(e)
            });
        }],
        [',K', function (ym) {
            ym.modules.define("util.scheduler.timescheduler", ["util.scheduler.strategy.Raf"], function (n, t) {
                function e() {
                    function n() {
                        for (var n = [], t = 0, e = m.length; e; ++t, --e) m[t] && n.push(m[t]);
                        m = n, T = 0
                    }

                    function e() {
                        b && b.stop(), b = new t(c), b.start()
                    }

                    function c() {
                        var t, i = 0, o = m.length;
                        for (x++, M++, e(), S = +new Date, R = 1, t = 0; o; ++t, --o) m[t] && (i++, m[t].fn.call(m[t].context, S) === !1 && w(t));
                        T > u && n(), !v && i && s(), g[D++] = S - W, W = S, D > r && (D = 0), a()
                    }

                    function a() {
                        for (var n = 0, t = g, e = Math.ceil(r / 2), i = 1; i < e; i++) {
                            var o = D - i;
                            o < 0 && (o = Math.min(t.length - 1, r)), n += t[o]
                        }
                        p = Math.round(n / e)
                    }

                    function f() {
                        y = x, j = window.setTimeout(f, 10 * i)
                    }

                    function l(n, t) {
                        m.push({fn: n, context: t}), v++, h()
                    }

                    function w(n) {
                        m[n] = null, T++, v--
                    }

                    function h() {
                        A || (g = [], D = 0, y = x - 1, R = 0, S = W = +new Date, e(), f(), A = 1), window.clearTimeout(k)
                    }

                    function s() {
                        m = [], T = 0, v = 0, window.clearTimeout(k), k = window.setTimeout(d, o)
                    }

                    function d() {
                        R = 0, A = 0, b && b.stop(), window.clearTimeout(k), window.clearTimeout(j)
                    }

                    var m = [], T = 0, v = 0, g = [], D = 0, p = 0, M = 0, x = 0, y = -1, A = 0, R = 0, S = +new Date,
                        W = +new Date, b = 0, j = 0, k = 0;
                    this.add = l, this.isActive = function () {
                        return R
                    }, this.currentThesholdWindow = function () {
                        return p
                    }, this.getSelfTime = function () {
                        return R ? S : +new Date
                    }, this.reactionTime = function (n) {
                        var t = R && p || i;
                        return Math.min(n || t, t)
                    }
                }

                var i = 6, o = 3e3, u = 100, r = 20;
                n(new e)
            });
        }],
        [',F', function (ym) {
            ym.modules.define("util.scheduler.strategy.storage", ["util.Storage"], function (e, t) {
                e(new t)
            });
        }],
        ['7p', function (ym) {
            ym.modules.define("localization.common.ru", [], function (e) {
                e({
                    Balloon: {close: "Закрыть"},
                    Control: {
                        ListBox: {Collapse: "Свернуть", Expand: "Развернуть"},
                        MiniMap: {hide: "Скрыть обзорную карту", show: "Показать обзорную карту"},
                        RoutePanel: {
                            ClearRoute: "Сбросить маршрут",
                            ErrorNoConnection: "Нет связи. Подключитесь к интернету и попробуйте {{повторить попытку}}",
                            ErrorNoLocation: "Не удалось определить местоположение",
                            ErrorNoTaxi: "В этом городе ещё нет Яндекс.Такси",
                            ErrorNoWay: "Не удалось построить маршрут между точками",
                            FromPlaceholder: "Откуда",
                            Geolocation: "Добавить моё местоположение",
                            Routes: "Маршруты",
                            SwitchInputs: "Поменять местами пункты отправления и назначения",
                            ToPlaceholder: "Куда",
                            TryAnotherMethod: "Попробуйте маршрут другого типа"
                        },
                        Ruler: {
                            close: "Удалить путь",
                            sure: "Удалить все отметки? \\n\\n(для удаления только одной отметки\\n дважды щелкните по ней)"
                        },
                        Search: {
                            clear: "Очистить",
                            correction: "Исправлена опечатка «%s»",
                            error: "Сервер не смог обработать запрос",
                            feedbackAddOrganization: "Добавить организацию на&nbsp;карту",
                            feedbackAddOrganizationShort: "Добавить организацию",
                            feedbackAddToponym: "Дополнить карту",
                            found: ["Найден %d объект", "Найдено %d объекта", "Найдено %d объектов", "Найдено %d объектов"],
                            loadMore: ["Ещё %d результат", "Ещё %d результата", "Ещё %d результатов", "Ещё %d результатов"],
                            next: ["Следующий %d", "Следующие %d", "Следующие %d", "Следующие %d"],
                            noname: "Без названия",
                            notFound: "Ничего не&nbsp;нашлось",
                            object: ["объект", "объекта", "объектов", "объектов"],
                            of: "из",
                            previous: ["Предыдущий %d", "Предыдущие %d", "Предыдущие %d", "Предыдущие %d"],
                            search: "Найти",
                            searchLegend: "Адрес или объект",
                            wait: "Идет запрос к серверу"
                        },
                        ToolBar: {
                            drag: "Переместить карту",
                            geolocation: "Определить ваше местоположение",
                            geolocationError: "Не получилось определить ваше местоположение",
                            geolocationSuccess: "Ваше местоположение",
                            info: "Получить информацию",
                            magnifier: "Увеличить",
                            ruler: "Измерение расстояний на карте"
                        },
                        TypeControl: {layers: "Слои", mapType: "Тип карты", more: "Ещё", panoramas: "Панорамы"},
                        Zoom: {city: "город", country: "страна", house: "дом", street: "улица", world: "мир"}
                    },
                    Copyrights: {
                        agreement: "Условия использования",
                        agreementCompact: "Условия",
                        agreementLink: "https://yandex.ru/legal/maps_termsofuse/",
                        edit: '<a href="http://n.maps.yandex.ru" style="font-weight: bold !important;" target="_blank">Редактировать Народную карту</a>',
                        editCompact: '<a href="http://n.maps.yandex.ru" style="font-weight: bold !important;" target="_blank">Народная карта</a>',
                        feedback: "",
                        feedbackTemplate: "",
                        logoLang: "ru",
                        logoLink: "http://maps.yandex.ru",
                        osm: '© Участники <a href="https://www.openstreetmap.org/copyright"  target="_blank">OpenStreetMap</a>',
                        yandex: '© <a href="http://maps.yandex.ru">Яндекс</a>'
                    },
                    DaysOfWeek: {
                        fri: "пт",
                        friday: "пятница",
                        mon: "пн",
                        monday: "понедельник",
                        onFri: "в пт",
                        onMon: "в пн",
                        onSat: "в сб",
                        onSun: "в вс",
                        onThu: "в чт",
                        onTue: "во вт",
                        onWed: "в ср",
                        sat: "сб",
                        saturday: "суббота",
                        sun: "вс",
                        sunday: "воскресенье",
                        thu: "чт",
                        thursday: "четверг",
                        tue: "вт",
                        tuesday: "вторник",
                        wed: "ср",
                        wednesday: "среда"
                    },
                    Editor: {
                        addCircle: "Добавить круг",
                        addGeometry: "Добавить геометрию",
                        addInterior: "Добавить внутренний контур",
                        addLineString: "Добавить линию",
                        addPoint: "Добавить точку",
                        addPolygon: "Добавить полигон",
                        removeCircle: "Удалить круг",
                        removeGeometry: "Удалить геометрию",
                        removeInterior: "Удалить контур",
                        removeLineString: "Удалить линию",
                        removePoint: "Удалить точку",
                        removePolygon: "Удалить полигон",
                        removeVertex: "Удалить",
                        startDrawing: "Продолжить",
                        startFraming: "Включить перетаскивание",
                        stopDrawing: "Завершить",
                        stopFraming: "Выключить перетаскивание"
                    },
                    MapType: {
                        hybrid: "Гибрид",
                        map: "Схема",
                        peoplesHybrid: "Народная + спутник",
                        peoplesMap: "Народная карта",
                        satellite: "Спутник"
                    },
                    PeopleMap: {
                        house: "Здание",
                        hydro: "Водоем, участок реки",
                        locality: "Населённый пункт",
                        noname: "Без названия",
                        other: "Другое",
                        phybrid: "Гибрид",
                        pmap: "Схема",
                        railway: "Участок железной дороги",
                        street: "Участок дороги",
                        vegetation: "Лес, парк"
                    },
                    Traffic: {
                        address: "Адрес",
                        archiveDataText: "На основе статистики Яндекс.Пробок",
                        archiveProvider: "обычно",
                        brownJam: "Движение перекрыто",
                        chooseCity: "Выберите город ",
                        description: "Описание",
                        detailedLink: "Подробнее о дорожной ситуации",
                        eventType0: "Дорожные работы",
                        eventType1: "ДТП",
                        eventType2: "Развод моста",
                        eventType3: "Перекрытие движения",
                        eventType4: "Камера",
                        eventType5: "Прочее",
                        expectedOn: "ожидается в %t",
                        forTheNearFuture: "На ближайшее время",
                        forecast: "Прогноз",
                        forecastData: "На основе прогноза пробок",
                        forecastDataText: "На основе прогноза Яндекс.Пробок",
                        greenJam: "Свободно",
                        inAnHour: "через час",
                        infoLayer: "Дорожные события",
                        jams: "Пробки",
                        later: "потом",
                        length: "Длина",
                        level0: "На дорогах свободно",
                        level1: "На дорогах свободно",
                        level10: "Пешком быстрее",
                        level2: "Дороги почти свободны",
                        level3: "Местами затруднения",
                        level4: "Местами затруднения",
                        level5: "Движение плотное",
                        level6: "Движение затруднено",
                        level7: "Серьёзные пробки",
                        level8: "Многокилометровые пробки",
                        level9: "Город стоит",
                        noData: "Данные о пробках недоступны",
                        noForecastHere: "На этой территории нет прогноза пробок.",
                        noRegion: "Нет данных о пробках в этом регионе",
                        noStatisticsHere: "На этой территории нет статистики пробок.",
                        noTimeZone: "Данные о пробках отсутствуют",
                        now: "сейчас",
                        nowHeader: "Сейчас",
                        nowOn: "сейчас, в %t",
                        onOtherDays: "На другие дни",
                        points: ["%d балл", "%d балла", "%d баллов", "%d баллов"],
                        redJam: "Пробка",
                        seeCurrentTrafficJams: "Посмотреть текущие пробки",
                        source: "Источник",
                        statistics: "Статистика",
                        statisticsData: "На основе статистики пробок",
                        statisticsHint: "Статистика основана на информации о пробках за последние два месяца",
                        time: "Дата",
                        times: "Сроки",
                        today: "Сегодня",
                        trafficBlocked: "движение перекрыто",
                        usuallyOn: "обычно в %s, %t",
                        yellowJam: "Движение затруднено",
                        zoomToWatch: '<a href="javascript:void(0)">Увеличьте масштаб</a>, чтобы увидеть пробки'
                    },
                    Unit: {
                        centimetreAbbr: "см.",
                        dayAbbr: ["д.", "дн.", "дн.", "дн."],
                        hourAbbr: "ч.",
                        kilometreAbbr: "км.",
                        kmh: "км/ч",
                        metreAbbr: "м",
                        minuteAbbr: "мин.",
                        secondAbbr: "с"
                    },
                    distribution: {
                        badgeUpdateBrowserInfoMessage: '<a href="https://tech.yandex.ru/maps/doc/jsapi/updating-browsers/index-docpage/?from=$[from]" target="_blank">[?]</a>',
                        badgeUpdateBrowserMessage: "Обновите браузер",
                        badgeYaBrowserLink: '<a href="https://browser.yandex.ru/?from=link_maps___&banerid=0408000000" target="_blank">$[messages.message]</a>',
                        badgeYaBrowserMobileAndroidCounter: "http://appmetrika.yandex.ru/serve/7778453801303976883?action=click&app_id=com.yandex.browser",
                        badgeYaBrowserMobileAndroidLink: '<a href="market://details?id=com.yandex.browser" target="_blank">$[messages.message]</a>',
                        badgeYaBrowserMobileIOsLink: '<a href="https://itunes.apple.com/ru/app/andeks.brauzer/id574939428?mt=8" target="_blank">$[messages.message]</a>',
                        badgeYaBrowserTabletAndroidCounter: "http://appmetrika.yandex.ru/serve/3382077458904646597?action=click&app_id=com.yandex.browser",
                        badgeYaBrowserTabletAndroidLink: '<a href="market://details?id=com.yandex.browser" target="_blank">$[messages.message]</a>',
                        bandMessage: 'Ваш браузер устарел. Пожалуйста, обновите браузер (<a href="https://tech.yandex.ru/maps/doc/jsapi/updating-browsers/index-docpage/?from=$[from]" target="_blank">подробнее</a>) или установите',
                        geoLinkEmptyHeader: "Нет информации",
                        geolinkChangeReq: "Попробуйте изменить запрос и",
                        geolinkGetThere: "Как добраться",
                        geolinkMoreInfo: "Подробнее о месте",
                        geolinkNotFound: "Ничего не найдено",
                        geolinkOrSearchInYandex: "или поищите в Яндекс.Картах",
                        geolinkSearchYandex: " поискать в Яндекс.Картах",
                        geolinkSomethingWentWrong: "Что-то пошло не так",
                        geolinkTitle: "Показать на карте",
                        geolinkTryAgain: "Попробуйте ещё раз",
                        mapsPromoGetThere: "Как добраться",
                        openRoute: "Открыть маршрут",
                        panoramas: 'К сожалению, нам не удалось запустить Яндекс.Панорамы на вашем устройстве (<a href="https://tech.yandex.ru/maps/doc/jsapi/updating-browsers/index-docpage/?from=$[from]" target="_blank">подробнее</a>).',
                        routeMoreInfo: "Подробнее",
                        routeOpenInMaps: "Подробнее",
                        searchInYandex: "Поискать в",
                        unavailable: 'Здесь должна быть карта.<br/>К сожалению, мы не можем отобразить её в вашем браузере.<br/>Но вы можете попытаться просмотреть её<br/>в <a href="{{ href }}" target="_blank">Мобильных Яндекс.Картах</a>.',
                        yaBrowser: '<a class="ya-distrib-browser"  target="_blank" href="https://browser.yandex.ru/?from=link_maps___&banerid=0408000000">Яндекс.Браузер</a>',
                        yaBrowserMobileAndroid: '<a href="market://details?id=com.yandex.browser" data-counter="http://appmetrika.yandex.ru/serve/7778453801303976883?action=click&app_id=com.yandex.browser" class="ya-distrib-browser" target="_blank">Я.Браузер</a>',
                        yaBrowserMobileIOs: '<a href="https://itunes.apple.com/ru/app/andeks.brauzer/id574939428?mt=8" class="ya-distrib-browser" >Я.Браузер</a>',
                        yaBrowserTabletAndroid: '<a href="market://details?id=com.yandex.browser" data-counter="http://appmetrika.yandex.ru/serve/3382077458904646597?action=click&app_id=com.yandex.browser" class="ya-distrib-browser" target="_blank">Я.Браузер</a>',
                        yaMapsAndroidLink: "intent://maps.yandex.ru/{parameters}#Intent;scheme=http;package=ru.yandex.yandexmaps;S.browser_fallback_url={fallback_url};end",
                        yaMapsIOsLink: "yandexmaps://maps.yandex.ru/",
                        yaMapsIOsRouteLink: "yandexmaps://build_route_on_map/",
                        yaMapsIOsServiceLink: "http://go.onelink.me/id313877526?pid=api-maps&c=text&af_dp={url-scheme}",
                        yaOpenInMaps: "Открыть в Яндекс.Картах",
                        yaOpenInMapsExtraShort: "В Карты &rarr;",
                        yaOpenInMapsShort: "Открыть в Картах",
                        yaOpenOrgInMaps: "Об организации",
                        yandexLink: "https://yandex.ru/search?text={text}&from=mapsapi"
                    },
                    geoXml: {Latitude: "Широта", Longitude: "Долгота", Time: "Время", Velocity: "Скорость"},
                    geocode: {
                        area: "",
                        country: "",
                        district: "",
                        house: "",
                        locality: "",
                        metro: "",
                        province: "",
                        street: ""
                    },
                    jsonp: {
                        scriptError: "Ошибка при загрузке скрипта",
                        timeoutExceeded: "Превышен интервал ожидания ответа от сервера"
                    },
                    layer: {tileNotFound: "Для этого участка местности нет данных.<br/>Попробуйте перейти на масштаб выше<br/>или выбрать другое место на карте."},
                    masstransit: {
                        "human-duration": '<i18n:dynamic>\n    <i18n:xsl>\n        <xsl:param name="duration" select="0"/>\n        <xsl:variable name="days" select="floor($duration div 86400)"/>\n        <xsl:variable name="hours" select="floor($duration mod 86400 div 3600)"/>\n        <xsl:variable name="minutes" select="ceiling($duration mod 3600 div 60)"/>\n        <xsl:if test="$days">\n            <xsl:value-of select="$days"/>\n            <xsl:choose>\n                <xsl:when test="$days = 1"> д. </xsl:when>\n                <xsl:otherwise> дн. </xsl:otherwise>\n            </xsl:choose>\n        </xsl:if>\n        <xsl:if test="$days &lt; 20 and $hours">\n            <xsl:value-of select="$hours"/>\n            <xsl:text> ч. </xsl:text>\n        </xsl:if>\n        <xsl:if test="$days = 0 and $hours &lt; 20 and $minutes">\n            <xsl:value-of select="$minutes"/>\n            <xsl:text> мин. </xsl:text>\n        </xsl:if>\n    </i18n:xsl>\n</i18n:dynamic>',
                        quote: "<i18n:dynamic>\n    <i18n:xsl>\n        <xsl:param name=\"text\"/>\n        <xsl:value-of select=\"concat('«', re:replace($text, '&quot;([^&quot;]+)&quot;', 'g', '„$1“'), '»')\" xmlns:re=\"http://exslt.org/regular-expressions\"/>\n    </i18n:xsl>\n</i18n:dynamic>",
                        "transport-aeroexpress": '<i18n:dynamic project="tanker" keyset="dynamic" key="gender">\n    <i18n:gender><i18n:param>gender</i18n:param></i18n:gender>\n    <i18n:masculine>Аэроэкспресс</i18n:masculine>\n    <i18n:plural>Аэроэкспрессы</i18n:plural>\n</i18n:dynamic>',
                        "transport-bus": '<i18n:dynamic project="tanker" keyset="dynamic" key="gender">\n    <i18n:gender><i18n:param>gender</i18n:param></i18n:gender>\n    <i18n:masculine>Автобус</i18n:masculine>\n    <i18n:plural>Автобусы</i18n:plural>\n</i18n:dynamic>',
                        "transport-cable": '<i18n:dynamic project="tanker" keyset="dynamic" key="gender">\n    <i18n:gender><i18n:param>gender</i18n:param></i18n:gender>\n    <i18n:masculine>Канатная дорога</i18n:masculine>\n    <i18n:plural>Канатные дороги</i18n:plural>\n</i18n:dynamic>',
                        "transport-dolmus": '<i18n:dynamic project="tanker" keyset="dynamic" key="gender">\n    <i18n:gender><i18n:param>gender</i18n:param></i18n:gender>\n    <i18n:masculine>Долмуш</i18n:masculine>\n    <i18n:plural>Долмуш</i18n:plural>\n</i18n:dynamic>',
                        "transport-ferry": '<i18n:dynamic project="tanker" keyset="dynamic" key="gender">\n    <i18n:gender><i18n:param>gender</i18n:param></i18n:gender>\n    <i18n:masculine>Паром</i18n:masculine>\n    <i18n:plural>Паромы</i18n:plural>\n</i18n:dynamic>',
                        "transport-funicular": '<i18n:dynamic project="tanker" keyset="dynamic" key="gender">\n    <i18n:gender><i18n:param>gender</i18n:param></i18n:gender>\n    <i18n:masculine>Фуникулёр</i18n:masculine>\n    <i18n:plural>Фуникулёры</i18n:plural>\n</i18n:dynamic>',
                        "transport-historic_tram": '<i18n:dynamic project="tanker" keyset="dynamic" key="gender">\n    <i18n:gender><i18n:param>gender</i18n:param></i18n:gender>\n    <i18n:masculine>Трамвай</i18n:masculine>\n    <i18n:plural>Трамваи</i18n:plural>\n</i18n:dynamic>',
                        "transport-metrobus": '<i18n:dynamic project="tanker" keyset="dynamic" key="gender">\n    <i18n:gender><i18n:param>gender</i18n:param></i18n:gender>\n    <i18n:masculine>Метробус</i18n:masculine>\n    <i18n:plural>Метробусы</i18n:plural>\n</i18n:dynamic>',
                        "transport-minibus": '<i18n:dynamic project="tanker" keyset="dynamic" key="gender">\n    <i18n:gender><i18n:param>gender</i18n:param></i18n:gender>\n    <i18n:masculine>Маршрутка</i18n:masculine>\n    <i18n:plural>Маршрутки</i18n:plural>\n</i18n:dynamic>',
                        "transport-number": '<i18n:dynamic project="tanker" keyset="dynamic" key="gender">\n    <i18n:gender><i18n:param>gender</i18n:param></i18n:gender>\n    <i18n:masculine>№</i18n:masculine>\n    <i18n:plural>№№</i18n:plural>\n</i18n:dynamic>&#160;',
                        "transport-railway": '<i18n:dynamic project="tanker" keyset="dynamic" key="gender">\n    <i18n:gender><i18n:param>gender</i18n:param></i18n:gender>\n    <i18n:masculine>Электричка</i18n:masculine>\n    <i18n:plural>Электрички</i18n:plural>\n</i18n:dynamic>',
                        "transport-rapid_tram": '<i18n:dynamic project="tanker" keyset="dynamic" key="gender">\n    <i18n:gender><i18n:param>gender</i18n:param></i18n:gender>\n    <i18n:masculine>Скоростной трамвай</i18n:masculine>\n    <i18n:plural>Скоростные трамваи</i18n:plural>\n</i18n:dynamic>',
                        "transport-suburban": '<i18n:dynamic project="tanker" keyset="dynamic" key="gender"> <i18n:gender><i18n:param>gender</i18n:param></i18n:gender> <i18n:masculine>Электричка</i18n:masculine> <i18n:plural>Электрички</i18n:plural> </i18n:dynamic>',
                        "transport-train": '<i18n:dynamic project="tanker" keyset="dynamic" key="gender">\n    <i18n:gender><i18n:param>gender</i18n:param></i18n:gender>\n    <i18n:masculine>Электричка</i18n:masculine>\n    <i18n:plural>Электрички</i18n:plural>\n</i18n:dynamic>',
                        "transport-tramway": '<i18n:dynamic project="tanker" keyset="dynamic" key="gender">\n    <i18n:gender><i18n:param>gender</i18n:param></i18n:gender>\n    <i18n:masculine>Трамвай</i18n:masculine>\n    <i18n:plural>Трамваи</i18n:plural>\n</i18n:dynamic>',
                        "transport-trolleybus": '<i18n:dynamic project="tanker" keyset="dynamic" key="gender">\n    <i18n:gender><i18n:param>gender</i18n:param></i18n:gender>\n    <i18n:masculine>Троллейбус</i18n:masculine>\n    <i18n:plural>Троллейбусы</i18n:plural>\n</i18n:dynamic>',
                        "transport-underground": '<i18n:dynamic project="tanker" keyset="dynamic" key="gender">\n    <i18n:gender><i18n:param>gender</i18n:param></i18n:gender>\n    <i18n:masculine>Метро</i18n:masculine>\n    <i18n:plural>Метро</i18n:plural>\n</i18n:dynamic>',
                        "transport-water": '<i18n:dynamic project="tanker" keyset="dynamic" key="gender">\n    <i18n:gender><i18n:param>gender</i18n:param></i18n:gender>\n    <i18n:masculine>Водный транспорт</i18n:masculine>\n    <i18n:plural>Водный транспорт</i18n:plural>\n</i18n:dynamic>',
                        "travel-distance": '<i18n:dynamic>\n    <i18n:xsl>\n        <xsl:param name="text"/>\n        <xsl:param name="value"/>\n        <xsl:choose>\n            <xsl:when test="$value = 0">Переcадка</xsl:when>\n            <xsl:when test="$value &lt; 100">Менее 100 м</xsl:when>\n            <xsl:otherwise><xsl:value-of select="$text"/></xsl:otherwise>\n        </xsl:choose>\n    </i18n:xsl>\n</i18n:dynamic>',
                        "travel-time": 'около <i18n:dynamic project="maps_api" keyset="masstransit" key="human-duration">\n    <i18n:duration><i18n:param>value</i18n:param></i18n:duration>\n</i18n:dynamic><i18n:dynamic project="tanker" keyset="dynamic" key="toggle">\n    <i18n:condition><i18n:param>isMoving</i18n:param></i18n:condition>\n    <i18n:true> в пути.</i18n:true>\n    <i18n:false/>\n</i18n:dynamic>',
                        "travel-to-berth": 'До причала <i18n:dynamic project="maps_api" keyset="masstransit" key="quote">\n    <i18n:text><i18n:param>name</i18n:param></i18n:text>\n</i18n:dynamic>',
                        "travel-to-station": 'До станции <i18n:dynamic project="maps_api" keyset="masstransit" key="quote">\n    <i18n:text><i18n:param>name</i18n:param></i18n:text>\n</i18n:dynamic>',
                        "travel-to-stop": 'До остановки <i18n:dynamic project="maps_api" keyset="masstransit" key="quote">\n    <i18n:text><i18n:param>name</i18n:param></i18n:text>\n</i18n:dynamic>',
                        "travel-transfer": 'Переход на станцию <i18n:dynamic project="maps_api" keyset="masstransit" key="quote">\n    <i18n:text><i18n:param>station</i18n:param></i18n:text>\n</i18n:dynamic> (<i18n:param>line</i18n:param>)'
                    },
                    panorama: {
                        close: "Закрыть",
                        enterFullscreen: "В полноэкранный режим",
                        error: "Что-то сломалось.<br>Но мы уже знаем об этом,<br>зайдите чуть позже",
                        leaveFullscreen: "В оконный режим",
                        scale: "Масштаб",
                        unsupportedMessage: "Попробуйте открыть страницу в&nbsp;другом браузере или&nbsp;на&nbsp;другом устройстве",
                        unsupportedTitle: "Невозможно отобразить панораму",
                        zoomIn: "Увеличить",
                        zoomOut: "Уменьшить"
                    },
                    ppo: {
                        Card: {
                            addReview: "Оставить отзыв",
                            advertLabel: "реклама",
                            days: "Понедельник, Вторник, Среда, Четверг, Пятница, Суббота, Воскресенье",
                            daysShort: "пн, вт, ср, чт, пт, сб, вс",
                            directUrl: "direct.yandex.ru",
                            feedbackAdd: "Добавить организацию",
                            feedbackCorrect: "Исправить неточность",
                            feedbackEdit: "Редактировать",
                            houseOrg: "Посмотреть организации в доме",
                            houseOrgShort: "Организации в доме",
                            interaction: "Маршрут сюда",
                            mapsUrl: "maps.yandex.ru",
                            metroDistance: "Путь от метро",
                            metroScheme: "Схема метро",
                            orderATaxi: "Вызвать такси",
                            orderYandexTaxi: "Заказать такси",
                            orderYandexTaxiPriceRubSuffix: "— от %price руб.",
                            railwayTimetable: "Расписание поездов",
                            ratingNoRating: "Ещё нет оценок",
                            ratingRate: "Оценить",
                            ratingRatings: ["оценка", "оценки", "оценок", "оценок"],
                            ratingReviews: ["отзыв", "отзыва", "отзывов", "отзывов"],
                            reviewsUrl: "maps.yandex.ru/org/",
                            routesList: "Список маршрутов",
                            spravAddUrl: "{mapsHost}feedback/org/add/",
                            spravEditUrl: "{mapsHost}?feedback=edit-organization&ol=biz&oid={organization_id}&utm_source={utm_source}&utm_medium={utm_medium}",
                            stopTypeMetro: "метро %name",
                            stopTypeMetroExit: "выход метро %name",
                            stopTypeRailway: "ж/д станция %name",
                            stopTypeUrban: "остановка %name",
                            timeClosed: "Закрыто",
                            timeClosedUntil: "Закрыто до %s",
                            timeOpen: "Открыто",
                            timeOpen24: "Круглосуточно",
                            timeOpenUntil: "Открыто до %s",
                            timetableLink: "Посмотреть расписание",
                            yandexTransport: "Яндекс.Транспорт"
                        }
                    },
                    route: {
                        and: "и",
                        back: "разворот",
                        blocked: "Проезд закрыт",
                        "board ferry": "паромная переправа",
                        contains_blocked: "содержит перекрытые участки",
                        duration_without_traffic: "Без пробок",
                        "enter roundabout": "круговое движение",
                        exit: "съезд",
                        "exit back": "разворот, съезд",
                        "exit hard left": "съезд налево",
                        "exit hard right": "съезд направо",
                        "exit left": "съезд налево",
                        "exit none": "съезд",
                        "exit right": "съезд направо",
                        "exit slight left": "левее на съезд",
                        "exit slight right": "правее на съезд",
                        "hard left": "резкий поворот налево",
                        "hard right": "резкий поворот направо",
                        has_ferries: "Паромная переправа на маршруте",
                        has_tolls: "Платная дорога на маршруте",
                        "leave ferry": "конец паромной переправы",
                        "leave roundabout": "съезд с кругового движения",
                        "leave roundabout 1": "1-й съезд",
                        "leave roundabout 10": "10-й съезд",
                        "leave roundabout 11": "11-й съезд",
                        "leave roundabout 12": "12-й съезд",
                        "leave roundabout 13": "13-й съезд",
                        "leave roundabout 14": "14-й съезд",
                        "leave roundabout 15": "15-й съезд",
                        "leave roundabout 2": "2-й съезд",
                        "leave roundabout 3": "3-й съезд",
                        "leave roundabout 4": "4-й съезд",
                        "leave roundabout 5": "5-й съезд",
                        "leave roundabout 6": "6-й съезд",
                        "leave roundabout 7": "7-й съезд",
                        "leave roundabout 8": "8-й съезд",
                        "leave roundabout 9": "9-й съезд",
                        left: "налево",
                        merge: "въезд",
                        none: "прямо",
                        order_a_taxi: "Заказать такси",
                        right: "направо",
                        roundabout: "круговое движение",
                        "slight left": "левее",
                        "slight right": "правее",
                        straight: "прямо",
                        taxiPrice: "~ %price руб.",
                        tolls_key: "ru",
                        via: "через %s"
                    },
                    searchSuggest: {
                        "01-restaurant": "Где поесть",
                        "02-bar": "Бары",
                        "03-atm": "Банкоматы",
                        "04-cinema": "Кино",
                        "05-barbershop": "Красота",
                        "06-pharmacy": "Аптеки",
                        "07-shop": "Продукты",
                        "08-shopping-mall": "Торговые центры",
                        "09-fitness": "Фитнес",
                        "10-auto-repair": "Автосервис",
                        "11-gasoline": "АЗС",
                        "12-hotel": "Гостиницы"
                    }
                })
            });
        }],
        [')d', function (ym) {
            ym.modules.define("util.cancellation.Error", ["util.defineClass"], function (n, i) {
                function e() {
                }

                i(e, Error), n(e)
            });
        }],
        [',L', function (ym) {
            ym.modules.define("util.scheduler.world", ["event.Manager"], function (e, o) {
                var n = 0;
                e({
                    events: new o, smoothMode: function (e) {
                        e && !n && this.events.fire("smoothmodeenter"), n += e ? 1 : -1, e || n || this.events.fire("smoothmodeleave")
                    }, isInSmoothMode: function () {
                        return n
                    }
                })
            });
        }],
        [',y', function (ym) {
            ym.modules.define("util.scheduler.strategy.Asap", ["util.defineClass", "util.scheduler.strategy.Base", "util.scheduler.executeASAP", "util.scheduler.strategy.storage"], function (e, t, s, u, l) {
                function a() {
                    var e = c;
                    c = [], n = null;
                    for (var t = 0, s = e.length; t < s; ++t) e[t].execute()
                }

                function r(e, t, s) {
                    r.superclass.constructor.call(this, e, t, s)
                }

                var c = [], n = null;
                t(r, s, {
                    start: function () {
                        c.push(this), n || (n = u(a))
                    }
                }), l.add("asap", r), e(r)
            });
        }],
        [',G', function (ym) {
            ym.modules.define("util.scheduler.strategy.Timeout", ["util.defineClass", "util.scheduler.strategy.Base", "util.scheduler.timescheduler", "util.scheduler.strategy.storage"], function (t, e, s, i, u) {
                function l(t, e, s) {
                    if (l.superclass.constructor.call(this, t, e, s), this.startTime = 0, this.delay = s ? +(s.delay || s) : 0, ym.env.debug && (+this.delay <= 0 || isNaN(+this.delay))) throw new Error("schedule: передан не верный delay(" + this.delay + ")")
                }

                e(l, s, {
                    start: function () {
                        i.add(this.scheduleFunction, this)
                    }, scheduleFunction: function (t) {
                        return !this.isStopped() && (this.startTime || (this.startTime = t + this.delay), this.startTime > t || (this.execute() || !1) && !1)
                    }
                }), u.add("timeout", l), t(l)
            });
        }],
        [',H', function (ym) {
            ym.modules.define("util.scheduler.executeASAP", ["system.nextTick"], function (e, n) {
                e(function (e, c) {
                    n(function () {
                        e.call(c)
                    })
                })
            });
        }],
        ['$I', function (ym) {
            ym.modules.define("package.full", ["Balloon", "behavior.DblClickZoom", "behavior.Drag", "behavior.LeftMouseButtonMagnifier", "behavior.MultiTouch", "behavior.RightMouseButtonMagnifier", "behavior.RouteEditor", "behavior.Ruler", "behavior.scrollZoom.DescreteZoomHandler", "behavior.scrollZoom.SmoothZoomHandler", "behavior.ScrollZoom", "behavior.storage", "Circle", "Clusterer", "clusterer.addon.balloon", "clusterer.addon.hint", "ClusterPlacemark", "Collection", "collection.Item", "control.Button", "control.FullscreenControl", "control.GeolocationControl", "control.ListBox", "control.ListBoxItem", "control.Manager", "control.RouteEditor", "control.RouteButton", "control.RoutePanel", "control.RulerControl", "control.SearchControl", "control.storage", "control.TrafficControl", "control.TypeSelector", "control.ZoomControl", "coordSystem.cartesian", "coordSystem.geo", "data.Manager", "DomEvent", "domEvent.manager", "domEvent.MultiPointer", "domEvent.MultiTouch", "domEvent.Pointer", "domEvent.Touch", "Event", "event.Group", "event.Manager", "event.Mapper", "formatter", "geocode", "findOrganization", "geolocation", "geometry.base.Circle", "geometry.base.LinearRing", "geometry.base.LineString", "geometry.base.Point", "geometry.base.Polygon", "geometry.base.Rectangle", "geometry.Circle", "geometry.LineString", "geometry.pixel.Circle", "geometry.pixel.LineString", "geometry.pixel.MultiPolygon", "geometry.pixel.Point", "geometry.pixel.Polygon", "geometry.pixel.Rectangle", "geometry.Point", "geometry.Polygon", "geometry.Rectangle", "geometry.MultiPolygon", "geometry.MultiLineString", "geometry.MultiPoint", "geometry.GeometryCollection", "geometryEditor.LineString", "geometryEditor.Point", "geometryEditor.Polygon", "GeoObject", "geoObject.addon.balloon", "geoObject.addon.editor", "geoObject.addon.hint", "geoObject.Balloon", "geoObject.Hint", "GeoObjectArray", "GeoObjectCollection", "geoQuery", "GeoQueryResult", "geoXml.load", "getZoomRange", "Hint", "Hotspot", "hotspot.Manager", "hotspot.Container", "hotspot.Layer", "hotspot.layer.addon.balloon", "hotspot.layer.addon.hint", "hotspot.layer.Balloon", "hotspot.layer.Hint", "hotspot.layer.Object", "hotspot.loader", "hotspot.ObjectSource", "hotspot.layer.ObjectSource", "interactivityModel.geoObject", "interactivityModel.layer", "interactivityModel.opaque", "interactivityModel.silent", "interactivityModel.storage", "interactivityModel.transparent", "Layer", "layer.storage", "layer.tile.CanvasTile", "layer.tile.DomTile", "layer.tileContainer.CanvasContainer", "layer.tileContainer.DomContainer", "LayerCollection", "layout.Image", "layout.ImageWithContent", "layout.PieChart", "layout.storage", "layout.templateBased.Base", "LoadingObjectManager", "Map", "map.action.Continuous", "map.action.Manager", "map.action.Single", "map.addon.balloon", "map.addon.hint", "map.Balloon", "map.behavior.Manager", "map.Container", "map.Converter", "map.Copyrights", "map.GeoObjects", "map.Hint", "map.layer.Manager", "map.margin.Manager", "map.margin.Accessor", "map.pane.Manager", "map.ZoomRange", "MapEvent", "MapType", "mapType.storage", "meta", "Monitor", "pane.EventsPane", "pane.MovablePane", "pane.StaticPane", "multiRouter.MultiRouteModel", "multiRouter.MultiRoute", "multiRouter.editor.addon", "ObjectManager", "objectManager.addon.clustersBalloon", "objectManager.addon.clustersHint", "objectManager.addon.objectsBalloon", "objectManager.addon.objectsHint", "option.Manager", "option.presetStorage", "overlay.storage", "package.controls.predefinedSets", "Placemark", "Polygon", "Polyline", "Popup", "panorama.Base", "panorama.Player", "panorama.createPlayer", "panorama.isSupported", "panorama.locate", "projection.Cartesian", "projection.sphericalMercator", "projection.wgs84Mercator", "Rectangle", "RemoteObjectManager", "regions", "borders", "util.requireCenterAndZoom", "route", "shape.Circle", "shape.LineString", "shape.MultiPolygon", "shape.Polygon", "shape.Rectangle", "shape.storage", "suggest", "SuggestView", "search", "Template", "template.filtersStorage", "templateLayoutFactory", "traffic.provider.Actual", "traffic.provider.Archive", "traffic.provider.Forecast", "traffic.provider.storage", "util.AsyncStorage", "util.augment", "util.bind", "util.bounds", "util.hd", "util.pixelBounds", "util.cursor.Accessor", "util.cursor.Manager", "util.defineClass", "util.Dragger", "util.extend", "util.math.areEqual", "util.math.cycleRestrict", "util.math.restrict", "util.Storage", "vow"], function (e) {
                var o = Array.prototype.slice.call(arguments, 1), t = ym.utils.createPackage(this.depends, o, !0);
                e(t)
            });
        }],
        ['0a', function (ym) {
            ym.modules.define("Balloon", ["util.defineClass", "Popup", "map.action.Single", "Monitor", "util.pixelBounds", "util.math.areEqual", "vow", "util.fireWithBeforeEvent", "balloon.component.getBalloonMode", "util.scheduler.strategy.Raf", "util.margin", ym.modules.preload("balloon.metaOptions")], function (e, t, n, s, i, o, a, r, h, l, p, u) {
                function c(e, t) {
                    c.superclass.constructor.call(this, e, t), this.options.setName("balloon")
                }

                t(c, n, {
                    open: function (e, t) {
                        this.options.set("panelMode", this._isPanelNeeded());
                        var n = this.isOpen(), s = c.superclass.open.call(this, e, t);
                        return s.then(function (e) {
                            var t = this.getOverlaySync().getLayout();
                            return t.then(function () {
                                return this._shape = this.getOverlaySync().getShape(), n || this._setupListeners(), this._isPanelNeeded() && this.options.get("autoPan") ? this._moveMapCenter() : this.options.get("autoPan") && this.autoPan(), e
                            }, this)
                        }, this)
                    }, close: function (e) {
                        var t = c.superclass.close.call(this, e);
                        return t.then(function () {
                            this._clearListeners(), this._shape = null
                        }, this), t
                    }, setPosition: function (e) {
                        return this._positionAtZoom = this._map.getZoom(), c.superclass.setPosition.call(this, e)
                    }, autoPan: function () {
                        if (this._isPanelNeeded()) return this.options.get("autoPan") ? this._moveMapCenter() : r.reject();
                        var e = this.getOverlaySync(), t = this.getMap();
                        if (!this.isOpen() || !t || !e) return r.reject();
                        var n = this._shape;
                        if (!n || "visible" == this.getOverlaySync().getPane().getOverflow()) return r.reject();
                        if (!this.isOpen()) return r.reject();
                        var i = r.defer(), a = t.action.getCurrentState(), h = Math.pow(2, a.zoom - t.getZoom()),
                            l = (1 == h ? n : n.scale(h)).getBounds(), p = this._map.container.getSize(),
                            c = this.options.get("autoPanMargin"),
                            g = this.options.get("autoPanUseMapMargin", !0) ? u.sum([c, this._map.margin.getMargin()]) : c,
                            v = p[0] / 2, d = p[1] / 2,
                            _ = [[a.globalPixelCenter[0] - v, a.globalPixelCenter[1] - d], [a.globalPixelCenter[0] + v, a.globalPixelCenter[1] + d]],
                            f = o.fit(l, _, g);
                        if (f) {
                            t.action.stop();
                            var M = t.getGlobalPixelCenter(), m = new s({
                                globalPixelCenter: [M[0] - f[0], M[1] - f[1]],
                                zoom: t.getZoom(),
                                duration: this.options.get("autoPanDuration", 500),
                                timingFunction: "ease-in-out",
                                checkZoomRange: this.options.get("autoPanCheckZoomRange", !1)
                            }, t);
                            this.events.fire("autopanbegin"), t.events.once("actionend", function () {
                                this.events.fire("autopanend"), i.resolve()
                            }, this), t.action.execute(m)
                        } else i.resolve();
                        return i.promise()
                    }, _setupListeners: function () {
                        this._mapListeners = this.getMap().events.group().add("boundschange", this._onMapBoundsChange, this).add("sizechange", this._applyPanelMode, this), this._overlayListeners = this.getOverlaySync().events.group().add("shapechange", this._onShapeChange, this).add("userclose", this._onUserClose, this), this._panelMaxMapAreaMonitor = new i(this.options).add("panelMaxMapArea", this._applyPanelMode, this)
                    }, _clearListeners: function () {
                        this._panelMaxMapAreaMonitor && this._panelMaxMapAreaMonitor.destroy(), this._overlayListeners && this._overlayListeners.removeAll(), this._mapListeners && this._mapListeners.removeAll()
                    }, _onMapBoundsChange: function () {
                        this.isOpen() && (this._preventAutoPanOnZoomChange = !0, this.setupGeometry(), this._preventAutoPanOnZoomChange = !1)
                    }, _applyPanelMode: function () {
                        var e = this._isPanelNeeded();
                        this.options.set("panelMode", e), e && this.options.get("autoPan") && (this.getOverlaySync().getLayoutSync() ? new p(this._moveMapCenter, this).start() : this.getOverlaySync().getLayout().then(this._moveMapCenter, this))
                    }, _onShapeChange: function () {
                        if (this.isOpen() && !this._isPanelNeeded()) {
                            var e = this.getOverlaySync().getShape();
                            if (e && this._shape) {
                                var t = e.getBounds(), n = this._shape.getBounds();
                                if (a(n[0], t[0]) && a(n[1], t[1])) return
                            }
                            this._shape = e, this.options.get("autoPan") && !this._preventAutoPanOnZoomChange && this.autoPan()
                        }
                    }, _moveMapCenter: function () {
                        var e = this.getMap(), t = this.getOverlaySync();
                        if (!this.isOpen() || !e || !t) return r.reject();
                        var n = r.defer(), s = t.getGeometry().getCoordinates(),
                            i = this.options.get("autoPanUseMapMargin", !0);
                        if (a(s, e.getGlobalPixelCenter({useMapMargin: i}))) n.resolve(); else {
                            var o = e.action.getCurrentState().zoom, h = this._positionAtZoom;
                            if (Math.abs(o - h) > 1e-7) {
                                var l = Math.pow(2, o - h);
                                s = [s[0] * l, s[1] * l]
                            }
                            n.resolve(e.setGlobalPixelCenter(s, o, {useMapMargin: i, duration: 300}))
                        }
                        return n.promise()
                    }, _onUserClose: function () {
                        h(this.events, {type: "userclose", target: this}, {
                            context: this,
                            successCallback: this._onBeforeUserCloseSuccess
                        })
                    }, _onBeforeUserCloseSuccess: function (e) {
                        this.close(), this.events.fire(e.type, e)
                    }, _isPanelNeeded: function () {
                        return "panel" == l(this.getMap(), this.options.get("panelMaxMapArea"))
                    }
                }), e(c)
            });
        }],
        ['0f', function (ym) {
            ym.modules.define("behavior.DblClickZoom", ["behavior.storage", "behavior.factory", "util.math.restrict", "util.coordinates.scaleInvert", "map.behavior.optionMapper", "yandex.counter"], function (t, e, i, n, o, a, l) {
                var s = i.create("dblClickZoom", {
                    startListening: function () {
                        this._listeners = this.getMap().events.group().add("dblclickdefaultaction", this._onDblClick, this).add("contextmenudefaultaction", this._onContextMenu, this)
                    }, stopListening: function () {
                        this._listeners.removeAll(), this._lastRightClick = null
                    }, _onDblClick: function (t) {
                        var e = t.get("originalEvent");
                        this._action(e, 1), this._preventDomEvent(e)
                    }, _onContextMenu: function (t) {
                        var e = +new Date, i = this.options.get("dblClickTimeout", 400), n = t.get("originalEvent");
                        this._lastRightClick && e - this._lastRightClick < i ? (this._action(n, -1), this._lastRightClick = null) : this._lastRightClick = e, this._preventDomEvent(n)
                    }, _action: function (t, e) {
                        var i = this.getMap();
                        i.action.stop();
                        var a, s = i.getZoom(), r = t.get("globalPixels"), c = this.options.get("duration", 200),
                            h = i.zoomRange.getCurrent(), g = n(s + e, h[0], h[1]), u = Math.pow(2, g - s),
                            d = this.options.get("centering", !0);
                        a = d ? [r[0] * u, r[1] * u] : o.fixedToCenter(i.getGlobalPixelCenter(), r, Math.pow(2, g - s));
                        var v = d && this.options.get("useMapMargin", !0);
                        i.setGlobalPixelCenter(a, g, {
                            duration: c,
                            useMapMargin: v
                        }), this.events.fire("zoomchange", {zoomDelta: e}), l.countByKey("control", "dblclick.action")
                    }, _preventDomEvent: function (t) {
                        var e = t.get("domEvent");
                        e && e.callMethod("preventDefault")
                    }
                });
                a.setRule({
                    name: "dblClickZoom",
                    key: ["centering", "duration"],
                    rule: "prefixed"
                }), e.add("dblClickZoom", s), t(s)
            });
        }],
        ['0g', function (ym) {
            ym.modules.define("behavior.Drag", ["behavior.storage", "behavior.action", "util.Dragger", "util.math.cubicBezier", "util.scheduler.strategy.Processing", "util.hd", "behavior.factory", "map.behavior.optionMapper", "Monitor", "behavior.component.defaultMouseDownDispatcher", "pane.EventsPane"], function (t, i, e, r, n, a, s, o, h, g, u, c) {
                function p(t, i, e, r, n, a, s) {
                    var o = m(i.slice(e)), h = t.get(e), g = n[1] ? n[1] - h.eventTimestamp : n[0] - h.timestamp,
                        u = Math.min(o / g, 1) * (s || 1), c = u * a, p = b(t.get(r).position, t.get(-1).position),
                        d = l(p);
                    return 0 == d ? {targetPath: [0, 0]} : {targetPath: [p[0] * c / d, p[1] * c / d]}
                }

                function d(t, i, e, r, n, a) {
                    var s = -.00125, o = m(i.slice(e)), h = t.get(e),
                        g = n[1] ? n[1] - h.eventTimestamp : n[0] - h.timestamp, u = Math.min(o / g, 2) * (a || 1),
                        c = Math.round(Math.min(Math.max(100, -u / s), 900)), p = u * c + s * c * c / 2,
                        d = b(t.get(r).position, t.get(-1).position), v = l(d);
                    return 0 == v ? {targetPath: [0, 0], duration: c} : {
                        targetPath: [d[0] * p / v, d[1] * p / v],
                        duration: c
                    }
                }

                function m(t) {
                    for (var i = 0, e = 0; e < t.length; ++e) i += t[e];
                    return i
                }

                function v(t, i) {
                    for (var e = 0, r = t.length - 1; r >= 0; r--) if (e += t[r], e >= i) return r;
                    return -1
                }

                function _(t) {
                    for (var i = s.getPixelRatio(), e = [], r = 0, n = t.length; r < n - 1; r++) e.push(l(t[r].position, t[r + 1].position) / i);
                    return e
                }

                function l(t, i) {
                    "undefined" == typeof i && (i = t, t = [0, 0]);
                    var e = b(t, i);
                    return Math.sqrt(Math.pow(e[0], 2) + Math.pow(e[1], 2))
                }

                function b(t, i) {
                    return [i[0] - t[0], i[1] - t[1]]
                }

                function f(t) {
                    this._length = t || 1 / 0, this.data = []
                }

                var D = ym.env.browser, C = o.create("drag", {
                    startListening: function () {
                        var t = this.getMap();
                        this._moves = new f(30), this._grabCursorKey = this.options.get("cursor"), this._grabbingCursorKey = this.options.get("actionCursor"), this._cursorMonitor = new g(this.options).add("cursor", this._onGrabCursorChange, this).add("actionCursor", this._onGrabbingCursorChange, this), this._grabCursor = t.cursors.push(this._grabCursorKey), this._mapEvents = t.events.group().add("multitouchstart", this._stopInertia, this).add("multitouchend", this._onMultiTouchEnd, this), this._dispatcher = u.get(t).add(0, this._onMouseDown, this)
                    }, stopListening: function () {
                        this._dispatcher.remove(0), this._mapEvents.removeAll(), this._grabCursor.remove(), this._cursorMonitor.removeAll(), this._clearDraggerData()
                    }, _onMouseDown: function (t) {
                        var i = t.get("originalEvent").get("domEvent");
                        0 == i.get("button") && this._createDragger(i)
                    }, _onMultiTouchEnd: function (t) {
                        function i(t) {
                            this._mapEvents.remove(["mousemove", "mouseup"], i, this), "mousemove" == t.get("type") && this._createDragger(t)
                        }

                        var e = t.get("touches");
                        e && 1 == e.length && this._mapEvents.add(["mousemove", "mouseup"], i, this)
                    }, _createDragger: function (t) {
                        this._draggerEvents && this._draggerEvents.removeAll(), this._dragger = new r({
                            tremor: this.options.get("tremor", 2),
                            disableBrowserBehavior: !0
                        }), this._dragger.start(t), this._draggerEvents = this._dragger.events.group(), this._draggerEvents.add("start", this._onDragStart, this).add("move", this._onDragMove, this).add("cancel", this._onDragCancel, this).add("stop", this._onDragStop, this), this._moved = !1
                    }, _onDragMove: function (t) {
                        if (e.capture(this.getMap(), this), !this._grabbingCursor) {
                            var i = (this.getMap(), this.getMap().panes.findUpper(c));
                            this._grabbingCursor = i.cursors.push(this._grabbingCursorKey)
                        }
                        this._moved || (this.events.fire("dragstart"), this._moved = !0), e.tick({
                            pixelOffset: t.get("delta"),
                            duration: 0
                        }, {
                            autoStopTimeout: this.options.get("autoStopTimeout", 500),
                            behavior: this
                        }), this.options.get("inertia") && this._addMove(t)
                    }, _onDragCancel: function () {
                        this._clearDraggerData(), e.release({behavior: this})
                    }, _onDragStart: function (t) {
                        this.options.get("inertia") && this._addMove(t), this._stopInertia()
                    }, _onDragStop: function (t) {
                        var i = null;
                        this.options.get("inertia") && (i = this._startKinetic(t)), this._clearDraggerData(), i || e.release({behavior: this})
                    }, _addMove: function (t) {
                        var i = {
                            timestamp: +new Date,
                            eventTimestamp: t.get("domEvent").get("timeStamp"),
                            position: t.get("position")
                        };
                        this._moves.add(i)
                    }, _clearDraggerData: function () {
                        this._grabbingCursor && (this._grabbingCursor.remove(), this._grabbingCursor = null), this._moved && (this.events.fire("dragend"), this._moved = !1), this._draggerEvents && (this._draggerEvents.removeAll(), this._draggerEvents = null)
                    }, _startKinetic: function (t) {
                        var i = -1;
                        t && (this._addMove(t), i = -2);
                        var r = this._moves;
                        if (!r.data.length) return !1;
                        var s = {
                                inertiaDuration: this.options.get("inertiaDuration", 400),
                                inertiaTimingFunction: this.options.get("inertiaTimingFunction", "cubic-bezier(0, 0.1, 0.4, 1)"),
                                inertiaTimeout: this.options.get("inertiaTimeout", 75),
                                inertiaMinDistance: this.options.get("inertiaMinDistance", 10),
                                inertiaSpeedDistance: this.options.get("inertiaSpeedDistance", 40),
                                inertiaSpeedFactor: this.options.get("inertiaSpeedFactor", 1)
                            }, o = _(r.data), h = v(o, s.inertiaMinDistance), g = v(o, s.inertiaSpeedDistance),
                            u = (new Date).getTime(), c = t.get("domEvent").get("timeStamp"), m = r.get(i),
                            l = m.timestamp, b = m.eventTimestamp, f = c && b ? c - b : 0, C = u - l, M = f;
                        if (f < 4 && (c = 0, M = C), M > s.inertiaTimeout) return r.clear(), !1;
                        if (h < 0) return r.clear(), !1;
                        g < 0 && (g = 0), "string" != typeof s.inertiaTimingFunction && (s.inertiaTimingFunction = "cubic-bezier(" + s.inertiaTimingFunction.toString() + ")");
                        var S, T, P, y = this.getMap().action.getCurrentState().globalPixelCenter,
                            E = this.getMap().action.getCurrentState().zoom;
                        if ("auto" == s.inertiaDuration ? (S = d(r, o, g, h, [u, c], s.inertiaSpeedFactor), P = S.duration) : (S = p(r, o, g, h, [u, c], s.inertiaDuration, s.inertiaSpeedFactor), P = s.inertiaDuration), T = S.targetPath, r.clear(), this.events.fire("inertiastart", {
                            targetGlobalPixelCenter: [y[0] - T[0], y[1] - T[1]],
                            zoom: E
                        }), this._inertiaStarted = !0, this.options.get("stepwiseInertia", !0) === !1 || "WebKit" == D.engine && "iOS" == D.osFamily) {
                            var w = [y[0] - T[0], y[1] - T[1]];
                            e.capture(this.getMap(), this), e.tick({
                                globalPixelCenter: w,
                                zoom: E,
                                duration: P,
                                timingFunction: s.inertiaTimingFunction
                            }, {autoStopTimeout: 0, behavior: this})
                        } else {
                            var F = +new Date;
                            this._kineticProcess && (this._kineticProcess.stop(), this._kineticProcess = null), e.capture(this.getMap(), this), this._kineticProcess = new a(function () {
                                var t = n(s.inertiaTimingFunction).getValue(Math.min((+new Date - F) / P, 1));
                                e.isActive() && e.tick({
                                    globalPixelCenter: [y[0] - T[0] * t, y[1] - T[1] * t],
                                    zoom: E,
                                    duration: 0
                                }, {
                                    autoStopTimeout: 100,
                                    behavior: this
                                }), 1 != t && e.isActive() || this._stopInertia()
                            }, this, {duration: P}), this._kineticProcess.start()
                        }
                        return e.events.once("end", this._stopInertia, this), !0
                    }, _stopInertia: function () {
                        if (this._inertiaStarted && (this._inertiaStarted = !1, this.getMap())) {
                            var t = this.getMap().action.getCurrentState();
                            this.events.fire("inertiaend", {globalPixelCenter: t.globalPixelCenter, zoom: t.zoom})
                        }
                        this._kineticProcess && (this._kineticProcess.stop(), this._kineticProcess = null), e.release({behavior: this})
                    }, _onGrabCursorChange: function (t) {
                        this._grabCursorKey = t, this._grabCursor && this._grabCursor.setKey(t)
                    }, _onGrabbingCursorChange: function (t) {
                        this._grabbingCursorKey = t, this._grabbingCursor && this._grabbingCursor.setKey(t)
                    }
                });
                h.setRule({
                    name: "drag",
                    key: ["inertia", "inertiaDuration", "inertiaTimingFunction", "inertiaTimeout", "stepwiseInertia", "frameRateCompensation", "inertiaMinDistance", "inertiaSpeedDistance", "inertiaSpeedFactor", "autoStopTimeout", "cursor", "actionCursor"],
                    rule: "prefixed"
                }), f.prototype = {
                    add: function (t) {
                        this.data.push(t), this.data.length > this._length && this.data.shift()
                    }, get: function (t) {
                        return t >= 0 ? this.data[t] : this.data[this.data.length + t]
                    }, clear: function () {
                        this.data = []
                    }
                }, i.add("drag", C), t(C)
            });
        }],
        ['0l', function (ym) {
            ym.modules.define("behavior.LeftMouseButtonMagnifier", ["behavior.factory", "behavior.magnifier.mouse.Component", "behavior.storage", "map.behavior.optionMapper", "Monitor"], function (o, t, e, i, n, r) {
                var s = t.create("leftMouseButtonMagnifier", {
                    startListening: function () {
                        this._component = new e(this, 0), this._optionsMonitor = new r(this.options), this._optionsMonitor.add("cursor", this._onCursorChange, this), this._magnifierCursor = this.getMap().cursors.push(this._optionsMonitor.get("cursor"))
                    }, stopListening: function () {
                        this._component.destroy(), this._optionsMonitor.destroy(), this._magnifierCursor.remove()
                    }, _onCursorChange: function (o) {
                        this._magnifierCursor.setKey(o)
                    }
                });
                n.setRule({
                    name: "leftMouseButtonMagnifier",
                    rule: "prefixed"
                }).setRule({
                    name: "leftMouseButtonMagnifier",
                    key: ["projection"],
                    rule: "plain"
                }), i.add("leftMouseButtonMagnifier", s), o(s)
            });
        }],
        ['0o', function (ym) {
            ym.modules.define("behavior.MultiTouch", ["behavior.storage", "behavior.factory", "behavior.MultiTouchEngine", "map.behavior.optionMapper"], function (e, i, t, n, o) {
                var r = t.create("multiTouch", {
                    startListening: function () {
                        this._engine = new n(this), this._engine.startListening()
                    }, stopListening: function () {
                        this._engine.stopListening(), this._engine = null
                    }
                });
                o.setRule({
                    name: "multiTouch",
                    key: ["tremor", "autoStopTimeout", "zoomSensitivity", "scaleTremor", "actionsPerSecond"],
                    rule: "prefixed"
                }), i.add("multiTouch", r), e(r)
            });
        }],
        ['0m', function (ym) {
            ym.modules.define("behavior.RightMouseButtonMagnifier", ["behavior.factory", "behavior.magnifier.mouse.Component", "behavior.storage", "map.behavior.optionMapper"], function (e, i, t, n, o) {
                var r = i.create("rightMouseButtonMagnifier", {
                    startListening: function () {
                        this._component = new t(this, 2)
                    }, stopListening: function () {
                        this._component.destroy()
                    }
                });
                o.setRule({
                    name: "rightMouseButtonMagnifier",
                    rule: "prefixed"
                }).setRule({
                    name: "rightMouseButtonMagnifier",
                    key: ["projection"],
                    rule: "plain"
                }), n.add("rightMouseButtonMagnifier", r), e(r)
            });
        }],
        ['0r', function (ym) {
            ym.modules.define("behavior.RouteEditor", ["behavior.storage", "behavior.factory", "util.array", "route", "map.associate.serviceGeoObjects", "util.cancelableCallback", "yandex.counter"], function (t, e, o, i, s, n, r, a) {
                var u = o.create("routeEditor", {
                    startListening: function () {
                        !this._route || this._route.getWayPoints().getLength() > 1 ? this._createLoadModulesRequest() : (this._startEditor(), this._bindEvents())
                    }, stopListening: function () {
                        this._clearLoadModulesRequest(), this._route && this._route.editor && this._route.editor.options.set("addWayPoints", !1), this._unbindEvents()
                    }, getRoute: function () {
                        return this._route
                    }, getState: function () {
                        for (var t = [], e = [], o = "", i = this._route.requestPoints, s = 0, n = i.length; s < n; s++) {
                            var r = i[s];
                            t.push((r.point || r).join(",")), "viaPoint" == r.type && e.push(s)
                        }
                        return t.length && (o += "rt=" + t.join("~")), e.length && (o += "&via=" + e.join(",")), o
                    }, setState: function (t) {
                        this._clearLoadModulesRequest();
                        var e = this._route;
                        if (this._removeRoute(), !t) return void this._fireRouteChange(e, this._route);
                        var o, n = t.split("&"), a = n[0] && n[0].substr(3).split("~"), u = [];
                        if (a && a.length) {
                            o = i.map(n[1] && n[1].substr(4).split(",") || [], parseInt);
                            for (var d = 0, h = a.length; d < h; d++) u.push({
                                type: i.indexOf(o, d) != -1 ? "viaPoint" : "wayPoint",
                                point: i.map(a[d].split(","), parseFloat)
                            });
                            this._loadModuleCallback = r.create(function (t) {
                                this._route = t, this._addRouteToMap(), this._startEditor(), this._onRouteUpdate(), this._fireRouteChange(e, this._route)
                            }, this), s(u).then(this._loadModuleCallback)
                        }
                    }, _startEditor: function () {
                        this._route.editor.start({
                            addViaPoints: !0,
                            addWayPoints: this._route.getWayPoints().getLength() < 2,
                            removeViaPoints: !0,
                            editWayPoints: !0,
                            editViaPoints: !0
                        }), a.countByKey("control", "routeEditor.start")
                    }, _addRouteToMap: function () {
                        n.get(this.getMap()).add(this._route)
                    }, _removeRouteFromMap: function () {
                        n.get(this.getMap()).remove(this._route)
                    }, _removeRoute: function () {
                        this._route && (this._unbindEvents(), this._removeRouteFromMap(), this._route = null)
                    }, _bindEvents: function () {
                        this._editorEvents = this._route.editor.events.group(), this._editorEvents.add("routeupdate", this._onRouteUpdate, this)
                    }, _unbindEvents: function () {
                        this._editorEvents && (this._editorEvents.removeAll(), this._editorEvents = null)
                    }, _onRouteUpdate: function () {
                        a.countByKey("control", "routeEditor.routeAdded"), this._route.getWayPoints().getLength() >= 2 && this.disable()
                    }, _fireRouteChange: function (t, e) {
                        t !== e && this.events.fire("routechange")
                    }, _createLoadModulesRequest: function () {
                        this._loadModuleCallback = r.create(function (t) {
                            this._loadModuleCallback = null, this.setState(null), this._route = new t({
                                features: [],
                                properties: {}
                            }, this.options.get("routeOptions")), this._addRouteToMap(), this._startEditor(), this._bindEvents()
                        }, this), ym.modules.require(["router.Route", "router.addon.editor"], this._loadModuleCallback)
                    }, _clearLoadModulesRequest: function () {
                        this._loadModuleCallback && (this._loadModuleCallback.cancel(), this._loadModuleCallback = null)
                    }
                });
                e.add("routeEditor", u), t(u)
            });
        }],
        ['0s', function (ym) {
            ym.modules.define("behavior.Ruler", ["behavior.factory", "behavior.storage", "map.behavior.optionMapper", "pane.EventsPane", "hotspot.Manager", "constants.paneZIndex", "geometry.LineString", "localization.common.current", "util.cancelableCallback", "domEvent.manager", "constants.mapListenerPriority", "yandex.counter", "yandex.state.component.RulerBehavior", "behavior.ruler.preset"], function (e, t, n, s, i, r, o, a, l, h, u, c, v, p) {
                function m() {
                    if ("iOS" == ym.env.browser.osFamily) {
                        var e = u.group(document.documentElement, !0);
                        e.add("touchstart", function (t) {
                            t.callMethod("preventDefault"), t.callMethod("stopPropagation"), e.removeAll()
                        })
                    }
                    return window.confirm(l.Control.Ruler.sure.split("\\n").join("\n"))
                }

                var g = "latlong" == ym.env.coordinatesOrder, _ = function (e) {
                    return g ? [e[1], e[0]] : e
                }, d = t.create("ruler", {
                    init: function (e, t) {
                        d.superclass.constructor.call(this, e, t), this.geometry = new a(null, {preset: "ruler#line"}), this._yandexStateRulerComponent = new p(this)
                    }, onAddToMap: function (e) {
                        d.superclass.onAddToMap.call(this, e), this.geometry.options.setParent(e.options), this.geometry.setMap(e)
                    }, onRemoveFromMap: function () {
                        this._clearView(), d.superclass.onRemoveFromMap.call(this)
                    }, startListening: function () {
                        this._setupEventsPane()
                    }, stopListening: function () {
                        this._clearEventsPane()
                    }, getState: function () {
                        for (var e = [], t = [0, 0], n = 0, s = this.geometry.getLength(); n < s; n++) {
                            var i = _(this.geometry.get(n));
                            e.push((i[0] - t[0]).toFixed(8) + "," + (i[1] - t[1]).toFixed(8)), t = i
                        }
                        return e.join("~")
                    }, setState: function (e) {
                        if (e) {
                            var t = e.split(/~|,/), n = t.length;
                            if (n > 1) {
                                for (var s = [0, 0], i = [], r = 0; r < n; r += 2) s[0] += parseFloat(t[r]), s[1] += parseFloat(t[r + 1]), i.push(_(s.slice()));
                                this._setupView(), this.geometry.setCoordinates(i)
                            }
                        } else this.geometry.setCoordinates([])
                    }, close: function () {
                        return !!(this.geometry.getLength() < 3 || m()) && (this.geometry.setCoordinates([]), !0)
                    }, _setupEventsPane: function () {
                        var e = this.getMap();
                        this._eventsPane = new i(e, {zIndex: o.ruler}), e.panes.append("rulerEvents", this._eventsPane), this._hotspotManager = new r(this._eventsPane), this._view && this._view.setEventsPane("rulerEvents"), e.events.add("click", this._onMapClick, this, c.ruler), this._cursorHandler = this._eventsPane.cursors.push("arrow")
                    }, _clearEventsPane: function () {
                        var e = this.getMap();
                        this._cursorHandler.remove(), e.events.remove("click", this._onMapClick, this, c.ruler), this._view && this._view.setEventsPane("events"), this._hotspotManager.destroy(), this._hotspotManager = null, e.panes.remove(this._eventsPane), this._eventsPane = null
                    }, _onMapClick: function (e) {
                        e.stopImmediatePropagation(), e.stopPropagation(), e.preventDefault(), this._setupView(), this.geometry.insert(this.geometry.getLength(), e.get("coords")), v.countByKey("control", "ruler.click")
                    }, _setupView: function () {
                        this._viewCallback || this._view || !this.getMap() || (this._viewCallback = h.create(function (e) {
                            this.geometry.setMap(null), this._viewCallback = null, this._view = new e(this), this._view.setEventsPane(this.isEnabled() ? "rulerEvents" : "events")
                        }, this), ym.modules.require(["behavior.ruler.View"], this._viewCallback))
                    }, _clearView: function () {
                        this._viewCallback && (this._viewCallback.cancel(), this._viewCallback = null), this._view ? (this._view.destroy(), this._view = null) : this.geometry.setMap(null)
                    }
                });
                n.add("ruler", d), s.setRule({name: "ruler", rule: "prefixed"}).setRule({
                    name: "ruler",
                    key: ["projection"],
                    rule: "plain"
                }), e(d)
            });
        }],
        ['0A', function (ym) {
            ym.modules.define("behavior.scrollZoom.DescreteZoomHandler", ["util.defineClass", "behavior.scrollZoom.BaseZoomHandler", "util.math.getSign"], function (t, e, o, i) {
                var r = function (t) {
                    r.superclass.constructor.call(this, t)
                };
                e(r, o, {
                    teardownState: function () {
                        this._startZoom = null
                    }, getTimeFilterValue: function () {
                        return this._behavior.options.get("speed", 5)
                    }, getZoomDuration: function (t, e) {
                        return Math.round(1e3 * Math.abs(t) / this.getTimeFilterValue())
                    }, getNextZoom: function (t, e) {
                        var o = e + i(t, !0);
                        return o = this._filterByZoomRange(this._filterByMaximumDelta(o))
                    }, _getStartZoom: function () {
                        return null === this._startZoom ? this._startZoom = this._behavior.getMap().action.getCurrentState().zoom : this._startZoom
                    }, _filterByMaximumDelta: function (t) {
                        var e = this._behavior.options.get("maximumDelta", 5);
                        if ("undefined" != typeof e) {
                            var o = t - this._getStartZoom();
                            Math.abs(o) > e && (t -= o - i(o) * e)
                        }
                        return t
                    }
                }), t(r)
            });
        }],
        ['0C', function (ym) {
            ym.modules.define("behavior.scrollZoom.SmoothZoomHandler", ["util.defineClass", "behavior.scrollZoom.BaseZoomHandler", "system.browser"], function (t, o, e, i) {
                function n(t) {
                    return t < 0 ? -1 : t > 0 ? 1 : 0
                }

                var a = 40, r = 23, s = 200, u = .025, l = .5, m = .01, c = 800, h = .75, f = 1,
                    v = "Windows" == i.osFamily ? h : f, d = function (t) {
                        d.superclass.constructor.call(this, t), this._zoomDeltaYAccumulator = 0
                    };
                o(d, e, {
                    onBeforeWheel: function (t) {
                        this._zoomDeltaYAccumulator += t
                    }, onAfterWheel: function (t) {
                        t && this.teardownState()
                    }, teardownState: function () {
                        this._zoomDeltaYAccumulator = 0
                    }, getTimeFilterValue: function () {
                        return a
                    }, getZoomDuration: function (t, o) {
                        var e = o < 2 * r ? 0 : Math.floor(Math.abs(t) / u * r);
                        return Math.min(e, s)
                    }, getNextZoom: function (t, o) {
                        var e = n(this._zoomDeltaYAccumulator),
                            i = this._zoomDeltaYAccumulator / this._getSensitivity(), a = Math.abs(i);
                        i = Math.max(Math.min(a, l), m) * e;
                        var r = this._filterByZoomRange(o + i);
                        return r = +r.toFixed(2)
                    }, _getSensitivity: function () {
                        return this._behavior.options.get("smoothSensitivity", c) * v
                    }
                }), t(d)
            });
        }],
        ['0B', function (ym) {
            ym.modules.define("behavior.ScrollZoom", ["util.coordinates.scaleInvert", "behavior.action", "behavior.storage", "behavior.factory", "map.behavior.optionMapper", "util.math.getSign", "domEvent.manager", "yandex.counter", "behavior.scrollZoom.SmoothZoomHandler", "behavior.scrollZoom.DescreteZoomHandler"], function (t, e, o, i, n, s, a, h, r, l, c) {
                var m = 100, u = 40, _ = n.create("scrollZoom", {
                    startListening: function () {
                        this._targetZoom = null, this._setupDocumentListener(), this._started = !1, this._mapListeners = this.getMap().events.group().add("wheeldefaultaction", this._onWheel, this).add("click", this._onClick, this), this._smoothZoomHandler = new l(this), this._descreteZoomHandler = new c(this), this._lastTickTime = Date.now()
                    }, stopListening: function () {
                        this._started && (this._unscheduleStop(), this._started = !1, this._lastDocumentWheel = null), this._teardownDocumentListener(), this._mapListeners.removeAll()
                    }, _setupDocumentListener: function () {
                        this._domListeners = h.group(document).add("wheel", this._onDocumentWheel, this)
                    }, _teardownDocumentListener: function () {
                        this._domListeners.removeAll()
                    }, _onDocumentWheel: function (t) {
                        var e = t.get("deltaX"), o = t.get("deltaY");
                        this._started || !e && !o || (this._lastDocumentWheel ? this._lastDocumentWheel.timestamp = Date.now() : this._lastDocumentWheel = {
                            timestamp: Date.now(),
                            firstWheelPosition: t.get("position")
                        })
                    }, _onClick: function () {
                        this._lastDocumentWheel = null, this._started = !1
                    }, _onWheel: function (t) {
                        var e = t.get("originalEvent"), o = e.get("domEvent"), i = e.get("position"), n = Date.now();
                        if ((!(this._lastDocumentWheel && n - this._lastDocumentWheel.timestamp < 300) || i[0] == this._lastDocumentWheel.firstWheelPosition[0] && i[1] == this._lastDocumentWheel.firstWheelPosition[1]) && o) {
                            o.callMethod("preventDefault");
                            var s = o.originalEvent && o.originalEvent.deltaMode === WheelEvent.DOM_DELTA_PIXEL ? 1 : u,
                                a = o.get("deltaX"), h = o.get("deltaY") * s;
                            if (this._started || r.countByKey("control", "scrollZoom.wheel"), this._started || h && Math.abs(h) > Math.abs(a)) {
                                this._started = !0, this._scheduleStop();
                                var l = this.options.get("smooth", !1) ? this._smoothZoomHandler : this._descreteZoomHandler;
                                l.onBeforeWheel(h);
                                var c = this._checkWheelTrend(h) || this._checkTimeInterval(l.getTimeFilterValue());
                                if (c) {
                                    var m = this._getTargetZoom(), _ = l.getNextZoom(h, m), d = _ - m;
                                    if (d) {
                                        var g = l.getZoomDuration(d, this._getTimeDelta());
                                        this._tick(_, i, g), this._fireZoomChange(d)
                                    } else this._teardownState()
                                }
                                l.onAfterWheel(c)
                            }
                        }
                    }, _checkWheelTrend: function (t) {
                        var e = this._currentWheelTrend, o = a(t, !0);
                        return Math.abs(o) > 1e-10 && (this._currentWheelTrend = o, o != e)
                    }, _checkTimeInterval: function (t) {
                        return !this._lastTickTime || Date.now() - this._lastTickTime > 1e3 / t
                    }, _scheduleStop: function () {
                        this._unscheduleStop(), this._stopTimeout = window.setTimeout(this._onSeriesStop.bind(this), m)
                    }, _unscheduleStop: function () {
                        window.clearTimeout(this._stopTimeout)
                    }, _onSeriesStop: function () {
                        this._started = !1, this._lastDocumentWheel = null
                    }, _getTargetZoom: function () {
                        return null === this._targetZoom ? this.getMap().action.getCurrentState().zoom : this._targetZoom
                    }, _tick: function (t, i, n) {
                        this._lastTickTime = Date.now(), this._targetZoom = t;
                        var s = this.getMap(), a = s.action.getCurrentState(), h = a.zoom, r = t - h,
                            l = a.globalPixelCenter, c = s.container.getOffset(), m = s.container.getSize();
                        this._actionListeners || (o.capture(s, this), this._actionListeners = o.events.group().add("end", this._teardownState, this)), o.tick({
                            globalPixelCenter: e.fixedToCenter(l, [l[0] + i[0] - c[0] - m[0] / 2, l[1] + i[1] - c[1] - m[1] / 2], Math.pow(2, r)),
                            zoom: t,
                            duration: n,
                            timingFunction: r > 0 ? "ease-in" : "ease-out"
                        }, {autoStopTimeout: Math.max(n, 100), behavior: this})
                    }, _teardownState: function () {
                        o.release({behavior: this}), this._actionListeners && (this._actionListeners.removeAll(), this._actionListeners = null), this._targetZoom = null, this._currentWheelTrend = null, this._smoothZoomHandler.teardownState(), this._descreteZoomHandler.teardownState()
                    }, _fireZoomChange: function (t) {
                        this.events.fire("zoomchange", {zoomDelta: t})
                    }, _getTimeDelta: function () {
                        return this._lastTickTime ? Date.now() - this._lastTickTime : null
                    }
                });
                s.setRule({
                    name: "scrollZoom",
                    key: ["maximumDelta", "speed", "sensitivity", "smooth", "smoothSensitivity"],
                    rule: "prefixed"
                }), i.add("scrollZoom", _), t(_)
            });
        }],
        ['0D', function (ym) {
            ym.modules.define("behavior.storage", ["util.Storage"], function (e, o) {
                e(new o)
            });
        }],
        ['4U', function (ym) {
            ym.modules.define("Circle", ["util.augment", "GeoObject"], function (e, t, n) {
                function r(e) {
                    return e && "undefined" == typeof e.length ? e : {type: "Circle", coordinates: e[0], radius: e[1]}
                }

                var i = function (e, t, n) {
                    i.superclass.constructor.call(this, {geometry: r(e), properties: t}, n)
                };
                t(i, n), e(i)
            });
        }],
        ['0L', function (ym) {
            ym.modules.define("Clusterer", ["util.defineClass", "geoObject.optionMapper", "clusterer.component.GridClusterer", "util.array", "util.id", "util.bounds", "component.child.MapChild", "Monitor", "ClusterPlacemark", "data.Manager", "option.Manager", "event.Manager", "component.collection.ParentCollection", "event.Mapper", "geoObject.EventMappingTable", "clusterer.optionMapper", "event.globalize", "yandex.counter", "error", "theme.islands.cluster.metaOptions"], function (e, t, n, s, o, r, i, a, c, h, l, u, g, d, p, _, b, m, f, j) {
                function v(e, t) {
                    return t + e.slice(0, 1).toUpperCase() + e.slice(1)
                }

                function C(e, t) {
                    var n = e.replace(t, "");
                    return n.slice(0, 1).toLowerCase() + n.slice(1)
                }

                var O = function (e) {
                    this.options = new u(e, null, "clusterer", b), this.options.events.add("change", this._onOptionsChange, this), this.events = new g({context: this}), this._clustererComponent = new s(this.options), this._mapChildComponent = new a({
                        onMapChange: {
                            callback: this._onMapChange,
                            context: this
                        }, onParentChange: {callback: this._onParentChange, context: this}
                    }), this._collectionComponent = new d(this, null, new p(this.events, new _(this))), this._objects = {}, this._clusters = {}, this._mapListener = null, this._objectsCounter = 0, this._geoBounds = null, this.events.addController(M), this.events.fire("create")
                }, M = m(O);
                t(O, {
                    add: function (e) {
                        var t;
                        t = o.isArray(e) ? e : [e], t = this._getNotAddedObjects(t), this._addGeoObjects(t);
                        var n = this._getHashesByObjects(t);
                        if (ym.env.debug) for (var s = 0, r = n.length; s < r; s++) j.warnIf("string" == typeof n[s].geometry.coordinates[0] || "string" == typeof n[s].geometry.coordinates[1], "Warning", "Clusterer: coordinates of added object are strings and must be numbers (" + n[s].geometry.coordinates + ").");
                        return this._clustererComponent.add(n), this.events.fire("pixelboundschange"), this
                    }, remove: function (e) {
                        var t;
                        t = o.isArray(e) ? e : [e], t = this._getAddedObjects(t);
                        var n = this._getHashesByObjects(t);
                        return this._clustererComponent.remove(n), this._removeGeoObjects(t), this.events.fire("pixelboundschange"), this
                    }, removeAll: function () {
                        return this._clustererComponent.removeAll(), this._objects = {}, this._geoBounds = null, this.events.fire("pixelboundschange"), this
                    }, createCluster: function (e, t) {
                        var n = "";
                        return n = this.options.get("showInAlphabeticalOrder") ? "alphabetical" : "serial", t.sort(y[n].bind(this)), new h(e, new l({
                            geoObjects: t,
                            iconContent: t.length.toString()
                        }))
                    }, getObjectState: function (e) {
                        var t = this._clustererComponent.getObjectState(r.get(e));
                        return {
                            isShown: !!t && !!t.isShown,
                            isClustered: !!t && !!t.isClustered,
                            cluster: t && t.isClustered ? this._clusters[t.cluster.id].clusterObject : null
                        }
                    }, getBounds: function () {
                        if (!this._geoBounds) {
                            var e = [];
                            for (var t in this._objects) this._objects.hasOwnProperty(t) && e.push(this._objects[t].geoObject.geometry.getCoordinates());
                            this._geoBounds = 0 == e.length ? null : i.fromPoints(e, this.options.get("projection"))
                        }
                        return this._geoBounds
                    }, getPixelBounds: function () {
                        var e = this.getBounds();
                        return e && this.getMap() ? i.toGlobalPixelBounds(e, this.getMap().getZoom(), this.options.get("projection")) : null
                    }, getGeoObjects: function () {
                        var e = [];
                        for (var t in this._objects) e.push(this._objects[t].geoObject);
                        return e
                    }, getClusters: function () {
                        var e = [];
                        for (var t in this._clusters) e.push(this._clusters[t].clusterObject);
                        return e
                    }, getMap: function () {
                        return this._mapChildComponent.getMap()
                    }, setParent: function (e) {
                        return this._mapChildComponent.setParent(e), this
                    }, getParent: function () {
                        return this._mapChildComponent.getParent()
                    }, _onMapChange: function (e, t) {
                        e && this._removeFromMap(e), t && this._addToMap(t), this.events.fire("mapchange", {
                            oldMap: e,
                            newMap: t
                        })
                    }, _addToMap: function (e) {
                        this._mapListener = e.events.group().add("boundschange", this._onMapBoundsChange, this), this._clustererComponent.events.add("statechange", this._onStateChange, this), this._clustererComponent.setMap(e), f.countByKey("modulesUsage", "clusterer.create")
                    }, _removeFromMap: function (e) {
                        this._clustererComponent.setMap(null), this._clustererComponent.events.remove("statechange", this._onStateChange, this), this._mapListener.removeAll()
                    }, _onStateChange: function (e) {
                        var t = e.get("added"), n = e.get("removed"), s = e.get("addedClusters"),
                            o = e.get("removedClusters");
                        this._removeObjectsFromMap(n), this._removeClustersFromMap(o), this._addObjectsToMap(t), this._addClustersToMap(s)
                    }, _addClustersToMap: function (e) {
                        for (var t = 0, n = e.length; t < n; t++) this._clusters[e[t].id] = this._createClusterObject(e[t]), this._addObjectToMap(this._clusters[e[t].id].clusterObject)
                    }, _removeClustersFromMap: function (e) {
                        for (var t = 0, n = e.length; t < n; t++) {
                            var s = this._getClusterByHash(e[t]);
                            this._removeObjectFromMap(s), this._clearClusterData(e[t])
                        }
                    }, _addObjectsToMap: function (e) {
                        for (var t = 0, n = e.length; t < n; t++) {
                            var s = this._getObjectByHash(e[t]);
                            e[t].singleShown = !0, s.getMap() || this._addObjectToMap(s)
                        }
                    }, _removeObjectsFromMap: function (e) {
                        for (var t = 0, n = e.length; t < n; t++) {
                            var s = this._getObjectByHash(e[t]);
                            e[t].singleShown = !1, s.getMap() && this._removeObjectFromMap(s)
                        }
                    }, _createClusterObject: function (e) {
                        for (var t, n, s = [], o = e.properties.geoObjects, r = 0, i = o.length; r < i; r++) n = this._objects[o[r].id].geoObject, n.options.setParent(this.options), s.push(n);
                        t = this.createCluster(e.geometry.coordinates, s);
                        for (var r = 0, i = o.length; r < i; r++) this._objects[o[r].id].cluster = t;
                        return {hash: e, clusterObject: t}
                    }, _getClusterByHash: function (e) {
                        return this._clusters[e.id] ? this._clusters[e.id].clusterObject : null
                    }, _addObjectToMap: function (e) {
                        this._collectionComponent.add(e)
                    }, _removeObjectFromMap: function (e) {
                        this._collectionComponent.remove(e)
                    }, _getObjectByHash: function (e) {
                        return this._objects[e.id].geoObject
                    }, _getAddedObjects: function (e) {
                        for (var t = [], n = 0, s = e.length; n < s; n++) this._objects[r.get(e[n])] && t.push(e[n]);
                        return t
                    }, _getNotAddedObjects: function (e) {
                        for (var t = [], n = 0, s = e.length; n < s; n++) this._objects[r.get(e[n])] || t.push(e[n]);
                        return t
                    }, _getHashesByObjects: function (e) {
                        for (var t = [], n = 0, s = e.length; n < s; n++) {
                            var o = r.get(e[n]);
                            this._objects[o] || (this._objects[o] = {
                                geoObject: e[n],
                                hash: this._createHashFromGeoObject(e[n]),
                                order: this._objectsCounter++
                            }), t.push(this._objects[o].hash)
                        }
                        return t
                    }, _addGeoObjects: function (e) {
                        if (e.length) {
                            for (var t = 0, n = e.length; t < n; t++) e[t].setParent(null);
                            this._geoBounds = null
                        }
                    }, _removeGeoObjects: function (e) {
                        if (e.length) {
                            this._geoBounds = null;
                            for (var t = 0, n = e.length; t < n; t++) delete this._objects[r.get(e[t])]
                        }
                    }, _createHashFromGeoObject: function (e) {
                        return {id: r.get(e), geometry: {type: "Point", coordinates: e.geometry.getCoordinates()}}
                    }, _clearClusterData: function (e) {
                        for (var t = e.properties.geoObjects, n = 0, s = t.length; n < s; n++) delete this._objects[t[n].id].cluster, this._objects[t[n].id].geoObject.options.setParent(null);
                        delete this._clusters[e.id]
                    }, _onParentChange: function (e, t) {
                        this.getParent() ? this.options.setParent(this.getParent().options) : this.options.setParent(null), this.events.fire("parentchange", {
                            oldParent: e,
                            newParent: t
                        })
                    }, _onOptionsChange: function () {
                        this.events.fire("optionschange")
                    }, _onMapBoundsChange: function (e) {
                        e.get("newZoom") != e.get("oldZoom") && this.events.fire("pixelboundschnage")
                    }
                }), n.setRule({
                    name: "clusterer", rule: function (e, t) {
                        return 0 == e.indexOf("cluster") ? e : 0 == e.indexOf("geoObject") ? [C(e, "geoObject")] : [v(e, t), e]
                    }
                }), n.setRule({name: "clusterer", key: "projection", rule: "plain"}), b.setRule({
                    name: "geoObject",
                    rule: "prefixed"
                }), b.setRule({name: "projection", rule: "plain"});
                var y = {
                    alphabetical: function (e, t) {
                        var n = e.properties, s = t.properties,
                            o = n.get("clusterCaption") || n.get("balloonContentHeader") || "",
                            i = s.get("clusterCaption") || s.get("balloonContentHeader") || "";
                        return o == i ? this._objects[r.get(e)].order - this._objects[r.get(t)].order : o < i ? -1 : 1
                    }, serial: function (e, t) {
                        return this._objects[r.get(e)].order - this._objects[r.get(t)].order
                    }
                };
                e(O)
            });
        }],
        ['0G', function (ym) {
            ym.modules.define("clusterer.addon.balloon", ["Clusterer", "popup.addonBuilder", "сlusterer.Balloon"], function (e, a, l, n) {
                e(l.build({type: "balloon", metaEventManager: a.getMetaEventManager(), defaultManager: n}))
            });
        }],
        ['0H', function (ym) {
            ym.modules.define("clusterer.addon.hint", ["Clusterer", "popup.addonBuilder", "сlusterer.Hint"], function (e, t, n, a) {
                e(n.build({type: "hint", metaEventManager: t.getMetaEventManager(), defaultManager: a}))
            });
        }],
        ['0N', function (ym) {
            ym.modules.define("ClusterPlacemark", ["util.defineClass", "util.bounds", "option.Manager", "collection.Item", "event.globalize", "vow", "data.Manager", "cluster.optionMapper", "clusterer.optionMapper", "geoObject.optionMapper", "clusterPlacemark.View", "geometry.Point", "theme.islands.cluster.metaOptions"], function (e, t, s, n, o, i, r, l, u, a, c, p, h, g) {
                function d(e, t) {
                    return t + e.slice(0, 1).toUpperCase() + e.slice(1)
                }

                var m = function (e, t, s) {
                    m.superclass.constructor.call(this), this.options = this._createOptionManager(s), "function" == typeof e.getType ? this.geometry = e : this.geometry = new h(e.coordinates || e), this.properties = t, this.state = new l, this._clusterBounds = null, this._clusterListeners = this.events.group(), this.events.addController(f), this.events.fire("create")
                }, f = i(m);
                t(m, o, {
                    getGeoObjects: function () {
                        return this.properties.get("geoObjects")
                    }, getOverlay: function () {
                        return this._view ? this._view.getOverlay() : r.reject("ClusterPlacemark wasn't added to map.")
                    }, getOverlaySync: function () {
                        return this._view ? this._view.getOverlaySync() : null
                    }, onAddToMap: function (e) {
                        this.options.get("disableClickZoom") || this._clusterListeners.add("click", this._onClickZoom, this, 100), this.geometry.setMap(e), this.geometry.options.setParent(this.options), this._setupView(e)
                    }, onRemoveFromMap: function (e) {
                        this.options.get("disableClickZoom") || this._clusterListeners.removeAll(), this._clearView(), this.geometry.setMap(null), this.geometry.options.setParent(null)
                    }, getBounds: function () {
                        return this._clusterBounds || this._calculateClusterBounds(), this._clusterBounds
                    }, _onClickZoom: function (e) {
                        if (!e.isDefaultPrevented()) {
                            var t = this.getMap();
                            t.getZoom() != t.zoomRange.getCurrent()[1] && (this.getBounds(), this._setMapBounds(), e.preventDefault())
                        }
                    }, _setupView: function () {
                        this._view = new p(this)
                    }, _clearView: function () {
                        this._view.destroy()
                    }, _calculateClusterBounds: function () {
                        for (var e, t = this.getGeoObjects(), n = [], o = 0, i = t.length; o < i; o++) n.push(t[o].geometry.getCoordinates());
                        e = 0 == n.length ? null : s.fromPoints(n, this.options.get("projection")), this._clusterBounds = e
                    }, _setMapBounds: function () {
                        var e = this.getMap();
                        e.setBounds(this._clusterBounds, {
                            preciseZoom: !e.options.get("avoidFractionalZoom"),
                            margin: this.options.get("zoomMargin", 0),
                            useMapMargin: this.options.get("useMapMargin", !0),
                            checkZoomRange: !0
                        })
                    }, _createOptionManager: function (e) {
                        var t = new n(null, null, "cluster", u);
                        return t.get = function (e, t) {
                            var s = n.prototype.getNative.call(this, e);
                            return "undefined" == typeof s && (s = n.prototype.get.call(this, d(e, "cluster")), "undefined" == typeof s && (s = n.prototype.get.call(this, e, t))), s
                        }, t
                    }
                }), u.setRule({name: ["balloon", "hint"], rule: "prefixed"}), a.setRule({
                    name: "cluster",
                    rule: function (e, t) {
                        return [d(e, t), e]
                    }
                }), a.setRule({name: "cluster", key: "projection", rule: "plain"}), c.setRule({
                    name: "cluster",
                    rule: function (e, t) {
                        return [d(e, t), e]
                    }
                }), c.setRule({name: "cluster", key: "projection", rule: "plain"}), e(m)
            });
        }],
        ['0Y', function (ym) {
            ym.modules.define("Collection", ["util.defineClass", "collection.Item", "component.collection.ParentCollection", "event.Mapper", "collection.EventMappingTable"], function (t, e, n, i, o, r) {
                function l(t) {
                    this._childrenCount = 0, l.superclass.constructor.call(this, t), this._collectionImplementation = new i(this, {
                        onAdd: {
                            callback: this._onAdd,
                            context: this
                        }, onRemove: {callback: this._onRemove, context: this}
                    }, new o(this.events, this.getEventMappingTable()))
                }

                e(l, n, {
                    add: function (t) {
                        return this._collectionImplementation.add(t), this._childrenCount = this._collectionImplementation.getLength(), this
                    }, remove: function (t) {
                        return this._collectionImplementation.remove(t), this._childrenCount = this._collectionImplementation.getLength(), this
                    }, removeAll: function () {
                        return this._collectionImplementation.removeAll(), this._childrenCount = 0, this
                    }, getIterator: function () {
                        return this._collectionImplementation.getIterator()
                    }, each: function (t, e) {
                        return this._collectionImplementation.each(t, e), this
                    }, getLength: function () {
                        return this._childrenCount
                    }, filter: function (t) {
                        for (var e, n = this.getIterator(), i = []; (e = n.getNext()) != n.STOP_ITERATION;) t(e) && i.push(e);
                        return i
                    }, get: function (t) {
                        if (t > -1 && t < this._childrenCount) {
                            for (var e = this.getIterator(), n = 0; n < t; n++) e.getNext();
                            return e.getNext()
                        }
                        return null
                    }, getAll: function () {
                        for (var t, e = this.getIterator(), n = []; (t = e.getNext()) != e.STOP_ITERATION;) n.push(t);
                        return n
                    }, indexOf: function (t) {
                        for (var e, n = 0, i = this.getIterator(); (e = i.getNext()) != i.STOP_ITERATION;) {
                            if (t == e) return n;
                            n++
                        }
                        return -1
                    }, getEventMappingTable: function () {
                        return new r(this)
                    }, _onAdd: function (t) {
                        this.events.fire("add", {child: t})
                    }, _onRemove: function (t) {
                        this.events.fire("remove", {child: t})
                    }
                }), t(l)
            });
        }],
        ['1c', function (ym) {
            ym.modules.define("control.Button", ["util.defineClass", "control.Selectable", "control.component.ToolBarButton", "control.optionMapper"], function (t, e, n, o, s) {
                var i = function (t) {
                    i.superclass.constructor.call(this, "string" == typeof t ? {data: {content: t}} : t), this.options.setName("button"), this._setupLayoutEventRules(), this._toolBarButtonComponent = new o(this)
                };
                e(i, n, {
                    _setupLayoutEventRules: function () {
                        this.eventProxy.setCallback("click", this._onClick, this, !0)
                    }, _onClick: function (t) {
                        this.isEnabled() && (this.events.fire("press"), this.options.get("selectOnClick", !0) && (this.isSelected() ? this.deselect() : this.select()))
                    }
                }), s.setRule({name: "button", rule: ["prefixed", "plain"]}), t(i)
            });
        }],
        ['1n', function (ym) {
            ym.modules.define("control.FullscreenControl", ["util.defineClass", "control.Button", "control.storage", "control.optionMapper", "yandex.counter"], function (e, n, t, l, s, r) {
                var c = function (e) {
                    c.superclass.constructor.call(this, e), this.options.setName("fullscreenControl")
                };
                n(c, t, {
                    onAddToMap: function (e) {
                        c.superclass.onAddToMap.call(this, e), this._mapContainerListener = e.container.events.group().add("fullscreenenter", this._onMapFullscreenEnter, this).add("fullscreenexit", this._onMapFullscreenExit, this), r.countByKey("control", "fullscreen.create")
                    }, onRemoveFromMap: function (e) {
                        this._mapContainerListener.removeAll(), c.superclass.onRemoveFromMap.call(this, e)
                    }, select: function () {
                        this.getMap().container.isFullscreen() ? c.superclass.select.call(this) : this.enterFullscreen()
                    }, deselect: function () {
                        this.getMap().container.isFullscreen() ? this.exitFullscreen() : c.superclass.deselect.call(this)
                    }, enterFullscreen: function () {
                        this.getMap().container.enterFullscreen()
                    }, exitFullscreen: function () {
                        this.getMap().container.exitFullscreen()
                    }, _onMapFullscreenEnter: function () {
                        this.state.set("fullscreen", !0), this.events.fire("fullscreenenter"), this.select(), r.countByKey("control", "fullscreen.enter")
                    }, _onMapFullscreenExit: function () {
                        this.state.set("fullscreen", !1), this.events.fire("fullscreenexit"), this.deselect()
                    }
                }), s.setRule({name: "fullscreenControl", rule: ["prefixed"]}), s.setRule({
                    name: "fullscreenControl",
                    key: ["adjustMapMargin"],
                    rule: ["prefixed", "plain"]
                }), l.add("fullscreenControl", c), e(c)
            });
        }],
        ['1o', function (ym) {
            ym.modules.define("control.GeolocationControl", ["util.defineClass", "geolocation", "control.Button", "control.storage", "control.optionMapper", "map.associate.serviceGeoObjects", "localization.common.current", "util.extend", "yandex.counter"], function (t, e, o, s, i, n, a, c, l, r) {
                var h = "geolocationControl", u = e(function (t) {
                    var e = t && t.data || {};
                    u.superclass.constructor.call(this, t), this.data.set(l({
                        iconType: "geolocation",
                        title: c.Control.ToolBar.geolocation
                    }, e)), this.options.setName(h), this.options.set("selectOnClick", !1), this._state = "ready", this._geoObjects = null, this._actualRequest = null
                }, s, {
                    onAddToMap: function () {
                        u.superclass.onAddToMap.call(this), this.events.add("press", this._onGeolocationPress, this), r.countByKey("control", "geolocation.create")
                    }, onRemoveFromMap: function (t) {
                        this.events.remove("press", this._onGeolocationPress, this);
                        var e = this._geoObjects;
                        e && e.getParent() && (e.getParent().remove(e), this._geoObjects = null, this._actualRequest = null, this._state = "ready"), u.superclass.onRemoveFromMap.call(this, t)
                    }, _onGeolocationPress: function () {
                        if ("ready" == this._state) {
                            this.disable(), this._state = "pending";
                            var t = this._actualRequest = this._getLocation().then(function (e) {
                                if (t == this._actualRequest) {
                                    this.enable();
                                    var o = this._geoObjects;
                                    o && o.getParent() && o.getParent().remove(o), this._geoObjects = e.geoObjects, this.options.get("noPlacemark", !1) || a.get(this.getMap()).add(this._geoObjects), this._state = "ready", this.events.fire("locationchange", {
                                        position: this._geoObjects.get(0).geometry.getCoordinates(),
                                        geoObjects: this._geoObjects
                                    })
                                }
                            }, function () {
                                t == this._actualRequest && (this.enable(), this._state = "ready")
                            }, null, this)
                        }
                        r.countByKey("control", "geolocation.click")
                    }, _getLocation: function () {
                        return o.get({mapStateAutoApply: !0, useMapMargin: this.options.get("useMapMargin", !0)})
                    }
                });
                n.setRule({name: h, rule: ["prefixed", "plain"]}), i.add(h, u), t(u)
            });
        }],
        ['1r', function (ym) {
            ym.modules.define("control.ListBox", ["util.defineClass", "control.BaseGroup", "control.component.ToolBarButton", "control.component.CollapseOnBlur", "control.optionMapper"], function (e, t, s, n, i, a) {
                var l = function (e) {
                    l.superclass.constructor.call(this, e), this.options.setName("listBox"), this._setupListBoxLayoutEventRules(), this._expanded = this.state.get("expanded"), this._enabled = this.state.get("enabled"), this.state.events.add("change", this._onListBoxStateChange, this), this._toolBarButtonComponent = new n(this), this._collapseOnBlurComponent = new i(this)
                };
                t(l, s, {
                    enable: function () {
                        return this.isEnabled() || this.state.set("enabled", !0), this
                    }, disable: function () {
                        return this.isEnabled() && this.state.set("enabled", !1), this
                    }, isEnabled: function () {
                        return this.state.get("enabled", !0)
                    }, expand: function () {
                        return this.isExpanded() || this.state.set("expanded", !0), this
                    }, collapse: function () {
                        return this.isExpanded() && this.state.set("expanded", !1), this
                    }, isExpanded: function () {
                        return this.state.get("expanded", !1)
                    }, _setupListBoxLayoutEventRules: function () {
                        this.eventProxy.disableEventFiring("expand").setCallback("expand", this.expand, this).disableEventFiring("collapse").setCallback("collapse", this.collapse, this).disableEventFiring("enable").setCallback("enable", this.enable, this).disableEventFiring("disable").setCallback("disable", this.disable, this).setCallback("click", this._onClick, this, !0)
                    }, _onClick: function (e) {
                        this.isEnabled() && (this.events.fire("press"), this.options.get("expandOnClick", !0) && (this.isExpanded() ? this.collapse() : this.expand()))
                    }, _onListBoxStateChange: function () {
                        this.state.get("expanded") != this._expanded && (this._expanded = this.state.get("expanded"), this.events.fire(this._expanded ? "expand" : "collapse")), this.state.get("enabled") != this._enabled && (this._enabled = this.state.get("enabled"), this.events.fire(this._enabled ? "enable" : "disable"))
                    }
                }), a.setRule({name: "listBox", rule: ["prefixed", "plain"]}), e(l)
            });
        }],
        ['1p', function (ym) {
            ym.modules.define("control.ListBoxItem", ["util.defineClass", "control.Selectable", "control.optionMapper"], function (t, e, s, i) {
                function n(t, e) {
                    return e + t.slice(0, 1).toUpperCase() + t.slice(1)
                }

                var o = function (t) {
                    o.superclass.constructor.call(this, "string" == typeof t ? {data: {content: t}} : t), this.options.setName("listBoxItem"), this._setupItemLayoutEventRules()
                };
                e(o, s, {
                    _setupItemLayoutEventRules: function () {
                        this.eventProxy.setCallback("click", this._onClick, this, !0)
                    }, _onClick: function (t) {
                        this.isEnabled() && this.options.get("selectOnClick", !0) && (this.isSelected() ? this.deselect() : this.select())
                    }
                }), i.setRule({
                    name: "listBoxItem", rule: function (t, e) {
                        return [n(t, "item"), n(t, "listBoxItem")]
                    }
                }), t(o)
            });
        }],
        ['1t', function (ym) {
            ym.modules.define("control.Manager", ["event.Manager", "option.Manager", "data.Manager", "Monitor", "vow", "control.manager.toolbarElementController", "control.childElementController.Base", "control.manager.predefinedSets", "component.array.BaseArray", "control.storage", "map.pane.helper.controls", "control.optionMapper", "event.Mapper", "control.EventMappingTable", "util.id", "util.array", "util.extend", "util.dom.style", "util.dom.element", "util.dom.className", "util.margin", "util.css", "yandex.counter", "util.defineClass", "control.manager.css"], function (t, e, i, n, o, r, s, a, l, h, d, c, _, g, p, m, f, u, v, C, y, E, M, b, S) {
                function x(t, e, i) {
                    var n = t.state && t.state.get("effectiveMaxWidth") || t.options.get("maxWidth") || 90;
                    if (f.isArray(n)) {
                        var o = t.options.get("size");
                        n = o && "auto" != o ? n[f.indexOf(i, o)] : n[e]
                    }
                    return n
                }

                function P(t) {
                    for (var e = {}, i = 0, n = K.length; i < n; i++) {
                        var o = K[i], r = typeof t[o];
                        "number" == r ? e[o] = t[o].toString() + "px" : "undefined" != r && (e[o] = t[o])
                    }
                    return e
                }

                function A(t) {
                    var e = w(t);
                    if ("none" != e) return e;
                    var i = u({}, B, P(t.options.get("position", {})));
                    return "auto" != i.bottom ? "bottom" : "top"
                }

                function w(t) {
                    var e = t.options.get("float", I["float"]), i = t.options.get("position");
                    return i || "none" == e ? "none" : e
                }

                var L = {position: "inherit", marginLeft: 0, marginRight: 0}, B = {
                        position: "inherit",
                        left: "auto",
                        right: "auto",
                        top: "auto",
                        bottom: "auto",
                        marginLeft: 0,
                        marginRight: 0
                    }, I = {
                        "float": "right",
                        floatIndex: 0,
                        states: ["small", "medium", "large"],
                        margin: 10,
                        pane: null,
                        toolbarMarginAreaHeight: 28
                    }, K = ["top", "left", "right", "bottom"], z = M.addPrefix("visibility-hidden"),
                    T = S(function (t, o, r) {
                        if (r = r || {}, ym.env.debug && !t) throw new Error("control.Manager: map not found");
                        this._map = t, this._mapContainerEvents = t.container.events.group().add("extendedlayouttoggle", this._onExtendedLayoutToggle, this), this.events = new e({context: this}), this._defaultPane = this._map.panes.get("controls"), this.options = new i(u({
                            margin: I.margin,
                            states: I.states,
                            pane: this._defaultPane
                        }, r), this._map.options, "controls", _), this._activeState = Math.floor(this.options.get("states", I.states).length / 2), this.state = new n({size: this._getActiveState()}), this._controlsOrderArray = [], this._controlsArray = new h, this._controlsByKey = {}, this._controlKeys = {}, this._toolbarsMarginAccessors = {
                            left: this._map.margin.addArea(0),
                            right: this._map.margin.addArea(0)
                        }, this._childMonitors = {}, this._childStateMonitors = {}, this._childListeners = {}, this._childElementControllers = {
                            top: new a(this),
                            bottom: new a(this),
                            left: s.create(this, "left"),
                            right: s.create(this, "right")
                        }, this._childElements = {}, this._childSides = {}, this._init(o)
                    }, {
                        add: function (t, e) {
                            var i;
                            if ("string" == typeof t && (i = l.get(t))) {
                                for (var n = 0, o = i.length; n < o; n++) {
                                    var r = i[n];
                                    "string" == typeof r ? this.add(r) : this.add(r.type, r.options)
                                }
                                b.countByKey("modulesUsage", "controlSet." + t.replace(/[^A-Za-z]/g, "_"))
                            } else {
                                if ("string" == typeof t) {
                                    if (this._controlsByKey[t]) {
                                        if (ym.env.debug) throw new Error("Control.Manager.add: " + t + " is already added by the key.");
                                        return !1
                                    }
                                    var s = d.get(t);
                                    if (ym.env.debug && !s) throw new Error("Control.Manager.add: " + t + " doesn't exist.");
                                    this._controlsByKey[t] = a, this._controlKeys[m.get(a)] = t, t = a
                                }
                                this._addControlInstance(t, e)
                            }
                            return this
                        }, getChildElement: function (t) {
                            var e = r.defer();
                            return e.resolve(this._childElements[m.get(t)]), e.promise()
                        }, remove: function (t) {
                            var e;
                            if ("string" == typeof t && (e = l.get(t))) for (var i = 0, n = e.length; i < n; i++) {
                                var o = e[i];
                                "string" == typeof o ? this.remove(o) : this.remove(o.type)
                            } else {
                                if (this.indexOf(t) == -1) return this;
                                if ("string" == typeof t) {
                                    var r = this._controlsByKey[t];
                                    delete this._controlsByKey[t], t = r
                                }
                                this._removeControlInstance(t), t.setParent(null), t.options.setParent(null), this._applyState()
                            }
                            return this
                        }, indexOf: function (t) {
                            return "string" == typeof t && (t = this._controlsByKey[t]), f.indexOf(this._controlsOrderArray, t)
                        }, getIterator: function () {
                            return this._controlsArray.getIterator()
                        }, get: function (t) {
                            return "string" == typeof t ? this._controlsByKey[t] : this._controlsArray.get(t)
                        }, getContainer: function () {
                            return this.options.get("pane", this._defaultPane).getElement()
                        }, each: function (t, e) {
                            return this._controlsArray.each(t, e), this
                        }, getMap: function () {
                            return this._map
                        }, destroy: function () {
                            this._optionMonitor.destroy(), this._mapStateMonitor.destroy(), this._mapListeners.removeAll(), this._mapContainerEvents.removeAll();
                            var t = [];
                            this.each(function (e) {
                                t.push(e)
                            });
                            for (var e = 0, i = t.length; e < i; e++) this.remove(t[e]);
                            this.options.setParent(null)
                        }, _addControlInstance: function (t, e) {
                            if (this._controlsArray.indexOf(t) != -1) {
                                if (ym.env.debug) throw new Error("Control.Manager.add: control is already added");
                                return !1
                            }
                            e && t.options.set(e), this._controlsOrderArray.push(t), this._childElements[m.get(t)] = C.create();
                            var i = A(t);
                            this._childSides[m.get(t)] = i, this._setupChildElementController(t, i), this._setupControlMonitors(t), this._controlsArray.add(t), this._applyState(), t.options.setParent(this.options), t.events.setParent(new g(this.events, new p(this))), t.setParent(this), this._setupControlListeners(t), this.events.fire("add", {child: t})
                        }, _removeControlInstance: function (t) {
                            var e = m.get(t);
                            if (this._controlKeys[m.get(t)]) {
                                var i = this._controlKeys[e];
                                delete this._controlKeys[e], delete this._controlsByKey[i]
                            }
                            this._controlsArray.remove(t), f.remove(this._controlsOrderArray, t), this._removeControlMonitors(t), this._clearControlListeners(t), this._clearChildElementController(t, this._childSides[e]), delete this._childSides[e], delete this._childElements[e], this.events.fire("remove", {child: t})
                        }, _setupControlListeners: function (t) {
                            this._childListeners[m.get(t)] = t.events.group().add("mapchange", this._onControlMapChange, this)
                        }, _clearControlListeners: function (t) {
                            var e = m.get(t);
                            this._childListeners[e].removeAll(), delete this._childListeners[e]
                        }, _setupControlMonitors: function (t) {
                            var i = m.get(t);
                            this._childMonitors[i] = new o(t.options).add("adjustMapMargin", function () {
                                this._recalculateToolbarsMarginAreas()
                            }, this).add("float", function () {
                                this._onControlFloatChange(t), this._recalculateToolbarsMarginAreas()
                            }, this).add("position", function () {
                                this._onControlPositionChange(t), this._recalculateToolbarsMarginAreas()
                            }, this).add(["maxWidth", "visible", "size"], this._applyState, this), t.state && t.state.events instanceof e && (this._childStateMonitors[i] = new o(t.state).add("effectiveMaxWidth", this._applyState, this))
                        }, _removeControlMonitors: function (t) {
                            var e = m.get(t);
                            this._childStateMonitors[e] && (this._childStateMonitors[e].destroy(), delete this._childStateMonitors[e]), this._childMonitors[e].destroy(), delete this._childMonitors[e]
                        }, _setupChildElementController: function (t, e) {
                            var i = this._childElements[m.get(t)];
                            if (this._childElementControllers[e].insert(t, i), "right" == e || "left" == e) {
                                var n = this.options.get("margin", I.margin).toString() + "px",
                                    o = {marginLeft: "left" == e ? n : 0, marginRight: "left" == e ? 0 : n};
                                o = u({}, L, o);
                                var r = t.options.get("zIndex");
                                "undefined" != typeof r && u(o, {
                                    left: "auto",
                                    top: "auto",
                                    right: "auto",
                                    bottom: "auto",
                                    position: "relative",
                                    zIndex: r
                                }), v.css(i, o), y.add(i, M.addPrefix("controls__control_toolbar"))
                            } else this._applyCustomPosition(t), y.add(i, M.addPrefix("controls__control"))
                        }, _clearChildElementController: function (t, e) {
                            var i = this._childElements[m.get(t)];
                            this._childElementControllers[e].remove(t, i), "right" == e || "left" == e ? y.remove(i, M.addPrefix("controls__control_toolbar")) : y.remove(i, M.addPrefix("controls__control"))
                        }, _applyState: function () {
                            for (var t = this.options.get("states", I.states), e = this.options.get("pane", this._defaultPane).getViewport(), i = e[1][0] - e[0][0], n = !0; n;) this._getMaxWidth(this._activeState) < i ? this._activeState + 1 < t.length && this._getMaxWidth(this._activeState + 1) < i ? this._activeState++ : n = !1 : this._activeState > 0 ? this._activeState-- : n = !1;
                            this.state.set("size", this._getActiveState()), this._recalculateToolbarsMarginAreas()
                        }, _onMarginChange: function (t) {
                            t = "undefined" != typeof t ? t : I.margin, v.css(this._toolbarElement, {marginTop: t.toString() + "px"}), this._applyState()
                        }, _onPaneChange: function () {
                            var t = this.getContainer();
                            this._toolbarElement.parentNode.removeChild(this._toolbarElement), this._bottomContainerElement.parentNode.removeChild(this._bottomContainerElement), t.appendChild(this._toolbarElement), t.appendChild(this._bottomContainerElement), this._childElementControllers.top.setParentElement(t)
                        }, _onMapSizeChange: function () {
                            this._applyState(), this._applyBottomContainerPosition()
                        }, _getActiveState: function () {
                            return this.options.get("states", I.states)[this._activeState]
                        }, _getMaxWidth: function (t) {
                            var e = this.options.get("states", I.states), i = this.options.get("margin", I.margin),
                                n = 0, o = 0;
                            return this._controlsArray.each(function (i) {
                                var r = w(i), s = i.options.get("visible", !0);
                                "none" != r && s && (n += parseInt(x(i, t, e), 10), o++)
                            }), n + i * (o + 1)
                        }, _onControlFloatChange: function (t) {
                            this._checkChildController(t)
                        }, _onControlPositionChange: function (t) {
                            this._checkChildController(t);
                            var e = this._childSides[m.get(t)];
                            "top" != e && "bottom" != e || this._applyCustomPosition(t)
                        }, _recalculateToolbarsMarginAreas: function () {
                            var t = this.options.get("margin", I.margin), e = {left: 0, right: 0},
                                i = this.options.get("states", I.states);
                            this._controlsArray.each(function (n) {
                                var o = this._childSides[m.get(n)], r = n.options.get("visible", !0);
                                e.hasOwnProperty(o) && n.options.get("adjustMapMargin", !1) && r && (e[o] += parseInt(x(n, this._activeState, i), 10) + t)
                            }, this);
                            for (var n in e) if (e.hasOwnProperty(n)) {
                                e[n] > 0 && (e[n] -= t);
                                var o = {
                                    top: t,
                                    width: e[n],
                                    height: this.options.get("toolbarMarginAreaHeight", I.toolbarMarginAreaHeight)
                                };
                                o[n] = t, this._toolbarsMarginAccessors[n].setArea(o)
                            }
                        }, _onControlMapChange: function (t) {
                            var e = t.get("target");
                            this._removeControlInstance(e), this._applyState()
                        }, _onMapMarginChange: function () {
                            this._applyBottomContainerPosition()
                        }, _checkChildController: function (t) {
                            var e = m.get(t), i = A(t), n = this._childSides[e];
                            i != n && (this._clearChildElementController(t, n), this._childSides[e] = i, this._setupChildElementController(t, i))
                        }, _applyCustomPosition: function (t) {
                            if ("none" == w(t)) {
                                var e = t.options, i = u({}, B, P(e.get("position", {})), {zIndex: e.get("zIndex")}),
                                    n = this._childElements[m.get(t)];
                                v.css(n, i)
                            }
                        }, _applyBottomContainerPosition: function () {
                            var t = this._map.state.get("margin"),
                                e = this.options.get("pane", this._defaultPane).getViewport(), i = e[1][1] - e[0][1];
                            i -= E.correct(t)[2], v.css(this._bottomContainerElement, {top: i.toString() + "px"})
                        }, _init: function (t) {
                            if (this._initHTMLContainers(), this._optionMonitor = new o(this.options).add("margin", this._onMarginChange, this).add("states", this._applyState, this).add("pane", this._onPaneChange, this), this._mapListeners = this._map.events.group().add("sizechange", this._onMapSizeChange, this), this._mapStateMonitor = new o(this._map.state).add("margin", this._onMapMarginChange, this), t) for (var e = 0, i = t.length; e < i; e++) this.add(t[e])
                        }, _initHTMLContainers: function () {
                            this._toolbarElement = C.create({
                                className: M.addPrefix("controls__toolbar"),
                                css: {marginTop: this.options.get("margin", I.margin).toString() + "px"}
                            }), this._bottomContainerElement = C.create({className: M.addPrefix("controls__bottom")}), this._leftContainerElement = C.create({className: M.addPrefix("controls__toolbar_left")}), this._rightContainerElement = C.create({className: M.addPrefix("controls__toolbar_right")});
                            var t = this.getContainer();
                            t.appendChild(this._toolbarElement), t.appendChild(this._bottomContainerElement), this._toolbarElement.appendChild(this._leftContainerElement), this._toolbarElement.appendChild(this._rightContainerElement), this._applyBottomContainerPosition(), this._childElementControllers.top.setParentElement(t), this._childElementControllers.bottom.setParentElement(this._bottomContainerElement), this._childElementControllers.right.setParentElement(this._rightContainerElement), this._childElementControllers.left.setParentElement(this._leftContainerElement)
                        }, _onExtendedLayoutToggle: function () {
                            var t = this.getContainer();
                            this._map.container.isExtendedLayoutEnabled() ? y.add(t, z) : y.remove(t, z)
                        }
                    });
                t(T)
            });
        }],
        ['1A', function (ym) {
            ym.modules.define("control.RouteEditor", ["util.defineClass", "localization.common.current", "control.storage", "control.optionMapper", "control.BaseBehaviorButton", "util.extend", "yandex.counter", "behavior.RouteEditor"], function (t, e, o, r, i, n, a, s) {
                function u(t) {
                    var e = t && t.data || {};
                    u.superclass.constructor.call(this, t), this.data.set(a({
                        iconType: "routes",
                        title: o.Control.RouteEditor
                    }, e)), this._behaviorEvents = null, this.options.setName("routeEditor")
                }

                e(u, n, {
                    getBehaviorName: function () {
                        return "routeEditor"
                    }, getRoute: function () {
                        return this.getMap().behaviors.get(this.getBehaviorName()).getRoute()
                    }, onAddToMap: function (t) {
                        u.superclass.onAddToMap.call(this, t);
                        var e = t.behaviors.get(this.getBehaviorName());
                        e.options.setParent(this.options), this._behaviorEvents = e.events.group().add("disable", this.deselect, this), s.countByKey("control", "routeEditor.create")
                    }, onRemoveFromMap: function (t) {
                        this._behaviorEvents.removeAll(), this._behaviorEvents = null, u.superclass.onRemoveFromMap.call(this, t)
                    }
                }), i.setRule({name: "routeEditor", rule: "prefixed"}), i.setRule({
                    name: "routeEditor",
                    key: ["adjustMapMargin"],
                    rule: ["prefixed", "plain"]
                }), r.add("routeEditor", u), t(u)
            });
        }],
        ['1w', function (ym) {
            ym.modules.define("control.RouteButton", ["util.defineClass", "util.extend", "map.metaOptions", "Monitor", "option.Mapper", "option.Manager", "control.Base", "control.storage", "control.component.CollapseOnBlur", "control.optionMapper", "control.RoutePanelComponent", "control.component.ToolBarButton", "theme.islands.control.layout.routePanel.Button"], function (t, e, o, n, s, a, u, i, r, l, h, p, c) {
                function d(t) {
                    d.superclass.constructor.call(this, t);
                    var e = t ? t.lazy : void 0;
                    this._lazyRoutePanel = "undefined" == typeof e || Boolean(e), this.options.setName(M), this.options.setMapper(m), this._layoutOptions = new u(null, this.options, _), this._collapseOnBlurComponent = new l(this, this._onCollapseOnBlur), this._toolBarButtonComponent = new c(this), this.routePanel = new p(this, {
                        editing: !0,
                        type: "auto"
                    }, {
                        counterKey: "control",
                        counterPath: "routeButtonControl",
                        load: this._createRoutePanelLayout.bind(this)
                    }), this._lastRouteMouseDownTs = 0, this.routePanel.getRouteAsync().then(function (t) {
                        t.events.add("mousedown", function () {
                            this._lastRouteMouseDownTs = +new Date
                        }, this).add("mouseup", this._onMouseUp, this), t.model.events.add("requestchange", this._cancelCollapse, this)
                    }, this)
                }

                var M = "routeButtonControl", _ = M + "LayoutOptions", f = 20,
                    m = (new a).setRule({rule: "prefixed", name: p.OPTIONS_NAME}).setRule({rule: "plain", name: _});
                e(d, i, {
                    createLayoutData: function () {
                        return o(d.superclass.createLayoutData.call(this), {options: this._layoutOptions})
                    }, createLayoutParameters: function () {
                        return {lazy: this._lazyRoutePanel}
                    }, onAddToMap: function (t) {
                        d.superclass.onAddToMap.call(this, t), this.routePanel.onAddToMap(t), this._panelFocusState = null, this._mapEvents = t.events.group().add("mousedown", function (t) {
                            +new Date - this._lastRouteMouseDownTs > f && (this._isMouseDownOverMap = !0, this._panelFocusState = this.routePanel.saveFocusState())
                        }, this).add("mouseup", this._onMouseUp, this);
                        var e = t.behaviors.get("drag");
                        this._dragEvents = e ? e.events.group().add("dragstart", function () {
                            this._isDraggingMap = !0, this._isMouseDownOverMap = !1
                        }, this).add("dragend", function () {
                            this._isDraggingMap = !1, this.routePanel.restoreFocusState(this._panelFocusState)
                        }, this) : {
                            removeAll: function () {
                            }
                        }, this.getLayout().then(function (t) {
                            if (this.getMap()) return t.getRoutePanelLayout()
                        }, this).then(function (t) {
                            this.getMap() && t && this.routePanel.setLayout(t)
                        }, this)
                    }, onRemoveFromMap: function (t) {
                        this._dragEvents.removeAll(), this._mapEvents.removeAll(), this.routePanel.onRemoveFromMap(t), d.superclass.onRemoveFromMap.call(this, t)
                    }, isExpanded: function () {
                        return this.state.get("expanded")
                    }, expand: function () {
                        this.state.set("expanded", !0)
                    }, collapse: function () {
                        this.state.set("expanded", !1)
                    }, _onMouseUp: function (t) {
                        this._isMouseDownOverMap && this.routePanel.restoreFocusState(this._panelFocusState), this._isMouseDownOverMap = !1
                    }, _onCollapseOnBlur: function (t) {
                        if (this.state.get("expanded") && !this._isMouseDownOverMap && !this._isDraggingMap) {
                            var e = this.getLayoutSync();
                            if (!(e && e.isClickUnderLayout() || e.isInFullscreen())) {
                                var o = +new Date;
                                o - this._lastRouteMouseDownTs < f || this.state.set("expanded", !1)
                            }
                        }
                    }, _createRoutePanelLayout: function () {
                        return this.getLayout().then(function (t) {
                            return t.forceCreateRoutePanelLayout()
                        })
                    }
                }), r.add("routeButtonControl", d), h.setRule({
                    name: M,
                    rule: "prefixed"
                }), n.set({
                    routeButtonControlLayout: "islands#controlRoutePanelButtonLayout",
                    routeButtonControlCollapseOnBlur: !0,
                    routeButtonControlFloat: "left",
                    routeButtonControlFloatIndex: 250,
                    routeButtonControlMaxWidth: [30, 93, 112]
                }), t(d)
            });
        }],
        ['1x', function (ym) {
            ym.modules.define("control.RoutePanel", ["util.defineClass", "util.extend", "map.metaOptions", "Monitor", "option.Manager", "option.Mapper", "control.Base", "control.storage", "control.optionMapper", "control.RoutePanelComponent"], function (t, o, e, n, a, u, l, s, r, i, p) {
                function c(t) {
                    c.superclass.constructor.call(this, t), this.options.setName(h), this.options.setMapper(d), this._layoutOptions = new u(null, this.options, P), this.routePanel = new p(this, {
                        editing: !0,
                        type: "auto"
                    }, {
                        counterKey: "control",
                        counterPath: "routePanelControl",
                        load: this._createRoutePanelLayout.bind(this)
                    }), this._lastRouteMouseDownTs = 0
                }

                var h = "routePanelControl", P = h + "LayoutOptions",
                    d = (new l).setRule({rule: "prefixed", name: p.OPTIONS_NAME}).setRule({rule: "plain", name: P});
                o(c, s, {
                    createLayoutData: function () {
                        return e(c.superclass.createLayoutData.call(this), {options: this._layoutOptions})
                    }, _createRoutePanelLayout: function () {
                        return this.getLayout().then(function (t) {
                            return t.forceCreateRoutePanelLayout()
                        })
                    }, onAddToMap: function (t) {
                        c.superclass.onAddToMap.call(this, t), this.routePanel.onAddToMap(t), this.getLayout().then(function (t) {
                            if (this.getMap()) return t.getRoutePanelLayout()
                        }, this).then(function (t) {
                            this.getMap() && t && (this.routePanel.setLayout(t), this.options.get("autofocus", !0) && this.routePanel.focus())
                        }, this)
                    }, onRemoveFromMap: function (t) {
                        this.routePanel.onRemoveFromMap(t), c.superclass.onRemoveFromMap.call(this, t)
                    }
                }), r.add("routePanelControl", c), i.setRule({
                    name: h,
                    rule: "prefixed"
                }), n.set({
                    routePanelControlLayout: "islands#controlRoutePanelFixedLayout",
                    routePanelControlFloat: "left",
                    routePanelControlFloatIndex: 1500,
                    routePanelControlZIndex: 50,
                    routePanelControlRoutePanelAdjustMapMargin: !0
                }), t(c)
            });
        }],
        ['1B', function (ym) {
            ym.modules.define("control.RulerControl", ["localization.common.current", "control.storage", "control.BaseBehaviorButton", "control.optionMapper", "util.extend", "yandex.counter", "util.defineClass", "behavior.Ruler"], function (e, t, r, l, n, o, i, s) {
                function u(e) {
                    var r = e && e.data || {};
                    u.superclass.constructor.call(this, e), this.data.set(o({
                        iconType: "ruler",
                        title: t.Control.ToolBar.ruler
                    }, r)), this.options.setName("rulerControl"), this._setupRulerButtonEvents(), i.countByKey("control", "ruler.create")
                }

                s(u, l, {
                    getBehaviorName: function () {
                        return "ruler"
                    }, _setupRulerButtonEvents: function () {
                        this.eventProxy.unsetCallback("click").disableEventFiring("click").setCallback("rulerbuttonclick", this._onRulerButtonClick, this).disableEventFiring("rulerbuttonclick")
                    }, _onRulerButtonClick: function () {
                        this.events.fire("click"), this.isEnabled() && (this.events.fire("press"), this.options.get("selectOnClick", !0) && (this.isSelected() ? this.deselect() : this.select()))
                    }
                }), r.add("rulerControl", u), n.setRule({
                    name: "rulerControl",
                    rule: "prefixed"
                }), n.setRule({name: "rulerControl", key: ["adjustMapMargin"], rule: ["prefixed", "plain"]}), e(u)
            });
        }],
        ['1G', function (ym) {
            ym.modules.define("control.SearchControl", ["control.Base", "control.storage", "control.optionMapper", "yandex.geocodeProvider.storage", "yandex.searchProvider.storage", "control.searchControl.GeocodeProvider", "control.searchControl.SearchProvider", "control.searchControl.component.SearchGeoObjects", "control.searchControl.component.GeocodeGeoObjects", "control.component.ToolBarButton", "Monitor", "util.extend", "util.cancelableCallback", "util.defineClass", "vow", "yandex.state.component.SearchControl", "yandex.counter", "meta.internal", "util.array", "theme.islands.search.meta"], function (e, t, s, o, n, r, i, a, u, l, h, c, d, g, p, v, _, f, m, C) {
                function S(e) {
                    S.superclass.constructor.call(this, e), this.options.setName("searchControl"), this._toolbarControlComponent = new h(this), this._controlOptionsMonitor = null, this._provider = null, this._providerListener = null, this._geoObjectsComponent = null, this._setupProvider(), this._setupLayoutEventRules(), this._suggestOptionMonitor = null, this._suggestStateMonitor = null, this._providerResolveCallback = null
                }

                var R = "yandex#map";
                p(S, t, {
                    onAddToMap: function (e) {
                        S.superclass.onAddToMap.call(this, e), this._yandexState = new _(this), this._setupSuggest(), f.countByKey("control", "search.create")
                    }, onRemoveFromMap: function (e) {
                        this._yandexState.destroy(), this._yandexState = null, this._teardownSuggest(), S.superclass.onRemoveFromMap.call(this, e)
                    }, search: function (e, t) {
                        t = t || {};
                        var s, o = this.getMap(),
                            n = d(t, {boundedBy: this.options.get("useMapBounds") && o ? o.getBounds() : this.options.get("boundedBy")});
                        return this._clearState(), s = this._provider.load(e, n), this.state.set("inputValue", e), this.events.fire("submit", {request: e}), s
                    }, showResult: function (e) {
                        var t = this._provider, s = t.state.get("found"), o = t.getResult(e), n = this.getMap(),
                            r = v.defer();
                        if (!t.isLoaded() || e >= s || !n) {
                            var i;
                            if (t.isLoaded() ? e >= s ? i = "control.SearchControl.showResult: index is larger then found" : n || (i = "control.SearchControl.showResult: map not found") : i = "control.SearchControl.showResult: results is not loaded", ym.env.debug) throw new Error(i);
                            return v.reject(i)
                        }
                        return o ? (this._selectResult(e), this._geoObjectsComponent.show(e).then(function () {
                            r.resolve(o)
                        }, this)) : this.getResult(e).then(function () {
                            r.resolve(this.showResult(e))
                        }, this), r.promise()
                    }, hideResult: function () {
                        var e = this.state.get("currentIndex");
                        this.events.fire("componenthide"), "number" == typeof e && this.events.fire("resulthide", {index: e}), this.state.unset("currentIndex")
                    }, getResponseMetaData: function () {
                        return this._provider.getResponseMetaData()
                    }, getResult: function (e) {
                        var t = v.defer(), s = this._provider, o = s.state.get("found"), n = s.getResult(e);
                        if (ym.env.debug) {
                            if (!s.isLoaded()) throw new Error("control.SearchControl: Данные ещё не были загружены.");
                            if (e >= o) throw new Error("control.SearchControl: индекс больше, чем количество найденных результатов")
                        }
                        return e < o && (n ? t.resolve(n) : s.load({
                            results: e - s.getResults().length + 1,
                            type: "loadmore"
                        }).then(function (o) {
                            return t.resolve(s.getResult(e)), o
                        })), t.promise()
                    }, getResultsArray: function () {
                        return this._provider.getResults()
                    }, getResultsCount: function () {
                        return this._provider.state.get("found")
                    }, getSelectedIndex: function () {
                        return this.state.get("currentIndex")
                    }, getRequestString: function () {
                        return this._provider.state.get("request")
                    }, destroy: function () {
                        this.events.fire("destroy"), this._clearProvider(), this._teardownSuggest(), this._clearState()
                    }, getProvider: function () {
                        return this._provider
                    }, clear: function () {
                        this._provider.stopLoad(), this.state.unset("currentIndex"), this.events.fire("componenthide", {data: !0}), this._clearState(), this.events.fire("clear")
                    }, _setupProvider: function () {
                        var e, t = this.options.get("provider", R);
                        "string" == typeof t && r.isDefined(t) ? (t = new a(this), e = u) : (t = new i(this), e = l), this._provider = t, this._setupProviderListeners(), this._setupGeoObjectsComponent(e)
                    }, _clearProvider: function () {
                        this._clearGeoObjectsComponent(), this._clearProviderListeners(), this._provider.destroy(), this._provider = null
                    }, _setupProviderListeners: function () {
                        this._providerListener = this._provider.events.group().add("load", this._onRequestLoad, this).add("error", this._onErrorLoad, this), this._providerOptionsMonitor = new c(this.options).add("provider", this._onProviderChange, this, {defaultValue: R})
                    }, _clearProviderListeners: function () {
                        this._providerListener.removeAll(), this._providerOptionsMonitor.destroy()
                    }, _setupGeoObjectsComponent: function (e) {
                        var t = new e(this);
                        this._geoObjectsComponentListeners = t.events.group().add("show", this._onComponentShowGeoObject, this).add("hide", this._onComponentGeoObjectHide, this), this._geoObjectsComponent = t
                    }, _clearGeoObjectsComponent: function (e) {
                        this._geoObjectsComponent && (this._geoObjectsComponentListeners.removeAll(), this._geoObjectsComponent.destroy(), this._geoObjectsComponent = null)
                    }, _setupSuggest: function () {
                        this._suggestOptionMonitor = new c(this.options).add("noSuggestPanel", this._checkSuggestNeeded, this), this._suggestStateMonitor = new c(this.state).add("size", this._checkSuggestNeeded, this), this._checkSuggestNeeded()
                    }, _teardownSuggest: function () {
                        this._cancelProviderResolve(), this._suggestOptionMonitor.removeAll(), this._suggestStateMonitor.removeAll(), this.state.set("noSuggestPanel", !0)
                    }, _cancelProviderResolve: function () {
                        this._providerResolveCallback && (this._providerResolveCallback.cancel(), this._providerResolveCallback = null)
                    }, _checkSuggestNeeded: function () {
                        var e = this.state.get("size"), t = this.options.get("noSuggestPanel");
                        "large" != e || t ? (this._cancelProviderResolve(), this.state.set("noSuggestPanel", !0)) : (this._providerResolveCallback = g.create(function (e) {
                            this.state.set("noSuggestPanel", !e), this._providerResolveCallback = null
                        }, this), this._provider.hasSuggest().done(this._providerResolveCallback))
                    }, _onComponentShowGeoObject: function (e) {
                        var t = e.get("index"), s = this.state.get("currentIndex");
                        s != t && this._selectResult(t), this.events.fire("resultshow", {index: t})
                    }, _onComponentSelectGeoObject: function (e) {
                    }, _onComponentGeoObjectHide: function (e) {
                        var t = e.get("index");
                        this.state.get("currentIndex") == t && (this.state.unset("currentIndex"), this.events.fire("resulthide", {index: t}))
                    }, _setupLayoutEventRules: function () {
                        this.eventProxy.disableEventFiring("search").setCallback("search", function (e) {
                            this.search(e.get("request"))
                        }, this).disableEventFiring("search-uncorrected").setCallback("search-uncorrected", function (e) {
                            this.search(e.get("request"), {correct_misspell: 0})
                        }, this).disableEventFiring("loadmore").setCallback("loadmore", function () {
                            this._provider.load({type: "loadmore"})
                        }, this).disableEventFiring("resultselect").setCallback("resultselect", this._onResultSelect, this).disableEventFiring("dataclear").setCallback("dataclear", this._onDataClear, this).disableEventFiring("suggest")
                    }, _onResultSelect: function (e) {
                        var t = e.get("index");
                        this.showResult(t)
                    }, _selectResult: function (e) {
                        var t = this.state.get("currentIndex");
                        "number" == typeof t && this.events.fire("resulthide", {index: t}), this.state.set("currentIndex", e), this.events.fire("resultselect", {index: e})
                    }, _onRequestLoad: function (e) {
                        var t = e.get("skip");
                        t || this.state.unset("currentIndex"), this._renderResults(), this.events.fire("load", {
                            skip: t,
                            count: e.get("count")
                        })
                    }, _onErrorLoad: function (e) {
                        this.events.fire("error", {error: e.get("error")})
                    }, _onDataClear: function () {
                        this.clear()
                    }, _clearState: function () {
                        this.getMap() && this.events.fire("componenthide"), this._provider && this._provider.state.unsetAll(), this.state.unset(["popupOpened", "inputValue", "request", "suggest", "correction", "isLoaded", "metaData", "found", "results", "currentIndex"]), this.events.fire("clearstate")
                    }, _renderResults: function () {
                        var e = this._provider, t = e.getType(), s = e.getResponseMetaData(), o = {};
                        switch (t) {
                            case"geocode":
                                o = s;
                                break;
                            case"search":
                                d(o, s.SearchRequest, s.SearchResponse)
                        }
                        var n;
                        if (o.suggest) {
                            var r = this._parseCorrection(o.suggest);
                            this._changeInputValueWithoutSuggest(r), n = r
                        } else n = o.request;
                        this.state.set({
                            isLoaded: !0,
                            request: n,
                            originalRequest: o.request,
                            correction: o.suggest,
                            suggest: o.suggest,
                            found: o.found,
                            advert: this._getAdvert(o),
                            results: e.getResults()
                        })
                    }, _changeInputValueWithoutSuggest: function (e) {
                        var t = this.state.get("noSuggestPanel");
                        this.state.set("noSuggestPanel", !0), this.state.set("inputValue", e), this.state.set("noSuggestPanel", t)
                    }, _parseCorrection: function (e) {
                        return C.isArray(e) ? C.reduce(e, function (e, t) {
                            return e + (C.isArray(t) ? t[0] : t)
                        }, "") : e
                    }, _getAdvert: function (e) {
                        var t = e.Banners && e.Banners[0], s = this.getMap();
                        return s && (m.displayAdvert || s.options.get("forceAdvert")) ? t : null
                    }, _onProviderChange: function () {
                        this._cancelProviderResolve(), this._clearProvider(), this.state.get("noSuggestPanel") || this.state.set("noSuggestPanel", !0), this._setupProvider(), this._checkSuggestNeeded()
                    }
                }), o.setRule({name: "searchControl", rule: ["prefixed"]}), o.setRule({
                    name: "searchControl",
                    key: ["adjustMapMargin"],
                    rule: ["prefixed", "plain"]
                }), s.add("searchControl", S), e(S)
            });
        }],
        ['1P', function (ym) {
            ym.modules.define("control.storage", ["util.Storage"], function (e, o) {
                e(new o)
            });
        }],
        ['1R', function (ym) {
            ym.modules.define("control.TrafficControl", ["control.component.ToolBarButton", "control.component.CollapseOnBlur", "control.Selectable", "control.storage", "Monitor", "control.optionMapper", "traffic.provider.storage", "util.defineClass", "control.component.exclusiveMode", "theme.islands.traffic.metaOptions", "traffic.provider.Actual", "traffic.provider.Archive", "traffic.provider.Forecast", "yandex.counter"], function (t, e, i, r, s, o, a, n, c, h, f, d, l, v, p) {
                var u = function (t) {
                    u.superclass.constructor.call(this, t), this.options.setName("trafficControl");
                    var r = this.state.get("providerKey");
                    "undefined" != typeof r && "traffic#forecast" != r || this.state.set("providerKey", "traffic#actual"), this._providers = {}, this._providerListeners = {}, this._currentProviderKey = null, this._stateMonitor = null, this._setupTrafficLayoutEventRules(), this._trafficShown = this.state.get("trafficShown"), this._expanded = this.state.get("expanded"), this.state.events.add("change", this._onTrafficStateChange, this), this._toolBarButtonComponent = new e(this), this._collapseOnBlurComponent = new i(this)
                };
                c(u, r, {
                    onAddToMap: function (t) {
                        u.superclass.onAddToMap.call(this, t), this._stateMonitor = new o(this.state).add(["trafficShown", "providerKey"], this._onVisibleProviderChange, this), this.state.get("trafficShown") && this._addProviderToMap(this.state.get("providerKey")), this._exclusiveMode = h.get(t), this._exclusiveMode.register("traffic", this.hideTraffic, this), p.countByKey("control", "traffic.create")
                    }, onRemoveFromMap: function (t) {
                        this._stateMonitor.removeAll(), u.superclass.onRemoveFromMap.call(this, t), this.state.get("trafficShown") && this._removeProviderFromMap(this.state.get("providerKey")), this._exclusiveMode.unregister("traffic", this.hideTraffic, this)
                    }, showTraffic: function () {
                        this.isTrafficShown() || this.state.set("trafficShown", !0), this._exclusiveMode.switchOn("traffic")
                    }, hideTraffic: function () {
                        this.isTrafficShown() && this.state.set("trafficShown", !1), this._exclusiveMode.switchOff("traffic")
                    }, isTrafficShown: function () {
                        return this.state.get("trafficShown")
                    }, expand: function () {
                        this.isExpanded() || this.state.set("expanded", !0)
                    }, collapse: function () {
                        this.isExpanded() && this.state.set("expanded", !1)
                    }, isExpanded: function () {
                        return this.state.get("expanded", !1)
                    }, _setupTrafficLayoutEventRules: function () {
                        this.eventProxy.disableEventFiring("showtraffic").setCallback("showtraffic", this.showTraffic, this).disableEventFiring("hidetraffic").setCallback("hidetraffic", this.hideTraffic, this).disableEventFiring("expand").setCallback("expand", this.expand, this).disableEventFiring("collapse").setCallback("collapse", this.collapse, this).disableEventFiring("collapse").setCallback("providerkeychange", function (t) {
                            this.state.set("providerKey", t.get("newProviderKey"))
                        }, this)
                    }, getProvider: function (t) {
                        return t = t || this.state.get("providerKey"), this._providers[t] || (this._providers[t] = this._createProvider(t), this._providerListeners[t] = this._providers[t].events.group().add("mapchange", this._getProviderCallback(t), this)), this._providers[t]
                    }, _createProvider: function (t) {
                        var e = n.get(t);
                        if (!e && ym.env.debug) throw new Error("control.TrafficControl.getProvider: can't find provider constructor by the key.");
                        var i = new e;
                        return i.options.setParent(this.options), i
                    }, _getProviderCallback: function (t) {
                        return function (e) {
                            var i = e.get("newMap");
                            this._currentProviderKey == t ? i || this.state.get("providerKey") != t || this.state.set("trafficShown", !1) : i && this.state.set("providerKey", t)
                        }.bind(this)
                    }, _addProviderToMap: function (t) {
                        this._currentProviderKey = t;
                        var e = this.getProvider(t);
                        e.setMap(this.getMap()), this.events.fire("providerkeychange", {
                            newProviderKey: t,
                            oldProviderKey: null
                        }), p.countByKey("control", "traffic." + t.replace("traffic#", "") + "Provider"), "traffic#archive" == t && p.countByKey("traffic.archive")
                    }, _removeProviderFromMap: function (t) {
                        var e = this.getProvider(t);
                        e.setMap(null), this._currentProviderKey = null, this.events.fire("providerkeychange", {
                            newProviderKey: null,
                            oldProviderKey: t
                        })
                    }, _changeProvider: function (t, e) {
                        var i = this.getProvider(t), r = this.getProvider(e);
                        i.setMap(null), r.options.setParent(this.options), r.setMap(this.getMap()), this._currentProviderKey = e, this.events.fire("providerkeychange", {newProviderKey: e}), i.options.setParent(null), p.countByKey("control", "traffic." + e.replace("traffic#", "") + "Provider"), "traffic#archive" == e && p.countByKey("traffic.archive")
                    }, _onVisibleProviderChange: function () {
                        this._applyProvider(this.state.get("providerKey"))
                    }, _applyProvider: function (t) {
                        var e = this.state, i = this._currentProviderKey;
                        e.get("trafficShown") ? t != i && (this._providers[i] ? this._changeProvider(i, t) : this._addProviderToMap(t)) : this._removeProviderFromMap(i)
                    }, _onTrafficStateChange: function () {
                        this.state.get("expanded") != this._expanded && (this._expanded = this.state.get("expanded"), this.events.fire(this._expanded ? "expand" : "collapse")), this.state.get("trafficShown") != this._trafficShown && (this._trafficShown = this.state.get("trafficShown"), this.events.fire(this._trafficShown ? "showtraffic" : "hidetraffic"))
                    }
                }), a.setRule({name: "trafficControl", rule: ["prefixed", "plain"]}), a.setRule({
                    name: "routeEditor",
                    key: ["adjustMapMargin"],
                    rule: ["prefixed", "plain"]
                }), s.add("trafficControl", u), t(u)
            });
        }],
        ['1S', function (ym) {
            ym.modules.define("control.TypeSelector", ["meta", "util.defineClass", "control.ListBox", "control.ListBoxItem", "mapType.storage", "localization.common.current", "control.storage", "util.array", "control.optionMapper", "projection.wgs84Mercator", "projection.sphericalMercator", "util.extend", "map.metaOptions", "control.component.exclusiveMode", "panorama.isSupported", "option.presetStorage", "system.browser", "Monitor", "yandex.counter"], function (e, t, a, s, o, i, n, r, p, m, l, h, c, d, u, y, _, f, M, g) {
                function I(e) {
                    return "string" == typeof e ? i.get(e) : e
                }

                var v = n.Control.TypeControl.layers, T = n.Control.TypeControl.panoramas, S = function (e) {
                    p.isArray(e) && (e = {mapTypes: e});
                    var t = e && e.data || {};
                    S.superclass.constructor.call(this, e), this.data.set(c({
                        content: v,
                        iconType: "layers"
                    }, t)), this._selectedMapType = null, this._mapTypeListItems = [], this._panoramasSeparator = null, this._panoramasItem = null, this._exclusiveMode = null, this._createMapTypeItems(e && e.mapTypes), this.options.setName("typeSelector"), this._mapListeners = null, this._optionsMonitor = new M(this.options), this._optionsMonitor.add("panoramasItemMode", this._onPanoramasItemModeChange, this)
                };
                a(S, s, {
                    addMapType: function (e, t) {
                        if (ym.env.debug && !I(e)) throw new Error("TypeSelector: undefined map type " + e);
                        if (this._getItem(e)) return this;
                        if ("undefined" == typeof t) {
                            var a = d.get("typeSelectorMapTypePositions");
                            "string" == typeof e && a[e] && (t = a[e])
                        }
                        var s = this._createItem(e, t), o = this.getMap(), i = !!o && o.getType() === e;
                        return this._mapTypeListItems.push(s), this.add(s.listItem), i && this._selectMapType(o.getType()), this
                    }, removeMapType: function (e) {
                        var t = this._getItem(e);
                        if (t) {
                            t = t.listItem, e = t.mapType;
                            for (var a = this.getMap(), s = !!a && a.getType() === e, o = 0; this._mapTypeListItems[o].listItem != t;) o++;
                            this._mapTypeListItems[o].listener.removeAll(), this._mapTypeListItems.splice(o, 1), this.remove(t), s && this._selectMapType(null)
                        }
                        return this
                    }, removeAllMapTypes: function () {
                        for (; this._mapTypeListItems.length;) this.removeMapType(this._mapTypeListItems[0].mapType);
                        return this
                    }, onAddToMap: function (e) {
                        S.superclass.onAddToMap.call(this, e), this._mapListeners = e.events.group().add("typechange", function (t) {
                            this._selectMapType(e.getType())
                        }, this);
                        var t = this.isExpanded();
                        this._selectMapType(e.getType()), t && this.expand(), this._shouldShowPanoramasItem() && this._addPanoramasItem(), g.countByKey("control", "typeSelector.create")
                    }, onRemoveFromMap: function (e) {
                        this._mapListeners.removeAll(), this._removePanoramasItem(), S.superclass.onRemoveFromMap.call(this, e)
                    }, _createMapTypeItems: function (e) {
                        e || (e = d.get("typeSelectorMapTypes"));
                        for (var t = 0, a = e.length; t < a; ++t) this.addMapType(e[t])
                    }, _onPanoramasItemModeChange: function () {
                        this.getMap() && (this._shouldShowPanoramasItem() ? this._addPanoramasItem() : this._removePanoramasItem())
                    }, _addPanoramasItem: function () {
                        var e = this.getMap();
                        this._createPanoramasItem(), this.indexOf(this._panoramasItem) == -1 && (this.add(this._panoramasSeparator), this.add(this._panoramasItem), e.getPanoramaManager().then(function (t) {
                            this.indexOf(this._panoramasItem) != -1 && (this._panoramaManager = t, this._panoramaManagerEvents = this._panoramaManager.events.group().add("enablelookup", function () {
                                this._panoramasItem.select()
                            }, this).add("disablelookup", function () {
                                this._panoramaManager.closePlayer(), this._panoramasItem.deselect()
                            }, this), this._exclusiveMode = u.get(e), this._exclusiveMode.register("panoramas", this._onPanoramasModeOff, this))
                        }, this))
                    }, _removePanoramasItem: function () {
                        this.indexOf(this._panoramasItem) != -1 && (this._panoramasItem.deselect(), this.remove(this._panoramasItem), this.remove(this._panoramasSeparator), this._panoramaManager && (this._panoramaManagerEvents.removeAll(), this._panoramaManager = null, this._exclusiveMode.unregister("panoramas", this._onPanoramasModeOff, this), this._exclusiveMode = null))
                    }, _createPanoramasItem: function () {
                        if (!this._panoramasSeparator || !this._panoramasItem) {
                            var e = Number.MAX_SAFE_INTEGER || 9007199254740991;
                            this._panoramasSeparator = new o({
                                options: {
                                    type: "separator",
                                    positionIndex: e - 1
                                }
                            }), this._panoramasItem = new o({
                                data: {content: T},
                                options: {positionIndex: e}
                            }), this._panoramasItem.events.group().add("select", function () {
                                g.countByKey("control", "typeSelector.panoramas"), this._panoramaManager.enableLookup(), this._exclusiveMode.switchOn("panoramas"), this.collapse()
                            }, this).add("deselect", function () {
                                this._exclusiveMode.switchOff("panoramas"), this._panoramaManager.disableLookup(), this.collapse()
                            }, this)
                        }
                    }, _getItem: function (e) {
                        for (var t, a = 0, s = this._mapTypeListItems.length; a < s; ++a) if (t = this._mapTypeListItems[a], t.mapType === e) return t;
                        return null
                    }, _selectMapType: function (e) {
                        var t = !1;
                        if (this._selectedMapType) {
                            var a = this._getItem(this._selectedMapType);
                            a && a.listItem.deselect(), t = !0
                        }
                        if (this._selectedMapType = e, e) {
                            var s = this._getItem(e);
                            s && s.listItem.select()
                        } else t = !1;
                        t && g.countByKey("control", "typeSelector." + typeof e == "string" ? e.replace(/[^A-Za-z]/g, "_") : "other")
                    }, _createItem: function (e, t) {
                        var a = new o({
                            data: {content: I(e).getName(), mapType: e},
                            options: {positionIndex: t, selectOnClick: !0}
                        });
                        a.deselect = function () {
                            return this.getMap() && e == this.getMap().getType() ? void this.collapse() : void o.prototype.deselect.call(a)
                        }.bind(this);
                        var s = a.events.group().add(["select"], function () {
                            var t = this.getMap();
                            t.getType() != e && ("string" == typeof e && g.countByKey("control", "typeSelector." + e.replace(/[^A-Za-z]/g, "_")), this.getMap().setType(e)), this.collapse()
                        }, this);
                        return {mapType: e, listItem: a, listener: s}
                    }, _shouldShowPanoramasItem: function () {
                        if (!y()) return !1;
                        if (f.isMobile && (f.isIE || f.isEdge)) return !1;
                        var e = _.get("islands#controls.core") || {};
                        if (this.options.get("layout") != e.typeSelectorLayout) return !1;
                        var a = this.options.get("panoramasItemMode", "ifMercator");
                        if ("on" == a) return !0;
                        if ("ifMercator" != a) return !1;
                        if (t.isEnterprise) return !1;
                        var s = this.getMap().options.get("projection");
                        return s == l || s == h
                    }, _onPanoramasModeOff: function () {
                        this._panoramasItem.deselect()
                    }
                }), m.setRule({name: "typeSelector", rule: ["prefixed", "plain"]}), m.setRule({
                    name: "routeEditor",
                    key: ["adjustMapMargin"],
                    rule: ["prefixed", "plain"]
                }), r.add("typeSelector", S), e(S)
            });
        }],
        ['1T', function (ym) {
            ym.modules.define("control.ZoomControl", ["util.defineClass", "control.storage", "control.Base", "control.optionMapper", "Monitor", "map.action.Continuous", "yandex.counter"], function (t, o, e, n, a, i, s, h) {
                var m = function (t) {
                    m.superclass.constructor.call(this, t), this.options.setName("zoomControl"), this._map = null, this._mapListeners = null, this._zoomRangeListeners = null, this._mapAction = null;
                    var o = this.options.get("size");
                    this.state.set("size", "auto" == o ? "small" : o)
                };
                o(m, n, {
                    onAddToMap: function (t) {
                        this._map = t, this.state.set({
                            zoom: this._map.getZoom(),
                            zoomRange: this._map.zoomRange.getCurrent(),
                            mapHeight: this._map.container.getSize()[1] - this._map.state.get("margin", [0, 0, 0, 0])[2]
                        }), m.superclass.onAddToMap.call(this, t), this._setupLayoutEventRules(), this._setupZoomListeners(), h.countByKey("control", "zoom.create")
                    }, onRemoveFromMap: function (t) {
                        this._clearZoomListeners(), m.superclass.onRemoveFromMap.call(this, t)
                    }, _setupZoomListeners: function () {
                        this._mapListeners = this._map.events.group().add("sizechange", this._onMapSizeChange, this).add("boundschange", this._onMapBoundsChange, this), this._mapMarginMonitor = new i(this._map.state).add("margin", this._onMapSizeChange, this), this._zoomRangeListeners = this._map.zoomRange.events.group().add("change", this._onZoomRangeChange, this)
                    }, _clearZoomListeners: function () {
                        this._mapListeners.removeAll(), this._mapMarginMonitor.removeAll(), this._zoomRangeListeners.removeAll()
                    }, _setupLayoutEventRules: function () {
                        this.eventProxy.disableEventFiring("zoomchange").disableEventFiring("dragstart").disableEventFiring("dragstop"), this.eventProxy.setCallback("zoomchange", this._onZoomChange, this).setCallback("dragstart", this._onDragStart, this).setCallback("dragstop", this._onDragStop, this)
                    }, _onDragStart: function () {
                        this._dragging = !0, this._initialZoom = this._map.getZoom(), h.countByKey("control", "zoom.drag")
                    }, _onDragStop: function () {
                        this._dragging = !1, this._mapAction && (this._mapAction.end(), this._mapAction = null), h.countByKey("control", "zoom.change." + Math.abs(Math.round(this._map.getZoom() - this._initialZoom)))
                    }, _onZoomRangeChange: function (t) {
                        this.state.set("zoomRange", t.get("newZoomRange"))
                    }, _onMapBoundsChange: function (t) {
                        var o = t.get("newZoom"), e = t.get("oldZoom");
                        !this._dragging && Math.abs(o - e) > .001 && this.state.set("zoom", o)
                    }, _onZoomChange: function (t) {
                        var o = t.get("newZoom");
                        if (this._dragging) this._mapAction || (this._mapAction = new s, this._map.action.execute(this._mapAction)), this._mapAction.tick({zoom: o}); else if (this._map.options.get("avoidFractionalZoom") && (o = Math.floor(o)), Math.abs(o - this.state.get("zoom")) > .001) {
                            var e = this._map.getZoom();
                            this.state.set("zoom", o), this._map.setZoom(o, {duration: this.options.get("zoomDuration")}), h.countByKey("control", "zoom.change." + Math.abs(Math.round(o - e)))
                        }
                    }, _onMapSizeChange: function () {
                        this.state.set("mapHeight", this._map.container.getSize()[1] - this._map.state.get("margin", [0, 0, 0, 0])[2])
                    }
                }), a.setRule({name: "zoomControl", rule: "prefixed"}), a.setRule({
                    name: "zoomControl",
                    key: ["adjustMapMargin"],
                    rule: ["prefixed", "plain"]
                }), e.add("zoomControl", m), t(m)
            });
        }],
        ['1V', function (ym) {
            ym.modules.define("coordSystem.cartesian", ["coordSystem.Cartesian"], function (e, n) {
                e(new n(1))
            });
        }],
        ['1$', function (ym) {
            ym.modules.define("domEvent.manager", ["util.defineClass", "util.id", "util.data", "DomEvent", "event.manager.Base", "event.Group", "domEvent.managerOverrideStorage", "util.dom.event"], function (e, t, n, r, a, i, g, o, s) {
                function u(e) {
                    var t = e.type, n = s.getIdealName(e.type);
                    r.get(this, h).fire(t, new a(e, t)), t == n || o.get(n) || r.get(this, h).fire(n, new a(e, n))
                }

                function v(e) {
                    var t = e.type, n = s.getIdealName(e.type);
                    r.get(this, d).fire(t, new a(e, t)), t == n || o.get(n) || r.get(this, d).fire(n, new a(e, n))
                }

                function m(e, t, n) {
                    this.htmlElement = e, this.domEventManager = t, this.capture = n
                }

                var h = "eventManagerCapturingPhase", d = "eventManagerBubblingPhase", f = {
                    add: function (e, t, n, r, a) {
                        if (ym.env.debug && (!e || !t)) throw new Error("domEvent.Manager: Не был передан обязательный аргумент!.");
                        var g = this._getEventManager(e, a);
                        return g || (g = new i({
                            controllers: [this],
                            htmlElement: e,
                            capture: !!a
                        }), this._setEventManager(e, g, a)), g.add(t, n, r), this
                    }, remove: function (e, t, n, r, a) {
                        if (ym.env.debug && (!e || !t)) throw new Error("domEvent.Manager: Не был передан обязательный аргумент!.");
                        var i = this._getEventManager(e, a);
                        return i && i.remove(t, n, r), this
                    }, fire: function (e, t, n) {
                        var r = this._getEventManager(e, !0), a = this._getEventManager(e, !1);
                        return r && r.fire(t, n), a && a.fire(t, n), this
                    }, onStartListening: function (e, t) {
                        var n = o.get(t);
                        if (n) n.start(e); else {
                            t = s.getActualName(t);
                            var r = e.params, a = r.htmlElement, i = !!r.capture;
                            a.addEventListener(t, i ? u : v, i)
                        }
                    }, onStopListening: function (e, t) {
                        var n = o.get(t), r = e.params, a = r.htmlElement, i = !!r.capture;
                        n ? n.stop(e) : (t = s.getActualName(t), a.removeEventListener(t, i ? u : v, i)), e.typesCount || this._unsetEventManager(a, i)
                    }, group: function (e, t) {
                        return new g(new m(e, this, t))
                    }, _getEventManager: function (e, t) {
                        return r.get(e, t ? h : d)
                    }, _setEventManager: function (e, t, n) {
                        r.add(e, n ? h : d, t)
                    }, _unsetEventManager: function (e, t) {
                        r.remove(e, t ? h : d)
                    }
                };
                t(m, {
                    add: function (e, t, n) {
                        return this.domEventManager.add(this.htmlElement, e, t, n, this.capture)
                    }, remove: function (e, t, n) {
                        return this.domEventManager.remove(this.htmlElement, e, t, n, this.capture)
                    }
                }), e(f)
            });
        }],
        ['1!', function (ym) {
            ym.modules.define("domEvent.MultiPointer", ["util.defineClass", "domEvent.Base", "domEvent.multiPointer.overrideStorage", "component.event.Cacher"], function (e, t, c, n, i) {
                function h(e, t, c) {
                    h.superclass.constructor.call(this, e, t), this._cache = {
                        type: t || "multi" + e.type,
                        touches: c
                    }, this._cacher = null
                }

                t(h, c, {
                    get: function (e) {
                        return this._cacher || (this._cacher = new i(this, this._cache, n)), this._cacher.get(e)
                    }, clone: function (e) {
                        return new h(e, this._cache.type, this._cache.touches)
                    }
                }), e(h)
            });
        }],
        ['1q', function (ym) {
            ym.modules.define("domEvent.Pointer", ["util.defineClass", "domEvent.Base", "domEvent.pointer.overrideStorage", "component.event.Cacher"], function (e, t, c, n, h) {
                function i(e, t, c) {
                    i.superclass.constructor.call(this, e, t), this._cache = {
                        type: t || e.type,
                        mode: c,
                        touches: [e]
                    }, this._cacher = null
                }

                t(i, c, {
                    get: function (e) {
                        return this._cacher || (this._cacher = new h(this, this._cache, n)), this._cacher.get(e)
                    }, clone: function (e) {
                        return new i(e, this._cache.type, this._cache.mode)
                    }
                }), e(i)
            });
        }],
        ['2d', function (ym) {
            ym.modules.define("event.Mapper", ["util.defineClass"], function (e, t) {
                function n(e, t) {
                    this._targetEventManager = e, this._mappingTable = t
                }

                t(n, {
                    getTargetEventManager: function () {
                        return this._targetEventManager
                    }, setMappingTable: function (e) {
                        this._mappingTable = e
                    }, getMappingTable: function () {
                        return this._mappingTable
                    }, fire: function (e, t) {
                        "undefined" == typeof this._mappingTable[e] && (e = "*");
                        var n, a = this._mappingTable[e];
                        return "function" == typeof a ? n = this._mappingTable[e](t) : a && (n = t), n && this._targetEventManager.fire(n.get("type"), n), this
                    }
                }), e(n)
            });
        }],
        ['2g', function (ym) {
            ym.modules.define("formatter", ["localization.units.current", "localization.lib"], function (t, n, a) {
                var e = {
                    distance: function (t, n) {
                        var i = a.UnitsTransform(ym.env.lang, "distance", t);
                        return e.unit(e.toSignificantDigits(i.value, n || 2), "distance", i.name)
                    }, duration: function (t, n) {
                        for (var i = a.UnitsTransform(ym.env.lang, "duration", t, n || 2), r = [], o = 0, u = i.length; o < u; o++) r.push(e.unit(i[o].value, "duration", i[o].name));
                        return r.join(" ")
                    }, unit: function (t, a, i) {
                        return e.numeral(t, n[a][i])
                    }, numeral: function (t, n) {
                        var a, e = parseFloat(t);
                        if ("string" == typeof n) a = n; else if (e > 10 && e < 20) a = n[2] || n[1]; else switch (("" + e % 10).charAt(0)) {
                            case"1":
                                a = n[0];
                                break;
                            case"2":
                            case"3":
                            case"4":
                                a = n[1];
                                break;
                            default:
                                a = n[2] || n[1]
                        }
                        return a.replace("%d", t)
                    }, toSignificantDigits: function (t, n) {
                        if (0 == t) return t;
                        var a = Math.floor(Math.log(Math.abs(t)) * Math.LOG10E), e = t / Math.pow(10, a),
                            i = Math.abs(e * Math.pow(10, n - 1));
                        Math.round(i).toString().length > Math.floor(i).toString().length && (a++, e = t / Math.pow(10, a), i = Math.abs(e * Math.pow(10, n - 1)));
                        var r, o = Math.round(i).toString(), u = a + 1, l = (e < 0 ? "-" : "") + (u <= 0 ? "0." : "");
                        if (u <= 0) {
                            for (r = u; r < 0; r++) l += "0";
                            l += o
                        } else if (u >= n) for (l += o, r = n; r < u; r++) l += "0"; else l += o.slice(0, u), o.length > u && (l += "." + o.slice(u));
                        return l
                    }
                };
                t(e)
            });
        }],
        ['2h', function (ym) {
            ym.modules.define("geocode", ["map.metaOptions", "yandex.geocodeProvider.storage", "vow", "yandex.counter", "yandex.geocodeProvider.metaOptions"], function (e, o, r, n, d) {
                function t(e, i) {
                    i = i || {};
                    var c = i.provider || o.get("geocodeProvider");
                    if ("string" == typeof c) {
                        var u = c;
                        if (d.countByKey("modulesUsage", "geocode." + u.replace(/[^A-Za-z]/g, "_")), c = r.get(u), !c) {
                            var a = n.defer();
                            return r.require([u]).spread(function (o) {
                                a.resolve(o.geocode(e, i))
                            }, function () {
                                a.reject(t.ProviderWasntFound())
                            }), a.promise()
                        }
                    } else d.countByKey("modulesUsage", "geocode.custom");
                    return c.geocode(e, i)
                }

                t.ProviderWasntFound = function () {
                    return new Error("Provider wasn't found")
                }, e(t)
            });
        }],
        ['2f', function (ym) {
            ym.modules.define("findOrganization", ["poi.fetcher", "searchResult.transportDataProvider", "yandex.counter", "yandex.state.associate"], function (t, e, o, a, n) {
                function r(t) {
                    var r = "ymapsbm1://org?oid=" + t;
                    return e.searchByUri(r).then(o.remoteExtendOrgWithTransport).then(function (t) {
                        var e = t.options;
                        e.set("balloonCardMetroLayout", "islands#islets-searchControlCardMetroLayout"), e.set("balloonCardContactsLayout", "islands#islets-searchControlCardContactsLayout"), e.set("balloonCardStatusLayout", "islands#islets-searchControlCardStatusLayout"), e.set("balloonContentLayout", "islands#islets-searchControlCardLayout"), e.set("balloonLayout", "islands#balloon");
                        var o;
                        return t.balloon.events.add("open", function (e) {
                            var a = t.getMap();
                            if (a) {
                                var r = n.get(a);
                                o = {
                                    type: t.properties.get("type"),
                                    uri: t.properties.get("uri"),
                                    point: t.properties.get("point")
                                }, r.setActiveObject(o)
                            }
                        }), t.balloon.events.add("close", function () {
                            var e = t.getMap();
                            if (e) {
                                var a = n.get(e);
                                a.get("poi") === o && a.setActiveObject(null), o = void 0
                            }
                        }), a.countByKey("modulesUsage", "findOrganization"), t
                    })
                }

                t(r)
            });
        }],
        ['2x', function (ym) {
            ym.modules.define("geolocation", function (e) {
                return ["vow", "util.extend", "util.defineClass", "util.bounds", "geocode", "Placemark", "GeoObjectCollection", "coordSystem.geo", "yandex.counter", "geolocationPreset.standard." + ("ru" == e.env.lang.slice(0, 2) ? "ru" : "en")]
            }, function (e, o, t, n, r, i, c, a, u, s) {
                function l(e, t) {
                    var n = o.defer(), r = e.accuracy, a = e.position, u = {origin: P, geolocationAccuracy: r};
                    return t.autoReverseGeocode ? (r >= f.locality && (u.kind = "locality"), i(a, u).then(function (e) {
                        var o = e.geoObjects.get(0);
                        o && g(o, a, r) ? (e.geoObjects.remove(o), n.resolve(v(o, a, r, t))) : n.reject("Not found")
                    }, function (e) {
                        n.reject(e)
                    })) : n.resolve(v(new c(a), a, r, t)), n.promise()
                }

                function d(e) {
                    var t = o.defer();
                    return navigator.geolocation ? navigator.geolocation.getCurrentPosition(function (e) {
                        t.resolve({
                            position: "longlat" == ym.env.coordinatesOrder ? [e.coords.longitude, e.coords.latitude] : [e.coords.latitude, e.coords.longitude],
                            accuracy: e.coords.accuracy
                        })
                    }, function (e) {
                        t.reject(e)
                    }, {
                        enableHighAccuracy: !0,
                        maximumAge: 6e4
                    }) : t.reject("Geolocation API isn't supported"), t.promise().timeout(e)
                }

                function g(e, o, t) {
                    return r.areIntersecting(e.properties.get("boundedBy") || p(e.geometry.getCoordinates(), t), p(o, t))
                }

                function p(e, o) {
                    return [[u.solveDirectProblem(e, [-1, 0], o).endPoint[0], u.solveDirectProblem(e, [0, -1], o).endPoint[1]], [u.solveDirectProblem(e, [1, 0], o).endPoint[0], u.solveDirectProblem(e, [0, 1], o).endPoint[1]]]
                }

                function v(e, o, t, n) {
                    var r;
                    return n.mapStateAutoApply && (r = t ? p(o, t) : e.geometry.getBounds()), e.geometry.setCoordinates(o), {geoObjects: new m(e, o, t, r, n)}
                }

                var m = n(function (e, o, t, n, r) {
                        m.superclass.constructor.call(this, {}, {preset: "islands#geolocationIcon"}), this.position = o, this.accuracy = t, this.add(e), n && this.events.once("mapchange", function () {
                            this.getMap().setBounds(n, {checkZoomRange: !0, useMapMargin: r.useMapMargin, duration: 400})
                        }, this)
                    }, a), y = ym.env.geolocation, f = {precise: 10, locality: 2e3, region: 1e4},
                    h = "longlat" == ym.env.coordinatesOrder ? [y.longitude, y.latitude] : [y.latitude, y.longitude],
                    b = {
                        position: h,
                        accuracy: y.isHighAccuracy ? f.precise : y.span.longitude || y.span.latitude ? Math.max(u.getDistance(h, "longlat" == ym.env.coordinatesOrder ? [h[0] + y.span.longitude, h[1]] : [h[0], h[1] + y.span.longitude]), u.getDistance(h, "longlat" == ym.env.coordinatesOrder ? [h[0], h[1] + y.span.latitude] : [h[0] + y.span.latitude, h[1]])) : f.region
                    }, P = "jsapi21Geolocation", j = {
                        get: function (e) {
                            if (e = t({
                                provider: "auto",
                                mapStateAutoApply: !1,
                                useMapMargin: !0,
                                autoReverseGeocode: !0,
                                timeout: 3e4
                            }, e), s.countByKey("modulesUsage", "geolocation.get." + e.provider), "yandex" == e.provider || "auto" == e.provider && b.accuracy <= 10) return l(b, e);
                            var n = o.defer();
                            return "browser" == e.provider ? d(e.timeout).then(function (o) {
                                n.resolve(l(o, e))
                            }, function (e) {
                                n.reject(e)
                            }) : d(e.timeout).then(function (o) {
                                n.resolve(l(o.accuracy > b.accuracy ? b : o, e))
                            }, function () {
                                n.resolve(l(b, e))
                            }), n.promise()
                        }
                    };
                e(j)
            });
        }],
        ['2B', function (ym) {
            ym.modules.define("geometry.base.Circle", ["event.Manager", "util.extend", "component.EventFreezer", "geometry.component.commonMethods.circle", "error"], function (t, e, n, r, i, s) {
                var o = i, u = function (t, n) {
                    this._coordinates = u.castCoordinates(t), this._radius = u.castRadius(n), this._freezer = new r(this._changeCallback, this), this.events = new e({context: this})
                };
                u.castCoordinates = function (t) {
                    if (ym.env.debug && t && (!t.length || 2 != t.length || "number" != typeof t[0])) throw new s.InputError("CircleGeometry.castCoordinates: Incorrect coordinate format.");
                    return t || null
                }, u.castRadius = function (t) {
                    return t || 0
                }, n(u.prototype, {
                    getType: function () {
                        return "Circle"
                    }, getBounds: function () {
                        return this._bounds || (this._bounds = this._calculateBounds())
                    }, setCoordinates: function (t) {
                        var e = this._coordinates;
                        return this._coordinates = t, this._bounds = null, this.onGeometryChange("Coordinates", e, this._coordinates), this
                    }, getCoordinates: function () {
                        return this._coordinates
                    }, onGeometryChange: function (t, e, n) {
                        this._freezer.fire(t, e, n)
                    }, getCenter: function () {
                        return this._coordinates
                    }, setRadius: function (t) {
                        var e = this._radius;
                        return this._radius = t, this._bounds = null, this.onGeometryChange("Radius", e, this._radius), this
                    }, getRadius: function () {
                        return this._radius
                    }, freeze: function () {
                        return this._freezer.freeze(), this
                    }, unfreeze: function () {
                        return this._freezer.unfreeze(), this
                    }, isFrozen: function () {
                        return this._freezer.isFrozen()
                    }, contains: function (t) {
                        return o.contains(this._coordinates, this._radius, t)
                    }, getClosest: function (t) {
                        return o.getClosest(this._coordinates, this._radius, t)
                    }, _calculateBounds: function () {
                        return o.calculateBounds(this._coordinates, this._radius)
                    }, _changeCallback: function (t) {
                        this.events.fire("change", n({type: "change", target: this}, t))
                    }
                }), t(u)
            });
        }],
        ['2C', function (ym) {
            ym.modules.define("geometry.base.LinearRing", ["event.Manager", "util.extend", "util.coordinates.encode", "util.pixelBounds", "geometry.component.pointInPolygon", "geometry.component.findClosestPathPosition", "component.EventFreezer", "geometry.component.closedPathDecode", "geometry.component.CoordPath", "geometry.component.ChildPath", "geometry.component.FillRule", "util.math.areEqual", "geometry.base.Point"], function (e, t, o, n, i, s, r, h, l, c, d, a, u, g) {
                function C(e, t) {
                    var o = this._getNonClosedCoords();
                    o[t] = e.getCoordinates(), this._setNonClosedCoords(o)
                }

                function f(e, t) {
                    this._freezer.fire("Coordinates", e, t)
                }

                function _(e) {
                    return i.fromPoints(e)
                }

                function p(e, t) {
                    this._freezer.fire("FillRule", e, t)
                }

                var P = function (e, o) {
                    this._coordPath = new c(P.keepClosed(e || [], !0), {callback: f, context: this}, {
                        callback: _,
                        context: this
                    }), this._childPath = new d([], g, ["change"], {
                        callback: C,
                        context: this
                    }), this._fillRuleComponent = new a(o, {
                        callback: p,
                        context: this
                    }), this._freezer = new h(this._changeCallback, this), this.events = new t({context: this})
                };
                P.keepClosed = function (e, t) {
                    var o = e.length;
                    return (1 == o || o > 1 && !u(e[0], e[o - 1])) && (t && (e = e.slice()), e.push(e[0])), e
                }, P.fromEncodedCoordinates = function (e) {
                    return new P(l(e))
                }, P.toEncodedCoordinates = function (e) {
                    if (ym.env.debug && "LinearRing" != e.getType()) throw new Error("geometry.base.LinearRing.toEncodedCoordinates: неверный тип геометрии: " + e.getType());
                    return n(e.getCoordinates())
                }, o(P.prototype, {
                    getType: function () {
                        return "LinearRing"
                    }, getBounds: function () {
                        return this._coordPath.getBounds()
                    }, set: function (e, t) {
                        this._childPath.setChild(e, null);
                        var o = this._getNonClosedCoords();
                        return o[e] = t, this._setNonClosedCoords(o), this
                    }, get: function (e) {
                        return this._coordPath.get(e)
                    }, getChildGeometry: function (e) {
                        return e == this._coordPath.getLength() - 1 && (e = 0), this._childPath.getChild(e) || this._childPath.createChild(e, this._coordPath.get(e))
                    }, remove: function (e) {
                        this._childPath.splice(e, 1);
                        var t = this._getNonClosedCoords(), o = t.splice(e, 1)[0];
                        return this._setNonClosedCoords(t), o
                    }, insert: function (e, t) {
                        this._childPath.splice(e, 0, null);
                        var o = this._getNonClosedCoords();
                        return o.splice(e, 0, t), this._setNonClosedCoords(o), this
                    }, splice: function (e, t) {
                        arguments.length > 2 ? this._childPath.splice.apply(this._childPath, [e, t].concat(new Array(arguments.length - 2))) : this._childPath.splice(e, t);
                        var o = this._getNonClosedCoords(),
                            n = arguments.length > 2 ? o.splice.apply(o, arguments) : o.splice(e, t);
                        return this._setNonClosedCoords(o), n
                    }, setCoordinates: function (e) {
                        return this._childPath.setChildren([]), this._coordPath.setCoordinates(P.keepClosed(e, !0)), this
                    }, getCoordinates: function () {
                        return this._coordPath.getCoordinates()
                    }, getLength: function () {
                        return this._coordPath.getLength()
                    }, setFillRule: function (e) {
                        return this._fillRuleComponent.setFillRule(e), this
                    }, getFillRule: function () {
                        this._fillRuleComponent.getFillRule()
                    }, freeze: function () {
                        return this._freezer.freeze(), this
                    }, unfreeze: function () {
                        return this._freezer.unfreeze(), this
                    }, isFrozen: function () {
                        return this._freezer.isFrozen()
                    }, contains: function (e) {
                        return s(e, [this._coordPath.getCoordinates()], this._fillRuleComponent.getFillRule())
                    }, getClosest: function (e) {
                        return r(this._coordPath.getCoordinates(), e)
                    }, _getNonClosedCoords: function () {
                        return this._coordPath.getCoordinates().slice(0, this._coordPath.getLength() - 1)
                    }, _setNonClosedCoords: function (e) {
                        this._coordPath.setCoordinates(P.keepClosed(e))
                    }, _changeCallback: function (e) {
                        this.events.fire("change", o({type: "change", target: this}, e))
                    }
                }), e(P)
            });
        }],
        ['2D', function (ym) {
            ym.modules.define("geometry.base.LineString", ["util.defineClass", "event.Manager", "geometry.component.findClosestPathPosition", "component.EventFreezer", "geometry.component.CoordPath", "geometry.component.ChildPath", "geometry.base.Point", "util.extend", "util.coordinates.encode", "util.coordinates.decode", "util.pixelBounds"], function (t, e, n, i, o, r, h, s, c, a, d, u) {
                function l(t, e) {
                    this._coordPath.set(e, t.getCoordinates())
                }

                function g(t, e) {
                    this.onGeometryChange("Coordinates", t, e)
                }

                function f(t) {
                    return u.fromPoints(t)
                }

                var _ = function (t) {
                    this._coordPath = new r(t || [], {callback: g, context: this}, {
                        callback: f,
                        context: this
                    }), this._childPath = new h([], s, ["change"], {
                        callback: l,
                        context: this
                    }), this._freezer = new o(this._changeCallback, this), this.events = new n({context: this})
                };
                _.fromEncodedCoordinates = function (t) {
                    return new _(d(t))
                }, _.toEncodedCoordinates = function (t) {
                    if (ym.env.debug && "LineString" != t.getType()) throw new Error("geometry.base.LineString.toEncodedCoordinates: неверный тип геометрии: " + t.getType());
                    return a(t.getCoordinates())
                }, e(_, {
                    getType: function () {
                        return "LineString"
                    }, getBounds: function () {
                        return this._coordPath.getBounds()
                    }, set: function (t, e) {
                        return this._childPath.setChild(t, null), this._coordPath.set(t, e), this
                    }, get: function (t) {
                        return this._coordPath.get(t)
                    }, getChildGeometry: function (t) {
                        return this._childPath.getChild(t) || this._childPath.createChild(t, this._coordPath.get(t))
                    }, remove: function (t) {
                        return this._childPath.splice(t, 1), this._coordPath.splice(t, 1)[0]
                    }, insert: function (t, e) {
                        return this._childPath.splice(t, 0, null), this._coordPath.splice(t, 0, e), this
                    }, splice: function (t, e) {
                        return arguments.length > 2 ? this._childPath.splice.apply(this._childPath, [t, e].concat(new Array(arguments.length - 2))) : this._childPath.splice(t, e), arguments.length > 2 ? this._coordPath.splice.apply(this._coordPath, arguments) : this._coordPath.splice(t, e)
                    }, setCoordinates: function (t) {
                        return this._childPath.setChildren([]), this._coordPath.setCoordinates(t), this
                    }, getCoordinates: function () {
                        return this._coordPath.getCoordinates()
                    }, getLength: function () {
                        return this._coordPath.getLength()
                    }, freeze: function () {
                        return this._freezer.freeze(), this
                    }, unfreeze: function () {
                        return this._freezer.unfreeze(), this
                    }, isFrozen: function () {
                        return this._freezer.isFrozen()
                    }, getClosest: function (t) {
                        return i(this._coordPath.getCoordinates(), t)
                    }, _changeCallback: function (t) {
                        this.events.fire("change", c({type: "change", target: this}, t))
                    }, onGeometryChange: function (t, e, n) {
                        this._freezer.fire(t, e, n)
                    }
                }), t(_)
            });
        }],
        ['2F', function (ym) {
            ym.modules.define("geometry.base.Point", ["util.extend", "component.EventFreezer", "event.Manager"], function (e, t, n, i) {
                var r = function (e) {
                    this._coordinates = e || null, this._freezer = new n(this._changeCallback, this), this.events = new i({context: this})
                };
                t(r.prototype, {
                    getType: function () {
                        return "Point"
                    }, setCoordinates: function (e) {
                        this._bounds = null;
                        var t = this._coordinates;
                        this._coordinates = e, this.onGeometryChange("Coordinates", t, this._coordinates)
                    }, getCoordinates: function () {
                        return this._coordinates
                    }, getBounds: function () {
                        return this._bounds || (this._bounds = this._coordinates ? [this._coordinates.slice(), this._coordinates.slice()] : null)
                    }, getClosest: function (e) {
                        var t = this._coordinates;
                        if (!t) return null;
                        var n = [e[0] - t[0], e[1] - t[1]], i = Math.sqrt(n[0] * n[0] + n[1] * n[1]);
                        return {position: [t[0], t[1]], distance: i}
                    }, freeze: function () {
                        return this._freezer.freeze(), this
                    }, unfreeze: function () {
                        return this._freezer.unfreeze(), this
                    }, isFrozen: function () {
                        return this._freezer.isFrozen()
                    }, onGeometryChange: function (e, t, n) {
                        this._freezer.fire(e, t, n)
                    }, _changeCallback: function (e) {
                        this.events.fire("change", t({type: "change", target: this}, e))
                    }
                }), e(r)
            });
        }],
        ['2G', function (ym) {
            ym.modules.define("geometry.base.Polygon", ["event.Manager", "util.extend", "util.coordinates.encode", "component.EventFreezer", "geometry.component.closedPathDecode", "geometry.component.CoordPath", "geometry.component.ChildPath", "geometry.component.FillRule", "geometry.component.commonMethods.polygon", "geometry.base.LinearRing"], function (e, t, n, o, i, r, h, s, c, l, a) {
                function u(e, t) {
                    this._coordPath.set(t, e.getCoordinates())
                }

                function d(e, t) {
                    this.onGeometryChange("Coordinates", e, t)
                }

                function g(e) {
                    return p.calculateBounds(e)
                }

                function f(e, t) {
                    this.onGeometryChange("FillRule", e, t)
                }

                var p = l, _ = function (e, n) {
                    this._coordPath = new h(_.keepClosed(e || []), {callback: d, context: this}, {
                        callback: g,
                        context: this
                    }), this._childPath = new s([], a, ["change"], {
                        callback: u,
                        context: this
                    }), this._fillRuleComponent = new c(n, {
                        callback: f,
                        context: this
                    }), this._freezer = new i(this._changeCallback, this), this.events = new t({context: this})
                };
                _.keepClosed = function (e) {
                    for (var t = 0, n = e.length, o = e; t < n; t++) {
                        var i = e[t], r = a.keepClosed(i, !0);
                        i !== r && (o == e && (o = e.slice()), o[t] = r)
                    }
                    return o
                }, _.fromEncodedCoordinates = function (e) {
                    for (var t = e.split(";"), n = [], o = 0, i = t.length; o < i; o++) n.push(r(t[o]));
                    return new _(n)
                }, _.toEncodedCoordinates = function (e) {
                    if (ym.env.debug && "Polygon" != e.getType()) throw new Error("geometry.base.Polygon.toEncodedCoordinates: неверный тип геометрии: " + e.getType());
                    for (var t = [], n = 0, i = e.getLength(); n < i; n++) t.push(o(e.get(n)));
                    return t.join(";")
                }, n(_.prototype, {
                    getType: function () {
                        return "Polygon"
                    }, getBounds: function () {
                        return this._coordPath.getBounds()
                    }, set: function (e, t) {
                        return this._childPath.setChild(e, null), this._coordPath.set(e, a.keepClosed(t)), this
                    }, get: function (e) {
                        return this._coordPath.get(e)
                    }, getChildGeometry: function (e) {
                        return this._childPath.getChild(e) || this._childPath.createChild(e, this._coordPath.get(e))
                    }, remove: function (e) {
                        return this._childPath.splice(e, 1), this._coordPath.splice(e, 1)[0]
                    }, insert: function (e, t) {
                        return this._childPath.splice(e, 0, null), this._coordPath.splice(e, 0, a.keepClosed(t)), this
                    }, splice: function (e, t) {
                        return arguments.length > 2 ? this._childPath.splice.apply(this._childPath, [e, t].concat(new Array(arguments.length - 2))) : this._childPath.splice(e, t), arguments.length > 2 ? this._coordPath.splice.apply(this._coordPath, [e, t].concat(_.keepClosed(Array.prototype.slice.call(arguments, 2)))) : this._coordPath.splice(e, t)
                    }, setCoordinates: function (e) {
                        return e = _.keepClosed(e), this._childPath.setChildren([]), this._coordPath.setCoordinates(e), this
                    }, getCoordinates: function () {
                        return this._coordPath.getCoordinates()
                    }, getLength: function () {
                        return this._coordPath.getLength()
                    }, setFillRule: function (e) {
                        return this._fillRuleComponent.setFillRule(e), this
                    }, getFillRule: function () {
                        return this._fillRuleComponent.getFillRule()
                    }, freeze: function () {
                        return this._freezer.freeze(), this
                    }, unfreeze: function () {
                        return this._freezer.unfreeze(), this
                    }, isFrozen: function () {
                        return this._freezer.isFrozen()
                    }, contains: function (e) {
                        return p.contains(this._coordPath.getCoordinates(), e, this._fillRuleComponent.getFillRule())
                    }, getClosest: function (e) {
                        return p.getClosest(this._coordPath.getCoordinates(), e)
                    }, _changeCallback: function (e) {
                        this.events.fire("change", n({type: "change", target: this}, e))
                    }, onGeometryChange: function (e, t, n) {
                        this._freezer.fire(e, t, n)
                    }
                }), e(_)
            });
        }],
        ['2H', function (ym) {
            ym.modules.define("geometry.base.Rectangle", ["event.Manager", "util.extend", "component.EventFreezer", "geometry.component.commonMethods.rectangle"], function (e, t, n, o, i) {
                var s = i, r = function (e) {
                    this._coordinates = r.keepConsistent(e), this._freezer = new o(this._changeCallback, this), this.events = new t({context: this})
                };
                r.keepConsistent = function (e) {
                    var t = null;
                    return e && e.length && (t = e, 2 != e.length && (t = t.slice(0, 2), 1 == e.length && (t[1] = t[0].slice()))), t
                }, n(r.prototype, {
                    getType: function () {
                        return "Rectangle"
                    }, getBounds: function () {
                        return this._bounds || (this._bounds = s.calculateBounds(this._coordinates))
                    }, setCoordinates: function (e) {
                        var t = this._coordinates;
                        return this._coordinates = r.keepConsistent(e), this._bounds = null, this.onGeometryChange("Coordinates", t, this._coordinates), this
                    }, getCoordinates: function () {
                        return this._coordinates
                    }, freeze: function () {
                        return this._freezer.freeze(), this
                    }, unfreeze: function () {
                        return this._freezer.unfreeze(), this
                    }, isFrozen: function () {
                        return this._freezer.isFrozen()
                    }, getClosest: function (e) {
                        return s.getClosest(this._coordinates, e)
                    }, contains: function (e) {
                        return s.contains(this._coordinates, e)
                    }, _changeCallback: function (e) {
                        this.events.fire("change", n({type: "change", target: this}, e))
                    }, onGeometryChange: function (e, t, n) {
                        this._freezer.fire(e, t, n)
                    }
                }), e(r)
            });
        }],
        ['2*', function (ym) {
            ym.modules.define("geometry.Circle", ["util.defineClass", "option.Manager", "geometry.base.Circle", "geometry.pixel.Circle", "geometry.component.renderFlowManager", "geometry.component.pixelGeometryGeodesic.circle", "geometry.component.renderFlow.stageScale", "geometry.component.renderFlow.stageShift", "geometry.defaultOptions", "geometry.component.boundsFromPixels", "geometry.component.pixelGetClosest", "util.getPixelRadius", "geometry.component.pixelContains", "util.matrix.2d", "Event", "geometry.serializer"], function (e, t, o, n, i, r, s, a, l, c, g, p, m, u, d, h, y) {
                function f() {
                    this.events.fire("optionschange")
                }

                function C(e) {
                    this._bounds = null, this.events.fire("pixelgeometrychange", new h({
                        type: "pixelgeometrychange",
                        target: this,
                        pixelGeometry: e
                    }))
                }

                function v(e, t) {
                    if (ym.env.debug && !t.projection) throw new Error("geometry.Circle._renderingStageBasePixels: значение опции projection не определено");
                    return e ? t.geodesic ? x(e, this.getRadius(), t) : new i(t.projection.toGlobalPixels(e, 0), m(e, this.getRadius(), t.projection, 0)) : new i
                }

                var w, x = s, _ = function (e, t, n) {
                    _.superclass.constructor.call(this, e, t), this._map = null, this.options = new o(n), this.options.events.add("change", f, this)
                };
                t(_, n, {
                    getBounds: function () {
                        return this.getCoordinates() ? this._bounds || (this._bounds = g.get(this)) : null
                    }, getPixelGeometry: function (e) {
                        if (ym.env.debug && !this._map) throw new Error("geometry.main.Circle.getPixelGeometry: Не задана карта.");
                        return this._map ? r.getPixelGeometry(this, e) : null
                    }, onGeometryChange: function (e, t, o) {
                        r.clear(this), _.superclass.onGeometryChange.call(this, e, t, o)
                    }, setMap: function (e) {
                        var t = this._map;
                        t && this._clearRenderFlow(), this._map = e, e && this._setupRenderFlow(), this.events.fire("mapchange", new h({
                            type: "mapchange",
                            target: this,
                            newMap: this._map,
                            oldMap: t
                        }))
                    }, getMap: function () {
                        return this._map
                    }, contains: function (e) {
                        return u(this, e)
                    }, getClosest: function (e) {
                        var t = p(this, e), o = this.options.get("projection");
                        if (ym.env.debug && "object" != typeof o) throw new Error("geometry.Circle.getClosest: В опциях геометрии не определена проекция.");
                        return t && (t.position = o.fromGlobalPixels(t.position, this._map.getZoom()), t.distance = o.getCoordSystem().getDistance(e, t.position)), t
                    }, applyProjectedTransformation: function (e) {
                        var t = this.options.get("projection"), o = this.getMap().action.getCurrentState().zoom,
                            n = t.toGlobalPixels(this.getCoordinates(), o), i = [];
                        d.applyToPoint(i, n, e), this.setCoordinates(t.fromGlobalPixels(i, o))
                    }, _setupRenderFlow: function () {
                        var e = w;
                        e[0].stage = this.getCoordinates, r.add(this, e, c, C)
                    }, _clearRenderFlow: function () {
                        r.remove(this, w)
                    }
                }), w = [{stage: null, event: {target: "self", event: "change"}}, {
                    stage: v,
                    options: ["projection", "geodesic"]
                }, {
                    stage: a.apply,
                    event: {target: "map", event: "actionend", callback: a.onActionEnd}
                }, {
                    stage: l.apply,
                    options: ["projection", "pixelRendering"],
                    event: {target: "map", event: "actionend", callback: l.onActionEnd}
                }], y.add("Circle", {
                    serialize: function (e) {
                        return {type: "Circle", coordinates: e.getCoordinates(), radius: e.getRadius()}
                    }, deserialize: function (e) {
                        return new _(e.coordinates, e.radius)
                    }, applyTo: function (e, t) {
                        e.setRadius(t.radius), e.setCoordinates(t.coordinates)
                    }
                }), e(_)
            });
        }],
        ['2:', function (ym) {
            ym.modules.define("geometry.LineString", ["util.defineClass", "util.coordinates.encode", "util.coordinates.decode", "option.Manager", "geometry.base.LineString", "geometry.pixel.LineString", "geometry.component.renderFlowManager", "geometry.component.renderFlow.stageGeodesic", "geometry.component.renderFlow.stageScale", "geometry.component.renderFlow.stageSimplification", "geometry.component.renderFlow.stageShift", "geometry.component.pixelGeometryGeodesic.lineString", "geometry.component.pixelGeometrySimplification.lineString", "geometry.component.ShortestPath", "geometry.component.boundsFromPixels", "geometry.component.pixelGetClosest", "geometry.defaultOptions", "util.matrix.2d", "Event", "geometry.serializer"], function (e, t, n, o, i, r, s, a, g, c, p, l, d, h, m, u, y, f, w, v, S) {
                function C() {
                    this.events.fire("optionschange")
                }

                function x(e) {
                    this._bounds = null, this.events.fire("pixelgeometrychange", new v({
                        pixelGeometry: e,
                        type: "pixelgeometrychange",
                        target: this
                    }))
                }

                function b(e, t) {
                    if (ym.env.debug && !t.projection) throw new Error("geometry.LineString._renderingStageBasePixels: значение опции projection не определено");
                    var n;
                    if ("straightPath" == t.coordRendering) n = _(e, t.projection); else if ("shortestPath" == t.coordRendering) n = P(e, t.projection, t.sharedShortestPath); else if (ym.env.debug) throw new Error("geometry.LineString._renderingStageBasePixels: неизвестное значение опции coordRendering");
                    return new s(n)
                }

                function P(e, t, n) {
                    return n = n || new m, n.calculate(_(e, t), t.isCycled())
                }

                function _(e, t) {
                    for (var n = [], o = 0, i = e.length; o < i; ++o) n[o] = t.toGlobalPixels(e[o], 0);
                    return n
                }

                var L, E = function (e, t) {
                    E.superclass.constructor.call(this, e), this._map = null, this.options = new i(t), this.options.events.add("change", C, this)
                };
                E.fromEncodedCoordinates = function (e, t) {
                    return new E(o(e), t)
                }, E.toEncodedCoordinates = function (e) {
                    if (ym.env.debug && "LineString" != e.getType()) throw new Error("geometry.LineString.toEncodedCoordinates: неверный тип геометрии: " + e.getType());
                    return n(e.getCoordinates())
                }, t(E, r, {
                    getBounds: function () {
                        return this._bounds || (this._bounds = u.get(this))
                    }, getPixelGeometry: function (e) {
                        if (ym.env.debug && !this._map) throw new Error("geometry.main.LineString.getPixelGeometry: Не задана карта.");
                        return this._map ? a.getPixelGeometry(this, e) : null
                    }, setMap: function (e) {
                        var t = this._map;
                        t && this._clearRenderFlow(), this._map = e, e && this._setupRenderFlow(), this.events.fire("mapchange", new v({
                            newMap: this._map,
                            oldMap: t,
                            target: this,
                            type: "mapchange"
                        }))
                    }, getMap: function () {
                        return this._map
                    }, onGeometryChange: function (e, t, n) {
                        a.clear(this), E.superclass.onGeometryChange.call(this, e, t, n)
                    }, getClosest: function (e) {
                        var t = y(this, e), n = this.options.get("projection");
                        if (ym.env.debug && "object" != typeof n) throw new Error("geometry.LineString.getClosest: В опциях геометрии не определена проекция.");
                        return t && (t.position = n.fromGlobalPixels(t.position, this._map.getZoom()), t.distance = n.getCoordSystem().getDistance(e, t.position)), t
                    }, getDistance: function (e, t) {
                        if (e = e || 0, t = t || this.getLength() - 1, ym.env.debug) {
                            if (!this.getMap()) throw new Error("geometry.LineString: геометрия должна быть добавлена на карту.");
                            if (e < 0 || t > this.getLength() - 1) throw new Error("geometry.LineString: выход за пределы массива точек")
                        }
                        for (var n = this.getMap().options.get("projection").getCoordSystem(), o = this.getCoordinates(), i = 0, r = e; r < t; r++) i += n.getDistance(o[r], o[r + 1]);
                        return i
                    }, applyProjectedTransformation: function (e) {
                        var t = this.options.get("projection"), n = this.getMap().action.getCurrentState().zoom,
                            o = Math.pow(2, n), i = this.options.get("coordRendering"), r = this.getCoordinates(),
                            s = [], a = [];
                        s = "shortestPath" == i ? P(r, t, this.options.get("sharedShortestPath")) : _(r, t), "function" == typeof e && (e = e({
                            type: "LineString",
                            pixels: s
                        }));
                        for (var g = 0, c = s.length; g < c; g++) {
                            var p = [s[g][0] * o, s[g][1] * o];
                            e && w.applyToPoint(p, p, e), a[g] = t.fromGlobalPixels(p, n)
                        }
                        this.setCoordinates(a)
                    }, _setupRenderFlow: function () {
                        L[0].stage = this.getCoordinates, a.add(this, L, f, x)
                    }, _clearRenderFlow: function () {
                        a.remove(this, L)
                    }
                }), L = [{stage: null, event: {target: "self", event: "change"}}, {
                    stage: b,
                    options: ["projection", "coordRendering", "sharedShortestPath"]
                }, {stage: g, options: ["projection", "geodesic"]}, {
                    stage: p.prepare,
                    options: ["simplification"]
                }, {
                    stage: p.apply,
                    options: ["simplification"],
                    event: {target: "map", event: "actionend", callback: c.onActionEnd}
                }, {
                    stage: c.apply,
                    event: {target: "map", event: "actionend", callback: c.onActionEnd}
                }, {
                    stage: l.apply,
                    options: ["projection", "pixelRendering"],
                    event: {target: "map", event: "actionend", callback: l.onActionEnd}
                }], S.add("LineString", {
                    serialize: function (e) {
                        return {type: "LineString", coordinates: e.getCoordinates()}
                    }, deserialize: function (e) {
                        return new E(e.coordinates)
                    }, applyTo: function (e, t) {
                        e.setCoordinates(t.coordinates)
                    }
                }), e(E)
            });
        }],
        ['2Z', function (ym) {
            ym.modules.define("geometry.pixel.Circle", ["util.extend", "geometry.component.commonMethods.circle", "event.Manager"], function (t, n, i, e) {
                var s = function (t, n, i) {
                    this._coordinates = t || null, this._radius = null == n ? null : n, this._metaData = i || {}, this._bounds = null, this.events = new e
                };
                s.prototype = {
                    getType: function () {
                        return "Circle"
                    }, getCoordinates: function () {
                        return this._coordinates
                    }, getCenter: function () {
                        return this._coordinates
                    }, getMetaData: function () {
                        return this._metaData
                    }, getRadius: function () {
                        return this._radius
                    }, getBounds: function () {
                        return this._coordinates ? this._bounds || (this._bounds = this._calculateBounds()) : null
                    }, clone: function (t, i, e) {
                        return new s(t || this._coordinates, i || this._radius, e ? n({}, this._metaData, e) : this._metaData)
                    }, scale: function (t) {
                        return this.clone(this._coordinates ? [this._coordinates[0] * t, this._coordinates[1] * t] : null, this._radius ? this._radius * t : null)
                    }, shift: function (t) {
                        return this.clone(this._coordinates ? [this._coordinates[0] + t[0], this._coordinates[1] + t[1]] : null)
                    }, contains: function (t) {
                        return i.contains(this._coordinates, this._radius, t)
                    }, getClosest: function (t) {
                        return i.getClosest(this._coordinates, this._radius, t)
                    }, equals: function (t) {
                        if (this.getType() != t.getType() || this._radius != t.getRadius()) return !1;
                        var n = t.getCoordinates();
                        return this._coordinates && n ? this._coordinates[0] == n[0] && this._coordinates[1] == n[1] : this._coordinates == n
                    }, _calculateBounds: function () {
                        return i.calculateBounds(this._coordinates, this._radius)
                    }
                }, t(s)
            });
        }],
        ['3a', function (ym) {
            ym.modules.define("geometry.pixel.LineString", ["util.extend", "util.pixelBounds", "geometry.component.findClosestPathPosition", "util.math.areEqualPaths", "event.Manager"], function (t, n, e, i, o, s) {
                var r = function (t, n) {
                    this._coordinates = t, this._metaData = n || {}, this._bounds = null, this.events = new s
                };
                r.prototype = {
                    getType: function () {
                        return "LineString"
                    }, getCoordinates: function () {
                        return this._coordinates
                    }, getMetaData: function () {
                        return this._metaData
                    }, getLength: function () {
                        return this._coordinates.length
                    }, getBounds: function () {
                        return this._coordinates ? this._bounds || (this._bounds = e.fromPoints(this._coordinates)) : null
                    }, getClosest: function (t) {
                        return i(this._coordinates, t)
                    }, clone: function (t, e) {
                        return new r(t || this._coordinates, e ? n({}, this._metaData, e) : this._metaData)
                    }, scale: function (t) {
                        for (var n = [], e = 0, i = this._coordinates.length; e < i; e++) {
                            var o = this._coordinates[e];
                            n[e] = [o[0] * t, o[1] * t]
                        }
                        return this.clone(n)
                    }, shift: function (t) {
                        for (var n = [], e = 0, i = this._coordinates.length; e < i; e++) {
                            var o = this._coordinates[e];
                            n[e] = [o[0] + t[0], o[1] + t[1]]
                        }
                        return this.clone(n)
                    }, equals: function (t) {
                        return this.getType() == t.getType() && o(this._coordinates, t.getCoordinates(), 0)
                    }
                }, t(r)
            });
        }],
        ['3d', function (ym) {
            ym.modules.define("geometry.pixel.MultiPolygon", ["util.defineClass", "geometry.pixel.Polygon", "geometry.pixel.MultiGeometry", "util.extend"], function (e, t, l, n, i) {
                function u(e, t, n) {
                    if (!e) return null;
                    for (var i = [], u = 0, o = e.length; u < o; u++) i.push(e[u].getType ? e[u] : new l(e[u], t, {convex: n}));
                    return i
                }

                var o = function (e, t, l) {
                    this._fillRule = t, this._convex = l && l.convex, o.superclass.constructor.call(this, u(e, t, this._convex), l)
                };
                t(o, n, {
                    getType: function () {
                        return "MultiPolygon"
                    }, getFillRule: function () {
                        return this._fillRule
                    }, clone: function (e, t, l) {
                        var n = this.getMetaData();
                        return new o(e || this.getCoordinates(), t || this._fillRule, l ? i({}, n, l) : n)
                    }, equals: function (e) {
                        return this.getFillRule() == e.getFillRule() && o.superclass.equals.call(this, e)
                    }
                }), e(o)
            });
        }],
        ['3e', function (ym) {
            ym.modules.define("geometry.pixel.Point", ["util.extend", "event.Manager"], function (t, i, n) {
                var o = function (t, i) {
                    this._position = t || null, this._metaData = i || {}, this._bounds = null, this.events = new n
                };
                o.prototype = {
                    getType: function () {
                        return "Point"
                    }, getCoordinates: function () {
                        return this._position
                    }, getMetaData: function () {
                        return this._metaData
                    }, getBounds: function () {
                        return this._position ? this._bounds || (this._bounds = [this._position.slice(), this._position.slice()]) : null
                    }, clone: function (t, n) {
                        return new o(t || this._position, n ? i({}, this._metaData, n) : this._metaData)
                    }, scale: function (t) {
                        return this.clone(this._position ? [this._position[0] * t, this._position[1] * t] : null)
                    }, shift: function (t) {
                        return this.clone(this._position ? [this._position[0] + t[0], this._position[1] + t[1]] : null)
                    }, equals: function (t) {
                        if (this.getType() != t.getType()) return !1;
                        var i = t.getCoordinates();
                        return this._position && i ? this._position[0] == i[0] && this._position[1] == i[1] : this._position == i
                    }, getClosest: function (t) {
                        var i = this._position;
                        if (!i) return null;
                        var n = [t[0] - i[0], t[1] - i[1]], o = Math.sqrt(n[0] * n[0] + n[1] * n[1]);
                        return {position: [i[0], i[1]], distance: o}
                    }
                }, t(o)
            });
        }],
        ['3f', function (ym) {
            ym.modules.define("geometry.pixel.Polygon", ["util.extend", "geometry.component.commonMethods.polygon", "util.math.areEqualPaths", "event.Manager"], function (t, e, n, o, i) {
                var s = function (t, e, n) {
                    this._coordinates = t, this._fillRule = e, this._convex = n && n.convex, this._metaData = n || {}, this._bounds = null, this.events = new i
                };
                s.prototype = {
                    getType: function () {
                        return "Polygon"
                    }, getCoordinates: function () {
                        return this._coordinates
                    }, getMetaData: function () {
                        return this._metaData
                    }, getFillRule: function () {
                        return this._fillRule
                    }, getLength: function () {
                        return this._coordinates.length
                    }, getBounds: function () {
                        return this._bounds || (this._bounds = n.calculateBounds(this._coordinates))
                    }, contains: function (t) {
                        return n.contains(this._coordinates, t, this._fillRule)
                    }, getClosest: function (t) {
                        return n.getClosest(this._coordinates, t)
                    }, clone: function (t, n, o) {
                        return new s(t || this.getCoordinates(), n || this._fillRule, o ? e({}, this._metaData, o) : this._metaData)
                    }, scale: function (t) {
                        for (var e, n = [], o = 0, i = this._coordinates.length; o < i; o++) {
                            n[o] = e = [];
                            for (var s = 0, r = this._coordinates[o].length, a = this._coordinates[o]; s < r; s++) e[s] = [a[s][0] * t, a[s][1] * t]
                        }
                        return this.clone(n)
                    }, shift: function (t) {
                        for (var e, n = [], o = 0, i = this._coordinates.length; o < i; o++) {
                            n[o] = e = [];
                            for (var s = 0, r = this._coordinates[o].length, a = this._coordinates[o]; s < r; s++) e[s] = [a[s][0] + t[0], a[s][1] + t[1]]
                        }
                        return this.clone(n)
                    }, equals: function (t) {
                        return this.getType() == t.getType() && this._fillRule == t.getFillRule() && o(this._coordinates, t.getCoordinates(), 1)
                    }
                }, t(s)
            });
        }],
        ['3g', function (ym) {
            ym.modules.define("geometry.pixel.Rectangle", ["util.extend", "geometry.component.commonMethods.rectangle", "event.Manager"], function (t, n, e, o) {
                var i = e, s = function (t, n) {
                    this._coordinates = t || null, this._metaData = n || {}, this._bounds = null, this.events = new o
                };
                s.prototype = {
                    getType: function () {
                        return "Rectangle"
                    }, getCoordinates: function () {
                        return this._coordinates
                    }, getMetaData: function () {
                        return this._metaData
                    }, getBounds: function () {
                        return this._bounds || (this._bounds = i.calculateBounds(this._coordinates))
                    }, clone: function (t, e) {
                        return new s(t || this._coordinates, e ? n({}, this._metaData, e) : this._metaData)
                    }, scale: function (t) {
                        return this.clone(this._coordinates ? [[this._coordinates[0][0] * t, this._coordinates[0][1] * t], [this._coordinates[1][0] * t, this._coordinates[1][1] * t]] : null)
                    }, shift: function (t) {
                        return this.clone(this._coordinates ? [[this._coordinates[0][0] + t[0], this._coordinates[0][1] + t[1]], [this._coordinates[1][0] + t[0], this._coordinates[1][1] + t[1]]] : null)
                    }, getClosest: function (t) {
                        return i.getClosest(this._coordinates, t)
                    }, contains: function (t) {
                        return i.contains(this._coordinates, t)
                    }, equals: function (t) {
                        if (this.getType() != t.getType()) return !1;
                        var n = this._coordinates, e = t.getCoordinates();
                        return n && e ? n[0][0] == e[0][0] && n[0][1] == e[0][1] && n[1][0] == e[1][0] && n[1][1] == e[1][1] : n == e
                    }
                }, t(s)
            });
        }],
        ['2z', function (ym) {
            ym.modules.define("geometry.Point", ["util.defineClass", "option.Manager", "geometry.base.Point", "geometry.pixel.Point", "geometry.component.renderFlowManager", "geometry.component.renderFlow.stageScale", "geometry.component.renderFlow.stageShift", "Event", "util.matrix.2d", "geometry.defaultOptions", "geometry.serializer", "geometry.component.ShortestPath"], function (e, t, n, o, i, r, a, s, c, l, p, g, h) {
                function d() {
                    this.events.fire("optionschange", new c({type: "optionschange", target: this}))
                }

                function m(e) {
                    this.events.fire("pixelgeometrychange", new c({
                        pixelGeometry: e,
                        type: "pixelgeometrychange",
                        target: this
                    }))
                }

                function u(e, t) {
                    if (ym.env.debug && !t.projection) throw new Error("geometry.Point._renderingStageBasePixels: значение опции projection не определено");
                    if (!e) return new i;
                    var n = t.projection.toGlobalPixels(e, 0);
                    return new i("shortestPath" == t.coordRendering && t.sharedShortestPath ? y(n, t.projection, t.sharedShortestPath) : n)
                }

                function y(e, t, n) {
                    return n = n || new h, n.calculate([e], t.isCycled())[0]
                }

                var f = function (e, t) {
                    f.superclass.constructor.call(this, e), this.options = new n(t), this.options.events.add("change", d, this)
                };
                t(f, o, {
                    getPixelGeometry: function (e) {
                        if (ym.env.debug && !this._map) throw new Error("geometry.main.Point.getPixelGeometry: Не задана карта.");
                        return this._map ? r.getPixelGeometry(this, e) : null
                    }, setMap: function (e) {
                        var t = this._map;
                        t && this._clearRenderFlow(), this._map = e, e && this._setupRenderFlow(), this.events.fire("mapchange", new c({
                            newMap: this._map,
                            oldMap: t,
                            target: this,
                            type: "mapchange"
                        }))
                    }, getMap: function () {
                        return this._map
                    }, onGeometryChange: function (e, t, n) {
                        r.clear(this), f.superclass.onGeometryChange.call(this, e, t, n)
                    }, applyProjectedTransformation: function (e) {
                        var t = this.options.get("projection"), n = this.getMap().action.getCurrentState().zoom,
                            o = t.toGlobalPixels(this.getCoordinates(), n);
                        "function" == typeof e && (e = e({
                            type: "Point",
                            pixels: o
                        })), e && l.applyToPoint(o, o, e), this.setCoordinates(t.fromGlobalPixels(o, n))
                    }, _setupRenderFlow: function () {
                        var e = P;
                        e[0].stage = this.getCoordinates, r.add(this, e, p, m)
                    }, _clearRenderFlow: function () {
                        r.remove(this, P)
                    }
                });
                var P = [{stage: null, event: {target: "self", event: "change"}}, {
                    stage: u,
                    options: ["projection", "coordRendering", "sharedShortestPath"]
                }, {
                    stage: a.apply,
                    event: {target: "map", event: "actionend", callback: a.onActionEnd}
                }, {
                    stage: s.apply,
                    options: ["projection", "pixelRendering"],
                    event: {target: "map", event: "actionend", callback: s.onActionEnd}
                }];
                g.add("Point", {
                    serialize: function (e) {
                        return {type: "Point", coordinates: e.getCoordinates()}
                    }, deserialize: function (e) {
                        return new f(e.coordinates)
                    }, applyTo: function (e, t) {
                        e.setCoordinates(t.coordinates)
                    }
                }), e(f)
            });
        }],
        ['2Q', function (ym) {
            ym.modules.define("geometry.Polygon", ["util.defineClass", "util.coordinates.encode", "geometry.component.closedPathDecode", "option.Manager", "geometry.base.Polygon", "geometry.pixel.Polygon", "geometry.component.renderFlowManager", "geometry.component.renderFlow.stageGeodesic", "geometry.component.pixelGeometryGeodesic.polygon", "geometry.component.renderFlow.stageShift", "geometry.component.renderFlow.stageSimplification", "geometry.component.pixelGeometrySimplification.polygon", "geometry.component.selfIntersection", "geometry.component.renderFlow.stageScale", "geometry.component.ShortestPath", "geometry.defaultOptions", "geometry.component.boundsFromPixels", "geometry.component.pixelGetClosest", "geometry.component.pixelContains", "util.matrix.2d", "Event", "geometry.serializer"], function (e, t, o, n, i, r, s, a, l, g, c, p, h, d, m, y, u, f, v, P, w, x, b) {
                function C() {
                    this.events.fire("optionschange")
                }

                function R(e) {
                    this._bounds = null, this.events.fire("pixelgeometrychange", new x({
                        pixelGeometry: e,
                        type: "pixelgeometrychange",
                        target: this
                    }))
                }

                function _(e, t) {
                    if (ym.env.debug && !t.projection) throw new Error("geometry.Polygon._renderingStageBasePixels: значение опции projection не определено");
                    var o;
                    if ("straightPath" == t.coordRendering) o = G(e, t.projection); else if ("shortestPath" == t.coordRendering) o = F(e, t.projection, t.sharedShortestPath); else if (ym.env.debug) throw new Error("geometry.Polygon._renderingStageBasePixels: неизвестное значение опции coordRendering");
                    return new s(o, this.getFillRule())
                }

                function F(e, t, o) {
                    var n = G(e, t);
                    o = o || new y;
                    for (var i = 0, r = e.length; i < r; i++) n[i] = o.calculate(n[i], t.isCycled());
                    return n
                }

                function G(e, t) {
                    for (var o, n = [], i = 0, r = e.length; i < r; i++) {
                        n[i] = o = [];
                        for (var s = 0, a = e[i].length, l = e[i]; s < a; s++) o[s] = t.toGlobalPixels(l[s], 0)
                    }
                    return n
                }

                var S, j = function (e, t, o) {
                    j.superclass.constructor.call(this, e, t), this.options = new i(o), this.options.events.add("change", C, this)
                };
                j.fromEncodedCoordinates = function (e, t) {
                    for (var o = e.split(";"), i = [], r = 0, s = o.length; r < s; r++) i.push(n(o[r]));
                    return new j(i, t)
                }, j.toEncodedCoordinates = function (e) {
                    if (ym.env.debug && "Polygon" != e.getType()) throw new Error("Неверный тип геометрии. Ожидался: Polygon, получен: " + e.getType());
                    for (var t = [], n = 0, i = e.getLength(); n < i; n++) t.push(o(e.get(n)));
                    return t.join(";")
                }, t(j, r, {
                    getBounds: function () {
                        return this._bounds || (this._bounds = f.get(this))
                    }, getPixelGeometry: function (e) {
                        if (ym.env.debug && !this._map) throw new Error("geometry.main.Polygon.getPixelGeometry: Не задана карта.");
                        return this._map ? a.getPixelGeometry(this, e) : null
                    }, setMap: function (e) {
                        var t = this._map;
                        t && this._clearRenderFlow(), this._map = e, e && this._setupRenderFlow(), this.events.fire("mapchange", new x({
                            newMap: this._map,
                            oldMap: t,
                            target: this,
                            type: "mapchange"
                        }))
                    }, getMap: function () {
                        return this._map
                    }, onGeometryChange: function (e, t, o) {
                        a.clear(this), j.superclass.onGeometryChange.call(this, e, t, o)
                    }, contains: function (e) {
                        return P(this, e)
                    }, getClosest: function (e) {
                        var t = v(this, e), o = this.options.get("projection");
                        if (ym.env.debug && "object" != typeof o) throw new Error("geometry.Polygon.getClosest: В опциях геометрии не определена проекция.");
                        return t && (t.position = o.fromGlobalPixels(t.position, this._map.getZoom()), t.distance = o.getCoordSystem().getDistance(e, t.position)), t
                    }, applyProjectedTransformation: function (e) {
                        var t = this.options.get("projection"), o = this.getMap().action.getCurrentState().zoom,
                            n = Math.pow(2, o), i = this.options.get("coordRendering"), r = this.getCoordinates(),
                            s = [], a = [];
                        s = "shortestPath" == i ? F(r, t, this.options.get("sharedShortestPath")) : G(r, t);
                        for (var l = 0, g = s.length; l < g; l++) for (var c = s[l], p = 0, h = c.length; p < h; p++) c[p] = [c[p][0] * n, c[p][1] * n];
                        "function" == typeof e && (e = e({type: "Polygon", pixels: s}));
                        for (var l = 0, g = s.length; l < g; l++) {
                            for (var c = s[l], d = [], p = 0, h = c.length; p < h; p++) {
                                var m = c[p];
                                e && w.applyToPoint(m, m, e), d[p] = t.fromGlobalPixels(m, o)
                            }
                            a[l] = d
                        }
                        this.setCoordinates(a)
                    }, _setupRenderFlow: function () {
                        a.add(this, S, u, R)
                    }, _clearRenderFlow: function () {
                        a.remove(this, S)
                    }
                }), S = [{stage: j.prototype.getCoordinates, event: {target: "self", event: "change"}}, {
                    stage: _,
                    options: ["projection", "coordRendering", "sharedShortestPath"]
                }, {stage: l, options: ["projection", "geodesic"]}, {
                    stage: d.prepare,
                    options: ["cureSelfIntersections"]
                }, {stage: p.prepare, options: ["simplification", "simplificationFixedPoints"]}, {
                    stage: p.apply,
                    options: ["simplification"],
                    event: {target: "map", event: "actionend", callback: m.onActionEnd}
                }, {
                    stage: m.apply,
                    event: {target: "map", event: "actionend", callback: m.onActionEnd}
                }, {
                    stage: c.apply,
                    options: ["projection", "pixelRendering"],
                    event: {target: "map", event: "actionend", callback: c.onActionEnd}
                }], b.add("Polygon", {
                    serialize: function (e) {
                        return {type: "Polygon", coordinates: e.getCoordinates(), fillRule: e.getFillRule()}
                    }, deserialize: function (e) {
                        return new j(e.coordinates, e.fillRule)
                    }, applyTo: function (e, t) {
                        e.setFillRule(t.fillRule), e.setCoordinates(t.coordinates)
                    }
                }), e(j)
            });
        }],
        ['2J', function (ym) {
            ym.modules.define("geometry.Rectangle", ["util.defineClass", "option.Manager", "geometry.base.Rectangle", "geometry.pixel.Rectangle", "geometry.component.renderFlowManager", "geometry.component.renderFlow.stageGeodesic", "geometry.component.pixelGeometryGeodesic.rectangle", "geometry.component.renderFlow.stageScale", "geometry.component.renderFlow.stageShift", "geometry.component.ShortestPath", "geometry.component.anchor", "geometry.defaultOptions", "geometry.component.boundsFromPixels", "geometry.component.pixelGetClosest", "geometry.component.pixelContains", "util.matrix.2d", "Event", "geometry.serializer"], function (e, t, o, n, r, i, s, a, c, g, l, p, m, h, d, u, y, f, w) {
                function v() {
                    this.events.fire("optionschange")
                }

                function R(e) {
                    this._bounds = null, this.events.fire("pixelgeometrychange", new f({
                        pixelGeometry: e,
                        type: "pixelgeometrychange",
                        target: this
                    }))
                }

                function x(e, t) {
                    if (ym.env.debug && !t.projection) throw new Error("geometry.Rectangle._renderingStageBasePixels: значение опции projection не определено");
                    if (!e) return new r;
                    var o;
                    if ("straightPath" == t.coordRendering) o = b(e, t.projection, 0); else if ("shortestPath" == t.coordRendering) o = P(e, t.projection, 0); else if ("boundsPath" == t.coordRendering) o = C(e, t.projection, 0); else if (ym.env.debug) throw new Error("geometry.Rectangle.getPixelGeometry: неизвестное значение опции coordRendering");
                    return new r(o)
                }

                function P(e, t, o) {
                    return (new l).calculate(b(e, t, o), t.isCycled())
                }

                function b(e, t, o) {
                    for (var n = [], r = 0, i = e.length; r < i; ++r) n[r] = t.toGlobalPixels(e[r], o);
                    return n
                }

                function C(e, t, o) {
                    var n, r = b(e, t, o), i = 256 * Math.pow(2, o);
                    return r[1][0] < r[0][0] && (n = p.getAnchor(r[1][0], r[0][0], i), r[1][0] = n < r[0][0] ? n += i : n), r[1][1] > r[0][1] && (n = p.getAnchor(r[1][1], r[0][1], i), r[1][1] = n > r[0][1] ? n -= i : n), r
                }

                var G = function (e, t) {
                    G.superclass.constructor.call(this, e), this.options = new o(t), this.options.events.add("change", v, this)
                };
                t(G, n, {
                    getBounds: function () {
                        return this._bounds || (this._bounds = h.get(this))
                    }, getPixelGeometry: function (e) {
                        if (ym.env.debug && !this._map) throw new Error("geometry.main.Rectangle.getPixelGeometry: Не задана карта.");
                        return this._map ? i.getPixelGeometry(this, e) : null
                    }, setMap: function (e) {
                        var t = this._map;
                        t && this._clearRenderFlow(), this._map = e, e && this._setupRenderFlow(), this.events.fire("mapchange", new f({
                            newMap: this._map,
                            oldMap: t,
                            type: "mapchange",
                            target: this
                        }))
                    }, getMap: function () {
                        return this._map
                    }, onGeometryChange: function (e, t, o) {
                        i.clear(this), G.superclass.onGeometryChange.call(this, e, t, o)
                    }, contains: function (e) {
                        return u(this, e)
                    }, getClosest: function (e) {
                        var t = d(this, e), o = this.options.get("projection");
                        if (ym.env.debug && "object" != typeof o) throw new Error("geometry.Rectangle.getClosest: В опциях геометрии не определена проекция.");
                        return t && (t.position = o.fromGlobalPixels(t.position, this._map.getZoom()), t.distance = o.getCoordSystem().getDistance(e, t.position)), t
                    }, applyProjectedTransformation: function (e) {
                        var t = this.options.get("projection"), o = this.getMap().action.getCurrentState().zoom,
                            n = Math.pow(2, o), r = this.options.get("coordRendering"), i = this.getCoordinates(),
                            s = [];
                        s = "shortestPath" == r ? P(i, t, 0) : b(i, t, 0), s[0][0] *= n, s[0][1] *= n, s[1][0] *= n, s[1][1] *= n, "function" == typeof e && (e = e({
                            type: "Rectangle",
                            pixels: s
                        })), e && (y.applyToPoint(s[0], s[0], e), y.applyToPoint(s[1], s[1], e)), this.setCoordinates([t.fromGlobalPixels(s[0], o), t.fromGlobalPixels(s[1], o)])
                    }, _setupRenderFlow: function () {
                        var e = _;
                        e[0].stage = this.getCoordinates, i.add(this, e, m, R)
                    }, _clearRenderFlow: function () {
                        i.remove(this, _)
                    }
                });
                var _ = [{stage: null, event: {target: "self", event: "change"}}, {
                    stage: x,
                    options: ["projection", "coordRendering"]
                }, {stage: s, options: ["projection", "geodesic"]}, {
                    stage: c.apply,
                    event: {target: "map", event: "actionend", callback: c.onActionEnd}
                }, {
                    stage: g.apply,
                    options: ["projection", "pixelRendering"],
                    event: {target: "map", event: "actionend", callback: g.onActionEnd}
                }];
                w.add("Rectangle", {
                    serialize: function (e) {
                        return {type: "Rectangle", coordinates: e.getCoordinates()}
                    }, deserialize: function (e) {
                        return new G(e.coordinates)
                    }, applyTo: function (e, t) {
                        e.setCoordinates(t.coordinates)
                    }
                }), e(G)
            });
        }],
        ['2i', function (ym) {
            ym.modules.define("geometry.MultiPolygon", ["util.defineClass", "geometry.MultiGeometry", "geometry.Polygon", "geometry.serializer", "geometry.pixel.MultiPolygon"], function (e, t, l, i, n, o) {
                var r = function (e, t, l) {
                    this._fillRule = t, r.superclass.constructor.call(this, l), this.setCoordinates(e)
                };
                t(r, l, {
                    getType: function () {
                        return "MultiPolygon"
                    }, getInnerType: function () {
                        return "Polygon"
                    }, createInnerType: function (e) {
                        return new i(e, this.getFillRule())
                    }, getFillRule: function () {
                        return this._fillRule
                    }, setCoordinates: function (e) {
                        if (this.clearChildren(), e) for (var t = 0; t < e.length; ++t) this.insert(t, this.createInnerType(e[t]))
                    }, equals: function (e) {
                        return this.getFillRule() == e.getFillRule() && o.superclass.equals.call(this, e)
                    }
                }), n.add("MultiPolygon", {
                    serialize: function (e) {
                        return {type: "MultiPolygon", coordinates: e.getCoordinates(), fillRule: e.getFillRule()}
                    }, deserialize: function (e) {
                        return new r(e.coordinates, e.fillRule)
                    }
                }), e(r)
            });
        }],
        ['2q', function (ym) {
            ym.modules.define("geometry.MultiLineString", ["util.defineClass", "geometry.MultiGeometry", "geometry.LineString", "geometry.serializer"], function (e, n, t, i, r) {
                var o = function (e, n) {
                    o.superclass.constructor.call(this, n), this.setCoordinates(e)
                };
                n(o, t, {
                    getType: function () {
                        return "MultiLineString"
                    }, getInnerType: function () {
                        return "LineString"
                    }, createInnerType: function (e) {
                        return new i(e)
                    }, setCoordinates: function (e) {
                        if (this.clearChildren(), e) for (var n = 0; n < e.length; ++n) this.insert(n, this.createInnerType(e[n]))
                    }
                }), r.add("MultiLineString", {
                    serialize: function (e) {
                        return {type: "MultiLineString", coordinates: e.getCoordinates()}
                    }, deserialize: function (e) {
                        return new o(e.coordinates)
                    }
                }), e(o)
            });
        }],
        ['2j', function (ym) {
            ym.modules.define("geometry.MultiPoint", ["util.defineClass", "geometry.MultiGeometry", "geometry.Point", "geometry.serializer"], function (e, t, n, i, r) {
                var o = function (e, t) {
                    o.superclass.constructor.call(this, t), this.setCoordinates(e)
                };
                t(o, n, {
                    getType: function () {
                        return "MultiPoint"
                    }, getInnerType: function () {
                        return "Point"
                    }, createInnerType: function (e) {
                        return new i(e)
                    }, setCoordinates: function (e) {
                        this.clearChildren();
                        for (var t = 0; t < e.length; ++t) this.insert(t, this.createInnerType(e[t]))
                    }
                }), r.add("MultiPoint", {
                    serialize: function (e) {
                        return {type: "MultiPoint", coordinates: e.getCoordinates()}
                    }, deserialize: function (e) {
                        return new o(e.coordinates)
                    }
                }), e(o)
            });
        }],
        ['2)', function (ym) {
            ym.modules.define("geometry.GeometryCollection", ["util.defineClass", "geometry.MultiGeometry", "geometry.serializer", "geometry.GeometryCollection.validTypes", "error"], function (e, t, o, r, i, n) {
                function s(e) {
                    return "function" == typeof e.getType ? e : r.deserialize(e)
                }

                var l = function (e, t) {
                    l.superclass.constructor.call(this, t), this.setCoordinates(e)
                };
                t(l, o, {
                    getType: function () {
                        return "GeometryCollection"
                    }, getCoordinates: function () {
                        return r.serialize(this).geometries
                    }, setCoordinates: function (e) {
                        this.clearChildren();
                        for (var t = 0; t < e.length; ++t) this.insert(t, s(e[t]))
                    }, insert: function (e, t) {
                        var o = t.getType();
                        o in i ? l.superclass.insert.call(this, e, t) : n.throwException("InputError", "GeometryCollection can not hold geometry of type " + o)
                    }
                }), r.add("GeometryCollection", {
                    serialize: function (e) {
                        var t = [];
                        return e.each(function (e) {
                            t.push(r.serialize(e))
                        }), {type: "GeometryCollection", geometries: t}
                    }, deserialize: function (e) {
                        return new l(e.geometries)
                    }
                }), e(l)
            });
        }],
        ['3m', function (ym) {
            ym.modules.define("geometryEditor.LineString", ["util.defineClass", "util.extend", "geometryEditor.Base", "geometryEditor.storage", "vow"], function (e, r, t, o, n, i) {
                var l = {model: null, view: null, controller: null}, u = function (e, r) {
                    u.superclass.constructor.call(this, e, r)
                };
                r(u, o, {
                    initialState: t({}, o.prototype.initialState, {drawingFrom: "end"}),
                    getModelClass: function () {
                        return null != l.model ? i.resolve(l.model) : ym.modules.require(["geometryEditor.model.RootLineString", "geometryEditor.view.Path", "geometryEditor.controller.LineString"]).spread(function (e) {
                            return l.model = e, e
                        }, this)
                    },
                    getViewClass: function (e) {
                        return null != l.view ? i.resolve(l.view) : ym.modules.require(["geometryEditor.view.Path"]).spread(function (e) {
                            return l.view = e, e
                        }, this)
                    },
                    getControllerClass: function () {
                        return null != l.controller ? i.resolve(l.controller) : ym.modules.require(["geometryEditor.controller.LineString"]).spread(function (e) {
                            return l.controller = e, e
                        }, this)
                    }
                }), n.add("LineString", u), e(u)
            });
        }],
        ['3p', function (ym) {
            ym.modules.define("geometryEditor.Point", ["util.defineClass", "geometryEditor.Base", "geometryEditor.storage", "vow"], function (e, t, o, r, l) {
                var n = {model: null, view: null, controller: null}, i = function (e, t) {
                    i.superclass.constructor.call(this, e, t)
                };
                t(i, o, {
                    _hasGeoObject: function () {
                        return this.options.get("geoObject")
                    }, _getModelClass: function () {
                        return this._hasGeoObject(), "geometryEditor.model.RootVertex"
                    }, _getViewClass: function () {
                        return this._hasGeoObject() ? "geometryEditor.view.Point" : "geometryEditor.view.Edge"
                    }, _getControllerClass: function () {
                        return this._hasGeoObject() ? "geometryEditor.controller.Point" : "geometryEditor.controller.MultiPoint"
                    }, getModelClass: function () {
                        return null != n.model, ym.modules.require([this._getModelClass(), this._getViewClass(), this._getControllerClass()]).spread(function (e) {
                            return n.model = e, e
                        }, this)
                    }, getViewClass: function (e) {
                        return null != n.view, ym.modules.require([this._getViewClass()]).spread(function (e) {
                            return n.view = e, e
                        }, this)
                    }, getControllerClass: function () {
                        return null != n.controller, ym.modules.require([this._getControllerClass()]).spread(function (e) {
                            return n.controller = e, e
                        }, this)
                    }
                }), r.add("Point", i), e(i)
            });
        }],
        ['3r', function (ym) {
            ym.modules.define("geometryEditor.Polygon", ["util.defineClass", "util.extend", "geometryEditor.Base", "geometryEditor.storage", "vow"], function (e, o, t, r, l, n) {
                var i = {model: null, view: null, controller: null}, u = function (e, o) {
                    u.superclass.constructor.call(this, e, o)
                };
                o(u, r, {
                    initialState: t({}, r.prototype.initialState, {drawingFrom: "end", drawingPath: 0}),
                    getModelClass: function () {
                        return null != i.model ? n.resolve(i.model) : ym.modules.require(["geometryEditor.model.RootPolygon", "geometryEditor.view.MultiPath", "geometryEditor.controller.Polygon"]).spread(function (e) {
                            return i.model = e, e
                        }, this)
                    },
                    getViewClass: function (e) {
                        return null != i.view ? n.resolve(i.view) : ym.modules.require(["geometryEditor.view.MultiPath"]).spread(function (e) {
                            return i.view = e, e
                        }, this)
                    },
                    getControllerClass: function () {
                        return null != i.controller ? n.resolve(i.controller) : ym.modules.require(["geometryEditor.controller.Polygon"]).spread(function (e) {
                            return i.controller = e, e
                        }, this)
                    }
                }), l.add("Polygon", u), e(u)
            });
        }],
        ['4H', function (ym) {
            ym.modules.define("GeoObject", ["util.defineClass", "geoObject.abstract.GeoObject", "event.globalize", "Event", "geoObject.metaOptions", "theme.islands.geoObject.meta.full"], function (e, t, s, n, a) {
                function c(e, t) {
                    c.superclass.constructor.call(this, e, t), this.events.addController(o), this.events.fire("create", new a({
                        type: "create",
                        target: this
                    }))
                }

                var o = n(c);
                t(c, s), e(c)
            });
        }],
        ['4v', function (ym) {
            ym.modules.define("geoObject.addon.balloon", ["GeoObject", "popup.addonBuilder", "geoObject.Balloon"], function (e, a, n, t) {
                e(n.build({
                    type: "balloon",
                    metaEventManager: a.getMetaEventManager(),
                    defaultManager: t,
                    lazyInit: !0,
                    initEvents: ["clickdefaultaction"]
                }))
            });
        }],
        ['4w', function (ym) {
            ym.modules.define("geoObject.addon.editor", ["GeoObject", "Event", "util.Associate", "util.extend", "util.defineProperty", "geometryEditor.storage", "geoObject.optionMapper", "util.EventPropagator", "option.Mapper", "geometryEditor.LineString", "geometryEditor.Point", "geometryEditor.Polygon", "geometryEditor.Circle", "geometryEditor.MultiGeometry"], function (e, t, r, n, o, i, a, d, g, s) {
                function u(e) {
                    if (!("editor" in e)) {
                        var t, r;
                        i(e, "editor", function () {
                            return r ? r : (t || (t = c(e)), t)
                        }, function (e) {
                            r = e
                        })
                    }
                }

                function c(e) {
                    var t, n = a.get(e.geometry.getType());
                    return n && (t = new n(e.geometry, {}), t.options.setParent(e.options), t.options.set("geoObject", e), e.getOverlay().then(function (e) {
                        y(t, e)
                    }), t.events.add("statechange", l, e), e.events.add("mapchange", v, e).add("overlaychange", f, e), new g(t.events, ["beforevertexadd", "vertexadd", "beforevertexdraw", "vertexdraw", "beforeedgedragstart", "edgedragstart", "beforeedgedrag", "edgedrag", "edgedragend", "beforevertexdragstart", "vertexdragstart", "beforevertexdrag", "vertexdrag", "vertexdragend"], e.events, function (e) {
                        return "editor" + e
                    }, {
                        callback: function (t, n, o) {
                            return new r({type: o, target: e}, t)
                        }, context: this
                    })), t
                }

                function l(e) {
                    this.events.fire("editorstatechange", {originalEvent: e})
                }

                function v() {
                    this.editor.state.get("editing") && this.editor.stopEditing(), this.editor.state.get("framing") && this.editor.stopFraming()
                }

                function f(e) {
                    y(this.editor, e.get("overlay"))
                }

                function y(e, t) {
                    e.options.set(t ? {pointOverlay: t, guideLinesOverlay: t} : {
                        pointOverlay: null,
                        guideLinesOverlay: null
                    })
                }

                var p = new n(function (e) {
                    return this.create(e), e.editor
                });
                o(p, {
                    create: function (e) {
                        e.geometry && u(e)
                    }
                }), d.setRule({name: "editor", rule: s.addOptionalPrefixForBalloonHint}).setRule({
                    name: "editor",
                    key: ["projection"],
                    rule: "plain"
                }), t.getMetaEventManager().add("create", function (e) {
                    p.create(e.get("target"))
                }), e(p)
            });
        }],
        ['4x', function (ym) {
            ym.modules.define("geoObject.addon.hint", ["GeoObject", "popup.addonBuilder", "geoObject.Hint"], function (e, t, n, a) {
                e(n.build({
                    type: "hint",
                    metaEventManager: t.getMetaEventManager(),
                    defaultManager: a,
                    lazyInit: !0,
                    initEvents: ["mouseenterdefaultaction"]
                }))
            });
        }],
        ['4y', function (ym) {
            ym.modules.define("geoObject.Balloon", ["util.defineClass", "component.sharedEntity.captor.Balloon", "Balloon", "event.Manager", "map.addon.balloon", "geoObject.balloonPositioner.storage", "geoObject.optionMapper", "option.Manager", "Monitor", "projection.idle", "util.component", "util.preset", "vow", "popup.managerStorage", "popup.component.checkEmptiness", "balloon.component.getBalloonMode", "geoObject.balloonPositioner.circle", "geoObject.balloonPositioner.point", "geoObject.balloonPositioner.polygon", "geoObject.balloonPositioner.lineString", "geoObject.balloonPositioner.rectangle", "geoObject.balloonPositioner.multi"], function (e, t, o, n, i, s, a, r, l, c, h, p, g, u, _, d, b) {
                function f(e) {
                    this._geoObject = e, this.events = new i({context: this}), this._panelModeMonitor = null, this._setupCaptor(), this._setupListeners()
                }

                function O(e) {
                    return {projection: h, panelMode: "panel" == b(e.getMap(), e.options.get("balloonPanelMaxMapArea"))}
                }

                var P = {visible: !1}, m = {autoPan: !1};
                t(f, p.createProxyMethods(function () {
                    return this._captor
                }, ["close", "isOpen", "getOverlay", "getOverlaySync", "autoPan", "getOwner", "getPosition", "getData", "getOptions"]), {
                    destroy: function () {
                        this._clearListeners(), this._clearCaptor()
                    }, isEmpty: function (e, t, o) {
                        var n = this.specifyData(t);
                        return n.options = new l(o || {}, this._geoObject.options, "balloon"), d(this._geoObject.getMap(), "balloon", this._specifyPosition(e, o && o.projection), n)
                    }, open: function (e, t, o) {
                        return this._captor.open(this._specifyPosition(e, o && o.projection), this.specifyData(t), o)
                    }, setPosition: function (e) {
                        return this._captor.setPosition(this._specifyPosition(e))
                    }, setData: function (e) {
                        return this._captor.setData(this.specifyData(e))
                    }, setOptions: function (e) {
                        return this._captor.setOptions(this._specifyOptions(e))
                    }, _setupCaptor: function () {
                        var e = this._geoObject.getMap(), t = e && s.get(e);
                        this._captor = new o(this, this._geoObject, "balloon", t), this._captor.events.add("open", this._onOpen, this).add("close", this._onClose, this)
                    }, _clearCaptor: function () {
                        this._captor.destroy(), this._captor = null
                    }, _setupListeners: function () {
                        this._geoObject.events.add("clickdefaultaction", this._onClickDefault, this).add("mapchange", this._onMapChange, this)
                    }, _clearListeners: function () {
                        this._geoObject.events.remove("clickdefaultaction", this._onClickDefault, this).remove("mapchange", this._onMapChange, this)
                    }, _onClickDefault: function (e) {
                        var t = this._geoObject, o = t.getMap();
                        if (o) {
                            var n = t.options, i = O(t), s = e.get("originalEvent"), a = s.get("globalPixels");
                            if (n.get("openBalloonOnClick", !0)) {
                                if (this.isOpen() && "Point" == t.geometry.getType()) return void this.close();
                                var r = o.action.getCurrentState().zoom;
                                f.shouldOpenOnClick(t, this, a, i).then(function (e) {
                                    if (e) {
                                        var t = o.action.getCurrentState().zoom, n = Math.pow(2, t - r);
                                        1 != n && (a = [a[0] * n, a[1] * n]), this.open(a, null, i)
                                    }
                                }, this)
                            }
                        }
                    }, _specifyPosition: function (e, t) {
                        var o = this._geoObject, n = o.geometry.getPixelGeometry(),
                            i = e ? (t || o.options.get("projection")).toGlobalPixels(e, o.getMap().getZoom()) : o.getMap().getGlobalPixelCenter();
                        if (ym.env.debug && !n) throw new Error("geoObject.Balloon._specifyPosition: У геообъекта отсутствует пиксельная геометрия.");
                        return this._anchorPixels = a.get(n.getType()).calculatePosition(n, i)
                    }, specifyData: function (e) {
                        var t = this._geoObject;
                        return {
                            geoObject: t,
                            properties: t.properties,
                            geometry: t.geometry,
                            state: t.state,
                            map: t.getMap(),
                            userData: e
                        }
                    }, _onOpen: function () {
                        this._enableAutoPan(), this.getOptions().get("autoPan") && this._captor.getPopup().autoPan();
                        var e = this._geoObject, t = this._captor.getPopup().getOverlaySync();
                        e.state.set("active", !0), e.events.add("beforedrag", this._onBeforeDrag, this).add("dragstart", this._disableAutoPan, this).add("dragend", this._enableAutoPan, this), e.geometry.events.add("pixelgeometrychange", this._onGeoObjectPixelGeometryChange, this), this._geoObjectMap = e.getMap(), this._geoObjectMap.events.add("boundschange", this._onMapBoundsChange, this), "Point" == e.geometry.getType() && e.options.get("hideIconOnBalloonOpen") && (this._panelModeMonitor = new c(t.options).add("panelMode", this._toggleIcon, this), t.options.get("panelMode") || this._toggleIcon())
                    }, _onClose: function () {
                        var e = this._geoObject;
                        "Point" == e.geometry.getType() && (this._showIcon(), this._panelModeMonitor && (this._panelModeMonitor.removeAll(), this._panelModeMonitor = null)), this._geoObjectMap && this._geoObjectMap.events.remove("boundschange", this._onMapBoundsChange, this), e.geometry.events.remove("pixelgeometrychange", this._onGeoObjectPixelGeometryChange, this), e.events.remove("dragend", this._enableAutoPan, this).remove("dragstart", this._disableAutoPan, this).remove("beforedrag", this._onBeforeDrag, this), e.state.set("active", !1)
                    }, _disableAutoPan: function () {
                        g.addTo(this.getOptions(), m)
                    }, _enableAutoPan: function () {
                        g.removeFrom(this.getOptions(), m)
                    }, _hideIcon: function () {
                        g.addTo(this._geoObject.options, P)
                    }, _showIcon: function () {
                        g.removeFrom(this._geoObject.options, P)
                    }, _onGeoObjectPixelGeometryChange: function (e) {
                        if (this.isOpen()) {
                            var t = this._geoObject.geometry.getPixelGeometry();
                            if (!t.getCoordinates().length) return void this.close();
                            this._disableAutoPan(), this._anchorPixels = a.get(t.getType()).calculatePosition(t, this._anchorPixels), this._captor.setPosition(this._anchorPixels), this._enableAutoPan()
                        }
                    }, _onBeforeDrag: function (e) {
                        var t = e.get("pixelOffset"), o = this._anchorPixels;
                        this._anchorPixels = [o[0] + t[0], o[1] + t[1]]
                    }, _onMapBoundsChange: function (e) {
                        var t = e.get("oldZoom"), o = e.get("newZoom");
                        if (t != o) {
                            var n = Math.pow(2, o - t), i = this._anchorPixels;
                            this._anchorPixels = [i[0] * n, i[1] * n]
                        }
                    }, _toggleIcon: function (e) {
                        e ? this._showIcon() : this._hideIcon()
                    }, _onMapChange: function () {
                        this._geoObject.getMap() ? this._setupSharingManager() : this.close()
                    }, _setupSharingManager: function () {
                        this._captor.setSharingManager(s.get(this._geoObject.getMap()))
                    }
                }), f.shouldOpenOnClick = function (e, t, o, n) {
                    return n = n || O(e), e.options.get("openBalloonOnClick", !0) ? e.options.get("openEmptyBalloon", !1) ? u.resolve(!0) : t ? t.isEmpty(o, null, n).then(function (e) {
                        return !e
                    }) : u.resolve(!1) : u.resolve(!1)
                }, _.add("geoObject#balloon", f), r.setRule({
                    name: "balloon",
                    rule: "prefixed"
                }).setRule({name: "balloon", key: ["projection"], rule: "plain"}), e(f)
            });
        }],
        ['4K', function (ym) {
            ym.modules.define("GeoObjectArray", [], function (e) {
                function o() {
                    throw new Error("Класс GeoObjectArray не поддерживается (соответствующая функциональность доступна в GeoObjectCollection)")
                }

                e(o)
            });
        }],
        ['4L', function (ym) {
            ym.modules.define("GeoObjectCollection", ["util.defineClass", "geoObject.abstract.Sequence", "event.globalize", "component.array.ParentArray", "event.Mapper", "geoObject.EventMappingTable", "Event"], function (e, t, n, o, i, c, l, s) {
                function r(e, t) {
                    r.superclass.constructor.call(this, e, t), this.events.addController(h), this.events.fire("create", new s({
                        type: "create",
                        target: this
                    }))
                }

                var h = o(r);
                t(r, n, {
                    set: function (e, t) {
                        return this._collectionComponent.set(e, t), this
                    }, add: function (e, t) {
                        return this._collectionComponent.add(e, t), this
                    }, remove: function (e) {
                        if (ym.env.debug && this._collectionComponent.indexOf(e) == -1) throw new Error("GeoObjectCollection.remove: удаляемый объект не найден");
                        return this._collectionComponent.remove(e), this
                    }, removeAll: function () {
                        return this._collectionComponent.removeAll(), this
                    }, splice: function (e, t) {
                        return new r({children: this._collectionComponent.splice.apply(this._collectionComponent, arguments)})
                    }, createCollectionComponent: function (e) {
                        return this._collectionComponent = new i(e, this, {
                            onAdd: {
                                callback: this._onAdd,
                                context: this
                            },
                            onRemove: {callback: this._onRemove, context: this},
                            onSet: {callback: this._onSet, context: this}
                        }, new c(this.events, new l(this)))
                    }, _onAdd: function (e, t) {
                        this.events.fire("add", new s({type: "add", target: this, index: e, child: t}))
                    }, _onRemove: function (e, t) {
                        this.events.fire("remove", new s({type: "remove", target: this, index: e, child: t}))
                    }, _onSet: function (e, t, n) {
                        this.events.fire("set", new s({type: "set", target: this, index: e, prevChild: t, child: n}))
                    }
                }), e(r)
            });
        }],
        ['4(', function (ym) {
            ym.modules.define("GeoQueryResult", ["util.extend", "util.List", "vow", "util.ArrayIterator", "Clusterer", "util.array", "util.bounds", "geoQueryResult.component.search", "geoQueryResult.component.contain", "geoQueryResult.component.distance", "geoQueryResult.component.intersect", "geoQueryResult.component.util", "geoQueryResult.component.geometryPicker", "GeoObject"], function (provide, extend, List, vow, ArrayIterator, Clusterer, utilArray, utilBounds, searchComponent, containComponent, distanceComponent, intersectComponent, utilComponent, geometryPicker, GeoObject) {
                var getFieldValue = utilComponent.getFieldValue,
                    notReadyError = "данные запроса еще обрабатываются. Вызовите метод в функции-обработчике метода then.",
                    GeoQueryResult = function (e, t) {
                        if (this._parent = t || null, this._objects = [], this._map = null, this._cachedBounds = null, this._lastPromise = vow.resolve(), this._resultReady = !0, e) {
                            var r = this._isPromise(e), o = this._isGeoQuery(e) && !e.isReady();
                            if (r || o) {
                                this._resultReady = !1;
                                var n = vow.defer();
                                e.then(function (t) {
                                    this._objects = this._getObjects(o ? e : t.geoObjects ? t.geoObjects : t), this._resultReady = !0, n.resolve()
                                }, function () {
                                    n.reject()
                                }, this), this._lastPromise = n.promise()
                            } else this._objects = this._getObjects(e)
                        }
                    };
                GeoQueryResult.prototype = {
                    getIterator: function () {
                        if (ym.env.debug && !this._resultReady) throw new Error("GeoQueryResult.getIterator: " + notReadyError);
                        return new ArrayIterator(this._objects)
                    }, getParent: function () {
                        return this._parent
                    }, add: function (e) {
                        return this._createNewResultWhenReady(function (t) {
                            var r = this._isPromise(e), o = this._isGeoQuery(e) && !e.isReady();
                            if (r || o) return t || (t = vow.defer()), e.then(function (r) {
                                var n = this._getObjects(o ? e : r.geoObjects ? r.geoObjects : r);
                                t.resolve([].concat(this._objects, n))
                            }, function () {
                                t.reject()
                            }, this), t.promise();
                            var n = this._getObjects(e);
                            return [].concat(this._objects, n)
                        }, this)
                    }, remove: function (e) {
                        return this._createNewResultWhenReady(function (t) {
                            var r = this._isPromise(e), o = this._isGeoQuery(e) && !e.isReady();
                            if (r || o) return t || (t = vow.defer()), e.then(function (r) {
                                var n = this._removeObjects(this._objects, o ? e : r.geoObjects ? r.geoObjects : r);
                                t.resolve(n)
                            }, function () {
                                t.reject()
                            }, this), t.promise();
                            var n = this._removeObjects(this._objects, e);
                            return t ? (t.resolve(n), t.promise()) : n
                        }, this)
                    }, getLength: function () {
                        if (ym.env.debug && !this._resultReady) throw new Error("GeoQueryResult.getLength: " + notReadyError);
                        return this._objects.length
                    }, then: function (e, t, r) {
                        return this._lastPromise.then(e, t, r), this
                    }, isReady: function () {
                        return this._resultReady
                    }, addToMap: function (e) {
                        return this._callMethod(function () {
                            for (var t = e.geoObjects, r = 0, o = this._objects.length; r < o; r++) this._objects[r].getMap() != e && t.add(this._objects[r])
                        }, arguments), this
                    }, removeFromMap: function (e) {
                        return this._callMethod(function () {
                            for (var t = e.geoObjects, r = 0, o = this._objects.length; r < o; r++) this._objects[r].getMap() == e && t.remove(this._objects[r])
                        }, arguments), this
                    }, addTo: function (e) {
                        return this._callMethod(function () {
                            for (var t = 0, r = this._objects.length; t < r; t++) e.add(this._objects[t])
                        }, arguments), this
                    }, removeFrom: function (e) {
                        return this._callMethod(function () {
                            for (var t = 0, r = this._objects.length; t < r; t++) e.remove(this._objects[t])
                        }, arguments), this
                    }, getBounds: function () {
                        if (ym.env.debug && !this._resultReady) throw new Error("GeoQueryResult.getBounds: " + notReadyError);
                        return this._cachedBounds || (this._cachedBounds = this._calculateBounds()), this._cachedBounds
                    }, getGlobalPixelBounds: function (e) {
                        if (ym.env.debug && !this._resultReady) throw new Error("GeoQueryResult.getGlobalPixelBounds: " + notReadyError);
                        return utilBounds.toGlobalPixelBounds(this.getBounds(), e.getZoom(), e.options.get("projection"))
                    }, getGlobalPixelCenter: function (e) {
                        if (ym.env.debug && !this._resultReady) throw new Error("GeoQueryResult.getGlobalPixelCenter: " + notReadyError);
                        var t = this.getGlobalPixelBounds(e);
                        return [(t[0][0] + t[1][0]) / 2, (t[0][1] + t[1][1]) / 2]
                    }, getCenter: function (e) {
                        if (ym.env.debug && !this._resultReady) throw new Error("GeoQueryResult.getCenter: " + notReadyError);
                        var t = this.getGlobalPixelCenter(e);
                        return e.options.get("projection").fromGlobalPixels(t, e.getZoom())
                    }, getMaxZoom: function (e, t) {
                        if (ym.env.debug && !this._resultReady) throw new Error("GeoQueryResult.getMaxZoom: " + notReadyError);
                        var r = {inscribe: !0, preciseZoom: !0};
                        t && t.hasOwnProperty("useMapMargin") && !t.useMapMargin || (r.margin = e.margin.getMargin());
                        var o = utilBounds.getCenterAndZoom(this.getBounds(), e.container.getSize(), e.options.get("projection"), r);
                        return o.zoom
                    }, applyBoundsToMap: function (e, t) {
                        t = extend({useMapMargin: !0}, t);
                        var r = vow.defer(), o = function () {
                            var o = this.getBounds();
                            o && (this._resultReady = !1, e.setBounds(o, t).then(function (e) {
                                this._resultReady = !0, e ? r.reject(e) : r.resolve()
                            }, this))
                        };
                        return this._resultReady ? o.call(this) : this.then(o, this), this._lastPromise = r.promise(), this
                    }, slice: function (e, t) {
                        return this._createNewResultWhenReady(function (r) {
                            var o = this._objects.slice(e, t);
                            return r ? (r.resolve(o), r.promise()) : o
                        }, this)
                    }, reverse: function () {
                        return this._createNewResultWhenReady(function (e) {
                            var t = this._objects.slice(0).reverse();
                            return e ? (e.resolve(t), e.promise()) : t
                        }, this)
                    }, intersect: function (e) {
                        if (e.isReady() && this.isReady()) return new GeoQueryResult(this._getIntersection(e), this);
                        var t = vow.defer();
                        return e.then(function () {
                            this.then(function () {
                                t.resolve({geoObjects: this._getIntersection(e)})
                            }, function () {
                                t.reject()
                            }, this)
                        }, function () {
                            t.reject()
                        }, this), new GeoQueryResult(t.promise(), this)
                    }, clusterize: function (e) {
                        var t = new Clusterer(e);
                        return this._callMethod(function () {
                            for (var e = [], r = 0, o = this._objects.length; r < o; r++) "Point" == this._objects[r].geometry.getType() && e.push(this._objects[r]);
                            t.add(e)
                        }), t
                    }, get: function (e) {
                        if (ym.env.debug && !this._resultReady) throw new Error("GeoQueryResult.get: " + notReadyError);
                        return this._objects[e]
                    }, indexOf: function (e) {
                        if (ym.env.debug && !this._resultReady) throw new Error("GeoQueryResult.indexOf: " + notReadyError);
                        return utilArray.indexOf(this._objects, e)
                    }, each: function (e, t) {
                        return this._callMethod(function () {
                            utilArray.each(this._objects, e, t)
                        }), this
                    }, map: function (e, t) {
                        return this._createNewResultWhenReady(function (r) {
                            var o = utilArray.map(this._objects, e, t);
                            return r ? (r.resolve(o), r.promise()) : o
                        }, this)
                    }, addEvents: function (e, t, r) {
                        return this._callMethod(function () {
                            for (var o = 0, n = this._objects.length; o < n; o++) this._objects[o].events.add(e, t, r)
                        }), this
                    }, removeEvents: function (e, t, r) {
                        return this._callMethod(function () {
                            for (var o = 0, n = this._objects.length; o < n; o++) this._objects[o].events.remove(e, t, r)
                        }), this
                    }, setProperties: function (e, t) {
                        return this._callMethod(function () {
                            for (var r = 0, o = this._objects.length; r < o; r++) this._objects[r].properties.set(e, t)
                        }), this
                    }, unsetProperties: function (e) {
                        return this._callMethod(function () {
                            for (var t = 0, r = this._objects.length; t < r; t++) this._objects[t].properties.unset(e)
                        }), this
                    }, setOptions: function (e, t) {
                        return this._callMethod(function () {
                            for (var r = 0, o = this._objects.length; r < o; r++) this._objects[r].options.set(e, t)
                        }), this
                    }, unsetOptions: function (e) {
                        return this._callMethod(function () {
                            for (var t = 0, r = this._objects.length; t < r; t++) this._objects[t].options.unset(e)
                        }), this
                    }, getCentralObject: function (e) {
                        if (ym.env.debug && !this._resultReady) throw new Error("GeoQueryResult.getCentralObject: " + notReadyError);
                        return distanceComponent.getCentralObject(this, e)
                    }, getExtreme: function (e) {
                        if (ym.env.debug && !this._resultReady) throw new Error("GeoQueryResult.getExtreme: " + notReadyError);
                        return distanceComponent.getExtreme(this, e)
                    }, getExtremeObject: function (e) {
                        if (ym.env.debug && !this._resultReady) throw new Error("GeoQueryResult.getExtremeObject: " + notReadyError);
                        return distanceComponent.getExtremeObject(this, e)
                    }, getClosestTo: function (e) {
                        if (ym.env.debug && !this._resultReady) throw new Error("GeoQueryResult.getClosestTo: " + notReadyError);
                        return distanceComponent.getClosestTo(this, e)
                    }, search: function (e) {
                        return this._createNewResultWhenReady(function (t) {
                            var r = searchComponent(this, e);
                            return t ? (t.resolve(r), t.promise()) : r
                        }, this)
                    }, searchInside: function (e) {
                        var t = geometryPicker(e);
                        return this._createNewResultWhenReady(function (e) {
                            var r = searchComponent(this, function (e) {
                                return t != e.geometry && containComponent(t, e.geometry)
                            });
                            return e ? (e.resolve(r), e.promise()) : r
                        }, this)
                    }, searchContaining: function (e) {
                        var t = geometryPicker(e);
                        return this._createNewResultWhenReady(function (e) {
                            var r = searchComponent(this, function (e) {
                                return t != e.geometry && containComponent(e.geometry, t)
                            });
                            return e ? (e.resolve(r), e.promise()) : r
                        }, this)
                    }, searchIntersect: function (e, t) {
                        t = extend({considerOccurance: !0}, t);
                        var r = geometryPicker(e);
                        return this._createNewResultWhenReady(function (e) {
                            var o = searchComponent(this, function (e) {
                                return r != e.geometry && intersectComponent(e.geometry, r, t)
                            });
                            return e ? (e.resolve(o), e.promise()) : o
                        }, this)
                    }, sort: function (e) {
                        var t;
                        if ("string" == typeof e) {
                            var r = e.split(" "), o = r[0], n = r[1] ? r[1] : "asc";
                            t = function (e, t) {
                                return "asc" == n ? getFieldValue(e, o) < getFieldValue(t, o) ? -1 : 1 : getFieldValue(t, o) < getFieldValue(e, o) ? -1 : 1
                            }
                        } else t = e;
                        return this._createNewResultWhenReady(function (e) {
                            var r = this._objects.concat(), o = r.sort(t);
                            return e ? (e.resolve(o), e.promise()) : o
                        }, this)
                    }, sortByDistance: function (e) {
                        var t = geometryPicker(e), r = function (e, r) {
                            return distanceComponent.getDistance(e.geometry, t) - distanceComponent.getDistance(r.geometry, t)
                        };
                        return this._createNewResultWhenReady(function (e) {
                            var t = this._objects.concat(), o = t.sort(r);
                            return e ? (e.resolve(o), e.promise()) : o
                        }, this)
                    }, _callMethod: function (e, t) {
                        var r = vow.defer();
                        this._resultReady ? (e.apply(this, t || []), r.resolve()) : (this.then(function () {
                            e.apply(this, t || []), r.resolve()
                        }, function () {
                            r.reject()
                        }, this), this._lastPromise = r.promise())
                    }, _createNewResultWhenReady: function (e, t) {
                        if (this._resultReady) return new GeoQueryResult(e.call(t), this);
                        var r = vow.defer();
                        return this.then(function () {
                            r.resolve(e.call(t))
                        }, function () {
                            r.reject()
                        }, this), new GeoQueryResult(r.promise(), this)
                    }, _calculateBounds: function () {
                        if (this._objects.length) {
                            for (var e = this._objects[0].getMap(), t = e ? e.options.get("projection") : null, r = [], o = 0, n = this._objects.length; o < n; o++) {
                                var s = this._objects[o].geometry.getBounds();
                                r.push(s[0], s[1])
                            }
                            return 0 == r.length ? null : utilBounds.fromPoints(r, t)
                        }
                        return null
                    }, _getObjects: function (e) {
                        var t = [];
                        if (this._isGeoQuery(e)) for (var r, o = e.getIterator(); (r = o.getNext()) != o.STOP_ITERATION;) t.push(r); else if (this._isJson(e)) t = this._createObjectsFromJson(e); else for (var n = [].concat(e), s = 0, i = n.length; s < i; s++) {
                            var u = n[s];
                            if (this._isJsonGeometry(u) && t.push(new GeoObject({geometry: u})), this._isGeoObject(u) && t.push(u), this._isCollection(u)) for (var r, o = u.getIterator(); (r = o.getNext()) != o.STOP_ITERATION;) r && (t = t.concat(this._getObjects(r)))
                        }
                        return t
                    }, _removeObjects: function (e, t) {
                        var r = [];
                        if (this._isGeoQuery(t)) for (var o, n = t.getIterator(); (o = n.getNext()) != n.STOP_ITERATION;) r.push(o); else r = [].concat(t);
                        return r.length ? (this._cachedBounds = null, "number" == typeof r[0] ? this._removeByIndexes(e, r) : this._removeByValues(e, r)) : this._objects
                    }, _removeByIndexes: function (e, t) {
                        t.sort();
                        for (var r = 0, o = 0, n = []; r < e.length;) r < t[o] || o == t.length ? (n.push(e[r]), r++) : r > t[o] ? o++ : (r++, o++);
                        return n
                    }, _removeByValues: function (e, t) {
                        for (var r = [], o = 0, n = e.length; o < n; o++) {
                            for (var s = !0, i = 0, u = t.length; i < u && s; i++) t[i] == e[o] && (s = !1);
                            s && r.push(e[o])
                        }
                        return r
                    }, _getIntersection: function (e) {
                        for (var t = e.getIterator(), r = [], o = []; (r = t.getNext()) != t.STOP_ITERATION;) o.push(r);
                        for (var e = [], n = 0, s = this._objects.length; n < s; n++) for (var i = !0, u = 0, c = o.length; u < c && i; u++) o[u] == this._objects[n] && (e.push(this._objects[n]), i = !1);
                        return e
                    }, _createObjectsFromJson: function (json) {
                        return "string" == typeof json && (json = !/[^,:{}\[\]0-9.\-+Eaeflnr-u \n\r\t]/.test(json.replace(/"(\\.|[^"\\])*"/g, "")) && eval("(" + json + ")")), json ? "Feature" == json.type ? [this._createObjectFromJsonFeature(json)] : this._createObjectsFromJsonFeatureCollection(json) : []
                    }, _createObjectsFromJsonFeatureCollection: function (e) {
                        for (var t = [], r = 0, o = e.features.length; r < o; r++) "Feature" == e.features[r].type ? t.push(this._createObjectFromJsonFeature(e.features[r])) : t = t.concat(this._createObjectsFromJsonFeatureCollection(e.features[r]));
                        return t
                    }, _createObjectFromJsonFeature: function (e) {
                        return new GeoObject({geometry: e.geometry, properties: e.properties}, e.options)
                    }, _isJsonGeometry: function (e) {
                        return !(!e.type || !e.coordinates)
                    }, _isGeoObject: function (e) {
                        return !!e.geometry
                    }, _isCollection: function (e) {
                        return !!e.getIterator
                    }, _isPromise: function (e) {
                        return !!e.then && !e.getIterator
                    }, _isGeoQuery: function (e) {
                        return !!e.then && !!e.getIterator
                    }, _isJson: function (e) {
                        return "string" == typeof e || "Feature" == e.type || "FeatureCollection" == e.type
                    }
                }, provide(GeoQueryResult)
            });
        }],
        ['4:', function (ym) {
            ym.modules.define("geoXml.load", ["geoXml.getJson", "geoXml.util", "vow", "yandex.counter"], function (e, o, t, s, n) {
                function a(e) {
                    n.countByKey("modulesUsage", "geoXml.load"), e = t.resolveUrl(e, window.location.href);
                    var a = s.defer();
                    return o(e).then(function (o) {
                        var t;
                        o.ymaps ? t = ["geoXml.parser.ymapsml.geoObjects", "geoXml.parser.ymapsml.MapState"] : o.gpx ? t = ["geoXml.parser.gpx.geoObjects"] : o.kml && (t = ["geoXml.parser.kml.geoObjects"]), ym.modules.require(t, function (t, s) {
                            var n, l, m;
                            if (o.ymaps) n = t(o.ymaps, e), o.ymaps.Representation && o.ymaps.Representation.View && (l = new s(o.ymaps.Representation.View)); else if (o.gpx) n = t(o.gpx); else if (o.kml) {
                                var r = t(o.kml, e);
                                n = r.collection, m = r.wait, m && m.then(function () {
                                    a.resolve({geoObjects: n})
                                })
                            }
                            m || a.resolve({geoObjects: n, mapState: l})
                        })
                    }, function (e) {
                        a.reject(e)
                    }), a.promise()
                }

                e(a)
            });
        }],
        ['4Q', function (ym) {
            ym.modules.define("getZoomRange", ["LayerCollection", "layer.storage", "mapType.storage"], function (e, o, n, t) {
                function r(e, r, a) {
                    if (ym.env.debug) {
                        if ("undefined" == typeof e) throw new Error("getZoomRange: не передан параметр mapType");
                        if ("undefined" == typeof r) throw new Error("getZoomRange: не указана точка для определения диапазона масштабирования ll")
                    }
                    for (var g = t.get(e).getLayers(), i = new o, f = 0, d = g.length; f < d; f++) {
                        var l = n.get(g[f]);
                        i.add(new l)
                    }
                    a && i.options.setParent(a.options);
                    var m = i.getZoomRange(r);
                    return i.options.setParent(null), m
                }

                e(r)
            });
        }],
        ['5i', function (ym) {
            ym.modules.define("Hint", ["util.defineClass", "Popup", "util.dom.style", "util.dom.viewport", "vow", "hint.metaOptions"], function (t, e, s, i, o, n) {
                function r(t, e) {
                    r.superclass.constructor.call(this, t, e), this.options.setName("hint"), this._setupHoverListeners()
                }

                r.UnderCursorError = function () {
                    return new Error("Hint is under cursor and 'holdByMouse' option is activated")
                }, e(r, s, {
                    open: function (t, e) {
                        var s = this.isOpen(), i = r.superclass.open.call(this, t, e);
                        return s || i.then(function () {
                            if (this.isOpen()) return this.setPosition(this.getPosition())
                        }, this).done(null, function () {
                        }, this), i
                    }, setPosition: function (t) {
                        return r.superclass.setPosition.call(this, this.isOpen() ? this._fitPane(t) : t)
                    }, doClose: function (t) {
                        return !t && this._mouseOver && this.options.get("holdByMouse", !0) ? (this.getOverlaySync().events.once("mouseleave", this.close, this), n.reject(r.UnderCursorError())) : r.superclass.doClose.call(this)
                    }, _setupHoverListeners: function () {
                        this._mouseOver = !1, this.events.add(["mouseenter", "mouseleave"], function (t) {
                            this._mouseOver = "mouseenter" == t.get("type")
                        }, this)
                    }, _fitPane: function (t) {
                        var e = this.getPosition(), s = t || e;
                        if (ym.env.debug && !s) throw new Error("Hint._fitPane: Не задана позиция.");
                        if (!this.options.get("fitPane", !0)) return s;
                        var n = this.getOverlaySync(), r = n.getLayoutSync();
                        if (!r || !r.getShape()) return s;
                        var u, a, l, h = this.options.get("projection"),
                            c = h.toGlobalPixels(s, this.getMap().getZoom()), p = r.getShape().getBounds(),
                            f = [p[1][0] - p[0][0], p[1][1] - p[0][1]], g = i.getOffset(n.getElement());
                        if (t) {
                            var v = h.toGlobalPixels(e, this.getMap().getZoom());
                            g = [g[0] + (c[0] - v[0]), g[1] + (c[1] - v[1])]
                        }
                        if ("visible" == this.getMap().panes.get(this.options.get("pane", "outerHint")).getOverflow()) {
                            var d = n.getMap().container.getOffset(), m = o.getSize(), O = o.getScrollOffsets();
                            u = [O, [m[0] + O[0], m[1] + O[1]]], g = [g[0] + d[0], g[1] + d[1]]
                        } else u = [[0, 0], n.getMap().container.getSize()];
                        return g[0] < u[0][0] ? c[0] -= g[0] - u[0][0] : (a = u[1][0] - (g[0] + f[0]), a < 0 && (c[0] += a)), g[1] < u[0][1] ? c[1] -= g[1] - u[0][1] : (l = u[1][1] - (g[1] + f[1]), l < 1 && (c[1] += l)), h.fromGlobalPixels(c, this.getMap().getZoom())
                    }
                }), t(r)
            });
        }],
        ['5Z', function (ym) {
            ym.modules.define("Hotspot", ["util.defineClass", "event.Manager"], function (e, n, t) {
                function s(e, n, s) {
                    s = s || {}, this._shape = e, this._zIndex = n || 0, this._id = null, this._eventsReplayEnabled = "undefined" == typeof s.eventsReplayEnabled || s.eventsReplayEnabled, this.events = new t({context: this})
                }

                n(s, {
                    setShape: function (e) {
                        this._shape = e, this.events.fire("shapechange")
                    }, getShape: function () {
                        return this._shape
                    }, setZIndex: function (e) {
                        this._zIndex = e || 0
                    }, getZIndex: function () {
                        return this._zIndex
                    }, destroy: function () {
                        this._shape = null
                    }, setId: function (e) {
                        this._id = e
                    }, getId: function () {
                        return this._id || null
                    }, isEventsReplayEnabled: function () {
                        return this._eventsReplayEnabled
                    }
                }), e(s)
            });
        }],
        ['6o', function (ym) {
            ym.modules.define("hotspot.Manager", ["util.defineClass", "event.Manager", "MapEvent", "constants.hotspotEvents", "hotspot.Container", "hotspot.manager.ContainerList", "hotspot.manager.EventController", "util.id", "util.math.areEqual", "util.WeakMap"], function (t, e, n, i, s, o, a, r, h, c, v) {
                function _(t) {
                    if (this.events = new n({context: this}), this._lastEvents = {}, this._activeObject = null, this._containersByZIndex = {}, "undefined" == typeof t) throw new Error("hotspot.Manager: Не удалось получить пейн.");
                    this._pane = t, this._map = t.getMap(), this._mapListener = this._map.events.group().add("boundschange", this._onMapBoundsChange, this), this._containerList = new a(this, t), this._containerList.events.add("found", this._onObjectsFound, this), this._paneController = new r(t, this), t.events.addController(this._paneController), d.set(t, this)
                }

                function l(t, e) {
                    return {position: t.get("globalPixels"), zoom: e, type: t.get("type")}
                }

                function p(t) {
                    for (var e = 0, n = m.length; e < n; e++) t.originalEvent[m[e]] = t.get(m[e])
                }

                var d = new v, m = ["pagePixels", "clientPixels", "globalPixels", "coords"];
                _.get = function (t) {
                    return d.get(t)
                }, e(_, {
                    destroy: function () {
                        this._pane && (this._pane.events.removeController(this._paneController), this._paneController = null, this._containerList.events.remove("found", this._onObjectsFound, this), this._containerList.clear(), this._containerList = null, this._mapListener.removeAll(), d.remove(this._pane), this._pane = this._map = this._activeObject = null, this._lastEvents = {}, this._containersByZIndex = {})
                    }, getContainerList: function () {
                        return this._containerList
                    }, addHotspots: function (t, e) {
                        this.getContainerList() && (this._containersByZIndex[e] || this._insertContainerByZIndex(e), this._containersByZIndex[e].add(t))
                    }, removeHotspots: function (t, e) {
                        this._containersByZIndex[e] && this._containersByZIndex[e].remove(t)
                    }, focus: function (t, e) {
                        var n = this._getActiveObjectByEvent(e);
                        if (n) {
                            var i = this._activeObject;
                            this._activeObject = n, this._enterObject(i, e)
                        } else e && e.allowMapEvent()
                    }, process: function (t, e) {
                        var n = this._getActiveObjectByEvent(e);
                        n ? this._removeLastEvent(t) : (this._addLastEvent(t, e), e.allowMapEvent()), this._processEvent(t, e, n)
                    }, blur: function (t, e) {
                        this._activeObject ? (this._leaveObject(null, e), this._activeObject = null) : e && e.allowMapEvent(), ym.env.browser.isMobile || this._clearLastEvents()
                    }, getActiveHotspot: function () {
                        return this._activeObject
                    }, _onMapBoundsChange: function (t) {
                        t.get("oldZoom") != t.get("newZoom") && this._clearLastEvents()
                    }, _getActiveObjectByEvent: function (t) {
                        return this._containerList.getObjectInPosition(t.get("globalPixels"), this._map.getZoom())
                    }, _processEvent: function (t, e, n) {
                        if (this._activeObject != n) {
                            this._activeObject ? this._leaveObject(n, e) : this._leaveMap(n, e);
                            var s = this._activeObject;
                            this._activeObject = n, this._activeObject ? this._enterObject(s, e) : this._enterMap(s, e)
                        }
                        this._activeObject && this._activeObject.events.fire(t, new i({
                            type: t,
                            map: this._map,
                            target: this._activeObject,
                            origin: "hotspots",
                            originalEvent: e
                        }, e))
                    }, _insertContainerByZIndex: function (t) {
                        var e = new o;
                        e.events.once("empty", function () {
                            this.getContainerList() && (this.getContainerList().remove(e), this._containersByZIndex[t] = null)
                        }, this), this.getContainerList().insert(e, t), this._containersByZIndex[t] = e
                    }, _onObjectsFound: function (t) {
                        for (var e = t.get("found"), n = [], o = s.order, a = 0, r = o.length; a < r; a++) {
                            var h = o[a], c = this._lastEvents[h], v = e[h] && e[h].activeObject;
                            c && e[h] && v.isEventsReplayEnabled() && (this._processEvent(h, new i({
                                type: h,
                                target: v,
                                map: this._map,
                                origin: "hotspots"
                            }, c.event), v), n.push(l(c.event, c.zoom)), delete this._lastEvents[h])
                        }
                        this.events.fire("positionchange", {added: [], removed: n})
                    }, _addLastEvent: function (t, e) {
                        "mousemove" != t || ym.env.browser.isMobile || this._clearLastEvents();
                        var n = this._lastEvents[t];
                        p(e), this._lastEvents[t] = {
                            event: e,
                            zoom: this._map.getZoom()
                        }, this.events.fire("positionchange", {
                            pane: this._pane,
                            added: [l(e, this._map.getZoom())],
                            removed: n ? [l(n.event, n.zoom)] : []
                        })
                    }, _removeLastEvent: function (t) {
                        var e = this._lastEvents[t];
                        e && (delete this._lastEvents[t], this.events.fire("positionchange", {
                            pane: this._pane,
                            added: [],
                            removed: [l(e.event, e.zoom)]
                        }))
                    }, _clearLastEvents: function () {
                        for (var t, e, n = [], i = 0, o = s.order.length; i < o; i++) t = s.order[i], e = this._lastEvents[t], e && n.push(l(e.event, e.zoom));
                        this._lastEvents = {}, this.events.fire("positionchange", {
                            pane: this._pane,
                            added: [],
                            removed: n
                        })
                    }, _leaveMap: function (t, e) {
                        this._map.events.fire("mouseleave", new i({
                            type: "mouseleave",
                            target: this._map,
                            map: this._map,
                            relatedTarget: t,
                            origin: "hotspots"
                        }, e))
                    }, _enterObject: function (t, e) {
                        this._activeObject.events.fire("mouseenter", new i({
                            type: "mouseenter",
                            target: this._activeObject,
                            map: this._map,
                            relatedTarget: t || this._map,
                            origin: "hotspots"
                        }, e))
                    }, _leaveObject: function (t, e) {
                        this._activeObject.events.fire("mouseleave", new i({
                            type: "mouseleave",
                            target: this._activeObject,
                            map: this._map,
                            relatedTarget: t || this._map,
                            origin: "hotspots"
                        }, e))
                    }, _enterMap: function (t, e) {
                        this._map.events.fire("mouseenter", new i({
                            type: "mouseenter",
                            target: this._map,
                            map: this._map,
                            relatedTarget: t,
                            origin: "hotspots"
                        }, e))
                    }
                }), t(_)
            });
        }],
        ['5Q', function (ym) {
            ym.modules.define("hotspot.Container", ["util.defineClass", "hotspot.container.Internal", "event.Manager", "hotspot.counter", "util.id"], function (t, n, e, i, r, s) {
                function o(t) {
                    this._internalContainers = {}, this._internalContainerListeners = {}, this._internalContainerCounter = 0, this._baseSize = t || 256, this.events = new i({context: this}), this._hotspotsHash = {}, this._hotspotListeners = {}, this._adding = !1
                }

                n(o, {
                    add: function (t) {
                        this._adding = !0;
                        for (var n = {}, e = 0, i = t.length; e < i; e++) {
                            var o = t[e];
                            r.setNumber(o), this._hotspotListeners[s.get(o)] = o.events.group().add("shapechange", this._onHotspotShapeChange, this);
                            var a = this._getContainerType(o);
                            this._hotspotsHash[s.get(o)] = a, n[a] || (n[a] = []), n[a].push(o)
                        }
                        for (var e in n) n.hasOwnProperty(e) && this._addHotspotsToContainer(n[e], e);
                        this._adding = !1
                    }, remove: function (t) {
                        for (var n = {}, e = 0, i = t.length; e < i; e++) {
                            var r = t[e], o = this._getContainerType(r);
                            this._hotspotListeners[s.get(r)].removeAll(), n[o] ? n[o].push(r) : n[o] = [r], delete this._hotspotListeners[s.get(r)]
                        }
                        for (var e in n) n.hasOwnProperty(e) && this._internalContainers[e].remove(n[e])
                    }, clear: function () {
                        for (var t in this._internalContainers) this._internalContainers.hasOwnProperty(t) && (this._internalContainers[t].forEach(function (t) {
                            this._hotspotListeners[s.get(t)].removeAll()
                        }, this), this._internalContainers[t] && this._internalContainers[t].clear());
                        this._hotspotsHash = {};
                        for (var t in this._internalContainers) this._internalContainers.hasOwnProperty(t) && this._removeInternalContainer(t);
                        this._hotspotListeners = {}
                    }, setParent: function () {
                    }, getObjectInPosition: function (t, n, e) {
                        var i = null, s = e || -(1 / 0);
                        for (var o in this._internalContainers) if (this._internalContainers.hasOwnProperty(o)) {
                            var a = this._internalContainers[o].getObjectInPosition(t, n);
                            if (a) {
                                var h = a.getZIndex() || 0;
                                h > s ? (i = a, s = h) : h == s && r.getNumber(a) > r.getNumber(i) && (i = a)
                            }
                        }
                        return i
                    }, getObjectsInPosition: function (t, n, e) {
                        var i = [];
                        for (var s in this._internalContainers) if (this._internalContainers.hasOwnProperty(s)) {
                            var o = this._internalContainers[s].getObjectsInPosition(t, n, e);
                            o.length && (i = i.concat(o))
                        }
                        return i.sort(function (t, n) {
                            var e = n.getZIndex() - t.getZIndex();
                            return e || r.getNumber(n) - r.getNumber(t)
                        })
                    }, forEach: function (t, n) {
                        for (var e in this._internalContainers) this._internalContainers.hasOwnProperty(e) && this._internalContainers[e].forEach(t, n)
                    }, _addHotspotsToContainer: function (t, n) {
                        if (!this._internalContainers[n]) {
                            var i = new e;
                            this._internalContainers[n] = i, this._internalContainerListeners[n] = i.events.group().add("empty", function () {
                                this._removeInternalContainer(n)
                            }, this), this._internalContainerCounter++
                        }
                        this._internalContainers[n].add(t)
                    }, _removeInternalContainer: function (t) {
                        delete this._internalContainers[t], this._internalContainerListeners[t].removeAll(), delete this._internalContainerListeners[t], this._internalContainerCounter--, 0 == this._internalContainerCounter && this.events.fire("empty")
                    }, _onHotspotShapeChange: function (t) {
                        if (!this._adding) {
                            var n = t.get("target"), e = this._getContainerType(n), i = this._hotspotsHash[s.get(n)];
                            i != e ? (this._addHotspotsToContainer([n], e), this._internalContainers[i].remove([n]), this._hotspotsHash[s.get(n)] = e) : this._internalContainers[i].setUnordered(n)
                        }
                    }, _getContainerType: function (t) {
                        return 0
                    }
                }), t(o)
            });
        }],
        ['6f', function (ym) {
            ym.modules.define("hotspot.Layer", ["util.defineClass", "event.globalize", "collection.Item", "Monitor", "constants.mapDomEvents", "hotspot.layer.Container", "hotspot.Container", "hotspot.Manager", "hotspot.layer.optionMapper", "layer.optionMapper", "util.id", "Event", "vow", "util.math.areEqual", "theme.islands.hotspot.meta.full"], function (t, e, o, i, n, s, a, r, h, l, c, u, _, p, d) {
                function m(t, e) {
                    return e + t.slice(0, 1).toUpperCase() + t.slice(1)
                }

                for (var g = {}, y = 0, b = s.length; y < b; y++) g[s[y]] = !0;
                var f, v = function (t, e) {
                    v.superclass.constructor.call(this, e), this.events.addController(f), this.options.setName("hotspotLayer"), this.options.setMapper(l), this._objectSource = t, this._objectSourceListener = this._objectSource.events.group().add("update", this.update, this), this._container = new a(this), this._temporaryContainer = null, this._temporaryContainerState = null, this._temporaryObjectsByHotspotId = {}, this._temporaryContainerTileStatus = null, this._containerListener = this._container.events.group(), this._activeTileStatus = null, this._mapListener = null, this.events.fire("create"), this._cursorSet = null, this._controller = {
                        onBeforeEventFiring: this._onBeforeObjectEventFiring.bind(this),
                        onAfterEventFiring: this._onAfterObjectEventFiring.bind(this)
                    }, this._objects = [], this._layerObjectsByHotspotId = {}, this._optionMonitor = null, this._mapActionCounter = 0, this._lastDataRequest = null, this._lastObjectsRequest = null, this._lastObjectsLoadCallback = null
                };
                f = o(v), v.OutdatedTile = function () {
                    return new Error("hotspot.Layer: requested tile data is outdated.")
                }, e(v, i, {
                    getObjectSource: function () {
                        return this._objectSource
                    }, update: function () {
                        this._cancelLastRequest(), this._lastObjectsRequest = null, this._lastObjectsLoadCallback = null, this._layerObjectsByHotspotId = {}, this.events.fire("update")
                    }, getObjectInPosition: function (t) {
                        return this._getInPosition(t, {
                            layer: this._getObjectFromLayerContainerSync.bind(this),
                            temporary: this._getObjectFromTemporaryContainerSync.bind(this)
                        })
                    }, getObjectsInPosition: function (t) {
                        return this._getInPosition(t, {
                            layer: this._getObjectsFromLayerContainerSync.bind(this),
                            temporary: this._getObjectsFromTemporaryContainerSync.bind(this)
                        })
                    }, _getInPosition: function (t, e) {
                        var o = this.getMap();
                        if (!o) return null;
                        var i = this._roundZoom(o.getZoom()), n = this._getTile(t),
                            s = this._container.getActiveTileAndZoom();
                        return s.tile && d(n, s.tile) && s.zoom == i ? this._getFromLayerContainer(t, n, i, e.layer) : this._getFromTemporaryContainer(t, n, i, e.temporary)
                    }, _getFromLayerContainer: function (t, e, o, i) {
                        var n = p.defer();
                        if ("ready" == this._activeTileStatus) n.resolve(i(t).data); else {
                            var s = i(t);
                            s.empty ? this._container.events.once("dataload", function (o) {
                                d(o.get("tile"), e) ? n.resolve(i(t).data) : n.reject(new v.OutdatedTile)
                            }, this) : n.resolve(s.data)
                        }
                        return n.promise()
                    }, _getFromTemporaryContainer: function (t, e, o, i) {
                        var n = p.defer(), s = this._temporaryContainerState, a = s && d(s.tile, e) && s.zoom == o;
                        return this._temporaryContainer && a && "ready" == this._temporaryContainerTileStatus ? n.resolve(i(t).data) : (this._temporaryContainer ? a || (this._temporaryObjectsByHotspotId = {}, this._temporaryContainer.clear()) : this._temporaryContainer = new r, this._temporaryContainerState = {
                            tile: e,
                            zoom: o
                        }, this._temporaryContainerTileStatus = "loading", this._requestObjects(e, o, !1, !0).then(function (s) {
                            var a = this._temporaryContainerState;
                            if (d(e, a.tile) && o == a.zoom) {
                                if ("loading" == this._temporaryContainerTileStatus) {
                                    for (var r, h = [], l = 0, c = s.length; l < c; l++) r = s[l].getHotspot(), this._temporaryObjectsByHotspotId[u.get(r)] = s[l], h.push(r);
                                    this._temporaryContainer.add(h), this._temporaryContainerTileStatus = "ready"
                                }
                                n.resolve(i(t).data)
                            } else n.reject(new v.OutdatedTile)
                        }, function () {
                            this._temporaryContainerTileStatus = "ready"
                        }, this)), n.promise()
                    }, _getObjectFromLayerContainerSync: function (t) {
                        var e = this.getMap(), o = this._roundZoom(e.getZoom()),
                            i = this._container.getObjectInPosition(e.options.get("projection").toGlobalPixels(t, o), o);
                        return {empty: !i, data: i ? this._layerObjectsByHotspotId[u.get(i)] : null}
                    }, _getObjectFromTemporaryContainerSync: function (t) {
                        var e = this.getMap(), o = this._roundZoom(e.getZoom()),
                            i = this._temporaryContainer.getObjectInPosition(this.options.get("projection").toGlobalPixels(t, o), o);
                        return {empty: !i, data: i ? this._temporaryObjectsByHotspotId[u.get(i)] : null}
                    }, _getObjectsFromLayerContainerSync: function (t) {
                        var e = this.getMap(), o = this._roundZoom(e.getZoom()),
                            i = this._container.getObjectsInPosition(e.options.get("projection").toGlobalPixels(t, o), o);
                        return {
                            empty: 0 == i.length, data: i.map(function (t) {
                                return this._layerObjectsByHotspotId[u.get(t)]
                            }, this)
                        }
                    }, _getObjectsFromTemporaryContainerSync: function (t) {
                        var e = this.getMap(), o = this._roundZoom(e.getZoom()),
                            i = this._temporaryContainer.getObjectsInPosition(this.options.get("projection").toGlobalPixels(t, o), o);
                        return {
                            empty: 0 == i.length, data: i.map(function (t) {
                                return this._temporaryObjectsByHotspotId[u.get(t)]
                            }, this)
                        }
                    }, _onBeforeObjectEventFiring: function (t, e, o) {
                        if (g[e] && ("mouseleave" == e || "mouseenter" == e)) {
                            var i, n, s = o.get("relatedTarget"), a = o.get("target");
                            a && a.getId && (i = a.getId()), s && s.getId && (n = s.getId()), i && i == n && (o.stopImmediatePropagation(), o.preventDefault())
                        }
                    }, _onAfterObjectEventFiring: function (t, e, o) {
                        if (g[e] && !o.isImmediatePropagationStopped()) {
                            var i = t.params.context;
                            this.events.fire(e, new _({
                                type: e,
                                activeObject: i,
                                pagePixels: o.get("pagePixels"),
                                clientPixels: o.get("clientPixels"),
                                globalPixels: o.get("globalPixels"),
                                coords: o.get("coords"),
                                domEvent: o.get("domEvent"),
                                target: this
                            })), this.options.get("dontChangeCursor") || this._checkCursor(e)
                        }
                    }, onAddToMap: function (t) {
                        this._containerListener.add("datarequest", this._onDataRequest, this), this._mapListener = t.events.group().add("boundschange", this._onMapBoundsChange, this).add("actionbegin", this._onMapActionBegin, this).add(["actionend", "actionbreak"], this._onMapActionEnd, this), this._optionMonitor = new n(this.options).add("zIndex", this._onZIndexChange, this).add("pane", this._onPaneChange, this), this.events.fire("addtomap", {
                            target: this,
                            type: "addtomap"
                        }), this._containerList = h.get(this._getPaneInstance()).getContainerList(), this._containerList.insert(this._container, this.options.get("zIndex", 0))
                    }, onRemoveFromMap: function (t) {
                        this._containerList.remove(this._container), this._containerListener.removeAll(), this._mapListener.removeAll(), this._optionMonitor.removeAll(), this.getObjectSource().cancelLastRequest(), this._cursorSet && (this._cursorSet.remove(), this._cursorSet = null), this._temporaryContainer && (this._temporaryContainer.clear(), this._temporaryContainerState = null, this._temporaryContainerTileStatus = null), this._cancelLastRequest(), this._lastObjectsRequest = null, this._mapActionCounter = 0, this._lastObjectsLoadCallback = null, this._layerObjectsByHotspotId = {}, this._activeTileStatus = null, this.events.fire("removefrommap", {
                            target: this,
                            type: "removefrommap"
                        })
                    }, _onPaneChange: function () {
                        this._containerList.remove(this._container), this._containerList = h.get(this._getPaneInstance()).getContainerList(), this._containerList.insert(this._container)
                    }, _getPaneInstance: function () {
                        var t = this.options.get("pane", "events");
                        return "string" == typeof t ? this.getMap().panes.get(t) : t
                    }, _onZIndexChange: function () {
                        var t = this.getMap();
                        t && (this.onRemoveFromMap(t), this.onAddToMap(t))
                    }, _onMapBoundsChange: function (t) {
                        this._roundZoom(t.get("newZoom")) != this._roundZoom(t.get("oldZoom")) && this.getObjectSource().cancelLastRequest()
                    }, _onMapActionBegin: function () {
                        this._mapActionCounter++
                    }, _onMapActionEnd: function () {
                        this._mapActionCounter--, this._lastDataRequest && (this._lastDataRequest.zoom == this._roundZoom(this.getMap().getZoom()) && this._loadData(this._lastDataRequest.tile, this._lastDataRequest.zoom), this._lastDataRequest = null)
                    }, _onDataRequest: function (t) {
                        this._mapActionCounter > 0 ? this._lastDataRequest = {
                            tile: t.get("tile"),
                            zoom: t.get("zoom")
                        } : this._loadData(t.get("tile"), t.get("zoom"))
                    }, _loadData: function (t, e) {
                        this._activeTileStatus = "loading", this._requestObjects(t, e, !0).then(this._getLoadListener(t, e), function () {
                            this._activeTileStatus = "ready"
                        }, this)
                    }, _requestObjects: function (t, e, o, i) {
                        var n = p.defer();
                        return this._lastObjectsRequest && d(this._lastObjectsRequest.tile, t) && this._lastObjectsRequest.zoom == e && this._lastObjectsRequest.isTemporaryData == i ? o ? n.reject() : n.resolve(this._lastObjectsRequest.deferred.promise()) : (this._cancelLastRequest(), this._lastObjectsRequest = {
                            tile: t,
                            zoom: e,
                            cancelable: o,
                            deferred: n,
                            isTemporaryData: i
                        }, this.getObjectSource().requestObjects(this, t, e, function (t) {
                            n.resolve(t)
                        })), n.promise()
                    }, _cancelLastRequest: function () {
                        this._lastObjectsRequest && this._lastObjectsRequest.cancelable && this._lastObjectsRequest.deferred.reject(new v.OutdatedTile)
                    }, _getLoadListener: function (t, e) {
                        var o = this._lastObjectsLoadCallback = function (i) {
                            o == this._lastObjectsLoadCallback && this._onObjectsLoaded(t, e, i)
                        };
                        return o
                    }, _onObjectsLoaded: function (t, e, o) {
                        var i = this._container.getActiveTileAndZoom();
                        if (i.tile && d(t, i.tile) && i.zoom == e) {
                            this._activeTileStatus = "ready", this._objects = o, this._layerObjectsByHotspotId = {};
                            for (var n = 0, s = o.length; n < s; n++) o[n].options.setParent(this.options), o[n].events.addController(this._controller), this._layerObjectsByHotspotId[u.get(o[n].getHotspot())] = o[n];
                            this.events.fire("dataload", {tile: t, zoom: e, objects: this._objects})
                        }
                    }, _checkCursor: function (t) {
                        if ("mouseenter" == t) this._cursorSet || (this._cursorSet = this._getPaneInstance().cursors.push(this.options.get("cursor") || "pointer")); else if ("mouseleave" == t) {
                            var e = this.getMap();
                            e && this._cursorSet && (this._cursorSet.remove(), this._cursorSet = null)
                        }
                    }, _getTile: function (t) {
                        var e = this.options.get("projection").toGlobalPixels(t, this._roundZoom(this.getMap().getZoom()));
                        return [Math.floor(e[0] / 256), Math.floor(e[1] / 256)]
                    }, _roundZoom: function (t) {
                        return "round" == this.options.get("tilesRoundingMethod", "round") ? Math.round(t) : Math.floor(t)
                    }
                }), c.setRule({
                    name: "hotspotLayer", rule: function (t, e) {
                        return [m(t, e), t]
                    }
                }), c.setRule({name: "hotspotLayer", key: ["projection"], rule: "plain"}), t(v)
            });
        }],
        ['6a', function (ym) {
            ym.modules.define("hotspot.layer.addon.balloon", ["hotspot.Layer", "popup.addonBuilder", "hotspot.layer.Balloon"], function (a, e, o, t) {
                a(o.build({type: "balloon", metaEventManager: e.getMetaEventManager(), defaultManager: t}))
            });
        }],
        ['6b', function (ym) {
            ym.modules.define("hotspot.layer.addon.hint", ["hotspot.Layer", "popup.addonBuilder", "hotspot.layer.Hint"], function (e, t, a, n) {
                e(a.build({type: "hint", metaEventManager: t.getMetaEventManager(), defaultManager: n}))
            });
        }],
        ['6c', function (ym) {
            ym.modules.define("hotspot.layer.Balloon", ["util.defineClass", "Balloon", "component.sharedEntity.captor.Balloon", "event.Manager", "map.addon.balloon", "hotspot.layer.optionMapper", "option.Manager", "projection.idle", "util.component", "util.extend", "util.preset", "popup.managerStorage", "popup.component.checkEmptiness", "balloon.component.getBalloonMode"], function (t, o, e, n, a, i, s, p, h, r, l, c, u, _, g) {
                function d(t) {
                    this._hotspotLayer = t, this.events = new a({context: this}), this._setupCaptor(), this._setupListeners(), this._checkMapListener(t.getMap())
                }

                var f = {autoPan: !1};
                o(d, r.createProxyMethods(function () {
                    return this._captor
                }, ["open", "close", "isOpen", "getOverlay", "getOverlaySync", "autoPan", "getOwner", "setPosition", "getPosition", "setData", "getData", "setOptions", "getOptions"]), {
                    destroy: function () {
                        this._clearListeners(), this._clearCaptor()
                    }, isEmpty: function (t, o, e) {
                        var n = this._specifyData(o), a = {
                            projection: h,
                            panelMode: "panel" == g(this._hotspotLayer.getMap(), this._hotspotLayer.options.get("balloonPanelMaxMapArea"))
                        };
                        return n.options = new p(e ? l(a, e) : a, this._hotspotLayer.options, "balloon"), _(this._hotspotLayer.getMap(), "balloon", t, n)
                    }, open: function (t, o, e) {
                        return this._captor.open(t, this._specifyData(o), e)
                    }, setData: function (t) {
                        return this._captor.setData(this._specifyData(t))
                    }, _setupCaptor: function () {
                        var t = this._hotspotLayer.getMap(), o = t && i.get(t);
                        this._captor = new n(this, this._hotspotLayer, "balloon", o)
                    }, _clearCaptor: function () {
                        this._captor.destroy(), this._captor = null
                    }, _setupListeners: function () {
                        this._hotspotLayer.events.add("mapchange", this._onMapChange, this).add("clickdefaultaction", this.onClickDefault, this)
                    }, _clearListeners: function () {
                        this._hotspotLayer.events.remove("clickdefaultaction", this.onClickDefault, this).remove("mapchange", this._onMapChange, this), this._checkMapListener(null)
                    }, onClickDefault: function (t) {
                        var o = this._hotspotLayer.options;
                        if (o.get("openBalloonOnClick", !0)) {
                            var e = t.get("originalEvent"), n = e.get("activeObject"), a = e.get("globalPixels"),
                                i = n.getProperties();
                            o.get("openEmptyBalloon", !1) ? this.open(a, i) : this.isEmpty(a, i).then(function (t) {
                                t || this.open(a, i)
                            }, this)
                        }
                    }, _specifyData: function (t) {
                        return t || (t = {}), t.layer = this._hotspotLayer, t
                    }, _onMapChange: function () {
                        var t = this._hotspotLayer.getMap();
                        t ? this._setupSharingManager() : this.close(), this._checkMapListener(t)
                    }, _checkMapListener: function (t) {
                        this._mapEventsListener && this._mapEventsListener.removeAll(), t ? (this._mapEventsListener = t.events.group().add("boundschange", this._onMapBoundsChange, this), this._oldMapZoom = t.getZoom()) : this._mapEventsListener = null
                    }, _setupSharingManager: function () {
                        this._captor.setSharingManager(i.get(this._hotspotLayer.getMap()))
                    }, _onMapBoundsChange: function (t) {
                        var o = this._oldMapZoom, e = this._hotspotLayer.getMap().getZoom();
                        if (this._oldMapZoom = e, this.isOpen() && o != e) {
                            if (this._hotspotLayer.options.get("closeBalloonOnZoomChange")) {
                                var n = "round" == this._hotspotLayer.options.get("tilesRoundingMethod", "round") ? Math.round(this._initialZoom) != Math.round(e) : Math.floor(this._initialZoom) != Math.floor(e);
                                if (n) return void this.close()
                            }
                            var a = this._captor.getPosition(), i = Math.pow(2, e - o);
                            this._disableAutoPan(), this.setPosition([a[0] * i, a[1] * i]), this._enableAutoPan()
                        }
                    }, _disableAutoPan: function () {
                        c.addTo(this.getOptions(), f)
                    }, _enableAutoPan: function () {
                        c.removeFrom(this.getOptions(), f)
                    }
                }), u.add("hotspot#balloon", d), s.setRule({name: "balloon", rule: "prefixed"}), t(d)
            });
        }],
        ['6e', function (ym) {
            ym.modules.define("hotspot.layer.Hint", ["util.defineClass", "Hint", "component.sharedEntity.captor.Popup", "event.Manager", "map.addon.hint", "hotspot.layer.optionMapper", "hotspot.Manager", "option.Manager", "projection.idle", "util.component", "util.extend", "util.preset", "popup.managerStorage", "popup.component.checkEmptiness"], function (t, e, o, n, s, i, a, r, p, h, u, c, _, l, g) {
                function f(t) {
                    this._hotspotLayer = t, this.events = new s({context: this}), this._setupCaptor(), this._setupListeners()
                }

                e(f, u.createProxyMethods(function () {
                    return this._captor
                }, ["close", "isOpen", "getOverlay", "getOverlaySync", "getOwner", "setPosition", "getPosition", "getData", "setOptions", "getOptions"]), {
                    destroy: function () {
                        this._clearListeners(), this._clearCaptor()
                    }, isEmpty: function (t, e, o) {
                        var n = this._specifyData(e), s = {projection: h};
                        return n.options = new p(o ? c(s, o) : s, this._hotspotLayer.options, "hint"), g(this._hotspotLayer.getMap(), "hint", t, n)
                    }, open: function (t, e, o) {
                        return this._captor.open(t, this._specifyData(e), o)
                    }, setData: function (t) {
                        return this._captor.setData(this._specifyData(t))
                    }, _setupCaptor: function () {
                        var t = this._hotspotLayer.getMap(), e = t && i.get(t);
                        this._captor = new n(this, this._hotspotLayer, "hint", e)
                    }, _clearCaptor: function () {
                        this._captor.destroy(), this._captor = null
                    }, _setupListeners: function () {
                        this._hotspotLayer.events.add("mapchange", this._onMapChange, this), this._startMouseenterListening()
                    }, _clearListeners: function () {
                        this._hotspotLayer.events.remove("mapchange", this._onMapChange, this), this._stopMouseenterListening()
                    }, _onMouseEnterDefault: function (t) {
                        var e = this._hotspotLayer;
                        if (e.options.get("openHintOnHover", !0)) {
                            var o = t.get("originalEvent"), n = o.get("globalPixels"), s = o.get("activeObject"),
                                i = s.getProperties();
                            this._hotspotLayer.options.get("openEmptyHint", !1) ? this.open(n, i).done(null, function () {
                            }) : this.isEmpty(n, i).then(function (t) {
                                t || this.open(n, i).then(function () {
                                    var t = e.getMap(), o = e.options.get("pane", "events"),
                                        n = "string" == typeof o ? t.panes.get(o) : o;
                                    if (r.get(n).getActiveHotspot() != s.getHotspot()) return this.close()
                                }, this).done(null, function () {
                                })
                            }, this), e.events.add("mousemove", this._onHotspotLayerMouseMove, this).add("mouseleave", this._onHotspotLayerMouseLeave, this)
                        }
                    }, _onMapChange: function () {
                        this._hotspotLayer.getMap() ? this._setupSharingManager() : (this._clearHotspotEvents(), this.close(!0).done(null, function () {
                        }))
                    }, _setupSharingManager: function () {
                        this._captor.setSharingManager(i.get(this._hotspotLayer.getMap()))
                    }, _onHotspotLayerMouseMove: function (t) {
                        this.setPosition(t.get("globalPixels")).done(null, function () {
                        })
                    }, _clearHotspotEvents: function () {
                        this._hotspotLayer.events.remove("mousemove", this._onHotspotLayerMouseMove, this).remove("mouseleave", this._onHotspotLayerMouseLeave, this)
                    }, _onHotspotLayerMouseLeave: function () {
                        this.close().done(null, function () {
                        }), this._clearHotspotEvents()
                    }, _specifyData: function (t) {
                        return t || (t = {}), t.layer = this._hotspotLayer, t
                    }, _startMouseenterListening: function () {
                        this._hotspotLayer.events.add("mouseenterdefaultaction", this._onMouseEnterDefault, this)
                    }, _stopMouseenterListening: function () {
                        this._hotspotLayer.events.remove("mouseenterdefaultaction", this._onMouseEnterDefault, this)
                    }
                }), l.add("hotspot#hint", f), a.setRule({name: "hint", rule: "prefixed"}), t(f)
            });
        }],
        ['6g', function (ym) {
            ym.modules.define("hotspot.layer.Object", ["util.defineClass", "option.Manager", "event.Manager", "Hotspot", "interactivityModel.EventController", "interactivityModel.layer"], function (t, e, i, o, s, n, r) {
                function h(t, e, s) {
                    this._geometry = e.geometry, this._properties = e.properties, this.options = new i(s), this.events = new o({context: this}), this._setupHotspot(t, this.options.get("zIndex")), this._interactivityModel = this.options.get("interactivityModel", r), this._interactivityEventController = new n(this._interactivityModel), this.events.addController(this._interactivityEventController)
                }

                t(e(h, {
                    getHotspot: function () {
                        return this._hotspot
                    }, setGeometry: function (t) {
                        this._geometry = t
                    }, getGeometry: function () {
                        return this._geometry
                    }, setProperties: function (t) {
                        this._properties = t
                    }, getProperties: function () {
                        return this._properties
                    }, setId: function (t) {
                        this._id = t, this._hotspot && this._hotspot.setId(this.getId())
                    }, getId: function () {
                        return this._id
                    }, destroy: function () {
                        this._clearHotspot(), this.events.removeController(this._interactivityEventController), this._geometry = null, this._interactivityEventController = null
                    }, _setupHotspot: function (t, e) {
                        this._hotspot = new s(t, e), this._hotspot.events.setParent(this.events), this._hotspot.setId(this.getId())
                    }, _clearHotspot: function () {
                        this._hotspot.events.setParent(null), this._hotspot.destroy(), this._hotspot = null
                    }
                }))
            });
        }],
        ['6l', function (ym) {
            ym.modules.define("hotspot.loader", ["util.extend", "util.jsonp", "vow"], function (e, n, o, a) {
                function r(e, n) {
                    if (t[e]) t[e].push(n); else {
                        t[e] = [n];
                        var o = function () {
                            delete t[e]
                        };
                        d[e] = window.setTimeout(o, 24e4)
                    }
                }

                var t = {}, d = {}, i = null, l = {
                    load: function (e, t) {
                        t = t || {};
                        var d, i = {};
                        if (t.key && t.key instanceof Array) {
                            for (var l = 0, c = t.key.length; l < c; l++) {
                                var f = {callback: t.callback[l], context: t.context[l]};
                                i[t.key[l]] = {
                                    abort: function () {
                                        f.aborted = !0, i.deferred.reject(new Error("aborted"))
                                    }
                                }, r(t.key[l], f)
                            }
                            d = t.padding || t.key.join("_").replace(/\W/g, "_")
                        } else {
                            var u;
                            if (t.key || t.id) {
                                u = t.key || t.id || Math.random();
                                var f = n(t, {loaderUrl: e});
                                r(u, f), i = {
                                    abort: function () {
                                        f.aborted = !0, i.deferred.reject(new Error("aborted"))
                                    }
                                }, d = t.padding || u.replace(/\W/g, "_")
                            } else u = Math.random(), d = t.padding || null
                        }
                        if (d) {
                            var h = window[d];
                            window[d] = function (e) {
                                this.onLoad(t.key, e), window[d] = h
                            }.bind(this)
                        }
                        var k = o({padding: d, noCache: t.noCache, url: e}), s = a.defer();
                        return i.deferred = s, k.then(function (e) {
                            this.onLoad(t.key, e), s.resolve(e)
                        }, function (e) {
                            this.onLoad(t.key, null), s.reject(e)
                        }, this), i
                    }, onLoad: function (e, n) {
                        for (var o = [].concat(e), a = 0, r = o.length; a < r; a++) {
                            var l = o[a], c = t[l];
                            if (c) {
                                for (var f = 0, u = c.length; f < u; f++) c[f].callback && !c[f].aborted && c[f].callback.call(c[f].context || window, n);
                                delete d[l], delete t[l]
                            }
                        }
                        i && i.onLoad(e, n)
                    }
                };
                e(l)
            });
        }],
        ['6p', function (ym) {
            ym.modules.define("hotspot.ObjectSource", ["hotspot.layer.ObjectSource"], function (e, o) {
                e(o)
            });
        }],
        ['6h', function (ym) {
            ym.modules.define("hotspot.layer.ObjectSource", ["util.defineClass", "util.Chunker", "hotspot.loader", "hotspot.layer.Object", "interactivityModel.storage", "interactivityModel.layer", "event.Manager", "option.Manager", "geometry.pixel.Polygon", "geometry.pixel.Rectangle", "geometry.pixel.MultiPolygon", "shape.Polygon", "shape.Rectangle", "shape.MultiPolygon", "vow", "util.coordinates.convert"], function (e, t, o, n, r, i, a, s, l, c, p, u, h, g, y, f, m) {
                var d = 256, v = {ConvexPolygon: c, Polygon: c, MultiConvexPolygon: u, MultiPolygon: u, Rectangle: p},
                    _ = {Polygon: h, MultiPolygon: y, Rectangle: g}, M = function (e, t, o) {
                        this._tileUrlTemplate = e, this._keyTemplate = t, this.options = new l(o), this.events = new s, this._lastRequest = null, this.options.setName("objectSource")
                    };
                t(M, {
                    getTileUrl: function (e, t) {
                        var o, n = this._tileUrlTemplate;
                        return o = "function" == typeof n ? this._tileUrlTemplate(e, t) : this._processTemplate(n, e, t)
                    }, getKey: function (e, t) {
                        var o = this._keyTemplate;
                        if (!o) return null;
                        var n;
                        return n = "function" == typeof o ? o(e, t) : this._processTemplate(o, e, t)
                    }, getTileUrlTemplate: function () {
                        return this._tileUrlTemplate
                    }, setTileUrlTemplate: function (e) {
                        this._tileUrlTemplate = e
                    }, getKeyTemplate: function () {
                        return this._keyTemplate
                    }, setKeyTemplate: function (e) {
                        this._keyTemplate = e
                    }, requestObjects: function (e, t, o, r) {
                        if (this.restrict(e, t, o)) r([]); else {
                            var i = this.getKey(t, o);
                            this.cancelLastRequest();
                            var a = this._lastRequest = n.load(this.getTileUrl(t, o), {
                                key: i,
                                noCache: this.options.get("noCache"),
                                notJsonpResponse: this.options.get("notJsonpResponse"),
                                callback: function (n) {
                                    a == this._lastRequest && this.parseResponse(e, n, r, t, o)
                                },
                                context: this
                            })
                        }
                    }, cancelLastRequest: function () {
                        var e = this._lastRequest;
                        if (e) {
                            if (e instanceof Array) for (var t = 0, o = e.length; t < o; t++) e[t].abort && e[t].abort(); else e.abort && e.abort();
                            this._lastRequest = null
                        }
                    }, restrict: function (e, t, o) {
                        var n = this.options.get("maxZoom", 23), r = this.options.get("minZoom", 0);
                        if (o > n) return !0;
                        if (o < r) return !0;
                        var i = this.options.get("bounds");
                        if (i) {
                            var a = [(t[0] + .5) * d, (t[1] + .5) * d], s = e.getMap();
                            if (!s) return !1;
                            var l = s.options.get("projection").fromGlobalPixels(a), c = i[1], p = i[0];
                            if (p[0] > l[0] || p[1] < l[1] || c[0] < l[0] || c[1] > l[1]) return !0
                        }
                        return !1
                    }, parseResponse: function (e, t, o, n, r) {
                        return !t || t.error ? void o([]) : void this._parser(e, t.data, o, n)
                    }, _restrict: function (e, t) {
                        var o = [Math.ceil(Math.pow(2, t + 8) / d), Math.ceil(Math.pow(2, t + 8) / d)], n = e[0],
                            r = e[1];
                        return n < 0 || n >= o[0] || r < 0 || r >= o[1] ? null : [n, r]
                    }, _processTemplate: function (e, t, o) {
                        if (t = this._restrict(t, o), !t) return null;
                        for (var n, r = e.replace(/%x/g, t[0].toString()).replace(/%y/g, t[1].toString()).replace(/%z/g, o.toString()).replace(/%c/g, "x=" + t[0] + "&y=" + t[1] + "&z=" + o).replace(/%l/g, "lang=" + ym.env.lang).replace(/{{ scale }}/g, 1); n = /%d\|?(\d+)?/.exec(r);) {
                            for (var i = n && n[1] || 4, a = n && n[0] || "%d", s = 0, l = 0, c = Math.ceil(Math.log(i) * Math.LOG2E); l < c; l++) s += (t[(l + 1) % 2] >> Math.floor(l / 2) & 1) << l;
                            r = r.replace(a, (s + 1).toString())
                        }
                        return r
                    }, _parser: function (e, t, n, s) {
                        var l = e.getMap();
                        l || n([]);
                        var c = [s[0] * d, s[1] * d], p = e.options.get("interactivityModel") || a,
                            u = "string" == typeof p ? i.get(p) : p, h = [], g = new o(t.features, {
                                timeout: 0, chunkSize: 30, worker: function (e) {
                                    this.options.get("coordOrder") && (e.geometry.coordinates = m(e.geometry.coordinates, ym.env.coordinatesOrder, this.options.get("coordOrder")));
                                    var t = e.properties.HotspotMetaData || {}, o = t.zIndex,
                                        n = this._makePixelGeometry(t.RenderedGeometry.type, this._makeCoordinates(t.RenderedGeometry.coordinates, c)),
                                        i = new r(this._makeShape(n), e, {zIndex: o, interactivityModel: u});
                                    i.setId(t.id), h.push(i)
                                }.bind(this)
                            });
                        g.start(function () {
                            n(h)
                        })
                    }, _makeCoordinates: function (e, t) {
                        var o = [];
                        if (e[0].length) for (var n = 0, r = e.length; n < r; n++) o[n] = this._makeCoordinates(e[n], t); else o = [e[0] + t[0], e[1] + t[1]];
                        return o
                    }, _makePixelGeometry: function (e, t) {
                        var o = v[e], n = !1;
                        return "MultiConvexPolygon" != e && "ConvexPolygon" != e || (n = !0), new o(t, "evenOdd", {convex: n})
                    }, _makeShape: function (e) {
                        var t = _[e.getType()];
                        return new t(e)
                    }
                }), e(M)
            });
        }],
        ['6K', function (ym) {
            ym.modules.define("interactivityModel.geoObject", ["constants.mapDomEvents", "interactivityModel.storage"], function (t, e, l) {
                for (var o = {}, a = 0, n = e.length; a < n; a++) o[e[a]] = {};
                o.wheel.allowMapEvent = !0, o.mousedown.allowMapEvent = !0, o.contextmenu.allowMapEvent = !0, o.multitouchstart.allowMapEvent = !0, o.multitouchmove.allowMapEvent = !0, o.multitouchend.allowMapEvent = !0, o.dblclick.allowMapEvent = !0, l.add("default#geoObject", o), t(o)
            });
        }],
        ['6L', function (ym) {
            ym.modules.define("interactivityModel.layer", ["constants.mapDomEvents", "interactivityModel.storage"], function (t, e, a) {
                for (var l = {}, o = 0, n = e.length; o < n; o++) l[e[o]] = {};
                l.wheel.allowMapEvent = !0, l.mousedown.allowMapEvent = !0, l.contextmenu.allowMapEvent = !0, l.multitouchstart.allowMapEvent = !0, l.multitouchmove.allowMapEvent = !0, l.multitouchend.allowMapEvent = !0, a.add("default#layer", l), t(l)
            });
        }],
        ['6M', function (ym) {
            ym.modules.define("interactivityModel.opaque", ["interactivityModel.storage"], function (e, t) {
                var a = {};
                t.add("default#opaque", a), e(a)
            });
        }],
        ['6N', function (ym) {
            ym.modules.define("interactivityModel.silent", ["constants.mapDomEvents", "interactivityModel.storage"], function (t, e, n) {
                for (var a = {}, i = 0, l = e.length; i < l; i++) a[e[i]] = {allowMapEvent: !0, cancel: !0};
                n.add("default#silent", a), t(a)
            });
        }],
        ['6O', function (ym) {
            ym.modules.define("interactivityModel.storage", ["util.Storage"], function (e, t) {
                e(new t)
            });
        }],
        ['6P', function (ym) {
            ym.modules.define("interactivityModel.transparent", ["constants.mapDomEvents", "interactivityModel.storage"], function (t, a, e) {
                for (var n = {}, o = 0, r = a.length; o < r; o++) n[a[o]] = {allowMapEvent: !0};
                e.add("default#transparent", n), t(n)
            });
        }],
        ['6U', function (ym) {
            ym.modules.define("Layer", ["util.defineClass", "util.dom.element", "util.hd", "constants.zIndex", "event.globalize", "collection.Item", "layer.optionMapper", "layer.tileContainer.storage", "layer.component.TileSource", "layer.component.TilePositioner", "Monitor", "map.pane.helper.ground"], function (t, e, i, n, o, s, r, a, l, h, u, _) {
                var d, p = function (t, e) {
                    p.superclass.constructor.call(this, e), this.options.setName("layer"), this.options.setMapper(a), this._tileUrlTemplate = n.selectValue(t), this._tileSource = new h(this), this._tilePositioner = new u(this), this.events.addController(d), this._pane = null, this._tileContainer = null, this._initialZoom = 0, this._tileLoadEvents = null, this._optionMonitor = new _(this.options), this._optionMonitor.add("brightness", this._onBrightnessChange, this, {defaultValue: .5}).add("zIndex", this._onZIndexChange, this, {defaultValue: o.layer})
                };
                d = s(p), e(p, r, {
                    update: function (t) {
                        this._pane && this._tileContainer && (this._tileContainer.redraw({
                            reload: !0,
                            animate: !0,
                            updateBounds: t
                        }), this.events.fire("update"))
                    }, reinitialize: function () {
                        var t = this._roundZoom(this._pane.getZoom());
                        this._tileContainer.setTileZoom(t, this.getViewport()), this._initTileLoadObserver()
                    }, setTileUrlTemplate: function (t) {
                        this._tileUrlTemplate = n.selectValue(t)
                    }, getTileUrlTemplate: function () {
                        return this._tileUrlTemplate
                    }, getTileUrl: function (t, e) {
                        var i = this._tileSource.getTileUrl(t, e);
                        return i ? n.selectValue(i) : null
                    }, numberToClientBounds: function (t, e) {
                        return this._tilePositioner.numberToClientBounds(t, e)
                    }, numberToGlobalBounds: function (t, e, i) {
                        return this._tilePositioner.numberToGlobalBounds(t, e, i)
                    }, clientPixelsToNumber: function (t, e) {
                        return this._tilePositioner.clientPixelsToNumber(t, e)
                    }, getTileSize: function (t) {
                        return this.options.get("tileSize", [256, 256])
                    }, restrict: function (t, e) {
                        return this._tileSource.restrict(t, e)
                    }, onAddToMap: function (t) {
                        this._tilePositioner.onAddToMap(t), this._pane = t.panes.get(this.options.get("pane", "ground")), this._element = i.create({
                            css: {
                                position: "absolute",
                                zIndex: this._optionMonitor.get("zIndex")
                            }, parentNode: this._pane.getElement()
                        });
                        var e = this.options.get("tileContainerClass");
                        "string" == typeof e && (e = l.get(e));
                        var n = this._tileContainer = new e(this);
                        n.setParent(this), n.options.setParent(this.options), n.events.setParent(this.events), this.reinitialize(), this._initialZoom = this._pane.getZoom(), this._paneListeners = this._pane.events.group().add("actionbegin", this._onActionStart, this), this._pane.supportsCompoundUpdate ? this._paneListeners.add("compoundupdate", this._onCompoundUpdate, this) : this._paneListeners.add("viewportchange", this._onViewportChange, this).add("clientpixelschange", this._onClientPixelsChange, this).add("actionend", this._onActionEnd, this), this._tileContainerListeners = n.events.group().add("ready", this._onTileContainerReady, this)
                    }, onRemoveFromMap: function (t) {
                        var e = this._tileContainer;
                        e.setParent(null), e.options.setParent(null), e.events.setParent(null), this._tileContainerListeners.removeAll(), this._tileContainer = null, this._paneListeners.removeAll(), i.remove(this._element), this._tilePositioner.onRemoveFromMap(t)
                    }, getPane: function () {
                        return this._pane
                    }, getElement: function () {
                        return this._element
                    }, toClientPixels: function (t) {
                        return this._pane.toClientPixels(t)
                    }, fromClientPixels: function (t) {
                        return this._pane.fromClientPixels(t)
                    }, getZoom: function () {
                        return this._pane.getZoom()
                    }, getViewport: function () {
                        return this._pane.getViewport()
                    }, getBrightness: function () {
                        return this._optionMonitor.get("brightness")
                    }, _onBrightnessChange: function (t, e) {
                        this.events.fire("brightnesschange", {newBrightness: t, oldBrightness: e})
                    }, _onZIndexChange: function (t) {
                        this._element && (this._element.style.zIndex = t)
                    }, _onActionStart: function () {
                        this.events.fire("actionstart"), this._initialZoom = this._pane.getZoom(), this._isActionStarted = !0
                    }, _onViewportChange: function () {
                        this._isActionStarted && !this.options.get("loadTilesInAction", !0) || (0 === this._initialZoom || this._pane.getZoom() >= this._initialZoom - 1) && this._tileContainer.setViewport(this._pane.getViewport())
                    }, _onClientPixelsChange: function () {
                        this._tileContainer.redraw()
                    }, _onCompoundUpdate: function (t) {
                        var e = t.get("reason"), i = t.get("viewportChanged"), n = t.get("clientPixelsChanged");
                        if ("actionend" === e) {
                            var o = this._prepareForActionEnd();
                            o ? this.reinitialize() : (n && this._tileContainer.redraw(), this._tileContainer.setViewport(this._pane.getViewport()))
                        } else "sizechange" === e ? (this._tileContainer.redraw(), this._tileContainer.setViewport(this._pane.getViewport())) : i ? this._onViewportChange() : n && this._onClientPixelsChange()
                    }, _prepareForActionEnd: function () {
                        var t = this._roundZoom(this._pane.getZoom()), e = this._roundZoom(this._initialZoom) != t;
                        return this._initialZoom = 0, this._isActionStarted = !1, e
                    }, _onActionEnd: function () {
                        var t = this._prepareForActionEnd();
                        t ? this.reinitialize() : this._tileContainer.setViewport(this._pane.getViewport())
                    }, _onTileContainerReady: function () {
                        this.events.fire("ready")
                    }, _initTileLoadObserver: function () {
                        this._tileLoadEvents && this._tileLoadEvents.removeAll(), this._tileLoadEvents = this._tileContainer.tiles.events.group().add(["tileready", "tileremoveall", "tileadd", "tileremove"], function (t) {
                            var e = this.getTileStatus();
                            this.events.fire("tileloadchange", e)
                        }, this).add("tileloaderror", function (t) {
                            this.events.fire("tileloaderror", t)
                        }, this)
                    }, _roundZoom: function (t) {
                        var e = this.options.get("tilesRoundingMethod", "round");
                        return "function" == typeof e ? e(t) : "round" == e ? Math.round(t) : Math.floor(t)
                    }, getTileStatus: function () {
                        if (!this._tileContainer || this._tileContainer && !this._tileContainer.tiles) return null;
                        var t = this._tileContainer.tiles, e = t.getTotalTilesNumber(),
                            i = e - t.getPendingTilesNumber();
                        return {readyTileNumber: i, totalTileNumber: e}
                    }
                }), t(p)
            });
        }],
        ['6W', function (ym) {
            ym.modules.define("layer.storage", ["util.Storage"], function (e, n) {
                e(new n)
            });
        }],
        ['6Y', function (ym) {
            ym.modules.define("layer.tile.DomTile", ["util.dom.element", "util.dom.style", "domEvent.manager", "event.Manager", "Event", "option.Manager", "localization.common.current", "util.imageLoader", "layer.tile.storage", "util.css", "system.browser", "util.cancellation.Token", "util.cancelableCallback", "layer.domTileNotFound.css"], function (t, e, i, s, n, o, a, r, l, h, c, d, _, u) {
                function m(t, e, i) {
                    var s, n = t[0], o = t[1],
                        a = [Math.ceil(o[0]) - Math.floor(n[0]), Math.ceil(o[1]) - Math.floor(n[1])];
                    if ("css3" != i && "css3-3d" != i || !T) s = {
                        size: [Math.ceil(a[0]), Math.ceil(a[1])],
                        position: [Math.floor(n[0]), Math.floor(n[1])],
                        css: {position: "absolute"}
                    }; else {
                        var r = [Math.floor(n[0]), Math.floor(n[1])], l = Math.ceil(e[0]), h = Math.ceil(e[1]),
                            c = a[0] / l, _ = a[1] / h, u = c > _ ? 1 : c / _, m = c > _ ? _ / c : 1;
                        s = d.androidBrokenBuild ? {
                            patch: {transform: {scale: [c, _]}},
                            size: [l, h]
                        } : {
                            patch: {transform: {scale: [u, m]}},
                            size: [a[0] / u, a[1] / m]
                        }, s.patch.transform.offset = r, s.patch.transform.use3D = "css3-3d" == i, s.css = {
                            position: "absolute",
                            transformOrigin: "0px 0px"
                        }
                    }
                    return s
                }

                var p = ym.supports, g = r.layer.tileNotFound, f = p.css.checkTransitionProperty("opacity"), y = !!f,
                    T = !!p.css.checkProperty("transform"), v = function (t, e, i) {
                        return this.options = e.get && "function" == typeof e.get ? e : new a(e), this.events = new n, this._renderOptions = i || {}, this._url = t, t ? (this._queuedTs = ym.performance.now(), this._loadedTs = void 0, this._renderedTs = void 0, this._readyTs = void 0, this._loadState = "loading", this._imagePreprocessingCallbacks = null, this._usedUrl = "", void (t && t.template && t.template.tileLoader ? this._runTileLoader() : t && (this._ready = !1, l.load({
                            url: t,
                            priority: this._renderOptions.priority,
                            channel: "tiles",
                            crossOrigin: this.options.get("crossOrigin", !1),
                            decode: this.options.get("decode", !1)
                        }, this._onLoad, this)))) : (this._ready = !0, void (this._loadState = "error"))
                    };
                v.prototype = {
                    renderAt: function (t, i, s) {
                        this._element && this._element.parentNode != t && e.remove(this._element), this._context = t, this._clientPixelBounds = i, this._renderOptions.tileTransparent = this.options.get("tileTransparent"), this._renderOptions.animate = y && s && this.options.get("tileAnimateOpacity"), "loading" != this._loadState ? this._draw() : this._rendered = !0
                    }, getTimestamps: function () {
                        return {
                            queued: this._queuedTs,
                            loaded: this._loadedTs,
                            rendered: this._renderedTs,
                            ready: this._readyTs
                        }
                    }, getInfo: function () {
                        return {url: "string" == typeof this._url ? this._url : null}
                    }, destroy: function () {
                        this._cancelAnimation(), this._cancellationToken && (this._cancellationToken.cancel(), this._cancellationToken.close()), "loading" == this._loadState && this._url && l.cancel(this._url, this._onLoad, this), this._imagePreprocessingCallbacks && (this._imagePreprocessingCallbacks.onSuccess.cancel(), this._imagePreprocessingCallbacks.onFail.cancel()), this._element && (e.remove(this._element), this._element = null), this._context = null
                    }, isReady: function () {
                        return this._ready
                    }, _onLoad: function (t, e, i) {
                        if (e) {
                            var s = this.options.get("imagePreprocessor");
                            s ? this._preprocessImage(t, s) : this._setupImageSource(t)
                        } else this._processUrlLoadingError(i)
                    }, _preprocessImage: function (t, e) {
                        this._imagePreprocessingCallbacks = {
                            onSuccess: u.create(this._setupImageSource, this),
                            onFail: u.create(this._processUrlLoadingError, this)
                        }, e(t, {
                            tileNumber: this._renderOptions.tileNumber,
                            tileZoom: this._renderOptions.tileZoom
                        }).then(this._imagePreprocessingCallbacks.onSuccess, this._imagePreprocessingCallbacks.onFail)
                    }, _setupImageSource: function (t) {
                        t && (this._imageSize = [t.naturalWidth || t.width, t.naturalHeight || t.height], this._usedUrl = t.src || ""), "loading" == this._loadState && (this._loadState = "loaded", this._loadedTs = ym.performance.now(), this._rendered && this._draw())
                    }, _processUrlLoadingError: function (t) {
                        t && this.events.fire("loaderror", {url: t.url}), "loading" == this._loadState && (this._loadState = "error", this._rendered && this._draw())
                    }, _runTileLoader: function () {
                        var t = this;
                        this._cancellationToken = new _, this._url.template.tileLoader({
                            priority: this._renderOptions.priority,
                            lang: ym.env.lang,
                            number: this._url.urlTemplateData.tileNumber,
                            zoom: this._url.urlTemplateData.zoom,
                            scale: this._url.urlTemplateData.scale
                        }, this._cancellationToken).then(function (e) {
                            var i = !0;
                            e.target instanceof HTMLImageElement || (e.target = null, i = !1, ym.logger.error("DOM TileContainer supports only HTMLImageElement for tileLoader")), t._onLoad(e.target, i)
                        })["catch"](function () {
                            t._onLoad(null, !1)
                        })
                    }, _elementCreate: function (t) {
                        return this._renderOptions.animate && (t.css[f] = 0), e.create(t)
                    }, _draw: function () {
                        this._cancelAnimation();
                        var t = this._renderOptions.tileTransparent,
                            e = m(this._clientPixelBounds, this._getImageSize(), this.options.get("tilePositionEngine", "css2"));
                        if (this._element) e.patch && i.patch(this._element, e.patch), e.size && i.setSize(this._element, e.size), e.position && i.setPosition(this._element, e.position), e.css[f] = void 0, i.css(this._element, e.css); else {
                            if ((e.patch || (e.patch = {})).selectable = !1, e.parentNode = this._context, "loaded" == this._loadState) e.patch.scaledBackground = this._usedUrl, e.patch.printBackground = this._usedUrl.replace(/scale=\d\.?\d*/, "scale=1"); else if (!t) {
                                var s = this.options.get("notFoundTile");
                                "string" == typeof s ? (e.patch.scaledBackground = s, e.patch.printBackground = s.replace(/scale=\d\.?\d*/, "scale=1")) : (e.css.backgroundColor = "#bebebe", e.html = '<ymaps class="' + c.addPrefix("tile-not-found") + '">' + g + "</ymaps>")
                            }
                            this._element = this._elementCreate(e)
                        }
                        this._renderOptions.animate ? this._applyAnimation(this.options.get("tileAnimationDuration", 300)) : this._onReady()
                    }, _getImageSize: function () {
                        return "error" == this._loadState ? [Math.ceil(this._clientPixelBounds[1][0]) - Math.floor(this._clientPixelBounds[0][0]), Math.ceil(this._clientPixelBounds[1][1]) - Math.floor(this._clientPixelBounds[0][1])] : this._imageSize
                    }, _applyAnimation: function (t) {
                        t > 0 ? (this._ready = !1, this._transiting = !0, s.add(this._element, "transitionend", this._onTransitionEnd, this), i.css(this._element, {
                            transitionProperty: f,
                            transitionDuration: t + "ms"
                        }), this._startAnimationTimeoutId = setTimeout(function () {
                            this._startAnimationTimeoutId = 0;
                            var t = {};
                            t[f] = 1, i.css(this._element, t)
                        }.bind(this), 32)) : this._onReady()
                    }, _cancelAnimation: function (t) {
                        this._startAnimationTimeoutId > 0 && (clearTimeout(this._startAnimationTimeoutId), this._startAnimationTimeoutId = 0), this._transiting && (s.remove(this._element, "transitionend", this._onTransitionEnd, this), t && i.css(this._element, {
                            transitionProperty: "",
                            transitionDuration: null
                        }), this._transiting = !1)
                    }, _onTransitionEnd: function () {
                        this._cancelAnimation(!0), this._onReady()
                    }, _onReady: function () {
                        this._ready = !0, this._readyTs = ym.performance.now(), this.events.fire("ready", new o({target: this}))
                    }
                }, h.add("default#dom", v), t(v)
            });
        }],
        ['6R', function (ym) {
            ym.modules.define("LayerCollection", ["Collection", "layer.storage", "util.defineClass", "vow", "component.ProviderObserver", "component.ZoomRangeObserver"], function (e, t, n, s, r, i, o) {
                var h = function (e) {
                    h.superclass.constructor.call(this, e), this._zoomRangeObserver = new o(this._onZoomRangeProvidersChange.bind(this)), this._copyrightsObserver = new i({
                        changeEventType: "copyrightschange",
                        changeCallback: function () {
                            this.events.fire("copyrightschange")
                        }.bind(this),
                        makeRequest: function (e, t) {
                            return e.getCopyrights(t.center, t.zoom)
                        }
                    }), this._brightness = .5, this._keyLayers = {}
                };
                s(h, t, {
                    add: function (e) {
                        var t;
                        if ("string" == typeof e) {
                            var s = n.get(e);
                            if (!s && ym.env.debug) throw new Error('LayerCollection.add: layer "' + e + '" does not exist');
                            if (this._keyLayers.hasOwnProperty(e)) {
                                if (ym.env.debug) throw new Error('LayerCollection.add: layer "' + e + '" is already in collection');
                                return this
                            }
                            t = this._keyLayers[e] = new s
                        } else t = e;
                        return h.superclass.add.call(this, t), "function" == typeof t.getZoomRange && this._zoomRangeObserver.addProvider(t), "function" == typeof t.getCopyrights && this._copyrightsObserver.addProvider(t), "function" == typeof t.getBrightness && (t.events.add("brightnesschange", this._onChildBrightnessChange, this), this._onChildBrightnessChange()), this
                    }, removeAll: function () {
                        return this.each(function (e) {
                            this.remove(e)
                        }.bind(this)), this
                    }, remove: function (e) {
                        var t;
                        if ("string" == typeof e) {
                            if (this._keyLayers.hasOwnProperty(e)) t = this._keyLayers[e], delete this._keyLayers[e]; else if (ym.env.debug) throw new Error('LayerCollection.remove: layer "' + e + '" does not exist')
                        } else t = e;
                        return h.superclass.remove.call(this, t), "function" == typeof t.getZoomRange && this._zoomRangeObserver.removeProvider(t), "function" == typeof t.getCopyrights && this._copyrightsObserver.removeProvider(t), "function" == typeof t.getBrightness && (t.events.remove("brightnesschange", this._onChildBrightnessChange, this), this._onChildBrightnessChange()), this
                    }, _onZoomRangeProvidersChange: function () {
                        this.events.fire("zoomrangechange")
                    }, getCopyrights: function () {
                        var e = r.defer();
                        return this._copyrightsObserver.get({
                            center: arguments[0] || this.getMap().getCenter(),
                            zoom: arguments[1] || this.getMap().getZoom()
                        }).then(function (t) {
                            e.resolve([].concat.apply([], t.resolved))
                        }, function () {
                            e.resolve([])
                        }), e.promise()
                    }, getZoomRange: function (e) {
                        return this._zoomRangeObserver.get(e || this.getMap().getCenter())
                    }, getBrightness: function () {
                        return this._brightness
                    }, _onChildBrightnessChange: function () {
                        var e = this._brightness, t = this._calculateBrightness();
                        e != t && (this._brightness = t, this.events.fire("brightnesschange", {
                            newBrightness: t,
                            oldBrightness: e
                        }))
                    }, _calculateBrightness: function () {
                        var e = 0, t = 0;
                        return this.each(function (n) {
                            "function" == typeof n.getBrightness && (e += n.getBrightness(), t++)
                        }), t ? e / t : .5
                    }
                }), e(h)
            });
        }],
        ['6,', function (ym) {
            var images = ym.modules.importImages({defaultImage: {src: "layout/defaultImage.png"}});
            ym.modules.define("layout.Image", ["util.hd", "util.dom.style", "util.dom.element", "domEvent.manager", "Monitor", "templateLayoutFactory", "layout.storage", "shape.Rectangle", "geometry.pixel.Rectangle", "util.shapeFactory", "util.imageLoader", "util.css"], function (e, t, a, i, s, o, r, n, g, h, m, l, p) {
                var u = ym.env.browser, d = u.isMobile || u.isTablet, c = d || "safari" == u.name.toLowerCase(),
                    f = images.get("defaultImage"),
                    _ = ym.supports.printPatchNeeded ? p.addPrefix("patched-for-print") : "", y = c && u.css3DTransform,
                    S = r.createClass('<ymaps class="' + p.addPrefix("image") + " " + _ + '" {% style %}position: absolute;left: {{ options.imageOffset.0|default:-11|raw }}px;top: {{ options.imageOffset.1|default:-38|raw }}px;width: {{ options.imageSize.0|default:34|raw }}px;height: {{ options.imageSize.1|default:41|raw }}px;' + (y ? "transform: translate3D(0,0,0);" : "") + "opacity: {{ options.opacity|default:1|raw }};{% endstyle %}></ymaps>", {
                        getShape: function () {
                            return this._shape && !this._shapeOptionsChanged() || (this._shape = this._createShape()), this._shape
                        }, build: function () {
                            this._buildTime || (this._buildTime = +new Date), S.superclass.build.call(this), this._monitor = new o(this.getData().options).add(["imageClipRect", "imageSize", "imageHref"], this._setupBackground, this, {
                                defaultValues: {
                                    imageHref: f,
                                    imageSize: [34, 41]
                                }
                            }), this._setupBackground()
                        }, clear: function () {
                            S.superclass.clear.call(this), this._imageHref && this._cancelImageLoading(), this._imageHref && l.cancel(this._imageHref, null, this), this._monitor.destroy(), this._imageSrc = this._imageHref = null
                        }, _createShape: function () {
                            var e = this.getData().options, t = e.get("imageShape") || e.get("shape");
                            if (t) return t.type && t.coordinates ? m.create(t) : t;
                            var a = e.get("imageOffset", [-11, -38]), i = e.get("imageSize", [34, 41]);
                            return new g(new h([[a[0], a[1]], [a[0] + i[0], a[1] + i[1]]]))
                        }, _shapeOptionsChanged: function () {
                            var e = ["imageOffset", "imageSize", "shape", "imageShape"], t = !1;
                            if (this._previousShapeOptions) {
                                for (var a = 0, i = e.length; a < i; a++) {
                                    var s = this.getData().options.get(e[a]);
                                    this._previousShapeOptions[e[a]] != s && (this._previousShapeOptions[e[a]] = s, t = !0)
                                }
                                return t
                            }
                            this._previousShapeOptions = {};
                            for (var a = 0, i = e.length; a < i; a++) this._previousShapeOptions[e[a]] = this.getData().options.get(e[a]);
                            return !0
                        }, _setupBackground: function (e) {
                            var a = e ? t.selectValue(e.imageHref) : t.selectValue(this._monitor.get("imageHref"));
                            a !== this._imageHref ? (this._imageHref && this._cancelImageLoading(), this._imageHref = a, l.load(a, this._onImageReady, this)) : this._imageSrc && this._onBackgroundImageLoaded(this._imageSrc)
                        }, _onImageReady: function (e) {
                            this._imageSrc = e, this._onBackgroundImageLoaded(e)
                        }, _cancelImageLoading: function () {
                            l.cancel(this._imageHref, this._onImageReady, this)
                        }, _onBackgroundImageLoaded: function (e) {
                            var t = this._monitor.get("imageClipRect"), i = this._monitor.get("imageSize"),
                                s = [e.width, e.height];
                            t = t || [[0, 0], s];
                            var o = [(i || s)[0] / (t[1][0] - t[0][0]), (i || s)[1] / (t[1][1] - t[0][1])],
                                r = [s[0] * o[0], s[1] * o[1]], n = [-t[0][0] * o[0], -t[0][1] * o[1]];
                            a.css(this.getElement().firstChild, {
                                backgroundImage: 'url("' + e.src + '")',
                                backgroundSize: r[0] + "px " + r[1] + "px",
                                backgroundPosition: n[0] + "px " + n[1] + "px",
                                listStyleImage: !!ym.supports.printPatchNeeded && 'url("' + e.src + '")'
                            }), i || a.setSize(this.getElement().firstChild, s)
                        }
                    });
                n.add("default#image", S), e(S)
            });
        }],
        ['6:', function (ym) {
            ym.modules.define("layout.ImageWithContent", ["util.defineClass", "Template", "layout.Image", "layout.templateBased.Base", "layout.storage", "util.css"], function (t, e, a, o, i, n, s) {
                function l(t) {
                    i.call(this, t)
                }

                var p,
                    f = '<ymaps class="' + s.addPrefix("image-with-content") + '" {% style %}position: absolute;left: {{ options.imageOffset.0|default:0|raw }}px;top: {{ options.imageOffset.1|default:0|raw }}px;width: {{ options.imageSize.0|default:30|raw }}px;height: {{ options.imageSize.1|default:30|raw }}px;opacity: {{ options.opacity|default:1|raw }};{% endstyle %}><ymaps class="' + s.addPrefix("image-with-content-content") + '" {% style %}font: 13px Arial,sans-serif;position: absolute;text-align: center;left: {{ options.contentOffset.0|default:0|raw }}px;top: {{ options.contentOffset.1|default:0|raw }}px;width: {{ options.contentSize.0|default:10|raw }}px;height: {{ options.contentSize.1|default:10|raw }}px;{% endstyle %}>{% include options.contentLayout %}</ymaps></ymaps>';
                e(l, o, {}, {
                    getTemplate: function () {
                        return p || (p = new a(f)), p
                    }
                }), n.add("default#imageWithContent", l), t(l)
            });
        }],
        ['6@', function (ym) {
            ym.modules.define("layout.PieChart", ["layout.pieChart.builder", "layout.storage", "templateLayoutFactory", "util.dom.element", "util.dom.style", "data.Manager", "option.Manager", "shape.Circle", "geometry.pixel.Circle", "Monitor", "util.array", "layout.pieChart.html", "map.metaOptions", "layout.pieChart.css", "layout.pieChart.metaOptions"], function (t, e, i, a, r, o, n, s, p, h, u, l, d, c) {
                function C(t) {
                    return 2 * t.pieChartRadius + t.pieChartStrokeWidth
                }

                function f(t, e) {
                    if (t && "function" == typeof t.get) return t;
                    var i = e ? new s(t || {}) : new n(t || {});
                    return e && i.setParent(e), i
                }

                var g = ["pieChartRadius", "pieChartCoreRadius", "pieChartCoreFillStyle", "pieChartStrokeStyle", "pieChartStrokeWidth"],
                    y = {pieChartRadius: !0, pieChartCoreRadius: !0}, m = a.createClass(d, {
                        build: function () {
                            m.superclass.build.call(this);
                            var t = r.findByPrefixedClass(this.getParentElement(), "pie-chart"),
                                i = r.findByPrefixedClass(t, "pie-chart-icon"),
                                a = r.findByPrefixedClass(t, "pie-chart-content"), n = f(this.getData().properties),
                                s = this.getData().options, p = this._layoutParameters = this.getLayoutParameters(n, s),
                                h = this._propertiesMonitor = new u(n), l = this._optionsMonitor = new u(s), d = C(p),
                                c = Math.ceil(d / 2);
                            if (n.get("iconCaption")) {
                                var g = r.findByPrefixedClass(this.getParentElement(), "pie-chart-caption"),
                                    y = s.get("pieChartCaptionMaxWidth");
                                o.css(g, {
                                    top: c - 4 + "px",
                                    maxWidth: y + "px"
                                }), p.usedOptions.push("pieChartCaptionMaxWidth")
                            }
                            h.add(p.usedProperties, this.rebuild, this), l.add(p.usedOptions, this.rebuild, this);
                            var P = "url('" + e.getDataUri(p) + "')";
                            o.css(t, {
                                width: d + "px",
                                height: d + "px",
                                lineHeight: d + "px",
                                top: "-" + c + "px",
                                left: "-" + c + "px"
                            }), o.css(i, {backgroundImage: P, listStyleImage: P}), r.html(a, p.iconContent)
                        }, clear: function () {
                            this._propertiesMonitor.removeAll(), this._optionsMonitor.removeAll(), m.superclass.clear.call(this)
                        }, getShape: function () {
                            return new p(new h([0, 0], Math.ceil(C(this._layoutParameters) / 2)))
                        }, getLayoutParameters: function (t, e) {
                            var i = {usedProperties: [], usedOptions: []}, a = t.get("data"), r = this.getData().options;
                            if (a) i.usedProperties.push("data"); else {
                                a = [];
                                var o = {};
                                l.each(t.get("geoObjects"), function (t) {
                                    var e = f(t.options, r).get("iconColor");
                                    o[e] ? o[e]++ : o[e] = 1
                                });
                                for (var n in o) o.hasOwnProperty(n) && a.push({weight: o[n], color: n});
                                i.usedProperties.push("geoObjects")
                            }
                            "function" == typeof a && (a = a()), i.data = a, l.each(g, function (t) {
                                var a = e.get(t);
                                y[t] && "function" == typeof a && (a = a(i.data)), i.usedOptions.push(t), i[t] = a
                            });
                            var s = 0;
                            l.each(i.data, function (t) {
                                s += t.weight
                            }), i.count = s;
                            var p = t.get("iconContent");
                            return "undefined" != typeof p ? (i.usedProperties.push("iconContent"), i.iconContent = p) : i.iconContent = s.toString(), i
                        }
                    });
                i.add("default#pieChart", m), t(m)
            });
        }],
        ['7a', function (ym) {
            ym.modules.define("layout.storage", ["util.AsyncStorage"], function (e, o) {
                e(new o("layout"))
            });
        }],
        ['7e', function (ym) {
            ym.modules.define("layout.templateBased.Base", ["util.defineClass", "layout.Base", "util.dom.element", "util.dom.style", "util.extend", "util.array", "Event", "util.ContentSizeObserver", "event.Manager", "data.Manager", "data.Aggregator", "Monitor", "constants.mapDomEvents", "layout.storage", "event.Mapper", "layout.SubLayoutEventMappingTable", "localization.common.current", "util.shapeFactory", "util.cancelableCallback", "system.browser", "vow"], function (e, t, a, s, n, i, r, o, u, l, h, p, c, _, m, d, g, y, f, b, v, S) {
                function M(e, t) {
                    e = this.prepareData(e), M.superclass.constructor.call(this, e, t), this._renderedTemplate = null, this._sublayouts = null, this._oldShape = null, this._setupTemplateDataManager(e), this._sublayoutsEmptiness = this.calculateSublayoutsEmptiness(), this._emptiness = this.calculateEmptiness(), this.init()
                }

                function E(e) {
                    this._layout = e, this._monitors = {}
                }

                function D(e) {
                    this._layout = e, this._observers = {}, this._csoListeners = {}, this._layoutChangeListeners = {}
                }

                var C = /^parameters\./, T = /^data\./;
                t(M, a, {
                    init: function () {
                    }, setData: function (e) {
                        e = this.prepareData(e), this._clearTemplateDataManager(), this._setupTemplateDataManager(e), M.superclass.setData.call(this, e)
                    }, getTemplate: function () {
                    }, prepareData: function (e) {
                        return e
                    }, createTemplateDataManager: function (e) {
                        return new p(i({localization: new h(y), parameters: this.getParameters(), browser: v}, e))
                    }, destroyTemplateDataManager: function (e) {
                        e.destroy()
                    }, getSublayout: function (e) {
                        var t = this._findSublayout(e);
                        return t && t.instance
                    }, getSublayoutAsync: function (e) {
                        var t = this._findSublayout(e);
                        return t && t.deferred.promise()
                    }, _findSublayout: function (e) {
                        for (var t = this._getSublayouts(), a = 0, s = t.length; a < s; a++) if (t[a].name == e) return t[a];
                        return null
                    }, getElement: function () {
                        return this._element
                    }, build: function () {
                        var e = this._getRenderedTemplate();
                        this._element = s.create({
                            html: e.text,
                            parentNode: this.getParentElement(),
                            flags: {styleConvert: e.flags && e.flags.containsInlineStyle}
                        }), this._appendSubnodes(), this._appendSublayouts(), M.superclass.build.call(this)
                    }, clear: function () {
                        M.superclass.clear.call(this), this._clearSublayoutsParamsMonitorsManager(), this._clearSublayoutsSizeObserveManager(), this._clearSublayouts(), s.destroy(this._element), this._element = null
                    }, rebuild: function () {
                        this._freezeTemplateDataManager(), this.getParentElement() && this.clear(), this._destroySublayouts(), this._render(), this._createSublayouts(), this._updateEmptiness(), this.getParentElement() && this.build(), this._initSublayoutsSizeObserveManager(), this._fireChange(), this.testShapeChange(), this._unfreezeTemplateDataManager()
                    }, isEmpty: function () {
                        return this._emptiness
                    }, areSublayoutsEmpty: function () {
                        return this._sublayoutsEmptiness
                    }, calculateEmptiness: function () {
                        return this.isTemplateEmpty() && this.areSublayoutsEmpty()
                    }, isTemplateEmpty: function () {
                        return this._getRenderedTemplate().empty
                    }, calculateSublayoutsEmptiness: function () {
                        for (var e = this._getSublayouts(), t = 0, a = e.length; t < a; t++) {
                            var s = e[t];
                            if (s.isLoaded && !s.instance.isEmpty()) return !1
                        }
                        return !0
                    }, _updateEmptiness: function () {
                        var e = this._emptiness;
                        this._emptiness = this.calculateEmptiness(), e != this._emptiness && (this.onEmptinessChange(), this.events.fire("emptinesschange"))
                    }, onEmptinessChange: function () {
                    }, _updateSublayoutsEmptiness: function () {
                        var e = this._sublayoutsEmptiness;
                        this._sublayoutsEmptiness = this.calculateSublayoutsEmptiness(), e != this._sublayoutsEmptiness && (this.onSublayoutsEmptinessChange(), this._updateEmptiness())
                    }, onSublayoutsEmptinessChange: function () {
                    }, getShape: function () {
                        return this._shape && !this._shapeOptionsChanged() || (this._shape = this._createShape()), this._shape
                    }, _shapeOptionsChanged: function () {
                        var e = this.getData().options.get("shape");
                        return this._previousShapeOption != e && (this._previousShapeOption = e, !0)
                    }, _createShape: function () {
                        if (this.getData() && this.getData().options) {
                            var e = this.getData().options.get("shape");
                            if (e) return e.type && e.coordinates ? f.create(e) : e
                        }
                        return null
                    }, onDataChange: function () {
                        this._testValuesChanges() ? this.rebuild() : this._sublayouts && this._testSublayoutChanges()
                    }, _fireChange: function () {
                        this.events.fire("change")
                    }, onSublayoutSizeChange: function (e, t) {
                        n.css(e.instance.getParentElement(), {
                            display: "block",
                            width: Math.max(t.width, e.params.minWidth || 0) + "px",
                            height: Math.max(t.height, e.params.minHeight || 0) + "px",
                            overflowX: t.scrollX ? "auto" : "hidden",
                            overflowY: t.scrollY ? "auto" : "hidden"
                        }), this.testShapeChange()
                    }, destroy: function () {
                        this.getParentElement() && this.clear(), this._destroySublayouts(), this._clearTemplateDataManager()
                    }, setParentElement: function (e) {
                        this._renderedTemplate || (this._render(), this._createSublayouts()), this._freezeTemplateDataManager();
                        var t = this._parentElement != e;
                        M.superclass.setParentElement.call(this, e), t && (this._initSublayoutsSizeObserveManager(), this.testShapeChange()), this._unfreezeTemplateDataManager()
                    }, testShapeChange: function () {
                        var e = this._oldShape, t = this.getShape();
                        (!!e != !!t || e && t && !e.equals(t)) && (this._oldShape = t, this.events.fire("shapechange"))
                    }, _clearSublayouts: function () {
                        for (var e = this._getSublayouts(), t = 0, a = e.length; t < a; t++) {
                            var s = e[t];
                            if (s.isLoaded) {
                                var n = e[t].instance;
                                n.getParentElement() && n.setParentElement(null)
                            }
                        }
                    }, _render: function () {
                        this._renderedTemplate = this.getTemplate().build(this._templateDataManager)
                    }, _createSublayouts: function () {
                        var e = this._getRenderedTemplate().sublayouts;
                        this._sublayouts = [];
                        for (var t = 0, a = e.length; t < a; t++) {
                            var s = e[t], n = s.value, i = m.get(n, this.getData()), r = "undefined" != typeof i, o = {
                                isLoaded: r,
                                storageKey: n,
                                key: s.key,
                                id: s.id,
                                name: s.name || s.id,
                                params: s,
                                deferred: S.defer()
                            };
                            r ? (o.instance = this._createSublayoutInstance(i, o), o.deferred.resolve(o.instance), o.value = i) : this._createSublayoutRequest(o), this._sublayouts.push(o)
                        }
                    }, _createSublayoutRequest: function (e) {
                        var t = b.create(function (t) {
                            e.isLoaded = !0, e.instance = this._createSublayoutInstance(t, e), e.deferred.resolve(e.instance), e.value = t, this._element && this._appendSublayout(e), this._updateSublayoutsEmptiness(), this._initSublayoutsSizeObserveManager(), this.testShapeChange(), this._fireChange()
                        }, this);
                        m.require({keys: [e.storageKey], data: this.getData()}).spread(t).done(), e.onLoadCallback = t
                    }, _destroySublayouts: function () {
                        if (this._sublayouts) {
                            for (var e = 0, t = this._sublayouts.length; e < t; e++) {
                                var a = this._sublayouts[e];
                                a.isLoaded ? this._destroySublayoutInstance(a.instance) : a.onLoadCallback.cancel()
                            }
                            this._sublayouts = null
                        }
                    }, _createSublayoutInstance: function (e, t) {
                        if (ym.env.debug && "function" != typeof e) throw new Error("layout.templateBased.Base._createSublayoutInstance: Не удалось получить класс вложенного макета.");
                        t = t || {params: []};
                        var a = null, s = null;
                        for (var n in t.params) if (t.params.hasOwnProperty(n)) if (C.test(n)) {
                            a = a || {};
                            var r = n.replace(C, "");
                            a[r] = t.params[n]
                        } else if (T.test(n)) {
                            s = s || {};
                            var o = n.replace(T, "");
                            s[o] = t.params[n]
                        }
                        var u = s ? i({}, this.getData(), s) : this.getData(),
                            l = a ? i({}, this.getParameters(), a) : this.getParameters(), h = new e(u, l);
                        return h.events.setParent(new d(this.events, this.createSubLayoutEventMappingTable())).add("emptinesschange", this.onSublayoutEmptinessChange, this).add("shapechange", this.testShapeChange, this), h
                    }, _destroySublayoutInstance: function (e) {
                        e.events.remove("emptinesschange", this.onSublayoutEmptinessChange, this).remove("shapechange", this.testShapeChange, this).setParent(null), e.destroy()
                    }, createSubLayoutEventMappingTable: function () {
                        return new g(this)
                    }, onSublayoutEmptinessChange: function () {
                        this._updateSublayoutsEmptiness()
                    }, _appendSubnodes: function () {
                        for (var e = this._getRenderedTemplate().subnodes, t = 0, a = e.length; t < a; t++) {
                            var s = e[t], n = document.getElementById(s.parentId);
                            n.appendChild(s.element)
                        }
                    }, _appendSublayouts: function () {
                        for (var e = this._getSublayouts(), t = 0, a = e.length; t < a; t++) {
                            var s = e[t];
                            s.isLoaded && this._appendSublayout(s)
                        }
                    }, _appendSublayout: function (e) {
                        e.instance.setParentElement(document.getElementById(e.id)), e.params.monitorValues.length && (this._pmManager || this._setupSublayoutsParamsMonitorsManager(), this._pmManager.add(e)), e.params.observeSize && (this._ssoManager || this._setupSublayoutsSizeObserveManager(), this._ssoManager.add(e))
                    }, _clearSublayout: function (e) {
                        this._ssoManager && this._ssoManager.remove(e.name), this._pmManager && this._pmManager.remove(e.name), e.instance.setParentElement(null)
                    }, _removeSublayout: function (e) {
                        this._clearSublayout(e), this._destroySublayoutInstance(e.instance)
                    }, _setupSublayoutsParamsMonitorsManager: function () {
                        this._pmManager = new E(this)
                    }, _clearSublayoutsParamsMonitorsManager: function () {
                        this._pmManager && (this._pmManager.destroy(), this._pmManager = null)
                    }, _setupSublayoutsSizeObserveManager: function () {
                        this._ssoManager = new D(this)
                    }, _clearSublayoutsSizeObserveManager: function () {
                        this._ssoManager && (this._ssoManager.destroy(), this._ssoManager = null)
                    }, _initSublayoutsSizeObserveManager: function () {
                        this._ssoManager && this._ssoManager.init()
                    }, _setupTemplateDataManager: function (e) {
                        this._templateDataManager = this.createTemplateDataManager(e), this._templateDataManager.events.add("change", this.onDataChange, this)
                    }, _clearTemplateDataManager: function () {
                        this._templateDataManager.events.remove("change", this.onDataChange, this), this.destroyTemplateDataManager(this._templateDataManager)
                    }, _freezeTemplateDataManager: function () {
                        this._templateDataManager && this._templateDataManager.freeze()
                    }, _unfreezeTemplateDataManager: function () {
                        this._templateDataManager && this._templateDataManager.unfreeze()
                    }, _testValuesChanges: function () {
                        if (!this._renderedTemplate) return !1;
                        var e = this._renderedTemplate.renderedValues, t = this._templateDataManager;
                        for (var a in e) if (e.hasOwnProperty(a) && e[a].value !== t.get(a)) return !0;
                        return !1
                    }, _testSublayoutChanges: function () {
                        for (var e, t, a = !1, s = this._getSublayouts(), n = 0, i = s.length; n < i; n++) {
                            e = s[n];
                            var r = this._templateDataManager.get(e.key);
                            "undefined" != typeof r && (t = m.get(r, this.getData()), t ? t !== e.value && (e.isLoaded ? this._removeSublayout(e) : (e.onLoadCallback.cancel(), delete e.onLoadCallback), e.isLoaded = !0, e.value = t, e.instance = this._createSublayoutInstance(e.value), this._appendSublayout(e), a = !0) : (e.instance && this._removeSublayout(e), delete e.instance, delete e.value, e.isLoaded || e.onLoadCallback.cancel(), a = !0, e.isLoaded = !1, e.storageKey = r, this._createSublayoutRequest(e)))
                        }
                        a && this._fireChange()
                    }, _getRenderedTemplate: function () {
                        return this._renderedTemplate || this._render(), this._renderedTemplate
                    }, _getSublayouts: function () {
                        return this._sublayouts || this._createSublayouts(), this._sublayouts
                    }
                }), E.prototype = {
                    add: function (e) {
                        this.remove(e.name), this._monitors[e.name] = new c(this._layout._templateDataManager).add(e.params.monitorValues, this._layout.rebuild, this._layout)
                    }, remove: function (e) {
                        this._monitors[e] && this._monitors[e].removeAll()
                    }, destroy: function () {
                        r.each(this._monitors, function (e, t) {
                            this.remove(t)
                        }, this)
                    }
                }, D.prototype = {
                    init: function () {
                        for (var e in this._observers) this._observers.hasOwnProperty(e) && this.observe(e)
                    }, add: function (e) {
                        function t(e, t) {
                            return e = "undefined" != typeof e ? e : t, isNaN(e) ? t : e
                        }

                        var a = e.name, s = e.params;
                        this.remove(a), this._observers[a] = new u(e.instance.getParentElement(), {
                            maxWidth: t(s.maxWidth, 1 / 0),
                            maxHeight: t(s.maxHeight, 1 / 0),
                            scrollX: "undefined" == typeof s.scrollX || s.scrollX,
                            scrollY: "undefined" == typeof s.scrollY || s.scrollY
                        }), this._csoListeners[a] = this._observers[a].events.group().add("sizechange", function (t) {
                            this._layout.onSublayoutSizeChange(e, t.get("sizeByContent"))
                        }, this), this._layoutChangeListeners[a] = e.instance.events.group().add("change", function () {
                            this.observe(a)
                        }, this)
                    }, remove: function (e) {
                        this._observers[e] && this._observers[e].destroy(), this._csoListeners[e] && this._csoListeners[e].removeAll(), this._layoutChangeListeners[e] && this._layoutChangeListeners[e].removeAll()
                    }, observe: function (e) {
                        this._observers[e] && this._observers[e].observe()
                    }, destroy: function () {
                        r.each(this._observers, function (e, t) {
                            this.remove(t)
                        }, this)
                    }
                }, e(M)
            });
        }],
        ['9Y', function (ym) {
            ym.modules.define("LoadingObjectManager", ["util.defineClass", "event.Manager", "BaseObjectManager", "objectManager.component.OnceLoadingDataController", "objectManager.component.View", "objectManager.ObjectCollection", "objectManager.ClusterCollection", "component.child.MapChild", "objectManager.component.ObjectControllerAddon", "objectManager.component.TileSource", "util.extend", "Event", "yandex.counter"], function (e, t, n, o, a, s, r, l, i, d, c, h, u, g) {
                var C = function (e, t) {
                    this._urlTemplate = e, this.events = new n({context: this}), this._mapChildComponent = new i({
                        onMapChange: {
                            callback: this._onMapChange,
                            context: this
                        }, onParentChange: {callback: this._onParentChange, context: this}
                    }), this._objectsEditingEventManager = new n, this._clustersEditingEventManager = new n, this.objects = new r(this, this._objectsEditingEventManager), this.clusters = new l(this, this._clustersEditingEventManager), this._tileSource = new c(this), C.superclass.constructor.call(this, t, {
                        objects: this.objects,
                        clusters: this.clusters,
                        events: this.events,
                        addDisplayedObjects: {callback: this._addObjects, context: this},
                        removeDisplayedObjects: {callback: this._removeObjects, context: this},
                        removeAll: {callback: this._removeAllObjects, context: this}
                    }), this._view = null, this._dataLoadController = null, this._dataLoadControllerListener = null, this._objectControllerAddon = new d(this), g.countByKey("modulesUsage", "loadingObjectManager.create")
                };
                t(C, o, {
                    setUrlTemplate: function (e) {
                        this._urlTemplate = e
                    }, getUrlTemplate: function () {
                        return this._urlTemplate
                    }, getTileUrl: function (e) {
                        return this._tileSource.getTileUrl(e)
                    }, getPadding: function (e) {
                        return this._tileSource.getPadding(e)
                    }, getMap: function () {
                        return this._mapChildComponent.getMap()
                    }, getParent: function () {
                        return this._mapChildComponent.getParent()
                    }, setParent: function (e) {
                        return this._mapChildComponent.setParent(e), this
                    }, onAddToMap: function (e) {
                        this._setupView(), this._objectControllerAddon.setMap(e), this._objectControllerAddon.events.add("statechange", this._onObjectControllerStateChange, this), this._setupDataLoadController(), C.superclass.onAddToMap.call(this, e)
                    }, onRemoveFromMap: function (e) {
                        C.superclass.onRemoveFromMap.call(this, e), this._clearDataLoadController(), this._objectControllerAddon.events.remove("statechange", this._onObjectControllerStateChange, this), this._objectControllerAddon.setMap(null), this._clearView()
                    }, getObjectState: function (e) {
                        var t = C.superclass.getObjectState.call(this, e),
                            n = this._objectControllerAddon.getController(), o = n && n.getObjectState(e);
                        return o && (t = h(t, o)), t
                    }, reloadData: function () {
                        this._dataLoadController && this._dataLoadController.reloadData()
                    }, getBounds: function () {
                        return this._dataLoadController && this.objects.getLength() ? this._dataLoadController.getBounds() : null
                    }, getPixelBounds: function () {
                        return this._dataLoadController ? this._dataLoadController.getPixelBounds() : null
                    }, _setupDataLoadController: function () {
                        this._dataLoadController = new a(this), this._dataLoadControllerListener = this._dataLoadController.events.group().add("statechange", this._onDataLoadControllerStateChange, this).add("pixelboundschange", this._onDataLoadControllerBoundsChange, this)
                    }, _clearDataLoadController: function () {
                        this._dataLoadControllerListener.removeAll(), this._dataLoadController.destroy()
                    }, _onDataLoadControllerStateChange: function (e) {
                        var t = e.get("removed"), n = e.get("added");
                        t && this.objects.remove(t), n && this.objects.add(n)
                    }, _onDataLoadControllerBoundsChange: function () {
                        this.events.fire("pixelboundschange")
                    }, _setupView: function () {
                        this._view = new s(this, this._objectsEditingEventManager, this._clustersEditingEventManager)
                    }, _clearView: function () {
                        this._view.destroy()
                    }, _onMapChange: function (e, t) {
                        e && this.onRemoveFromMap(e), t && this.onAddToMap(t), this.events.fire("mapchange", {
                            oldMap: e,
                            newMap: t
                        })
                    }, _onParentChange: function (e, t) {
                        t && this.options.setParent(t.options), this.events.fire("parentchange", {
                            oldParent: e,
                            newParent: t
                        }), t || this.options.setParent(null)
                    }, _addObjects: function (e) {
                        this._objectControllerAddon.getController().add(e)
                    }, _removeObjects: function (e) {
                        this._objectControllerAddon.getController().remove(e)
                    }, _removeAllObjects: function (e) {
                        this._objectControllerAddon.getController().removeAll()
                    }, _onObjectControllerStateChange: function (e) {
                        var t = e.get("removedClusters"), n = e.get("addedClusters");
                        t && t.length && this._clustersEditingEventManager.fire("remove", new u({
                            target: this,
                            type: "remove",
                            clusters: t
                        })), n && n.length && this._clustersEditingEventManager.fire("add", new u({
                            target: this,
                            type: "add",
                            clusters: n
                        })), this._fireStateChange({
                            added: e.get("added"),
                            removed: e.get("removed"),
                            addedClusters: e.get("addedClusters"),
                            removedClusters: e.get("removedClusters"),
                            update: e.get("update"),
                            sync: e.get("sync")
                        })
                    }, _fireStateChange: function (e) {
                        this.events.fire("statechange", {
                            added: e.added || [],
                            removed: e.removed || [],
                            addedClusters: e.addedClusters || [],
                            removedClusters: e.removedClusters || [],
                            update: e.update || [],
                            sync: e.sync
                        })
                    }
                }), e(C)
            });
        }],
        ['7,', function (ym) {
            ym.modules.define("Map", ["util.defineClass", "map.Container", "map.Converter", "map.Copyrights", "map.ZoomRange", "map.metaOptions", "map.event.Manager", "map.behavior.Manager", "map.pane.Manager", "map.action.Manager", "map.layer.Manager", "pane.EventsPane", "data.Manager", "domEvent.manager", "constants.paneZIndex", "Event", "MapEvent", "event.Mapper", "event.globalize", "mapType.storage", "map.action.Single", "map.action.Sequence", "map.action.AreaRestrictionManager", "map.margin.Manager", "option.Manager", "map.optionMapper", "hotspot.Manager", "LayerCollection", "layer.storage", "constants.zIndex", "util.bounds", "util.requireCenterAndZoom", "util.coordinates.getClosestPixelPosition", "util.animation.getFlyingTicks", "util.math.areEqual", "util.dom.element", "vow", "getZoomRange", "map.GeoObjects", "control.Manager", "yandex.state.component.Map", "yandex.state.component.MapGeoObjects", "yandex.counter", "util.margin", "system.browser", "util.lazy", "vectorEngine.collectStatistics", "map.behavior.ScrollZoomController", "package.yandex"], function (e, t, n, i, o, s, a, r, h, l, c, g, u, p, m, d, _, v, y, f, M, C, b, T, x, w, P, z, S, Z, R, E, A, O, G, j, k, B, V, L, N, F, I, q, D, K, H, U, W) {
                function J(e, t, _) {
                    if (ym.env.debug) {
                        if (!e) throw new Error("Map.constructor: the map container is specified incorrectly");
                        if (!t) throw new Error("Map.constructor: incorrect map state")
                    }
                    var v = ym.performance.startMeasure("Map.sync");
                    this._rasterTilesReadyMeasure = ym.performance.startMeasure("Map.tiles"), this._vectorTilesReadyMeasure = ym.performance.startMeasure("Map.vectorTiles"), this._vectorRevealMeasure = ym.performance.startMeasure("Map.vectorReveal"), this._firstTileMeasure = ym.performance.startMeasure("Map.firstTile"), this.options = new w(_, a, "map", P), this.options.events.add("change", this._onOptionsChange, this), this.events = new r({
                        controllers: [X],
                        context: this
                    }), this.state = new p({margin: [0, 0, 0, 0]}), this.container = new n(e, this), this.container.events.setParent(new y(this.events, this.createEventMappingTable())), this.container.events.add("sizechange", this._onContainerSizeChange, this), this._containerSize = this.container.getSize(), this._containerEventListener = m.group(this.container.getElement()).add("mousedown", this._onContainerMouseDown, this, !0), this.converter = new i(this), this.margin = new x(this, t.margin), this.margin.events.add("change", this._onMarginChange, this);
                    var f, M, C, b = this.options.get("avoidFractionalZoom", !1), S = this.options.get("minZoom"),
                        Z = this.options.get("maxZoom");
                    t.bounds && (C = E.getCenterAndZoom(t.bounds, this.container.getSize(), this.options.get("projection"), {
                        preciseZoom: !b,
                        inscribe: !0,
                        margin: this.margin.getMargin()
                    })), C ? (f = C.zoom, M = C.center) : (f = t.zoom, M = t.center), this._zoom = Math.max(Math.min(Number(f), Z), S), b && (this._zoom = Math.round(this._zoom)), this._type = "undefined" != typeof t.type ? t.type : this.options.get("defaultMapType"), this._projection = this.options.get("projection");
                    var R = this._projection.toGlobalPixels(M, this._zoom), A = this.margin.getOffset();
                    this._globalPixelCenter = [R[0] - A[0], R[1] - A[1]], this._bounds = this.getBounds(), this.panes = new l(this);
                    var O = new u(this, {zIndex: d.events});
                    this.panes.append("events", O), this._hotspotManager = new z(O), this.cursors = O.cursors, this.action = new c(this), this.action.events.add("statechange", this._onActionChange, this).add(["begin", "tick", "tickcomplete", "break", "end", "render"], this._onAction, this), this.layers = new g(this), this._type && (this._setMapType(this._type), this._onTypeChange()), this.zoomRange = new s(this, ["undefined" == typeof S ? 0 : S, "undefined" == typeof Z ? 23 : Z]), this.zoomRange.addProvider(this.layers), this.copyrights = new o(this), this.copyrights.addProvider(this.layers), this.behaviors = new h(this, t.behaviors || "default"), this._restrictMapArea = new T(this), this.zoomRange.addProvider(this._restrictMapArea, !0), this.action.setupRestrictArea(this._restrictMapArea), this._createPanoramaManager(), this.geoObjects = new L(this), this.controls = new N(this, t && t.controls || this.options.get("defaultControls"), {
                        states: ["small", "medium", "large"],
                        margin: 10
                    }), this._yandexState = new F(this), this._yandexStateGeoObjects = new I(this.geoObjects), this._vectorOptionMonitor = this.options.getMonitor().add("vector", this._onVectorOptionChange, this), this.layers.events.once("vectorerror", function () {
                        this._vectorDisabledAfterError = !0, this._setMapType(this._type)
                    }, this), this._scrollZoomController = new W(this), this.events.fire("create", {
                        map: this,
                        state: t
                    }), q.countByKey("map", ["created", q.versionPrefix, K.platform].join(".")), q.isActiveCounter("map") && this.container.setupVisibilityTests(), this.events.add("contextmenu", this._onContextMenu, this), this._setupPerformanceMeasurement(), U(), v.finish()
                }

                function Q(e, t, n, i) {
                    var o = i ? i.totalTileNumber : null, s = 0;
                    t.events.add("tileloadchange", function a(i) {
                        var r = i.get("tileType") || "raster";
                        if (r == n) {
                            var h = i.get("totalTileNumber");
                            o = null === o ? h : o;
                            var l = i.get("readyTileNumber");
                            (o != h || s > l) && t.events.remove("tileloadchange", a), l == h && (e.finish(), t.events.remove("tileloadchange", a))
                        }
                    })
                }

                var X;
                J.TypeNotChangedError = function () {
                    return new Error("Type has not changed")
                }, X = f(J), t(J, {
                    getCenter: function (e) {
                        return this._projection.fromGlobalPixels(this.getGlobalPixelCenter(e), this._zoom)
                    }, setCenter: function (e, t, n) {
                        n = n || {};
                        var i = "undefined" == typeof t ? this._zoom : Number(t),
                            o = this._projection.toGlobalPixels(e, i);
                        return this.setGlobalPixelCenter(o, i, n)
                    }, panTo: function (e, t) {
                        t = t || {};
                        for (var n = B.defer(), i = e[0].length ? e : [e], o = [], s = this.container.getSize(), a = [2 * s[0], 2 * s[1]], r = "undefined" == typeof t.flying || t.flying, h = "undefined" == typeof t.safe || t.safe, l = 0, c = i.length; l < c; l++) o.push({
                            center: i[l],
                            delay: l > 0 ? "undefined" == typeof t.delay ? 1e3 : t.delay : 0,
                            zoom: this._zoom,
                            duration: "undefined" == typeof t.duration ? 500 : t.duration,
                            checkZoomRange: t.checkZoomRange,
                            useMapMargin: t.useMapMargin,
                            timingFunction: t.timingFunction || "ease-in-out"
                        });
                        for (var g = this._globalPixelCenter, l = 0, c = o.length; l < c; l++) {
                            var u = o[l], p = this._projection.toGlobalPixels(u.center, this._zoom);
                            if (u.globalPixelCenter = O(g, p, this._zoom, this._projection), !r && h) {
                                var m = [Math.abs(u.globalPixelCenter[0] - g[0]), Math.abs(u.globalPixelCenter[1] - g[1])];
                                (m[0] > a[0] || m[1] > a[1]) && (u.duration = 0)
                            }
                            g = u.globalPixelCenter
                        }
                        r && (o = G(o, this));
                        var d = new b(o, {callback: this._createActionEndCallback(n)});
                        return d.begin(this.action), n.promise()
                    }, getBounds: function (e) {
                        return E.fromGlobalPixelBounds(this.getGlobalPixelBounds(e), this.getZoom(), this._projection)
                    }, getGlobalPixelBounds: function (e) {
                        var t = this.getGlobalPixelCenter(e), n = this.container.getSize();
                        if (e && e.useMapMargin) {
                            var i = this.margin.getMargin();
                            n = [n[0] - (i[1] + i[3]), n[1] - (i[0] + i[2])]
                        }
                        var o = [[t[0] - .5 * n[0], t[1] - .5 * n[1]], [t[0] + .5 * n[0], t[1] + .5 * n[1]]];
                        return o
                    }, setBounds: function (e, t) {
                        if (t = t || {}, t.zoomMargin && (t.margin = t.zoomMargin, this.options.get("avoidFractionalZoom", !1) && (t.preciseZoom = !1)), t.useMapMargin && (t.margin = D.sum([t.margin || 0, this.margin.getMargin()]), t.useMapMargin = !1), t.projection = this._projection, t.checkZoomRange) {
                            var n = B.defer();
                            return A(this.zoomRange, e, this.container.getSize(), t).then(function (e) {
                                n.resolve(this.setCenter(e.center, e.zoom, t))
                            }, function (e) {
                                n.reject(e)
                            }, this), n.promise()
                        }
                        var i = E.getCenterAndZoom(e, this.container.getSize(), this._projection, t);
                        return this.setCenter(i.center, i.zoom, t)
                    }, getGlobalPixelCenter: function (e) {
                        var t = this._globalPixelCenter.slice();
                        if (e && e.useMapMargin) {
                            var n = this.margin.getMargin();
                            t[0] += (n[3] - n[1]) / 2, t[1] += (n[0] - n[2]) / 2
                        }
                        return t
                    }, setGlobalPixelCenter: function (e, t, n) {
                        n = n || {};
                        var i = B.defer();
                        return this.action.execute(new C({
                            globalPixelCenter: e.slice(),
                            zoom: "undefined" != typeof t ? t : this._zoom,
                            duration: n.duration || 0,
                            callback: this._createActionEndCallback(i),
                            checkZoomRange: n.checkZoomRange,
                            useMapMargin: n.useMapMargin,
                            timingFunction: n.timingFunction
                        })), i.promise()
                    }, getZoom: function () {
                        return this._zoom
                    }, setZoom: function (e, t) {
                        e = Math.min(Math.max(e, this.options.get("minZoom", 0)), this.options.get("maxZoom", 23));
                        var n = this.getGlobalPixelCenter(t), i = Math.pow(2, e - this.getZoom());
                        return n = [n[0] * i, n[1] * i], this.setGlobalPixelCenter(n, e, t)
                    }, _createPanoramaManager: function () {
                        this._getPanoramaManagerLazy = H(function () {
                            return new B.Promise(function (e) {
                                ym.modules.require(["panorama.Manager"], e)
                            }).then(function (e) {
                                var t = new e(e.USE_MAP_CONTAINER, this), n = this;
                                return t.events.setParent(new y(this.events, {
                                    "*": function (e) {
                                        return new _({
                                            type: "panoramamanager" + e.get("type"),
                                            target: n,
                                            originalTarget: t
                                        })
                                    }
                                })), t
                            }, this)
                        }, this)
                    }, _onContainerSizeChange: function (e) {
                        var t = this._bounds, n = e.get("oldOffset"), i = e.get("oldSize");
                        this._containerSize = this.container.getSize(), this.events.fire("sizechange", {
                            map: this,
                            oldSize: i,
                            newSize: e.get("newSize")
                        });
                        var o = this._zoom, s = this.getCenter(), a = this._globalPixelCenter;
                        if (e.get("preservePixelPosition")) {
                            this.action.stop(), a = this._globalPixelCenter;
                            var r = [n[0] + i[0] / 2, n[1] + i[1] / 2],
                                h = this.converter.globalToPage(this._globalPixelCenter), l = r[0] - h[0],
                                c = r[1] - h[1];
                            this.setGlobalPixelCenter([a[0] - l, a[1] - c])
                        } else {
                            this._bounds = this.getBounds();
                            var g = this.getCenter(), u = this._globalPixelCenter;
                            this.events.fire("boundschange", {
                                map: this,
                                oldZoom: o,
                                newZoom: o,
                                oldCenter: s,
                                newCenter: g,
                                oldGlobalPixelCenter: a,
                                newGlobalPixelCenter: u,
                                oldBounds: t,
                                newBounds: this._bounds
                            })
                        }
                    }, getPanoramaManager: function () {
                        return this._getPanoramaManagerLazy()
                    }, getType: function () {
                        return this._type
                    }, setType: function (e, t) {
                        if (this._type == e && this._vectorMapTypeShown == this._needsToTurnOnVector()) return B.reject(J.TypeNotChangedError());
                        var n = t && t.checkZoomRange, i = B.defer();
                        return n ? V(e, this.getCenter(), this.layers).then(function (t) {
                            var n = this.getZoom();
                            this.setZoom(t[0] > n ? t[0] : t[1] < n ? t[1] : n), this._type == e && this._vectorMapTypeShown == this._needsToTurnOnVector() || this._setMapType(e), i.resolve()
                        }, this) : (this._setMapType(e), i.resolve()), i.promise()
                    }, _setMapType: function (e) {
                        var t = this._type;
                        t && this._removeType(), this._type = e, this._vectorMapTypeShown = this._needsToTurnOnVector(), e && this._addType(), this._onTypeChange(), this.events.fire("typechange", {map: this})
                    }, _addType: function () {
                        var e = "string" == typeof this._type ? M.get(this._type) : this._type, t = new S({
                            zIndex: R.mapTypeLayer,
                            tilesRoundingMethod: this.options.get("tilesRoundingMethod")
                        }), n = this._needsToTurnOnVector() ? e.getVectorLayers() : null;
                        n = n || e.getLayers();
                        for (var i = 0, o = n.length; i < o; i++) {
                            var s = "string" == typeof n[i] ? Z.get(n[i]) : n[i], a = new s;
                            t.add(a)
                        }
                        this._layerCollection = t, this.layers.add(t)
                    }, _removeType: function () {
                        this._layerCollection && (this._layerCollection.removeAll(), this.layers.remove(this._layerCollection), this._layerCollection = null)
                    }, _onVectorOptionChange: function () {
                        this._vectorDisabledAfterError || this._setMapType(this._type)
                    }, _onOptionsChange: function () {
                        this.events.fire("optionschange")
                    }, _onAction: function (e) {
                        var t = "action" + e.get("type");
                        this.events.fire(t, {map: this, action: e.get("action"), tick: e.get("tick")})
                    }, _onActionChange: function (e) {
                        var t, n = this.getCenter(), i = this._bounds, o = this._zoom, s = this._containerSize,
                            a = this.container.getSize(), r = this._globalPixelCenter, h = e.get("globalPixelCenter"),
                            l = e.get("zoom"), c = Math.pow(2, l - this.options.get("maxZoom"));
                        o == l && j(s, a) && j(r, h, c) || (this._globalPixelCenter = h, this._zoom = l, this._bounds = this.getBounds(), this._containerSize = a, t = this.getCenter(), this.events.fire("boundschange", {
                            map: this,
                            oldCenter: n,
                            newCenter: t,
                            oldGlobalPixelCenter: r,
                            newGlobalPixelCenter: this._globalPixelCenter,
                            oldZoom: o,
                            newZoom: this._zoom,
                            oldBounds: i,
                            newBounds: this._bounds
                        }))
                    }, _createActionEndCallback: function (e) {
                        return function (t) {
                            t ? e.reject(t) : e.resolve()
                        }
                    }, _setupPerformanceMeasurement: function () {
                        this.layers.events.once("vectorreveal", function () {
                            this._vectorRevealMeasure.finish()
                        }, this);
                        var e = "yandex#map" == this._type ? this._layerCollection.get(0) : null;
                        if (e) {
                            var t = "vector" == e.constructor.layerType;
                            if (t) {
                                var n = e.getVectorTileStatus();
                                Q(this._vectorTilesReadyMeasure, e, "vector", n)
                            }
                            var i = t ? e.getRasterTileStatus() : e.getTileStatus();
                            Q(this._rasterTilesReadyMeasure, e, "raster", i), e.events.once("tileready", function () {
                                this._firstTileMeasure.finish()
                            }, this)
                        }
                    }, createEventMappingTable: function () {
                        return {
                            _map: this, "*": function (e) {
                                var t = null;
                                return e.isMapEventAllowed() && (t = new v({
                                    type: e.get("type"),
                                    target: this._map,
                                    map: this._map
                                }, e)), t
                            }, sizechange: !1
                        }
                    }, destroy: function () {
                        this._scrollZoomController.destroy(), this.controls.destroy(), this._containerEventListener.removeAll(), this._type && this._removeType(), this._restrictMapArea.destroy(), this.action.events.remove("statechange", this._onActionChange, this).remove(["begin", "tick", "tickcomplete", "break", "end"], this._onAction, this), this._hotspotManager.destroy(), this.panes.destroy(), this.margin.events.remove("change", this._onMarginChange, this), this.margin.destroy(), this.container.events.setParent(null), this.container.events.remove("sizechange", this._onContainerSizeChange, this), this.container.destroy(), this.options.events.remove("change", this._onOptionsChange, this), this._vectorOptionMonitor.remove("vector", this._onVectorOptionChange, this), this._yandexState && this._yandexState.destroy(), this._yandexStateGeoObjects && this._yandexStateGeoObjects.destroy(), this._yandexState = null, this._yandexStateGeoObjects = null, this._singleContextMenuTimer && clearTimeout(this._singleContextMenuTimer), this.events.remove("contextmenu", this._onContextMenu, this), this.events.remove("typechange", this._toggleSmoothZoomIfVectorAndTypeScheme, this), this.events.fire("destroy", {map: this}), this.options.setParent(null)
                    }, _onContainerMouseDown: function (e) {
                        if (this.options.get("mapAutoFocus", !0)) {
                            var t = document.activeElement;
                            e.get("target") != t && (t != document.body && k.isHTMLElement(t) && t.blur(), K.isIE && window.focus())
                        }
                    }, _onMarginChange: function (e) {
                        this.events.fire("marginchange")
                    }, _onContextMenu: function () {
                        this._singleContextMenuTimer ? (clearTimeout(this._singleContextMenuTimer), this._singleContextMenuTimer = null) : this._singleContextMenuTimer = window.setTimeout(function () {
                            this._singleContextMenuTimer = null, q.countByKey("control", "singleContextmenu")
                        }.bind(this), this.options.get("dblClickTimeout", 400))
                    }, _onTypeChange: function () {
                        var e = Boolean(this._needsToTurnOnVector());
                        this.state.set("vectorEnabled", e), e ? (this._oldTilesRoundingMethod = this.options.set("tilesRoundingMethod", "round"), this.options.set("tilesRoundingMethod", function (e) {
                            return e - Math.floor(e) < .75 ? Math.floor(e) : Math.ceil(e)
                        })) : this._oldTilesRoundingMethod && (this.options.set("tilesRoundingMethod", this._oldTilesRoundingMethod), this._oldTilesRoundingMethod = null), this.state.set({useOverlayMovablePaneWhenPossible: this.state.get("vectorEnabled")});
                        var t = this.getZoom();
                        this.options.get("scrollZoomSmooth", !1) && "yandex#map" != this.getType() && t % 1 != 0 && this.setZoom(Math.round(t))
                    }, _needsToTurnOnVector: function () {
                        return "yandex#map" == this.getType() && this.options.get("vector") && ym.supports.vector.isSupported() && !this._vectorDisabledAfterError
                    }
                }), ym.modules.require("vectorEngine.collectStatistics"), e(J)
            });
        }],
        ['7S', function (ym) {
            ym.modules.define("map.action.Continuous", ["util.defineClass", "map.action.Base", "Event"], function (i, t, e, n) {
                function s() {
                    s.superclass.constructor.call(this)
                }

                t(s, e, {
                    begin: function (i) {
                        return s.superclass.begin.call(this, i), this
                    }, tick: function (i) {
                        if (!this.isActive()) {
                            var t = this._activeBehavior ? this._activeBehavior.createOptionManager(null).getName() : "unknown";
                            throw new Error("map.action.Continuous: ticking while inactive. browser:" + ym.env.browser.name + " behavior:" + t)
                        }
                        return this._fireTick(this.fixTick(i, this.getActionManager())), this
                    }, end: function () {
                        return s.superclass.end.call(this), this
                    }, _fireTick: function (i) {
                        this.events.fire("tick", new n({type: "tick", target: this, tick: i}))
                    }
                }), i(s)
            });
        }],
        ['7T', function (ym) {
            ym.modules.define("map.action.Manager", ["util.defineClass", "event.Manager", "Event", "util.extend", "util.coordinates.scaleInvert", "util.math.cubicBezier", "util.scheduler.timescheduler", "util.scheduler.manager", "util.scheduler.world"], function (t, i, e, o, n, s, r, a, c, h) {
                var l = function (t) {
                    this.events = new e({context: this}), this._map = t, this._globalPixelCenter = t.getGlobalPixelCenter(), this._zoom = t.getZoom(), this._userCorrection = null, this._restrictMapArea = null, this._action = null, this._actionTick = null, this._actionListeners = null, this._delayedActionsQueue = [], this._mapListener = this._map.events.group().add("destroy", this._onDestroy, this)
                };
                i(l, {
                    execute: function (t) {
                        this._actionEnds ? this._delayedActionsQueue.push(t) : (this.stop(), h.smoothMode(!0), this._action = t, this._actionListeners = t.events.group().add("tick", this._onActionTick, this).add("end", this._onActionEnd, this).add("break", this.breakTick, this), this.events.fire("begin", new o({
                            type: "begin",
                            target: this,
                            action: t
                        })), t.begin(this))
                    }, stop: function () {
                        this._action && (this._actionListeners.removeAll(), this._action.end(), this._onActionEnd())
                    }, breakTick: function () {
                        this._actionTick && this._stopTick()
                    }, _onActionTick: function (t) {
                        var i = t.get("target"), e = t.get("tick"), n = this._getCorrectedTick(e);
                        (this._actionTick || i != this._action) && this._stopTick();
                        var s = Math.abs(n.duration) < 1e-7;
                        s ? (this._globalPixelCenter = n.globalPixelCenter, this._zoom = n.zoom) : this._actionTick = {
                            startTime: a.getSelfTime(),
                            timeout: window.setTimeout(function () {
                                this._actionTick = null, this._globalPixelCenter = n.globalPixelCenter, this._zoom = n.zoom, this.events.fire("tickcomplete", {
                                    action: this._action,
                                    tick: n
                                })
                            }.bind(this), n.duration),
                            shedulerProcess: c.schedule("processing", function () {
                            }, this, {duration: n.duration}),
                            data: n
                        }, this.events.fire("tick", new o({
                            type: "tick",
                            target: this,
                            action: this._action,
                            tick: n
                        })), this._renderTick(), s && this.events.fire("tickcomplete", new o({
                            type: "tickcomplete",
                            target: this,
                            action: this._action,
                            tick: n
                        }))
                    }, getMap: function () {
                        return this._map
                    }, setupRestrictArea: function (t) {
                        this._restrictMapArea = t
                    }, getCurrentState: function () {
                        var t = this._getCurrentTick();
                        return {
                            isTicking: !!this._actionTick,
                            tickProgress: t.tickProgress,
                            zoom: t.zoom,
                            globalPixelCenter: t.globalPixelCenter
                        }
                    }, _onActionEnd: function () {
                        if (this._action) {
                            this._actionEnds = !0;
                            var t = this._action;
                            if (this._actionListeners.removeAll(), this._stopTick(), this._map.options.get("avoidFractionalZoom") && this._roundZoom(), this._action = null, this._applyBounds(), this.events.fire("end", new o({
                                type: "end",
                                target: this,
                                action: t
                            })), h.smoothMode(!1), this._renderTick(), this._actionEnds = !1, this._delayedActionsQueue.length) for (var i; i = this._delayedActionsQueue.shift();) this.execute(i), this._delayedActionsQueue.length && this.stop()
                        }
                    }, _stopTick: function (t) {
                        if (this._actionTick) {
                            var i = this._getCurrentTick();
                            this._globalPixelCenter = i.globalPixelCenter, this._zoom = i.zoom, window.clearTimeout(this._actionTick.timeout), this._actionTick.shedulerProcess.stop(), this._actionTick = null
                        }
                    }, _renderTick: function () {
                        this.events.fire("render", new o({type: "render", target: this}))
                    }, _getCurrentTick: function () {
                        if ("undefined" == typeof this._zoom && (this._zoom = this._map.getZoom()), !this._actionTick) return {
                            tickProgress: null,
                            zoom: this._zoom,
                            globalPixelCenter: this._globalPixelCenter
                        };
                        var t, i = this._actionTick, e = i.data,
                            o = r(e.timingFunction).getValue(Math.min(Math.max(a.getSelfTime() - i.startTime, 0) / e.duration, 1)),
                            n = this._zoom, c = this._globalPixelCenter, h = e.zoom, l = e.globalPixelCenter, _ = h - n,
                            u = n + o * _;
                        if (Math.abs(_) > 1e-7) {
                            var m = Math.pow(2, _), d = Math.pow(2, u - n), g = [l[0] / m, l[1] / m],
                                p = s.centerToFixed(c, g, m), f = [p[0] / m, p[1] / m];
                            t = s.fixedToCenter(c, f, d)
                        } else t = [c[0] + o * (l[0] - c[0]), c[1] + o * (l[1] - c[1])];
                        return {tickProgress: o, zoom: u, globalPixelCenter: t}
                    }, _applyBounds: function () {
                        this.events.fire("statechange", new o({
                            type: "statechange",
                            target: this,
                            globalPixelCenter: this._globalPixelCenter,
                            zoom: this._zoom
                        }))
                    }, _roundZoom: function () {
                        var t = Math.round(this._zoom);
                        if (this._zoom != t) {
                            var i = Math.pow(2, t - this._zoom),
                                e = [this._globalPixelCenter[0] * i, this._globalPixelCenter[1] * i];
                            this._globalPixelCenter = e, this._zoom = t
                        }
                    }, setCorrection: function (t) {
                        this._userCorrection = t
                    }, _zoomAndDelayCorrection: function (t) {
                        var i = t.zoom, e = this._map.options, o = e.get("maxZoom", 23), n = e.get("minZoom", 0),
                            s = Math.max(Math.min(i, o), n), r = e.get("maxAnimationZoomDifference", 5),
                            a = Math.abs(s - this._map.getZoom()) < r ? t.duration : 0;
                        if (this._restrictMapArea && (s = this._restrictMapArea.fixZoom(s)), Math.abs(t.zoom - s) > 1e-7 || a != t.duration) {
                            var c = Math.pow(2, s - i);
                            t.globalPixelCenter = [t.globalPixelCenter[0] * c, t.globalPixelCenter[1] * c], t.zoom = s, t.duration = a
                        }
                    }, _getCorrectedTick: function (t) {
                        var i = n({}, t);
                        return this._zoomAndDelayCorrection(i), this._restrictMapArea && this._restrictMapArea.correctTick(i), this._userCorrection && (i = this._userCorrection(n({}, i))), i
                    }, _onDestroy: function () {
                        this._mapListener.removeAll()
                    }
                }), t(l)
            });
        }],
        ['7V', function (ym) {
            ym.modules.define("map.action.Single", ["util.defineClass", "map.action.Base", "Event"], function (i, t, e, o) {
                function c(i) {
                    c.superclass.constructor.call(this), this._originalTick = i, this._activeTick = null, this._tickDelayTimeoutID = 0, this._zoomRangeChecking = !1, this._tickFiring = !1
                }

                t(c, e, {
                    begin: function (i) {
                        c.superclass.begin.call(this, i);
                        var t = this._originalTick;
                        if (t.checkZoomRange) {
                            this._zoomRangeChecking = !0;
                            var e = this._getActiveTick(), o = i.getMap();
                            o.zoomRange.get(o.options.get("projection").fromGlobalPixels(e.globalPixelCenter, e.zoom)).then(this._zoomRangeGetCallback, this)
                        } else t.useMapMargin && this._applyMargin();
                        return "number" == typeof t.delay && (this._tickDelayTimeoutID = window.setTimeout(this._onTickDelayTimeout.bind(this), t.delay)), this._fireTick(), this
                    }, end: function () {
                        return this._tickDelayTimeoutID && (window.clearTimeout(this._tickDelayTimeoutID), this._tickDelayTimeoutID = 0), this._completeTick(), this
                    }, _getActiveTick: function () {
                        return this._activeTick || (this._activeTick = this.fixTick(this._originalTick, this.getActionManager()))
                    }, _zoomRangeGetCallback: function (i) {
                        this._zoomRangeChecking = !1, this.isActive() && (this._correctZoom(i[0], i[1]), this._originalTick.useMapMargin && this._applyMargin(), this._fireTick())
                    }, _onTickDelayTimeout: function () {
                        this._tickDelayTimeoutID = 0, this._fireTick()
                    }, _fireTick: function () {
                        this._zoomRangeChecking || this._tickDelayTimeoutID || (this.getActionManager().events.add("tickcomplete", this._onTickComplete, this), this._tickFiring = !0, this.events.fire("tick", new o({
                            type: "tick",
                            target: this,
                            tick: this._getActiveTick()
                        })))
                    }, _onTickComplete: function (i) {
                        i.get("action") == this && this._completeTick()
                    }, _completeTick: function () {
                        this._tickFiring && (this._tickFiring = !1, this.getActionManager().events.remove("tickcomplete", this._onTickComplete, this)), this._activeTick = null, c.superclass.end.call(this), this._originalTick.callback && this._originalTick.callback(null)
                    }, _correctZoom: function (i, t) {
                        var e = this._getActiveTick(), o = Math.min(t, Math.max(i, e.zoom));
                        if (o != e.zoom) {
                            var c = Math.pow(2, o - e.zoom);
                            e.globalPixelCenter[0] *= c, e.globalPixelCenter[1] *= c, e.zoom = o
                        }
                    }, _applyMargin: function () {
                        var i = this.getActionManager().getMap(), t = i.margin.getMargin(), e = this._getActiveTick();
                        this._correctZoom(i.options.get("minZoom", 0), i.options.get("maxZoom", 23)), e.globalPixelCenter[0] -= (t[3] - t[1]) / 2, e.globalPixelCenter[1] -= (t[0] - t[2]) / 2
                    }
                }), i(c)
            });
        }],
        ['7W', function (ym) {
            ym.modules.define("map.addon.balloon", ["Map", "popup.addonBuilder", "map.Balloon"], function (e, a, n, o) {
                e(n.build({
                    type: "balloon",
                    metaEventManager: a.getMetaEventManager(),
                    fireEvents: ["open", "close", "setdata", "setposition"]
                }))
            });
        }],
        ['7X', function (ym) {
            ym.modules.define("map.addon.hint", ["Map", "popup.addonBuilder", "map.Hint"], function (e, n, a, t) {
                e(a.build({type: "hint", metaEventManager: n.getMetaEventManager()}))
            });
        }],
        ['7$', function (ym) {
            ym.modules.define("map.Copyrights", ["component.ProviderObserver", "map.copyrights.StaticProvider", "map.copyrights.Layout", "map.copyrights.Promo", "event.Manager", "data.Manager", "projection.wgs84Mercator", "projection.sphericalMercator", "vow", "util.dom.element", "util.math.differ", "Monitor", "util.defineClass", "yandex.counter"], function (t, e, i, s, o, n, r, a, h, g, p, c, u, l, _) {
                var y = .499999, d = 400, m = ym.env.hosts.api.ua.replace("{{lang}}", ym.env.languageCode),
                    f = function (t) {
                        this._map = t, this.events = new n({context: this}), this._copyrightsObserver = new e({
                            changeEventType: "copyrightschange",
                            changeCallback: this._updateCopyrights.bind(this),
                            makeRequest: function (t, e) {
                                return t.getCopyrights(e.center, e.zoom)
                            }
                        });
                        var i = t.options;
                        this._dataSet = new r({
                            copyrights: [],
                            bright: t.layers.getBrightness() > y,
                            "float": i.get("copyrightFloat", "right"),
                            logo: this._isLogoVisible(),
                            userAgreementLink: m
                        }), this._state = new r({
                            size: t.container.getSize()[0] > d ? "large" : "small",
                            copyrightsWidth: null
                        }), this._layout = null, this._actualRequest = null, this._mapListeners = null, this._mapLayerListeners = null, this._mapOptionsMonitor = null, this._stateMonitor = null, this._promoBlock = null, this._setupLayout(), this._setupPromo(), this._setupListeners(), this.get()
                    };
                l(f, {
                    addProvider: function (t) {
                        if (ym.env.debug && "function" != typeof t.getCopyrights) throw new Error("map.Copyrights.addProvider: parameter doesn't implement ICopyrightsProvider interface");
                        return this._copyrightsObserver.addProvider(t), this
                    }, removeProvider: function (t) {
                        return this._copyrightsObserver.removeProvider(t), this
                    }, add: function (t) {
                        var e = new i(t, this);
                        return this.addProvider(e), e
                    }, get: function (t, e) {
                        var i = g.defer(), s = this._map;
                        return this._copyrightsObserver.get({
                            center: t || s.getCenter({useMapMargin: s.options.get("coverageUseMapMargin", !0)}),
                            zoom: "undefined" == typeof e ? s.getZoom() : e
                        }).then(function (t) {
                            i.resolve([].concat.apply([], t.resolved))
                        }, function () {
                            i.resolve([])
                        }), i.promise()
                    }, getMap: function () {
                        return this._map
                    }, getState: function () {
                        return this._state
                    }, getPromoLink: function () {
                        return _.countByKey("distribution", "getPromoLink"), this._promoBlock.getLink()
                    }, togglePromo: function (t) {
                        this._promoBlock && this._promoBlock.toggle(t)
                    }, checkVisibility: function () {
                        this._layout.checkVisibility()
                    }, _setupListeners: function () {
                        var t = this._map;
                        this._mapListeners = t.events.group().add("boundschange", this._onBoundsChange, this).add("destroy", this._onMapDestroy, this).add("sizechange", this._onMapSizeChange, this), this._mapLayerListeners = t.layers.events.group().add("brightnesschange", this._onBrightnessChange, this), this._mapOptionsMonitor = new u(t.options).add("copyrightFloat", this._onCopyrightsFloatChange, this).add(["copyrightLogoVisible", "suppressMapOpenBlock"], this._setCopyrightsLogoVisibleState, this)
                    }, _clearListeners: function () {
                        this._mapLayerListeners.removeAll(), this._mapListeners.removeAll(), this._mapOptionsMonitor.destroy()
                    }, _setupPromo: function () {
                        var t = this._layout.getParentElement();
                        this._promoBlock = new o(t, this)
                    }, _clearPromo: function () {
                        this._promoBlock.destroy(), this._promoBlock = null
                    }, _onMapDestroy: function () {
                        this._clearPromo(), this._clearListeners(), this._clearLayout(), this._actualRequest = null, this._copyrightsObserver.destroy()
                    }, _onMapSizeChange: function (t) {
                        var e = t.get("newSize")[0] > d ? "large" : "small";
                        this._state.set("size", e)
                    }, _setupLayout: function () {
                        var t = this._map;
                        this._layout = new s({
                            data: this._dataSet,
                            state: this._state,
                            map: t
                        }), this._layout.setParentElement(t.panes.get("copyrights").getElement())
                    }, _clearLayout: function () {
                        this._layout.destroy()
                    }, _updateCopyrights: function () {
                        var t = this._actualRequest = this.get();
                        t.then(function (e) {
                            t == this._actualRequest && this._onCopyrightsReady(t, e)
                        }, this)
                    }, _onCopyrightsReady: function (t, e) {
                        var i = this._dataSet.get("copyrights"), s = c(e, i);
                        s && this._onCurrentCopyrightsChange(i, e)
                    }, _onCurrentCopyrightsChange: function (t, e) {
                        this._dataSet.set("copyrights", e), this.events.fire("change", {
                            oldCopyrights: t.slice(),
                            newCopyrights: e.slice()
                        })
                    }, _onBoundsChange: function () {
                        this._updateCopyrights()
                    }, _onBrightnessChange: function () {
                        this._dataSet.set("bright", this._map.layers.getBrightness() > y)
                    }, _onCopyrightsFloatChange: function (t) {
                        this._dataSet.set("float", t)
                    }, _setCopyrightsLogoVisibleState: function () {
                        this._dataSet.set("logo", this._isLogoVisible())
                    }, _isLogoVisible: function () {
                        var t = this._map.options, e = t.get("copyrightLogoVisible", !0),
                            i = t.get("suppressMapOpenBlock", !1), s = t.get("projection"),
                            o = !i && (s == a || s == h);
                        return e && !o
                    }
                }), t(f)
            });
        }],
        ['7*', function (ym) {
            ym.modules.define("map.GeoObjects", ["util.defineClass", "map.GeneralCollection", "geoObject.component.BoundsAggregator", "GeoObjectCollection", "map.optionMapper", "geoObject.optionMapper", "component.array.ParentArray", "event.Mapper", "geoObject.EventMappingTable", "Event", "option.Mapper", "error"], function (e, t, n, r, o, i, a, s, c, h, u, l, d) {
                function p(e, t) {
                    p.superclass.constructor.call(this, e, t, "geoObject", a), this._parentArray = new s([], this, {
                        onAdd: {
                            callback: this._onAdd,
                            context: this
                        },
                        onRemove: {callback: this._onRemove, context: this},
                        onSet: {callback: this._onSet, context: this}
                    }, new c(this.events, new h(this))), this._boundsAggregator = new r(this, {
                        onPixelBoundsChange: {
                            callback: this._pixelBoundsChangeCallback,
                            context: this
                        }, onGeoBoundsChange: {callback: this._geoBoundsChangeCallback, context: this}
                    })
                }

                function g(e, t) {
                    return 0 == e.indexOf("editor") ? l.addOptionalPrefix(e, t) : l.addOptionalPrefixForBalloonHint(e, t)
                }

                t(p, n, {
                    get: function (e) {
                        return this._parentArray.get(e)
                    }, set: function (e, t) {
                        return this._parentArray.set(e, t), this
                    }, add: function (e, t) {
                        return this._parentArray.add(e, t), this
                    }, remove: function (e) {
                        return this._parentArray.indexOf(e) == -1 ? d.warn("OveruseWarning", "map.GeoObjects.remove: удаляемый объект не найден") : this._parentArray.remove(e), this
                    }, removeAll: function () {
                        return this._parentArray.removeAll(), this
                    }, splice: function (e, t) {
                        return new o({children: this._parentArray.splice.apply(this._parentArray, arguments)})
                    }, getLength: function () {
                        return this._parentArray.getLength()
                    }, each: function (e, t) {
                        return this._parentArray.each(e, t), this
                    }, getIterator: function () {
                        return this._parentArray.getIterator()
                    }, indexOf: function (e) {
                        return this._parentArray.indexOf(e)
                    }, getPixelBounds: function () {
                        return this._boundsAggregator.getPixelBounds()
                    }, getBounds: function () {
                        return this._boundsAggregator.getBounds()
                    }, onMapDestroy: function (e) {
                        this._boundsAggregator.destroy(), p.superclass.onMapDestroy.call(this, e)
                    }, _pixelBoundsChangeCallback: function () {
                        this.events.fire("pixelboundschange")
                    }, _geoBoundsChangeCallback: function () {
                        this.events.fire("boundschange")
                    }, _onAdd: function (e, t) {
                        this.events.fire("add", new u({index: e, child: t, type: "add", target: this}))
                    }, _onRemove: function (e, t) {
                        this.events.fire("remove", new u({index: e, child: t, type: "remove", target: this}))
                    }, _onSet: function (e, t, n) {
                        this.events.fire("set", new u({index: e, prevChild: t, child: n, type: "set", target: this}))
                    }
                }), i.setRule({name: "geoObject", rule: g}), i.setRule({
                    name: "geoObject",
                    key: ["projection"],
                    rule: "plain"
                }), e(p)
            });
        }],
        ['7(', function (ym) {
            ym.modules.define("map.Hint", ["util.defineClass", "Hint", "component.sharedEntity.manager.Popup", "event.Manager", "map.optionMapper", "option.Manager", "option.Router", "util.component", "vow", "popup.managerStorage"], function (t, n, i, e, s, o, r, a, h, p, u) {
                function c(t) {
                    this._map = t, this.events = new s({context: this}), this._hint = new i(t), this._hint.options.setParent(this._map.options), this._sharingManager = new e(this, this._hint, this._map), this._forkOptions = new r, this._setupListeners()
                }

                n(c, h.createProxyMethods(function () {
                    return this._sharingManager
                }, ["capture", "open", "close", "isOpen", "getOverlay", "getOverlaySync", "getOwner", "setPosition", "getPosition", "setData", "getData", "setOptions", "getOptions"]), {
                    destroy: function () {
                        this._clearListeners(), this.capture(null), this._hint.destroy()
                    }, capture: function (t) {
                        var n = this._sharingManager.capture(t);
                        return n.then(this._reset, this), n
                    }, open: function (t, n, i) {
                        t = t || this._map.getCenter();
                        var e = p.defer(), s = function (t) {
                            e.reject(t)
                        };
                        return this._sharingManager.perform("open", [t, n, i], this, function (t) {
                            p.resolve(!t[2] || this.setOptions(t[2])).then(function () {
                                e.resolve(this._sharingManager.getEntity().open(t[0], t[1]))
                            }, s, this)
                        }, s), e.promise()
                    }, setOptions: function (t) {
                        return this._sharingManager.perform("setOptions", [t], this, function (t) {
                            this._addForkOptions(), this._forkOptions.freeze().unsetAll().set(t[0]).unfreeze()
                        })
                    }, getOptions: function () {
                        return this._sharingManager.perform("getOptions", null, this, function () {
                            return this._addForkOptions(), this._forkOptions
                        })
                    }, _setupListeners: function () {
                        this._actionListeners = this._map.events.group().add(["actionbegin", "actiontick"], this._onAction, this)
                    }, _clearListeners: function () {
                        this._actionListeners.removeAll()
                    }, _onAction: function () {
                        this.isOpen() && this.capture(null)
                    }, _addForkOptions: function () {
                        var t = this._hint.options.getParent();
                        t && "function" == typeof t.spliceParents ? t.indexOfParent(this._forkOptions) == -1 && t.spliceParents(0, 0, this._forkOptions) : this._hint.options.setParent(new a(this._forkOptions, t))
                    }, _reset: function () {
                        this.getOwner() == this._map && this._hint.options.setParent(this._map.options), this._forkOptions.unsetAll()
                    }
                }), u.add("map#hint", c), t(c)
            });
        }],
        ['7)', function (ym) {
            ym.modules.define("map.layer.Manager", ["util.defineClass", "LayerCollection", "layer.optionMapper", "option.Manager", "map.optionMapper"], function (e, n, t, a, r, i) {
                function o(e, n) {
                    if (0 == e.indexOf("hotspotLayer")) return e;
                    var t = "layer" + e.slice(0, 1).toUpperCase() + e.slice(1);
                    return 0 == e.indexOf("balloon") || 0 == e.indexOf("hint") ? [t, e] : t
                }

                var s = function (e, n) {
                    s.superclass.constructor.call(this, n), this.options = new r({}, e.options, "layerManager", a), this._map = e, this._mapListeners = this._map.events.group().add("destroy", this._onMapDestroy, this)
                };
                n(s, t, {
                    setParent: function () {
                        if (ym.env.debug) throw new Error("map.layer.Manager: невозможно выполнить операцию setParent")
                    }, getMap: function () {
                        return this._map
                    }, _onMapDestroy: function () {
                        this._mapListeners.removeAll(), this._map = null, this.removeAll(), this.options.setParent(null)
                    }
                }), i.setRule({name: "layerManager", rule: o}), i.setRule({
                    name: "layerManager",
                    key: ["projection"],
                    rule: "plain"
                }), e(s)
            });
        }],
        ['7;', function (ym) {
            ym.modules.define("map.margin.Manager", ["event.Manager", "map.margin.Accessor", "util.array", "util.margin", "map.margin.util.findLargestFreeArea"], function (t, e, r, i, n, a) {
                function s(t, e) {
                    return [Math.round(t[0][1]), Math.round(e[0] - t[1][0]), Math.round(e[1] - t[1][1]), Math.round(t[0][0])]
                }

                function h(t, e) {
                    var r, i, n = e[0], a = e[1], s = c(t.width, n), h = c(t.height, a), o = null;
                    return r = t.hasOwnProperty("left") ? c(t.left, n) : t.hasOwnProperty("right") ? n - c(t.right, a) - s : 0, i = t.hasOwnProperty("top") ? c(t.top, a) : t.hasOwnProperty("bottom") ? a - c(t.bottom, a) - h : 0, s > 0 && h > 0 && (o = [[r, i], [r + s, i + h]]), o
                }

                function c(t, e) {
                    if ("string" == typeof t) {
                        var r = t[t.length - 1];
                        t = "%" == r ? Number(t.replace("%", "")) / 100 * e : "x" == r ? Number(t.replace("px", "")) : Number(t)
                    }
                    return t
                }

                function o(t, e) {
                    return t[0] == e[0] && t[1] == e[1] && t[2] == e[2] && t[3] == e[3]
                }

                function u(t, e) {
                    var r = {};
                    switch (e) {
                        case 0:
                            r.top = 0, r.left = 0, r.height = t, r.width = "100%";
                            break;
                        case 1:
                            r.top = 0, r.right = 0, r.height = "100%", r.width = t;
                            break;
                        case 2:
                            r.bottom = 0, r.left = 0, r.height = t, r.width = "100%";
                            break;
                        case 3:
                            r.top = 0, r.left = 0, r.height = "100%", r.width = t
                    }
                    return r
                }

                var g = function (t, r) {
                    this._mapContainer = t.container, this._margin = [0, 0, 0, 0], this._accessors = [], this.events = new e({context: this}), this._setupMapListener(), this._defaultMargin = n.correct(r || 0), r && this._recalculateMargin()
                };
                g.prototype = {
                    getMargin: function () {
                        return this._margin
                    }, getOffset: function () {
                        return [.5 * (this._margin[3] - this._margin[1]), .5 * (this._margin[0] - this._margin[2])]
                    }, addArea: function (t) {
                        var e = new r(t);
                        return e.events.add("change", this._recalculateMargin, this).add("remove", this._onAccessorRemoved, this), this._accessors.push(e), this._recalculateMargin(), e
                    }, setDefaultMargin: function (t) {
                        this._defaultMargin = n.correct(t), this._recalculateMargin()
                    }, destroy: function () {
                        return this._teardownMapListener(), this
                    }, _onAccessorRemoved: function (t) {
                        var e = t.get("target");
                        e.events.remove("change", this._recalculateMargin, this).remove("remove", this._onAccessorRemoved, this), i.remove(this._accessors, e), this._recalculateMargin()
                    }, _recalculateMargin: function () {
                        var t = [], e = this._mapContainer.getSize();
                        i.each(this._accessors, function (r) {
                            var i = h(r.getArea(), e);
                            i && t.push(i)
                        }, this);
                        var r = this._defaultMargin.slice();
                        if (t.length > 0) {
                            i.each(r, function (i, n) {
                                if (r[n]) {
                                    var a = h(u(i, n), e);
                                    a && t.push(a)
                                }
                            });
                            var n = a(t, e);
                            n && (r = s(n, e))
                        }
                        o(r, this._margin) || (this._margin = r, this.events.fire("change"))
                    }, _setupMapListener: function () {
                        this._mapContainer.events.add("sizechange", this._recalculateMargin, this)
                    }, _teardownMapListener: function () {
                        this._mapContainer.events.remove("sizechange", this._recalculateMargin, this)
                    }
                }, t(g)
            });
        }],
        ['7:', function (ym) {
            ym.modules.define("map.margin.Accessor", ["event.Manager"], function (e, t) {
                function n(e, t) {
                    return e.left == t.left && e.right == t.right && e.top == t.top && e.bottom == t.bottom && e.width == t.width && e.height == t.height
                }

                var r = function (e) {
                    this.events = new t({context: this}), this.setArea(e)
                };
                r.prototype = {
                    setArea: function (e) {
                        return this._screenArea && n(this._screenArea, e) || (this._screenArea = e, this.events.fire("change")), this
                    }, getArea: function () {
                        return this._screenArea
                    }, remove: function () {
                        return this.events.fire("remove"), this
                    }
                }, e(r)
            });
        }],
        ['8o', function (ym) {
            ym.modules.define("map.pane.Manager", ["util.defineClass", "util.array", "util.dom.element", "util.dom.style", "util.dom.className", "map.pane.helper.storage", "util.css", "domEvent.manager", "map.pane.helper.areas", "map.pane.helper.balloon", "map.pane.helper.controls", "map.pane.helper.copyrights", "map.pane.helper.editor", "map.pane.helper.ground", "map.pane.helper.hint", "map.pane.helper.outerBalloon", "map.pane.helper.outerHint", "map.pane.helper.overlaps", "map.pane.helper.panel", "map.pane.helper.phantom", "map.pane.helper.places", "map.pane.helper.shadows", "map.pane.helper.vector", "map.paneManager.css"], function (e, n, t, r, a, i, s, h, l) {
                function o(e) {
                    this._map = e, this._innerElement = null, this._outerElement = null, this._hash = {}, this._array = []
                }

                n(o, {
                    getInnerElement: function () {
                        return this._innerElement || (this._innerElement = this._createInnerElement())
                    }, getOuterElement: function () {
                        return this._outerElement || (this._outerElement = this._createOuterElement())
                    }, get: function (e) {
                        return "string" == typeof e || e instanceof String ? (this._hash[e] || this._tryToCreatePane(e), this._hash[e] ? this._hash[e].pane : null) : e
                    }, append: function (e, n) {
                        if (ym.env.debug && this._hash[e]) throw new Error('map.pane.Manager.append: Для данной карты пейн с ключом "' + e + '" уже существует');
                        this._addPane(e, n)
                    }, insertBefore: function (e, n, t) {
                        if (ym.env.debug) {
                            if (this._hash[e]) throw new Error('map.pane.Manager.insertBefore: Для данной карты пейн с ключом "' + e + '" уже существует');
                            if (!this._hash[t]) throw new Error('map.pane.Manager.insertBefore: Для данной карты пейн с ключом "' + t + '" отсутствует')
                        }
                        this._addPane(e, n, t)
                    }, remove: function (e) {
                        for (var n = null, t = 0, a = this._array.length; t < a; t++) if (this._array[t].pane == e) {
                            n = this._array[t];
                            break
                        }
                        if (n) {
                            e.events.setParent(null);
                            var s = e.getElement();
                            r.remove(s), i.remove(s, h.addPrefix(n.key + "-pane")), n.listeners.removeAll(), this._array.splice(t, 1), delete this._hash[n.key], this._refreshZIndexes()
                        } else if (ym.env.debug) throw new Error("map.pane.Manager.remove: Для данной карты пейн отсутствует")
                    }, getUpper: function () {
                        return this._findPane(0 == arguments.length ? this._array : this._keysToPanes(arguments), !0)
                    }, getLower: function () {
                        return this._findPane(0 == arguments.length ? this._array : this._keysToPanes(arguments), !1)
                    }, destroy: function () {
                        for (var e = 0, n = this._array.length; e < n; e++) {
                            var t = this._array[e];
                            t.listeners.removeAll(), t.pane.destroy()
                        }
                        this._innerElementEvents && (this._innerElementEvents.removeAll(), this._innerElementEvents = null), this._innerElement && r.remove(this._innerElement), this._outerElement && r.remove(this._outerElement)
                    }, findUpper: function (e) {
                        for (var n, t = 0, r = this._array.length; t < r; t++) {
                            var a = this._array[t];
                            a.pane instanceof e && (!n || n.zIndex < a.zIndex) && (n = a)
                        }
                        return n ? n.pane : null
                    }, _createInnerElement: function () {
                        var e = this._map.container,
                            n = r.create({parentNode: e.getElement(), className: h.addPrefix("inner-panes")});
                        return this._innerElementEvents = l.group(n).add("scroll", function () {
                            n.scrollLeft = 0, n.scrollTop = 0
                        }), n
                    }, _createOuterElement: function () {
                        var e = this._map.container;
                        return r.create({parentNode: e.getElement(), className: h.addPrefix("outer-panes")})
                    }, _tryToCreatePane: function (e) {
                        var n = s.get(e);
                        n && this._addPane(e, n(this._map))
                    }, _addPane: function (e, n, r) {
                        var a = {
                            key: e,
                            pane: n,
                            zIndex: 0,
                            listeners: n.events.group().add("zindexchange", this._onZIndexChange, this).add("overflowchange", this._onOverflowChange, this)
                        };
                        this._hash[e] = a, r ? this._array.splice(t.indexOf(this._array, this._hash[r]), 0, a) : this._array.push(a), this._refreshZIndexes();
                        var s = n.getElement();
                        i.add(s, h.addPrefix(e + "-pane")), this._overflowToElement(n.getOverflow()).appendChild(s), n.events.setParent(this._map.container.events)
                    }, _findPane: function (e, n) {
                        for (var t = null, r = 0, a = e.length; r < a; r++) {
                            var i = e[r];
                            t && !(n ? t.zIndex < i.zIndex : t.zIndex > i.zIndex) || (t = i)
                        }
                        return t ? t.key : null
                    }, _onZIndexChange: function () {
                        this._refreshZIndexes()
                    }, _onOverflowChange: function (e) {
                        var n = e.get("target");
                        this._overflowToElement(n.getOverflow()).appendChild(n.getElement())
                    }, _refreshZIndexes: function () {
                        for (var e = 0, n = this._array.length; e < n; e++) {
                            var t = this._array[e];
                            t.zIndex = t.pane.getElement().style.zIndex = t.pane.getZIndex() * n + e
                        }
                    }, _overflowToElement: function (e) {
                        if ("visible" == e) return this.getOuterElement();
                        if ("hidden" == e) return this.getInnerElement();
                        if (ym.env.debug) throw new Error('map.pane.Manager: Неверный результат getOverflow(): "' + e + '"');
                        return null
                    }, _keysToPanes: function (e) {
                        for (var n = [], t = 0, r = e.length; t < r; t++) {
                            var a = e[t];
                            if (this._hash[a] || this._tryToCreatePane(a), n[t] = this._hash[a], ym.env.debug && !n[t]) throw new Error('map.pane.Manager: Пейн с именем "' + a + '" не найден')
                        }
                        return n
                    }
                }), e(o)
            });
        }],
        ['8p', function (ym) {
            ym.modules.define("map.ZoomRange", ["util.defineClass", "component.ZoomRangeObserver", "event.Manager", "util.math.areEqual", "Monitor", "vow"], function (o, t, n, e, i, s, r) {
                var a = function (o, t) {
                    this._map = o, this._mapListeners = o.events.group().add("actionend", this._onActionEnd, this).add("destroy", this._onMapDestroy, this), this._mapOptionsMonitor = new s(this._map.options), this._mapOptionsMonitor.add(["minZoom", "maxZoom"], this._onConstraintsChange, this), this._zoomRange = this._constraints = t, this._providersZoomRange = null, this._error = null, this._zoomRangeObserver = new n(this._onProviderChange.bind(this)), this.events = new e
                };
                t(a, {
                    get: function (o) {
                        var t = r.defer();
                        return o || (o = this._map.getCenter({useMapMargin: this._map.options.get("coverageUseMapMargin", !0)}), this._lastDeferred = t), this._zoomRangeObserver.get(o).then(function (n) {
                            this._onReady(null, n, o, t)
                        }, function (n) {
                            this._onReady(n, null, o, t)
                        }, this), t.promise()
                    }, _onReady: function (o, t, n, e) {
                        var s;
                        if (s = o ? "noProvider" == o ? this._constraints.slice() : this._zoomRange : [Math.max(this._constraints[0], t[0]), Math.min(this._constraints[1], t[1])], this._lastDeferred == e && i(n, this._map.getCenter({useMapMargin: !0}), 1e-7)) {
                            var r = this._zoomRange;
                            this._providersZoomRange = t, this._error = o, this._zoomRange = s.slice(), r[0] == s[0] && r[1] == s[1] || this.events.fire("change", {
                                oldZoomRange: r,
                                newZoomRange: s
                            })
                        }
                        e.resolve(s)
                    }, getCurrent: function () {
                        return this._zoomRange.slice()
                    }, _onActionEnd: function () {
                        this.get()
                    }, _onMapDestroy: function () {
                        this._mapListeners.removeAll(), this._mapOptionsMonitor.destroy(), this._zoomRangeObserver.destroy()
                    }, _onConstraintsChange: function () {
                        var o = this._zoomRange, t = this._map, n = this._providersZoomRange;
                        this._constraints = [t.options.get("minZoom"), t.options.get("maxZoom")], n ? this._zoomRange = [Math.max(this._constraints[0], n[0]), Math.min(this._constraints[1], n[1])] : this._zoomRange = this._constraints.slice(), o[0] == this._zoomRange[0] && o[1] == this._zoomRange[1] || this.events.fire("change", {
                            oldZoomRange: o,
                            newZoomRange: this._zoomRange.slice()
                        })
                    }, _onProviderChange: function () {
                        this.get()
                    }, addProvider: function (o, t) {
                        return "function" == typeof o.getZoomRange && this._zoomRangeObserver.addProvider(o, t), this
                    }, removeProvider: function (o) {
                        return "function" == typeof o.getZoomRange && this._zoomRangeObserver.removeProvider(o), this
                    }
                }), o(a)
            });
        }],
        ['8r', function (ym) {
            ym.modules.define("MapEvent", ["util.defineClass", "Event", "mapEvent.overrideStorage", "component.event.Cacher"], function (e, t, n, c, i) {
                function r(e, t) {
                    r.superclass.constructor.call(this, e, t), this._cache = {}, this._cacher = new i(this, this._cache, c)
                }

                t(r, n, {
                    get: function (e) {
                        var t = this._cacher.get(e);
                        return "undefined" == typeof t && this.getSourceEvent() && (t = this.getSourceEvent().get(e)), t
                    }, callMethod: function (e) {
                        var t = this._cacher.get(e);
                        return "undefined" == typeof t && this.getSourceEvent() ? this.getSourceEvent().callMethod.apply(this.getSourceEvent(), arguments) : t.apply(this.originalEvent, Array.prototype.slice.call(arguments, 1))
                    }, clone: function (e) {
                        return new r(e, this.getSourceEvent())
                    }
                }), e(r)
            });
        }],
        ['8u', function (ym) {
            ym.modules.define("MapType", [], function (e) {
                var t = function (e, t, r) {
                    this._name = e, this._layers = t, this._vectorLayers = r
                };
                t.prototype = {
                    getLayers: function () {
                        return this._layers
                    }, getName: function (e) {
                        return this._name
                    }, getVectorLayers: function () {
                        return this._vectorLayers
                    }
                }, e(t)
            });
        }],
        ['8v', function (ym) {
            ym.modules.define("mapType.storage", ["util.Storage"], function (e, n) {
                e(new n)
            });
        }],
        ['8y', function (ym) {
            ym.modules.define("Monitor", ["util.extend", "util.array"], function (e, a, t) {
                function s(e) {
                    this._dataManager = e, this._groups = [], this._names = {}, this._values = {}, this._oldValues = null, this._cleanTimeoutId = 0, this._clearGroupsCallback = function () {
                        this._cleanTimeoutId = 0, this._clearGroups()
                    }.bind(this)
                }

                function n(e, a, t, s) {
                    var n = {
                        names: "string" == typeof e ? [e] : e.slice(),
                        singleName: "string" == typeof e,
                        changeCallback: a,
                        context: t,
                        resolveCallbacks: {},
                        compareCallbacks: {},
                        defaultValues: {},
                        deleted: !1
                    };
                    if (s) for (var l = n.names, i = n.resolveCallbacks, o = n.compareCallbacks, r = n.defaultValues, h = 0, u = l.length; h < u; h++) e = l[h], i[e] = s.resolveCallbacks && s.resolveCallbacks[e] || s.resolveCallback, o[e] = s.compareCallbacks && s.compareCallbacks[e] || s.compareCallbacks, r[e] = s.defaultValues && "undefined" != typeof s.defaultValues[e] ? s.defaultValues[e] : s.defaultValue;
                    return n
                }

                a(s.prototype, {
                    add: function (e, a, t, s) {
                        this._groups.length || this._dataManager.events.add("change", this._onChange, this);
                        var l = n(e, a, t, s);
                        if (ym.env.debug) for (var i = 0, o = l.names.length; i < o; i++) if (this._names[l.names[i]]) throw new Error('Monitor.add: name "' + l.names[i] + '" has already been added.');
                        for (var r = Boolean(s && s.init), h = r ? l.singleName ? void 0 : {} : null, i = 0, o = l.names.length; i < o; i++) e = l.names[i], this._names[e] = l, this._values[e] = this._resolveName(e), r && (l.singleName ? h = this._values[e] : h[e] = this._values[e]);
                        return this._groups.push(l), r && l.changeCallback.call(l.context, h, l.singleName ? void 0 : {}), this
                    }, remove: function (e) {
                        if ("string" == typeof e) this._removeField(e); else for (var a = 0, t = e.length; a < t; a++) this._removeField(e[a]);
                        return this._groups.length || this._dataManager.events.remove("change", this._onChange, this), this
                    }, removeAll: function () {
                        return this._values = {}, this._names = {}, this._groups = [], this._dataManager.events.remove("change", this._onChange, this), this
                    }, get: function (e) {
                        return this._values[e]
                    }, forceChange: function () {
                        return this._onChange(), this
                    }, _removeField: function (e) {
                        if (ym.env.debug && !this._names[e]) throw new Error('Monitor.remove: name "' + e + '" was not added.');
                        var a = this._names[e];
                        delete this._values[e], delete this._names[e], 1 == a.names.length ? a.names[0] == e && a.names.pop() : a.names.splice(t.indexOf(a.names, e), 1), a.names.length || (a.deleted = !0, this._cleanTimeoutId || (this._cleanTimeoutId = setTimeout(this._clearGroupsCallback, 0)))
                    }, _resolveName: function (e) {
                        var a = this._names[e],
                            t = a.resolveCallbacks[e] ? a.context ? a.resolveCallbacks[e].call(a.context, e, this._dataManager) : a.resolveCallbacks[e](e, this._dataManager) : this._dataManager.get(e);
                        return "undefined" == typeof t ? a.defaultValues[e] : t
                    }, _onChange: function () {
                        for (var e = this._values, a = 0, t = this._groups.length; a < t; a++) {
                            if (!this._groups.length) return;
                            var s = this._groups[a];
                            s.deleted || this._checkGroup(s, e)
                        }
                    }, _checkGroup: function (e, t) {
                        for (var s, n, l = !1, i = 0, o = e.names.length; i < o; i++) {
                            var r = e.names[i], h = this._resolveName(r), u = t[r];
                            (e.compareCallbacks[r] ? e.context ? e.compareCallbacks[r].call(e.context, h, u) : e.compareCallbacks[r](h, u) : h !== u) && (l || (s = e.singleName ? u : a({}, t), n = e.singleName ? h : a({}, t), l = !0), e.singleName || (s[r] = u, n[r] = h), this._values[r] = h)
                        }
                        l && (e.context ? e.changeCallback.call(e.context, n, s) : e.changeCallback(n, s))
                    }, _clearGroups: function () {
                        for (var e, a = 0, t = this._groups.length - 1; t >= 0; t--) this._groups[t].deleted && (a++, e = t, t > 0) || a && (this._groups.length == a ? this._groups = [] : this._groups.splice(e, a), a = 0)
                    }
                }), s.prototype.destroy = s.prototype.removeAll, e(s)
            });
        }],
        ['-c', function (ym) {
            ym.modules.define("pane.EventsPane", ["util.defineClass", "util.extend", "util.dom.style", "util.cursor.Manager", "pane.Base", "interactivityModel.EventController", "interactivityModel.transparent", "util.css"], function (e, t, n, s, a, i, l, r, c) {
                function o(e, t) {
                    t = n({
                        className: c.addPrefix("events-pane"),
                        css: {width: "100%", height: "100%"},
                        patch: {selectable: !1},
                        transparent: !1,
                        checkContextMenu: !0
                    }, t), o.superclass.constructor.call(this, e, t), this.cursors = new a(this.getElement()), t.transparent && this.events.addController(new l(r))
                }

                t(o, i), e(o)
            });
        }],
        ['-d', function (ym) {
            ym.modules.define("pane.MovablePane", function (n) {
                return ["util.defineClass", n.env.browser.transformTransition ? "pane.movable.TransitionPane" : "pane.movable.StepwisePane"]
            }, function (n, e, a) {
                function o(n, e) {
                    o.superclass.constructor.call(this, n, e)
                }

                e(o, a), n(o)
            });
        }],
        ['-k', function (ym) {
            ym.modules.define("pane.StaticPane", ["util.defineClass", "pane.BaseContainer"], function (t, e, i) {
                function n(t, e) {
                    n.superclass.constructor.call(this, t, e), this._zoom = t.getZoom()
                }

                e(n, i, {
                    getZoom: function () {
                        return this._zoom
                    }, onActionBegin: function () {
                        this.events.fire("actionbegin")
                    }, onActionTick: function (t) {
                        var e = t.get("tick");
                        if (this._zoom != e.zoom) {
                            this._zoom = e.zoom, this.events.fire("zoomchange");
                            var i = this.updateClientPixels(e.globalPixelCenter);
                            this.fireCompoundUpdate(null, !1, i)
                        }
                        this.events.fire("actiontick")
                    }, onActionEnd: function () {
                        this._zoom = this.getMap().getZoom();
                        var t = this.updateClientPixels(this.getMap().getGlobalPixelCenter());
                        this.fireCompoundUpdate("actionend", !1, t), this.events.fire("actionend")
                    }, destroy: function () {
                        this.getMap().events.remove("boundschange", this._onMapBoundsChange, this), n.superclass.destroy.call(this)
                    }
                }), t(n)
            });
        }],
        ['8)', function (ym) {
            ym.modules.define("multiRouter.MultiRouteModel", ["util.defineClass", "event.Manager", "data.Manager", "data.Sync", "vow", "util.array", "util.lazy", "multiRoute.model.common.emptyJson", "multiRouter.model.component.ServiceController", "multiRoute.component.DecoratorEventMapper", "yandex.counter"], function (e, t, n, s, o, i, r, a, l, c, h, u) {
                function d(e, t) {
                    this._serviceController = new c(e, t, {
                        onRequestChange: this._requestChangeCallback.bind(this),
                        onRequestSend: this._requestSendCallback.bind(this),
                        onRequestLoading: this._requestLoadingCallback.bind(this),
                        onRequestSuccess: this._requestSuccessCallback.bind(this),
                        onRequestFail: this._requestFailCallback.bind(this),
                        onRequestCancel: this._requestCancelCallback.bind(this)
                    }), u.countByKey("modulesUsage", "multiRoute." + this._serviceController.getParams().routingMode), this._destroyed = !1, this._jsonModel = null, this._jsonModelDataSync = null, this._pointModelsDecorator = null, this._ignoreRequestChange = !1, this._ensureJsonModelIsCreated = a(function () {
                        return f().then(function () {
                            this._destroyed || (this._jsonModel = new g(l), this._jsonModel.events.setParent(new h(this.events)), this._jsonModel.events.add("jsonchange", this._onJsonModelJsonChange, this), this._jsonModelDataSync = new o([this.properties, this._jsonModel.properties]), this._pointModelsDecorator = new _(this._jsonModel, this, {
                                wayReferencePointChangeCallback: {
                                    callback: this._onWayPointReferencePointChange,
                                    context: this
                                },
                                viaReferencePointChangeCallback: {
                                    callback: this._onViaPointReferencePointChange,
                                    context: this
                                }
                            }))
                        }, this)
                    }, this), this.events = new n({context: this}), this.properties = new s
                }

                var _, g, f = a(function () {
                    return ym.modules.require(["multiRouter.model.component.PointModelsDecorator", "multiRouter.MultiRouteJsonModel"]).spread(function (e, t) {
                        _ = e, g = t
                    })
                });
                t(d, {
                    getJson: function () {
                        return this._jsonModel ? this._jsonModel.getJson() : l
                    }, setReferencePoints: function (e, t, n) {
                        this._serviceController.setReferencePoints(e, t, n)
                    }, getReferencePoints: function () {
                        return this._serviceController.getReferencePoints()
                    }, getReferencePointIndexes: function () {
                        return this._serviceController.getReferencePointIndexes()
                    }, setParams: function (e, t, n) {
                        var s = this._serviceController.getParams();
                        this._serviceController.setParams(e, t, n);
                        var o = this._serviceController.getParams();
                        o.routingMode != s.routingMode && u.countByKey("modulesUsage", "multiRoute." + o.routingMode)
                    }, getParams: function () {
                        return this._serviceController.getParams()
                    }, getAllPoints: function () {
                        return this._pointModelsDecorator ? this._pointModelsDecorator.getAllPoints() : []
                    }, getWayPoints: function () {
                        return this._pointModelsDecorator ? this._pointModelsDecorator.getWayPoints() : []
                    }, getViaPoints: function () {
                        return this._pointModelsDecorator ? this._pointModelsDecorator.getViaPoints() : []
                    }, getRoutes: function () {
                        return this._pointModelsDecorator ? this._pointModelsDecorator.getRoutes() : []
                    }, destroy: function () {
                        this._destroyed = !0, this._serviceController.destroy(), this._jsonModel && (this._pointModelsDecorator.destroy(), this._jsonModelDataSync.destroy(), this._jsonModel.events.remove("jsonchange", this._onJsonModelJsonChange, this), this._jsonModel.events.setParent(null), this._jsonModel.destroy())
                    }, setStateAsync: function (e, t, n) {
                        return this._assertInManualServiceMode(), this._ensureJsonModelIsCreated().then(function () {
                            this._setState(e, t, n)
                        }, this)
                    }, setStateSync: function (e, t, n) {
                        return this._assertInManualServiceMode(), !!this._jsonModel && (this._setState(e, t, n), !0)
                    }, _assertInManualServiceMode: function () {
                        if ("manual" !== this._serviceController.getServiceMode()) throw new Error("Method is available only in manual service mode.")
                    }, _setState: function (e, t, n) {
                        (t || n) && (this._ignoreRequestChange = !0, t && this.setReferencePoints(t), n && this.setParams(n), this._ignoreRequestChange = !1), this._setJson(e)
                    }, _requestChangeCallback: function (e, t) {
                        this._ignoreRequestChange || this.events.fire("requestchange", {
                            referencePoints: t.referencePoints,
                            params: t.params,
                            oldReferencePoints: e.referencePoints,
                            oldParams: e.params
                        })
                    }, _requestSendCallback: function (e) {
                        this.events.fire("requestsend", {referencePoints: e.referencePoints, params: e.params})
                    }, _requestLoadingCallback: function (e) {
                        return this._jsonModel || (e = i.all([e, this._ensureJsonModelIsCreated()]).spread(function (e) {
                            return e
                        })), e
                    }, _requestSuccessCallback: function (e, t, n) {
                        var s = e.features[2].features;
                        s[0] && "driving" == s[0].properties.type && (e.features[2].features = this._getNotBlockedRoutes(s)), this._setJson(e);
                        var o = this._fireWayPointsChange, i = this._fireViaPointsChange, r = this._fireRoutesChange;
                        this._fireWayPointsChange = !1, this._fireViaPointsChange = !1, this._fireRoutesChange = !1, this.events.fire("requestsuccess", {
                            init: n,
                            rough: t,
                            wayPointsChange: o,
                            viaPointsChange: i,
                            routesChange: r
                        })
                    }, _setJson: function (e) {
                        this._jsonModel.setJson(e)
                    }, _getNotBlockedRoutes: function (e) {
                        for (var t = [], n = 0; n < e.length; n++) e[n].properties.blocked || t.push(e[n]);
                        return t.length > 0 ? t : e
                    }, _requestFailCallback: function (e) {
                        this.events.fire("requestfail", {error: e})
                    }, _requestCancelCallback: function (e) {
                        this.events.fire("requestcancel", {referencePoints: e.referencePoints, params: e.params})
                    }, _onViaPointReferencePointChange: function (e) {
                        var t = e.get("target"),
                            n = this._serviceController.getReferencePointIndexes().via[r.indexOf(this._pointModelsDecorator.getViaPoints(), t)];
                        this._serviceController.setReferencePoint(n, t.getReferencePoint())
                    }, _onWayPointReferencePointChange: function (e) {
                        var t = e.get("target"),
                            n = this._serviceController.getReferencePointIndexes().way[r.indexOf(this._pointModelsDecorator.getWayPoints(), t)];
                        this._serviceController.setReferencePoint(n, t.getReferencePoint())
                    }, _onJsonModelJsonChange: function (e) {
                        this._fireWayPointsChange = e.get("wayPointsChange"), this._fireViaPointsChange = e.get("viaPointsChange"), this._fireRoutesChange = e.get("routesChange")
                    }
                }), d.prototype.getPoints = d.prototype.getAllPoints, e(d)
            });
        }],
        ['9F', function (ym) {
            ym.modules.define("multiRouter.MultiRoute", ["util.defineClass", "event.Manager", "event.globalize", "multiRoute.component.DecoratorEventMapper", "multiRouter.component.PointsDragController", "multiRouter.component.markerDispatcherEvents", "yandex.state.component.MultiRouter", "multiRouter.MultiRouteModel", "multiRouter.MultiRouteJsonView", "multiRouter.referencePointUtils", "util.extend"], function (t, e, n, i, o, s, r, a, u, g, h, d) {
                function l(t, e) {
                    t = c(t), this._jsonView = new g(t, e), this.geometry = this._jsonView.geometry, this.properties = this._jsonView.properties, this.state = this._jsonView.state, this.options = this._jsonView.options, this.events = new n({context: this}), this._jsonView.events.setParent(new o(this.events)), this._pointsDragController = new s(this._jsonView, {
                        dragStart: {
                            callback: this._onDragStart,
                            context: this
                        },
                        drag: {callback: this._onDrag, context: this},
                        dragEnd: {callback: this._onDragEnd, context: this}
                    }), this.model = this._jsonView.model, this.events.addController(m), this.events.fire("create"), this._yandexStateComponent = new a(this), this._modelParamsCache = {}
                }

                function c(t) {
                    return "function" != typeof t.getWayPoints && (t = new u(t.referencePoints, t.params, t.json)), t
                }

                var m = i(l);
                e(l, {
                    getWayPoints: function () {
                        return this._jsonView.getWayPoints()
                    }, getTemporaryWayPoints: function () {
                        return this._jsonView.getTemporaryWayPoints()
                    }, getViaPoints: function () {
                        return this._jsonView.getViaPoints()
                    }, getRoutes: function () {
                        return this._jsonView.getRoutes()
                    }, setActiveRoute: function (t) {
                        if (ym.env.debug && t && t.model.multiRoute != this.model) throw new Error("multiRouter.MultiRoute: Недопустимый объект маршрута.");
                        this._jsonView.setActiveRoute(t)
                    }, getActiveRoute: function () {
                        return this._jsonView.getActiveRoute()
                    }, getPixelBounds: function () {
                        return this._jsonView.getPixelBounds()
                    }, getBounds: function () {
                        return this._jsonView.getBounds()
                    }, destroy: function () {
                        this._pointsDragController.destroy(), this._jsonView.events.setParent(null), this._jsonView.destroy()
                    }, adjustMapBounds: function () {
                        this._jsonView.adjustMapBounds()
                    }, getOverlay: function () {
                        return this._jsonView.getOverlay()
                    }, getOverlaySync: function () {
                        return this._jsonView.getOverlaySync()
                    }, setParent: function (t) {
                        return this._jsonView.setParent(t), this
                    }, getParent: function () {
                        return this._jsonView.getParent()
                    }, getMap: function () {
                        return this._jsonView.getMap()
                    }, _onDragStart: function (t) {
                        this._dragendTimeoutID && (clearTimeout(this._dragendTimeoutID), this._dragendTimeoutID = null), t.capture(), r.get(this.getMap()).dragEvents.fire("dragstart", {map: t.getMap()}), this.options.getMonitor().add("preventDragUpdate", this._onPreventDragUpdateChange, this), this.options.get("preventDragUpdate") || this._setupDragParams()
                    }, _onDrag: function (t) {
                        this.options.get("preventDragUpdate") || this._dragReferencePoint(t)
                    }, _onDragEnd: function (t) {
                        this.options.get("preventDragUpdate") ? this._dragReferencePoint(t) : this._clearDragParams(), this.options.getMonitor().remove("preventDragUpdate", this._onPreventDragUpdateChange, this);
                        var e = t.getMap();
                        this._dragendTimeoutID || (this._dragendTimeoutID = setTimeout(function () {
                            this._dragendTimeoutID = NaN, r.get(e).dragEvents.fire("dragend", {map: e}), t.release()
                        }.bind(this), 700))
                    }, _onPreventDragUpdateChange: function (t) {
                        t ? this._clearDragParams() : this._setupDragParams()
                    }, _dragReferencePoint: function (t) {
                        t.model.setReferencePoint(h.fixCoordOrder(t.model.multiRoute, t.geometry.getCoordinates()))
                    }, _setupDragParams: function () {
                        var t = this.model.getParams();
                        this._modelParamsCache = d({}, t), t.snap = "rough";
                        var e = this.options.get("dragUpdateInterval");
                        "undefined" != typeof e && (t.requestSendInterval = e), this.model.setParams(t)
                    }, _clearDragParams: function () {
                        this.model.setParams(this._modelParamsCache)
                    }
                }), t(l)
            });
        }],
        ['8C', function (ym) {
            ym.modules.define("multiRouter.editor.addon", ["util.defineClass", "event.Manager", "event.Mapper", "Event", "data.Manager", "option.Manager", "multiRouter.MultiRoute", "util.Associate", "util.cancelableCallback", "data.Sync", "yandex.counter"], function (t, e, i, n, s, r, o, a, u, l, c, h) {
                function d() {
                    this.editor.isActive() && this.editor.stop()
                }

                function _(t) {
                    this._multiRoute = t, this.state = new r, this.events = new i({context: this}), this.options = new o({}, t.options, "editorAddon"), this._editor = null, this._stateSync = null, this._editorEventMapper = new n(this.events, new f(this)), this._requireCallback = null
                }

                function f(t) {
                    this["*"] = function (e) {
                        return new s({target: t}, e)
                    }
                }

                var p = new u(function (t) {
                    return this.create(t), t.editor
                });
                p.create = function (t) {
                    "function" == typeof t.model.setReferencePoints && (t.editor = new _(t), t.events.add("mapchange", d, t))
                }, a.getMetaEventManager().add("create", function (t) {
                    p.create(t.get("target"))
                }), e(_, {
                    start: function (t) {
                        this._editor || (this.state.setAll(t || {}), this._requireCallback = l.create(function (t) {
                            this._editor = new t(this._multiRoute, this.state.getAll()), this._editor.events.setParent(this._editorEventMapper), this._editor.options.setParent(this.options), this._stateSync = new c([this._editor.state, this.state]), this.events.fire("start")
                        }, this), ym.modules.require(["multiRouter.Editor"], this._requireCallback), h.countByKey("modulesUsage", "multiRoute.editor.start"))
                    }, stop: function () {
                        this._editor ? (this._stateSync.destroy(), this._editor.destroy(), this._editor = null, this.events.fire("stop")) : this._requireCallback && this._requireCallback.isActive() && this._requireCallback.cancel()
                    }, isActive: function () {
                        return !!this._editor
                    }
                }), t(_)
            });
        }],
        ['9R', function (ym) {
            ym.modules.define("objectManager.addon.clustersBalloon", ["objectManager.ClusterCollection", "popup.addonBuilder", "objectManager.Balloon"], function (e, a, n, o) {
                e(n.build({type: "balloon", metaEventManager: a.getMetaEventManager(), defaultManager: o}))
            });
        }],
        ['9T', function (ym) {
            ym.modules.define("objectManager.addon.clustersHint", ["objectManager.ClusterCollection", "popup.addonBuilder", "objectManager.Hint"], function (e, a, n, t) {
                e(n.build({
                    type: "hint",
                    metaEventManager: a.getMetaEventManager(),
                    defaultManager: t,
                    popupManagerOption: "objectManagerHintManager"
                }))
            });
        }],
        ['9S', function (ym) {
            ym.modules.define("objectManager.addon.objectsBalloon", ["objectManager.ObjectCollection", "popup.addonBuilder", "objectManager.Balloon"], function (e, a, n, o) {
                e(n.build({type: "balloon", metaEventManager: a.getMetaEventManager(), defaultManager: o}))
            });
        }],
        ['9U', function (ym) {
            ym.modules.define("objectManager.addon.objectsHint", ["objectManager.ObjectCollection", "popup.addonBuilder", "objectManager.Hint"], function (e, a, n, t) {
                e(n.build({
                    type: "hint",
                    metaEventManager: a.getMetaEventManager(),
                    defaultManager: t,
                    popupManagerOption: "objectManagerHintManager"
                }))
            });
        }],
        ['$7', function (ym) {
            ym.modules.define("overlay.storage", ["util.AsyncStorage"], function (e, o) {
                e(new o("overlay"))
            });
        }],
        ['$!', function (ym) {
            ym.modules.define("package.controls.predefinedSets", ["control.manager.predefinedSets", "map.metaOptions"], function (e, l, t) {
                function a(e) {
                    var l = ["zoomControl", "searchControl", "typeSelector", "geolocationControl"], t = [];
                    "small" != e && "medium" != e || l.push("fullscreenControl"), "medium" != e && "large" != e || l.push("trafficControl", "rulerControl"), "large" == e && l.push("routeEditor");
                    for (var a = 0, o = l.length; a < o; a++) t.push("small" == e ? {
                        type: l[a],
                        options: {size: "small"}
                    } : l[a]);
                    return t
                }

                l.add("smallMapDefaultSet", a("small")), l.add("mediumMapDefaultSet", a("medium")), l.add("largeMapDefaultSet", a("large")), l.add("default", a("medium")), t.set("defaultControls", ["default"]), e(a)
            });
        }],
        ['4V', function (ym) {
            ym.modules.define("Placemark", ["util.defineClass", "GeoObject"], function (e, t, n) {
                function o(e, t, n) {
                    o.superclass.constructor.call(this, {geometry: i(e), properties: t}, n)
                }

                function i(e) {
                    return e && "undefined" == typeof e.length ? e : {type: "Point", coordinates: e}
                }

                t(o, n), e(o)
            });
        }],
        ['4W', function (ym) {
            ym.modules.define("Polygon", ["util.augment", "GeoObject"], function (e, n, o) {
                function t(e) {
                    return e && "undefined" != typeof e.length ? {type: "Polygon", coordinates: e} : e
                }

                var r = function (e, n, o) {
                    r.superclass.constructor.call(this, {geometry: t(e), properties: n}, o)
                };
                n(r, o), e(r)
            });
        }],
        ['4X', function (ym) {
            ym.modules.define("Polyline", ["util.augment", "GeoObject"], function (e, n, t) {
                function o(e) {
                    return e && "undefined" != typeof e.length ? {type: "LineString", coordinates: e} : e
                }

                var i = function (e, n, t) {
                    i.superclass.constructor.call(this, {geometry: o(e), properties: n}, t)
                };
                n(i, t), e(i)
            });
        }],
        ['_W', function (ym) {
            ym.modules.define("Popup", ["util.defineClass", "constants.mapDomEvents", "event.Manager", "geometry.pixel.Point", "option.Manager", "util.math.areEqual", "util.dom.element", "vow", "overlay.storage", "popup.states", "event.Mapper", "Event"], function (e, t, o, i, s, n, r, a, l, h, u, _, p) {
                function c(e, t) {
                    this._map = e, this.events = new i({context: this}), this.options = new n(t), this._data = null, this._state = u.CLOSED, this._deferredOpen = null, this._deferredClose = null
                }

                function f(e) {
                    this._popup = e, this._createMappings()
                }

                c.OpenError = function () {
                    return new Error("Opening was canceled by another action")
                }, c.CloseError = function () {
                    return new Error("Closing was canceled by another action")
                }, c.DestroyedError = function () {
                    return new Error("Popup was destroyed")
                }, c.OverlayNotFound = function () {
                    return new Error("Overlay wasn't found")
                };
                var v = c.OpenError(), d = c.CloseError(), y = c.DestroyedError(), m = c.OverlayNotFound();
                t(c, {
                    open: function (e, t) {
                        this._clearCloseAction();
                        var o, i = l.defer(), s = i.promise();
                        if (t && this.setData(t), e && (o = this.setPosition(e)), this._state == u.OPEN) o ? i.resolve(o) : i.resolve(); else if (this._state == u.OPENING) i.resolve(this._deferredOpen.promise()); else {
                            this._clearOpenAction(), this._deferredOpen = i;
                            var n = this.options.get("openTimeout");
                            "number" == typeof n ? this._openTimeout = setTimeout(function () {
                                this._openTimeout = null, i.resolve(this.doOpen())
                            }.bind(this), n) : i.resolve(this.doOpen()), s.done(this._onOpen, function () {
                            }, this)
                        }
                        return s
                    }, close: function (e) {
                        e = e && "boolean" == typeof e, this._clearCloseAction(), this._clearOpenAction();
                        var t = this._deferredClose = l.defer(), o = t.promise();
                        if (this._state == u.OPEN) {
                            var i = this.options.get("closeTimeout");
                            "number" != typeof i || e ? t.resolve(this.doClose(e)) : this._closeTimeout = setTimeout(function () {
                                this._closeTimeout = null, t.resolve(this.doClose(e))
                            }.bind(this), i), o.done(this._onClose, function () {
                            }, this)
                        } else this._state = u.CLOSED, t.resolve();
                        return o
                    }, isOpen: function () {
                        return this._state == u.OPEN
                    }, getState: function () {
                        return this._state
                    }, setPosition: function (e) {
                        return this._position = e, this.setupGeometry(), this.events.fire("setposition"), l.resolve()
                    }, getPosition: function () {
                        return this._position
                    }, setData: function (e) {
                        return e && "object" == typeof e && !a.isNode(e) || (e = {content: e}), this._data = e, this._overlay && this._overlay.setData(this._data), this.events.fire("setdata"), l.resolve()
                    }, getData: function () {
                        return this._data
                    }, getMap: function () {
                        return this._map
                    }, getOverlay: function () {
                        if (this._overlay) return l.resolve(this._overlay);
                        if (this._overlayDeferred) return l.resolve(this._overlayDeferred.promise());
                        var e = this._overlayDeferred = l.defer(), t = this.options.get("overlay"),
                            o = {options: this.options}, i = h.get(t, o);
                        return "undefined" == typeof i ? h.require({keys: [t], data: o}).spread(function (t) {
                            e.resolve(this._createOverlay(t))
                        }, function () {
                            e.reject(m)
                        }, this) : e.resolve(this._createOverlay(i)), e.promise()
                    }, getOverlaySync: function () {
                        return this._overlay
                    }, destroy: function () {
                        this._clearCloseAction(), this._clearOpenAction(), this._clearOverlay(), this._state = u.DESTROYED
                    }, doOpen: function () {
                        if ("DESTROYED" == this._state) return l.reject(y);
                        var e = this.getOverlaySync();
                        return e ? (this._state = u.OPEN, e.setMap(this._map), l.resolve()) : (this._state = u.OPENING, this.getOverlay().then(function (e) {
                            this._state == u.OPENING && (this._state = u.OPEN, e.setMap(this._map))
                        }, this))
                    }, doClose: function () {
                        return this._state = u.CLOSED, this._overlay && this._overlay.setMap(null), l.resolve()
                    }, setupGeometry: function () {
                        if (this._overlay) {
                            var e = this._buildGeometry();
                            this._geometry && r(this._geometry.getCoordinates(), e.getCoordinates()) || (this._overlay.setGeometry(e), this._geometry = e)
                        }
                    }, _createOverlay: function (e) {
                        this._geometry = this._buildGeometry();
                        var t = this._overlay = new e(this._geometry, this._data);
                        return t.options.setParent(this.options), t.events.setParent(new _(this.events, new f(this))), t
                    }, _clearOverlay: function () {
                        this._overlay && (this._overlay.setMap(null), this._overlay.events.setParent(null), this._overlay = null)
                    }, _buildGeometry: function () {
                        var e = this.options.get("projection");
                        if (ym.env.debug) {
                            if (!this._position) throw new Error("Popup.buildGeometry: Не заданы координаты.");
                            if (!e) throw new Error("Popup.buildGeometry: Не задана проекция.")
                        }
                        return new s(e.toGlobalPixels(this._position, this._map.getZoom()))
                    }, _clearOpenAction: function () {
                        this._openTimeout && (clearTimeout(this._openTimeout), this._openTimeout = null), this._deferredOpen && this._deferredOpen.reject(v)
                    }, _clearCloseAction: function () {
                        this._closeTimeout && (clearTimeout(this._closeTimeout), this._closeTimeout = null), this._deferredClose && this._deferredClose.reject(d)
                    }, _onOpen: function () {
                        this._state == u.OPEN && this.events.fire("open")
                    }, _onClose: function () {
                        this._state == u.CLOSED && this.events.fire("close")
                    }
                }), t(f, {
                    _createMappings: function () {
                        for (var e = 0, t = o.length; e < t; e++) this[o[e]] = this._defaultMapping
                    }, _defaultMapping: function (e) {
                        return new p({type: e.get("type"), target: this._popup, domEvent: e.get("domEvent")}, e)
                    }
                }), e(c)
            });
        }],
        ['-o', function (ym) {
            ym.modules.define("panorama.Base", ["coordSystem.geo", "option.Manager", "panorama.math.util", "system.settings", "util.defineClass"], function (t, e, n, r, o, i) {
                function a() {
                }

                a.createPanorama = function (t) {
                    function n() {
                        n.superclass.constructor.call(this), ym.env.debug && this.validate()
                    }

                    if (ym.env.debug) {
                        var r = ["position", "angularBBox", "tileSize", "tileLevels"].filter(function (e) {
                            return !t.hasOwnProperty(e)
                        });
                        if (r.length) throw new Error(r.join(", ") + " cannot be ommited")
                    }
                    return i(n, a, {
                        getPosition: function () {
                            return t.position
                        }, getCoordSystem: function () {
                            return t.coordSystem || e
                        }, getName: function () {
                            return t.name || ""
                        }, getAngularBBox: function () {
                            return t.angularBBox
                        }, getTileSize: function () {
                            return t.tileSize
                        }, getTileLevels: function () {
                            return t.tileLevels
                        }
                    }), new n
                }, a.getMarkerPositionFromDirection = function (t, n, r) {
                    var i = Math.cos(n[0]), a = Math.sin(n[0]), s = t.getCoordSystem();
                    return s.solveDirectProblem(t.getPosition(), s == e && "latlong" == o.coordOrder ? [i, a] : [a, i], r * Math.cos(n[1])).endPoint.concat(r * Math.sin(n[1]))
                }, t(i(a, {
                    getName: function () {
                        return ""
                    }, getPosition: function () {
                        throw new Error(this.constructor.name + ".getTileSize isn't implemented")
                    }, getCoordSystem: function () {
                        return e
                    }, getAngularBBox: function () {
                        throw new Error(this.constructor.name + ".getTileSize isn't implemented")
                    }, getDefaultDirection: function () {
                        return [0, 0]
                    }, getDefaultSpan: function () {
                        return [r.deg2rad(130), r.deg2rad(80)]
                    }, getTileSize: function () {
                        throw new Error(this.constructor.name + ".getTileSize isn't implemented")
                    }, getTileLevels: function () {
                        throw new Error(this.constructor.name + ".getTileLevels isn't implemented")
                    }, getMarkers: function () {
                        return []
                    }, getConnectionMarkers: function () {
                        return []
                    }, getConnectionArrows: function () {
                        return []
                    }, getGraph: function () {
                        return null
                    }, validate: function () {
                        if (this.getPosition().length < 3) throw new Error("Panorama position must include height");
                        for (var t = this.getMarkers(), e = 0; e < t.length; ++e) if (t[e].getPosition().length < 3) throw new Error("Panorama marker position must include height");
                        for (var n = "function" == this.getConnections ? this.getConnections() : this.getConnectionMarkers(), e = 0; e < n.length; ++e) if (n[e].getPosition().length < 3) throw new Error("Panorama connection marker position must include height");
                        var o = this.getTileSize();
                        if (!r.isPowOfTwo(o[0]) || !r.isPowOfTwo(o[1])) throw new Error("Tile size must be power of two");
                        var i = this.getAngularBBox();
                        if (!r.floatsAreEqual(i[1] - i[3], 2 * Math.PI)) throw new Error("Panorama must be cycled in horizontal direction");
                        var a = this.getTileLevels();
                        if (0 == a.length) throw new Error("Panorama must have at least one tile level");
                        for (var e = 0; e < a.length; ++e) {
                            var s = a[e].getImageSize(), u = s[0] / o[0];
                            if (!r.floatsAreEqual(u, Math.round(u))) throw new Error("Tile level must contain integer number of tiles horizontally")
                        }
                    }, getConnections: function () {
                        return this.getConnectionMarkers()
                    }, getThoroughfares: function () {
                        return this.getConnectionArrows()
                    }
                }))
            });
        }],
        ['-!', function (ym) {
            ym.modules.define("panorama.Player", ["Panorama", "event.Manager", "meta.internal", "panorama.Engine", "panorama.locate", "panorama.math.util", "system.settings", "util.defineClass", "util.dom.element", "util.extend", "util.throttle", "vow"], function (e, t, n, i, a, r, o, s, g, h, c, u, m) {
                function d(e, t) {
                    return [o.rad2deg(2 * Math.atan(t * Math.tan(.5 * e))), o.rad2deg(e)]
                }

                function l(e, t, i) {
                    if ("string" == typeof e && (e = document.getElementById(e)), ym.env.debug && !h.isHTMLElement(e)) throw new TypeError("panorama.Player: element is not a HTMLElement instance");
                    i = c({}, E, i);
                    var r = this._engine = new a(e, i);
                    this._engineEvents = r.events.group().add(p, this._onEngineEvent, this).add(f, this._onMarkerEvent, this).add("close", this.destroy, this).add("error", this._onEngineError, this), this._cameraEvents = r.getCamera().events.group().add("directionchange", u(_, this._onDirectionChange), this).add(["aspectratiochange", "fovchange"], u(_, this._onFovChange), this), this.events = new n({context: this}), this.setPanorama(t), this.setSpan(i.span), this.setDirection(i.direction)
                }

                var v = "latlong" == s.coordOrder,
                    p = ["fullscreenenter", "fullscreenexit", "panoramachange", "renderload"],
                    f = ["markermouseenter", "markermouseleave", "markerexpand", "markercollapse"], _ = 100, E = {
                        autoFitToViewport: "always",
                        copyrightLogoVisible: !0,
                        copyrightVisible: !0,
                        direction: "auto",
                        hotkeysEnabled: !1,
                        scrollZoomBehavior: !0,
                        span: "auto",
                        suppressMapOpenBlock: i.suppressDistribution
                    };
                e(g(l, {
                    getPanorama: function () {
                        return this._engine.getPanorama()
                    }, setPanorama: function (e) {
                        return this._engine.setPanorama(e), this
                    }, moveTo: function (e, t) {
                        return r(e, t).then(function (e) {
                            return 0 == e.length ? m.reject(new Error("No panoramas")) : void this.setPanorama(e[0])
                        }, this)
                    }, getDirection: function () {
                        var e = this._engine.getCamera().getDirection();
                        return [o.rad2deg(e[0]), o.rad2deg(e[1])]
                    }, setDirection: function (e) {
                        return this._engine.getCamera().setDirection("auto" == e ? this._engine.getPanorama().getDefaultDirection() : [o.deg2rad(e[0]), o.deg2rad(e[1])]), this._engine.onActionEnd(), this
                    }, lookAt: function (e) {
                        var t = this.getPanorama(), n = this.getPanorama().getPosition(),
                            i = t.getCoordSystem().solveInverseProblem(n, e), a = i.startDirection;
                        return this._engine.getCamera().setDirection([Math.atan2(a[+v], a[+!v]), Math.atan2(e[2] || 0, i.distance)]), this._engine.onActionEnd(), this
                    }, getSpan: function () {
                        var e = this._engine.getCamera();
                        return d(e.getFov(), e.getAspectRatio())
                    }, getMinSpan: function () {
                        var e = this._engine.getCamera();
                        return d(e.getMinFov(), e.getAspectRatio())
                    }, getMaxSpan: function () {
                        var e = this._engine.getCamera();
                        return d(e.getMaxFov(), e.getAspectRatio())
                    }, setSpan: function (e) {
                        return this._engine.getCamera().setFov("auto" == e ? this._engine.getPanorama().getDefaultSpan()[1] : o.deg2rad(e[1])), this._engine.onActionEnd(), this
                    }, fitToViewport: function () {
                        this._engine.getScreen().updateSize()
                    }, destroy: function () {
                        this.events.fire("destroy"), this._cameraEvents.removeAll(), this._engineEvents.removeAll(), this._engine.destroy(), this._engine = null
                    }, toggleInternalCopyrights: function (e) {
                        this._engine.toggleInternalCopyrights(e)
                    }, zoomIn: function () {
                        this._engine.zoomIn()
                    }, zoomOut: function () {
                        this._engine.zoomOut()
                    }, _onEngineError: function (e) {
                        ym.logger.warning("panorama.Player: " + e.get("error").message), this.events.fire("error", {error: e.get("error")})
                    }, _onDirectionChange: function () {
                        this.events.fire("directionchange")
                    }, _onFovChange: function () {
                        this.events.fire("spanchange")
                    }, _onEngineEvent: function (e) {
                        this.events.fire(e.get("type"))
                    }, _onMarkerEvent: function (e) {
                        var t = e.get("type"), n = this.events.createEventObject(t, {marker: e.get("marker")}, this);
                        this.events.fire(t, n), n.isDefaultPrevented() && e.preventDefault()
                    }
                }))
            });
        }],
        ['-w', function (ym) {
            ym.modules.define("panorama.createPlayer", ["panorama.locate", "vow"], function (e, r, a) {
                e(function (e, n, o) {
                    return a.all([r(n, o), ym.modules.require("panorama.Player").spread(function (e) {
                        return e
                    })]).spread(function (r, n) {
                        return 0 == r.length ? a.reject(new Error("No panoramas")) : new n(e, r[0], o)
                    })
                })
            });
        }],
        ['-Y', function (ym) {
            ym.modules.define("panorama.isSupported", ["system.browser"], function (n, s) {
                function e(n, s) {
                    return "Android" == n && parseInt(s) < 4
                }

                function r(n, s) {
                    return "IEMobile" == n && /^10\./.test(s)
                }

                n(function () {
                    return !(!ym.supports.graphics.hasWebGl() && !ym.supports.graphics.hasCanvas()) && !(e(s.osFamily, s.osVersion) && "MobileFirefox" !== s.name || r(s.name, s.version))
                })
            });
        }],
        ['-1', function (ym) {
            ym.modules.define("panorama.locate", ["panorama.util.coordOrder", "panorama.util.layerName", "util.jsonp", "vow"], function (e, a, n, r, o) {
                e(function (e, t) {
                    t = t || {};
                    var m = t.layer || "yandex#panorama", s = {
                        format: "json",
                        l: n.toInternal(m) || m,
                        lang: ym.env.lang,
                        ll: a.toInternalOrder(e).join(),
                        connectionsTimestamp: t.connectionsTimestamp,
                        key: ym.env.key,
                        token: ym.env.token,
                        origin: "locate",
                        apikey: ym.env.apikey
                    };
                    return o.all([r({
                        url: ym.env.hosts.api.services.panoramaLocate + "1.x/",
                        requestParams: s
                    }), ym.modules.require("Panorama").spread(function (e) {
                        return e
                    })]).spread(function (e, a) {
                        return "success" == e.status ? [new a(e.data, m)] : 404 == e.code ? [] : o.reject(Error(e.message))
                    })
                })
            });
        }],
        ['_2', function (ym) {
            ym.modules.define("projection.Cartesian", ["util.defineClass", "util.math.cycleRestrict", "coordSystem.Cartesian"], function (e, t, o, n) {
                function i(e, t, o) {
                    if (ym.env.debug && (e[0][0] == e[1][0] || e[0][1] == e[1][1])) throw new Error("projection.Cartesian: Некорректные значения параметра bounds. Координаты углов не должны совпадать.");
                    r && (e = [[e[0][1], e[0][0]], [e[1][1], e[1][0]]]), this._bounds = e, this._cycled = t ? t : [!1, !1], this._xRange = e[1][0] - e[0][0], this._yRange = e[1][1] - e[0][1], this._coordSystem = new n(o)
                }

                var r = "latlong" == ym.env.coordinatesOrder;
                t(i, {
                    toGlobalPixels: function (e, t) {
                        if (ym.env.debug) {
                            if (!e) throw new Error("Cartesian.toGlobalPixels: не передан параметр point");
                            if ("undefined" == typeof t) throw new Error("Cartesian.toGlobalPixels: не передан параметр zoom")
                        }
                        var o = this._bounds, n = Math.pow(2, t + 8), i = e[r ? 1 : 0], s = e[r ? 0 : 1];
                        return [(i - o[0][0]) / this._xRange * n, (o[1][1] - s) / this._yRange * n]
                    }, fromGlobalPixels: function (e, t) {
                        if (ym.env.debug) {
                            if (!e) throw new Error("Cartesian.fromGlobalPixels: не передан параметр point");
                            if ("undefined" == typeof t) throw new Error("Cartesian.fromGlobalPixels: не передан параметр zoom")
                        }
                        var o = this._bounds, n = Math.pow(2, t + 8),
                            i = ("latlong" == ym.env.coordinatesOrder, [e[0] * this._xRange / n + o[0][0], o[1][1] - this._yRange * e[1] / n]);
                        return i = this._getFixedPoint(i), r ? [i[1], i[0]] : i
                    }, isCycled: function () {
                        return this._cycled
                    }, getCoordSystem: function () {
                        return this._coordSystem
                    }, _getFixedPoint: function (e) {
                        var t = this._bounds;
                        return [this._cycled[0] ? o(e[0], t[0][0], t[1][0]) : e[0], this._cycled[1] ? o(e[1], t[0][1], t[1][1]) : e[1]]
                    }
                }), e(i)
            });
        }],
        ['_6', function (ym) {
            ym.modules.define("projection.sphericalMercator", ["projection.GeoToGlobalPixels"], function (e, o) {
                e(new o({e: 0, coordinatesOrder: ym.env.coordinatesOrder}))
            });
        }],
        ['4Y', function (ym) {
            ym.modules.define("Rectangle", ["util.augment", "GeoObject"], function (e, t, n) {
                function o(e) {
                    return e && "undefined" != typeof e.length ? {type: "Rectangle", coordinates: e} : e
                }

                var c = function (e, t, n) {
                    c.superclass.constructor.call(this, {geometry: o(e), properties: t}, n)
                };
                t(c, n), e(c)
            });
        }],
        ['_-', function (ym) {
            ym.modules.define("regions", ["objectManager.component.customPaddingJsonp", "GeoObjectCollection", "vow", "constants.zIndex", "regions.decode", "regions.OsmGeoObject", "Polyline", "Placemark", "util.hash.rot13"], function (e, n, r, o, t, i, s, a, l, p) {
                function d(e, a) {
                    a = a || {};
                    var l = o.defer(), d = a.lang || ym.env.lang.substr(0, 2), u = "quality" in a ? a.quality : 1,
                        c = a.disputedBorders || ym.env.lang.substr(3, 2), g = a.host || m,
                        y = {lang: d + "_" + e, disputedBorders: c, quality: u};
                    return n({
                        url: g,
                        padding: "rcallback" + p(g) + (d + e + u + c).replace(new RegExp(/(\W)/g), ""),
                        requestParams: y,
                        postprocessUrl: function (e) {
                            return ym.env.hostConfigQuery ? e + "&" + ym.env.hostConfigQuery : e
                        }
                    }).then(function (e) {
                        var n = {}, o = e.regions, a = [];
                        for (var p in o) if (o.hasOwnProperty(p)) {
                            var d = i.geometry(p, e);
                            if (o[p].feature) n.properties = {
                                osmId: p,
                                hintContent: o[p].name,
                                name: o[p].name,
                                quality: u,
                                lang: e.lang,
                                country: e.country,
                                properties: o[p].property,
                                geometry: d
                            }; else {
                                o[p].property && (o[p].property.wikipedia = o[p].wikipedia), a[o[p].index] = new s({
                                    geometry: d,
                                    properties: {
                                        osmId: p,
                                        level: o[p].level,
                                        properties: o[p].property,
                                        parents: o[p].parents,
                                        hintContent: o[p].name,
                                        name: o[p].name
                                    }
                                }, {simplificationFixedPoints: d.fixedPoints})
                            }
                        }
                        for (var m = new r(n, {zIndexHover: t.overlay}), p = a.length - 1; p >= 0; --p) m.add(a[p]);
                        l.resolve({geoObjects: m})
                    }, function () {
                        l.reject()
                    }), l.promise()
                }

                var m = ym.env.hosts.api.services.regions + "1.0/regions.xml";
                e({load: d})
            });
        }],
        ['0E', function (ym) {
            ym.modules.define("borders", ["vow", "util.crossDomainXhr", "util.querystring", "regions.decode", "constants.zIndex", "regions.OsmGeoObject", "GeoObjectCollection"], function (e, n, t, r, o, i, s, a) {
                function u(e, n) {
                    return n.hintContent = n.name, {
                        type: "Feature",
                        geometry: {type: e.type, coordinates: e.coordinates, fillRule: "evenOdd"},
                        properties: n
                    }
                }

                function d(e) {
                    var n = e.regions, t = {type: "FeatureCollection", features: []};
                    for (var r in n) if (n.hasOwnProperty(r)) {
                        var i = o.geometry(r, e);
                        t.features.push(u(i, n[r]))
                    }
                    return t
                }

                function c(e, n) {
                    n = n || {};
                    var o = n.lang || ym.env.languageCode, i = "quality" in n ? n.quality : 1,
                        s = n.disputedBorders || ym.env.countryCode,
                        a = {lang: [o, e].join("_"), quality: i, disputedBorders: s}, u = l + "?" + r.stringify(a);
                    return t(u, {headers: {Accept: "application/json"}}, !0).then(function (e) {
                        return d(JSON.parse(e))
                    })
                }

                var l = ym.env.hosts.api.services.regions + "v2";
                e({load: c})
            });
        }],
        [',u', function (ym) {
            ym.modules.define("util.requireCenterAndZoom", ["util.margin", "util.bounds", "vow", "getZoomRange", "projection.wgs84Mercator"], function (e, o, r, n, t, i) {
                e(function (e, a, c, m) {
                    var s = m || {};
                    m = {
                        inscribe: !s.hasOwnProperty("inscribe") || s.inscribe,
                        preciseZoom: !!s.hasOwnProperty("preciseZoom") && s.preciseZoom,
                        projection: s.hasOwnProperty("projection") ? s.projection : i
                    };
                    var l = null;
                    s.hasOwnProperty("margin") && (l = o.correct(s.margin), c = [Math.max(c[0] - (l[1] + l[3]), 1), Math.max(c[1] - (l[0] + l[2]), 1)]);
                    var p = n.defer(), u = m.projection, f = r.getCenterAndZoom(a, c, u, m), h = f.center, g = f.zoom,
                        b = "function" == typeof e.get ? e.get(h) : t(e, h);
                    return b.then(function (e) {
                        var o, r = Math.min(e[1], Math.max(e[0], g));
                        if (r != g) {
                            o = u.toGlobalPixels(h, g);
                            var n = Math.pow(2, r - g);
                            o[0] *= n, o[1] *= n, g = r
                        }
                        l && (o || (o = u.toGlobalPixels(h, g)), o[0] += (l[1] - l[3]) / 2, o[1] += (l[2] - l[0]) / 2), o && (h = u.fromGlobalPixels(o, g)), p.resolve({
                            center: h,
                            zoom: g
                        })
                    }, function (e) {
                        p.reject(e)
                    }), p.promise()
                })
            });
        }],
        ['__', function (ym) {
            ym.modules.define("route", ["vow", "util.extend", "yandex.counter"], function (e, t, o, r) {
                function u(e, u) {
                    if (ym.env.debug && !e) throw new Error("route: Не передан массив точек, через которые должен проходить маршрут");
                    u = u || {};
                    var n = t.defer();
                    return u.multiRoute ? ym.modules.require(["multiRouter.MultiRouteModel", "multiRouter.MultiRoute"], function (t, i) {
                        for (var a = [], s = [], d = 0, l = e.length; d < l; d++) {
                            var p = e[d];
                            "object" == typeof p && "string" == typeof p.type ? (s.push(p.point), "viaPoint" == p.type && a.push(d)) : s.push(p)
                        }
                        u.viaIndexes || (u = o({}, u, {viaIndexes: a}));
                        var m = new t(s, u), c = m.events.group();
                        r.countByKey("modulesUsage", "route.multiRoute." + m.getParams().routingMode), c.add("requestsuccess", function () {
                            n.resolve(new i(m, {
                                boundsAutoApply: u.mapStateAutoApply,
                                useMapMargin: u.useMapMargin
                            })), c.removeAll()
                        }).add("requestfail", function (e) {
                            n.reject(e.get("error")), c.removeAll()
                        })
                    }) : (r.countByKey("modulesUsage", "route"), ym.modules.require(["router.Service", "router.Route", "router.addon.editor"], function (t, o) {
                        (new t).route(e, u).then(function (e) {
                            var t = new o(e, {
                                mapStateAutoApply: u.mapStateAutoApply,
                                avoidTrafficJams: u.avoidTrafficJams,
                                zoomMargin: u.zoomMargin,
                                useMapMargin: u.useMapMargin,
                                reverseGeocoding: u.reverseGeocoding
                            });
                            t.getPaths().getLength() ? n.resolve(t) : n.reject.reject("no route")
                        }, function (e) {
                            n.reject(e)
                        })
                    })), n.promise()
                }

                e(u)
            });
        }],
        ['.f', function (ym) {
            ym.modules.define("shape.Circle", ["util.defineClass", "shape.Base", "util.vector", "shape.storage", "shape.common.withOutlineBoundsGetter"], function (e, t, i, n, r, s) {
                function o(e, t) {
                    o.superclass.constructor.call(this, e, t)
                }

                t(o, i, s, {
                    getType: function () {
                        return "Circle"
                    }, contains: function (e) {
                        var t = this.getGeometry(), i = this.getParams(), r = t.getRadius(), s = t.getCoordinates(),
                            o = n.length([e[0] - s[0], e[1] - s[1]]);
                        if (i.get("fill", !0) && o <= r) return !0;
                        if (i.get("outline", !0)) {
                            var a = i.get("strokeWidth", 0) / 2, u = r + a, l = r - a;
                            return o <= u && o >= l
                        }
                        return !1
                    }
                }), r.add("Circle", o), e(o)
            });
        }],
        ['.k', function (ym) {
            ym.modules.define("shape.LineString", ["util.defineClass", "shape.Base", "shape.storage", "shape.common.withoutOutlineBoundsGetter", "geometry.component.findClosestPathPosition"], function (t, e, n, i, s, o) {
                function r(t, e) {
                    r.superclass.constructor.call(this, t, e)
                }

                e(r, n, s, {
                    getType: function () {
                        return "LineString"
                    }, contains: function (t) {
                        var e = this.getGeometry().getCoordinates();
                        return !!e.length && o(e, t).distance <= .5 * this.getParams().get("strokeWidth", 1)
                    }
                }), i.add("LineString", r), t(r)
            });
        }],
        ['.m', function (ym) {
            ym.modules.define("shape.MultiPolygon", ["util.defineClass", "shape.MultiGeometry", "shape.storage"], function (e, t, o, l) {
                function n(e, t) {
                    n.superclass.constructor.call(this, e, t)
                }

                t(n, o, {
                    getType: function () {
                        return "MultiPolygon"
                    }
                }), l.add("MultiPolygon", n), e(n)
            });
        }],
        ['.n', function (ym) {
            ym.modules.define("shape.Polygon", ["util.defineClass", "shape.Base", "shape.storage", "shape.common.withOutlineBoundsGetter", "geometry.component.findClosestPathPosition"], function (t, e, n, o, s, i) {
                function r(t, e) {
                    r.superclass.constructor.call(this, t, e)
                }

                e(r, n, s, {
                    getType: function () {
                        return "Polygon"
                    }, contains: function (t) {
                        var e = this.getParams();
                        if (e.get("fill", !0) && this.getGeometry().contains(t)) return !0;
                        if (e.get("outline", !0)) for (var n = .5 * e.get("strokeWidth", 0), o = this.getGeometry().getCoordinates(), s = 0, r = o.length; s < r; s++) if (o[s].length && i(o[s], t).distance <= n) return !0;
                        return !1
                    }
                }), o.add("Polygon", r), t(r)
            });
        }],
        ['.o', function (ym) {
            ym.modules.define("shape.Rectangle", ["util.defineClass", "shape.Base", "shape.storage", "shape.common.withOutlineBoundsGetter", "geometry.component.findClosestPathPosition"], function (t, e, n, s, a, i) {
                function o(t, e) {
                    o.superclass.constructor.call(this, t, e)
                }

                e(o, n, a, {
                    getType: function () {
                        return "Rectangle"
                    }, contains: function (t) {
                        var e = this.getParams();
                        if (e.get("fill", !0) && this.getGeometry().contains(t)) return !0;
                        if (e.get("outline", !0)) {
                            var n = this._getExternalPath();
                            return n && i(n, t).distance <= .5 * e.get("strokeWidth", 0)
                        }
                        return !1
                    }, _getExternalPath: function () {
                        var t = this.getGeometry().getCoordinates();
                        return t ? [t[0], [t[1][0], t[0][1]], t[1], [t[0][0], t[1][1]], t[0]] : null
                    }
                }), s.add("Rectangle", o), t(o)
            });
        }],
        ['.p', function (ym) {
            ym.modules.define("shape.storage", ["util.Storage"], function (e, n) {
                e(new n)
            });
        }],
        ['.v', function (ym) {
            ym.modules.define("suggest", ["yandex.geocodeProvider.storage", "yandex.searchProvider.storage"], function (e, r, n) {
                e(function (e, i) {
                    i = i || {};
                    var s, t = i.provider || "yandex#map";
                    return "string" == typeof t ? (r.isDefined(t) ? s = r.require([t]) : n.isDefined(t) && (s = n.require([t])), s.then(function (r) {
                        return r[0].suggest(e, i)
                    })) : t.suggest(e, i)
                })
            });
        }],
        ['.w', function (ym) {
            ym.modules.define("SuggestView", ["util.defineClass", "suggestView.component.Panel", "event.Manager", "option.Manager", "data.Manager", "layout.storage", "suggest", "map.metaOptions", "util.cancelableCallback", "yandex.counter"], function (e, t, s, n, a, i, o, l, u, h, c) {
                var g = function (e, t) {
                    this.state = new i({
                        request: "",
                        items: [],
                        activeIndex: null,
                        panelClosed: !1,
                        catalogClosed: !1
                    }), this.events = new n({context: this}), this.options = new a(t, u, "suggestView"), this._panel = new s(e, {
                        state: this.state,
                        options: this.options
                    }, {
                        onRequestChange: this._onRequestChange.bind(this),
                        onPanelOpen: this._onPanelOpen.bind(this),
                        onPanelClose: this._onPanelClose.bind(this),
                        onPanelCancel: this._onPanelCancel.bind(this),
                        onActiveIndexChange: this._onActiveIndexChange.bind(this),
                        onItemSelect: this._onItemSelect.bind(this),
                        onCatalogOpen: this._onCatalogOpen.bind(this),
                        onCatalogClose: this._onCatalogClose.bind(this)
                    }), this._requestCallback = null
                };
                t(g, {
                    destroy: function () {
                        this._lastDataRequest = null, this._panel.destroy()
                    }, isClickUnderLayout: function () {
                        return this._panel.isClickUnderLayout()
                    }, _onRequestChange: function (e) {
                        if (e) {
                            this.state.set({
                                request: e,
                                originalRequest: e
                            }), this._requestCallback = h.create(function (e) {
                                t == this._lastDataRequest && (this._lastDataRequest = null, this._onDataRequestSuccess(e))
                            }, this);
                            var t = this._lastDataRequest = this._makeRequest(e);
                            t.done(this._requestCallback)
                        } else this.state.set({request: "", items: []}), this._lastDataRequest = null
                    }, _onPanelOpen: function () {
                        this.state.set("panelClosed", !1)
                    }, _onPanelClose: function () {
                        this.state.set({panelClosed: !0, activeIndex: null})
                    }, _onPanelCancel: function () {
                        this._requestCallback && this._requestCallback.cancel(), this._requestCallback = null, this._onPanelClose()
                    }, _onActiveIndexChange: function (e, t) {
                        t ? this.state.set({activeIndex: e, request: t.value}) : this.state.set({activeIndex: e})
                    }, _onItemSelect: function (e) {
                        this.state.set({request: e.value, panelClosed: !0}), this.events.fire("select", {item: e})
                    }, _onCatalogOpen: function () {
                        c.countByKey("control", "searchSuggest.show"), this.state.set("catalogClosed", !1)
                    }, _onCatalogClose: function () {
                        this.state.set("catalogClosed", !0)
                    }, _makeRequest: function (e) {
                        return l(e, {
                            provider: this.options.get("provider"),
                            boundedBy: this.options.get("boundedBy"),
                            strictBounds: this.options.get("strictBounds"),
                            results: this.options.get("results")
                        })
                    }, _onDataRequestSuccess: function (e) {
                        this.state.set({
                            items: e,
                            activeIndex: null
                        }), e.length ? this.state.set({panelClosed: !1}) : this.state.set({panelClosed: !0})
                    }
                }), u.mapper.setRule({
                    name: "suggestView",
                    rule: "prefixed"
                }), u.set({
                    suggestViewLayout: "islands#suggestView",
                    suggestViewItemsLayout: "islands#suggestItems",
                    suggestViewProvider: "yandex#map",
                    suggestViewResults: 5,
                    suggestViewZIndex: 4e4
                }), o.define("islands#suggestItems", [], function (e) {
                    var t = ym.modules.require(["theme.islands.suggest.ItemsLayout"]).spread(function (e) {
                        return e
                    });
                    e.async(t)
                }), o.define("islands#suggestView", ["islands#suggestItems"], function (e) {
                    var t = ym.modules.require(["theme.islands.suggest.Layout", "theme.islands.suggest.ItemsLayout"]).spread(function (e) {
                        return e
                    });
                    e.async(t)
                }), e(g)
            });
        }],
        ['_Z', function (ym) {
            ym.modules.define("search", ["yandex.searchProvider.storage", "yandex.counter"], function (e, r, n) {
                e(function (e, a, c) {
                    a = a || {};
                    var t = a.provider || "yandex#search";
                    return n.countByKey("modulesUsage", "search." + (c || "direct")), "string" == typeof t ? r.require([t]).then(function (r) {
                        return r[0].search(e, a)
                    }) : t.search(e, a)
                })
            });
        }],
        ['.K', function (ym) {
            ym.modules.define("Template", ["util.defineClass", "template.Parser", "template.Builder", "template.filtersStorage"], function (e, t, r, i, s) {
                var a = function (e, t) {
                    "string" == typeof e ? (this._text = e, this._tree = null) : this._tree = e, this._parser = t
                };
                t(a, {
                    build: function (e) {
                        this._prepareParser(), this._prepareBuilder();
                        var t = this._builder.build(this._tree, e);
                        return t.text = t.strings.join(""), t
                    }, _prepareParser: function () {
                        this._parser || (this._parser = new r), this._tree || this._parse()
                    }, _prepareBuilder: function () {
                        this._builder = this._builder || new i(s)
                    }, _parse: function () {
                        this._parser || (this._parser = new r), this._tree = this._parser.parse(this._text)
                    }
                }), e(a)
            });
        }],
        ['.H', function (ym) {
            ym.modules.define("template.filtersStorage", ["util.Storage"], function (e, t) {
                var a = new t;
                a.add("default", function (e, t, a) {
                    var n = t;
                    if ("undefined" == typeof t) {
                        var i = a, r = i.charAt(0);
                        "'" == r || '"' == r ? (i = i.slice(1, i.length - 1), n = i) : n = isNaN(i) ? e.get(a) : i
                    }
                    return n
                }), e(a)
            });
        }],
        ['.N', function (ym) {
            ym.modules.define("templateLayoutFactory", ["templateLayoutFactory.Class"], function (t, e) {
                t(new e)
            });
        }],
        ['(S', function (ym) {
            function processVectorUrlTemplate(t) {
                return t.replace("{{lang}}", ym.env.lang)
            }

            ym.modules.define("traffic.provider.Actual", ["traffic.tileLayer", "control.optionMapper", "map.optionMapper", "Monitor", "traffic.constants", "traffic.provider.Base", "traffic.provider.storage", "traffic.regionData", "traffic.view.Actual", "traffic.weekDays", "util.augment", "yandex.dataProvider", "traffic.provider.actual.timestampProvider", "traffic.component.processUrlTemplate", "hotspot.layer.addon.balloon", "hotspot.layer.addon.hint", "theme.islands.traffic.metaOptions", "traffic.provider.actual.metaOptions", "util.cancelableCallback", "yandex.counter", "hotspot.Layer", "traffic.ActualMultiSource", "traffic.provider.initHintShowedTimeLogger"], function (t, e, i, s, a, o, r, n, l, h, p, c, u, m, f, d, _, g, y, v, T, L, M, S) {
                function I(t, e) {
                    if (t.length != e.length) return !1;
                    for (var i = 0, s = t.length; i < s; i++) if (t[i] != e[i]) return !1;
                    return !0
                }

                var b = m, w = {traffic: {png: "trf", js: "trj"}, info: {png: "trfe", js: "trje"}}, R = o.layers.geoId,
                    P = null, j = function (t, e) {
                        j.superclass.constructor.call(this, t, e), this.options.setName("actualProvider"), this._view = new h(this), this._timestampListener = null, this._hotspotObjectSource = null, this._layers = null, this._mapListener = null, this._stateMonitor = null, this._optionsMonitor = null, this._descriptionRequest = null, this._lastErrorTimestamp = 0
                    };
                c(j, r, {
                    setMap: function (t) {
                        j.superclass.setMap.call(this, t), this._view.setMap(t), t && T.countByKey("modulesUsage", "trafficProvider.actual.create")
                    }, onAddToMap: function (t) {
                        t.options.get("vector") && !P && this._requireVectorLayer(), this._hotspotObjectSource || (this._hotspotObjectSource = this._createHotspotSource()), this._layers || (this._layers = this._createLayers()), this._mapStateMonitor = new a(t.state).add("vectorEnabled", this._onVectorEnabledChange, this), this._setupOptionsMonitor(), this._setupStateMonitor(), this._checkInited(), this._setupTimestampProvider(), this._updateTimestamp(), this._updateRegionId(), this.state.get("infoLayerShown") && this._hotspotObjectSource.addLayer(w.info.js, this._layers.info), this._layers.png.setTileUrlTemplate(this._getPngTemplate()), this._layers.png.update(), this._layers.vector && this._layers.vector.setTileUrlTemplate(this._getVectorTemplate()), this._mapListener = t.events.group().add("boundschange", this._onMapBoundsChange, this).add("marginchange", this._updateRegionId, this)
                    }, onRemoveFromMap: function (t) {
                        this._mapListener.removeAll(), this._mapStateMonitor.removeAll(), this.state.get("infoLayerShown") && this._hotspotObjectSource.removeLayer(w.info.js), this._clearTimestampProvider(), this._clearStateMonitor(), this._clearOptionsMonitor(), this._clearLastDescriptionRequest(), this.state.set({
                            regionIds: null,
                            level: null,
                            iconStyle: null,
                            isInited: null,
                            timestamp: null
                        }), this._layers.png.events.remove("tileloaderror", this._onTileLoadError, this), this._lastErrorTimestamp = null, this._layers = null;
                        var e = this._hotspotObjectSource;
                        e && (e.options.setParent(null), this._hotspotObjectSource = null), this._trafficLayerHintShowedEvents && (this._trafficLayerHintShowedEvents.removeAll(), this._trafficLayerHintShowedEvents = null)
                    }, getLayers: function () {
                        return this._layers
                    }, update: function () {
                        this._updateTimestamp()
                    }, getTime: function () {
                        var t = this.state.get("timestamp");
                        if (!t) return null;
                        var e = new Date;
                        e.setTime(1e3 * t);
                        var i = 0 == e.getDay() ? 6 : e.getDay() - 1, s = e.getHours(), a = e.getMinutes();
                        return {
                            dayOfWeek: p.numberToAbbr(i),
                            hours: s < 10 ? "0" + s : s,
                            minutes: a < 10 ? "0" + a : a
                        }
                    }, _requireVectorLayer: function () {
                        ym.modules.require(["vectorEngine.TrafficLayer"]).spread(function (t) {
                            P = t, this._layers && (this._createVectorLayer(this._layers), this._layers.vector.setTileUrlTemplate(this._getVectorTemplate()), this._checkInited(), this._setupHotspotLayerZIndex())
                        }, this)
                    }, _onVectorEnabledChange: function () {
                        this._checkVectorLayerReady(), this._setupHotspotLayerZIndex()
                    }, _checkVectorLayerReady: function () {
                        this.getMap().state.get("vectorEnabled") && !P && this._requireVectorLayer()
                    }, _setupHotspotLayerZIndex: function () {
                        P && this.getMap().state.get("vectorEnabled") ? (this._layers.traffic.options.set("zIndex", -1), this._layers.info.options.set("zIndex", 1)) : (this._layers.traffic.options.set("zIndex", 1), this._layers.traffic.options.set("zIndex", 2))
                    }, _setupTimestampProvider: function () {
                        this._timestampProvider = b.get(this.getMap()), this.options.get("autoUpdate") && (this._timestampProvider.addAutoUpdateListener(), this._timestampListener = this._timestampProvider.events.group().add("timestampchange", function (t) {
                            this.state.set("timestamp", t.get("timestamp"))
                        }, this))
                    }, _clearTimestampProvider: function () {
                        this.options.get("autoUpdate") && (this._timestampProvider.removeAutoUpdateListener(), this._timestampListener.removeAll()), this._timestampProvider = null
                    }, _updateTimestamp: function () {
                        var t = this._timestampProvider.getCurrent();
                        t && this.state.set("timestamp", t), this._timestampProvider.get().then(function (t) {
                            this.state.set("timestamp", t)
                        }, this)
                    }, _checkInited: function () {
                        if (!this.state.get("isInited")) {
                            if (this.getMap().state.get("vectorEnabled") && !this._layers.vector) return;
                            this.state.set("isInited", !!this.state.get("timestamp"))
                        }
                    }, _setupOptionsMonitor: function () {
                        this._optionsMonitor = new a(this.options), this._optionsMonitor.add(["urlTemplate", "keyTemplate"], this._updateLayers, this).add("useMapMargin", this._updateRegionId, this)
                    }, _clearOptionsMonitor: function () {
                        this._optionsMonitor.destroy()
                    }, _setupStateMonitor: function () {
                        this._stateMonitor = new a(this.state), this._stateMonitor.add(["timestamp"], this._onTimestampChange, this).add("isInited", function (t) {
                            t && this.events.fire("init")
                        }, this).add(["infoLayerShown"], this._onInfoLayerShownChange, this).add(["regionIds"], this._updateRegionData, this)
                    }, _clearStateMonitor: function () {
                        this._stateMonitor.destroy()
                    }, _onMapBoundsChange: function (t) {
                        this._updateRegionId(), t.get("oldZoom") != t.get("newZoom") && this._closeLayersBalloon()
                    }, _getPngTemplate: function () {
                        var t = this.state.get("infoLayerShown") ? [w.traffic.png, w.info.png] : [w.traffic.png];
                        return f(this.options.get("urlTemplate"), {
                            layer: t.join(","),
                            timestamp: this.state.get("timestamp")
                        })
                    }, _getVectorTemplate: function () {
                        var t = this.state.get("infoLayerShown") ? [w.traffic.png, w.info.png] : [w.traffic.png];
                        return f(this.options.get("vectorTileUrlTemplate"), {
                            layer: t.join(","),
                            timestamp: this.state.get("timestamp")
                        })
                    }, _getDescriptionTemplate: function () {
                        return f(this.options.get("descriptionUrlTemplate"), {timestamp: this.state.get("timestamp")})
                    }, _updateRegionId: function () {
                        var t = this.getMap();
                        t && u.getLayersInfo([R], t.getCenter({useMapMargin: this.options.get("useMapMargin", !0)}), t.getZoom()).then(this._onRegionIdLoaded, this)
                    }, _onRegionIdLoaded: function (t) {
                        var e = [];
                        if (t[R] && t[R].LayerMetaData) for (var i = 0, s = t[R].LayerMetaData.length; i < s; i++) e.push(t[R].LayerMetaData[i].geoId);
                        I(this.state.get("regionIds") || [], e) || this.state.set("regionIds", e)
                    }, _updateRegionData: function () {
                        var t = this.state.get("regionIds"), e = t && t.length;
                        if (this.state.set({
                            level: null,
                            iconStyle: null,
                            localtime: null,
                            isotime: null,
                            trafficDataLoading: e
                        }), e) {
                            if (this._clearLastDescriptionRequest(), !this.state.get("timestamp")) return;
                            this._descriptionRequestCallback = v.create(function (t) {
                                if (t.isRejected()) this.state.set("trafficDataLoading", !1); else {
                                    var e = t.valueOf().JamsMetaData;
                                    this.state.set({
                                        level: e.level,
                                        iconStyle: e.icon,
                                        localtime: e.localtime,
                                        isotime: e.isotime,
                                        trafficDataLoading: !1
                                    })
                                }
                            }, this), l.get(t, this._getDescriptionTemplate()).always(this._descriptionRequestCallback)
                        }
                    }, _clearLastDescriptionRequest: function () {
                        this._descriptionRequestCallback && (this._descriptionRequestCallback.cancel(), this._descriptionRequestCallback = null)
                    }, _closeLayersBalloon: function () {
                        var t = this._layers;
                        t.traffic.balloon && t.traffic.balloon.close(), t.info.balloon && t.info.balloon.close()
                    }, _onTimestampChange: function () {
                        this._updateLayers(), this._updateRegionData(), this._checkInited()
                    }, _onTileLoadError: function (t) {
                        var e = f.getTimestamp(t.get("url"));
                        this.state.get("timestamp") === e && this._lastErrorTimestamp < e && (this._lastErrorTimestamp = e, this._updateTimestamp())
                    }, _updateLayers: function () {
                        this._closeLayersBalloon();
                        var t = this._hotspotObjectSource;
                        this._layers.png.setTileUrlTemplate(this._getPngTemplate()), this._layers.vector && this._layers.vector.setTileUrlTemplate(this._getVectorTemplate()), t && (t.setTimestamp(this.state.get("timestamp")), t.setTileUrlTemplate(this.options.get("urlTemplate")), t.setKeyTemplate(this.options.get("keyTemplate")));
                        for (var e in this._layers) this._layers.hasOwnProperty(e) && this._layers[e].update && this._layers[e].update()
                    }, _onInfoLayerShownChange: function () {
                        var t = this.state.get("infoLayerShown");
                        if (t != this._infoLayerShown) {
                            var e = this._hotspotObjectSource;
                            t ? (e && e.addLayer(w.info.js, this._layers.info), this._layers.png.setTileUrlTemplate(this._getPngTemplate()), this._layers.png.update(), this._layers.vector && this._layers.vector.setTileUrlTemplate(this._getVectorTemplate())) : (e && e.removeLayer(w.info.js), this._layers.png.setTileUrlTemplate(this._getPngTemplate()), this._layers.vector && this._layers.vector.setTileUrlTemplate(this._getVectorTemplate()), this.getMap() && this._layers.png.update())
                        }
                        this._infoLayerShown = t
                    }, _createHotspotSource: function () {
                        var t = new M(this.options.get("urlTemplate"), this.options.get("keyTemplate"), this.state.get("timestamp"));
                        return t.options.setParent(this.options), t
                    }, _createLayers: function () {
                        var t = this.options.get("tilesRoundingMethod"),
                            i = {png: new e(this._getPngTemplate(), {tilesRoundingMethod: t})};
                        return i.png.options.setName("trafficImage"), i.png.events.add("tileloaderror", this._onTileLoadError, this), P && this._createVectorLayer(i), i.traffic = new L(this._hotspotObjectSource, {tilesRoundingMethod: t}), this._trafficLayerHintShowedEvents = S(i.traffic), i.info = new L(this._hotspotObjectSource, {tilesRoundingMethod: t}), i.info.options.setName("trafficInfo"), i.traffic.options.setName("trafficJam"), this._hotspotObjectSource.addLayer(w.traffic.js, i.traffic), i
                    }, _createVectorLayer: function (t) {
                        t.vector = new P({}, {
                            vectorImageUrl: this.options.get("vectorImageUrlTemplate"),
                            vectorTileUrl: this._getVectorTemplate(),
                            vectorGlyphsUrl: processVectorUrlTemplate(ym.env.hosts.vectorGlyphs)
                        }), t.vector.options.setName("trafficVector")
                    }
                }), s.setRule({name: "actualProvider", rule: ["prefixed"]}), i.setRule({
                    name: "actualProvider",
                    rule: ["prefixed", "plain"]
                }), n.add("traffic#actual", j), t(j)
            });
        }],
        ['(X', function (ym) {
            ym.modules.define("traffic.provider.Archive", ["traffic.tileLayer", "control.optionMapper", "map.optionMapper", "Monitor", "traffic.constants", "traffic.provider.Base", "traffic.provider.storage", "traffic.regionData", "traffic.timeZone", "traffic.view.Archive", "traffic.weekDays", "util.augment", "util.extend", "util.math.cycleRestrict", "yandex.dataProvider", "traffic.component.processUrlTemplate", "hotspot.layer.addon.balloon", "hotspot.layer.addon.hint", "theme.islands.traffic.metaOptions", "traffic.provider.archive.metaOptions", "util.cancelableCallback", "yandex.counter", "hotspot.Layer", "traffic.MultiSource", "traffic.provider.initHintShowedTimeLogger"], function (t, e, i, s, o, n, a, r, l, h, u, p, c, m, d, g, _, f, T, v, M, y, L, I, b, Z) {
                function R(t, e) {
                    if (t.length != e.length) return !1;
                    for (var i = 0, s = t.length; i < s; i++) if (t[i] != e[i]) return !1;
                    return !0
                }

                var j = p, w = (ym.env.hosts.trafficArchive, {
                    png: "trf",
                    js: "trj",
                    regionInfo: n.layers.regionInfo,
                    geoId: n.layers.geoId
                }), S = function (t, e) {
                    S.superclass.constructor.call(this, t, m({
                        timeZone: null,
                        dst: "std",
                        stat: null,
                        isInited: !1
                    }, e || {})), this._view = new u(this), this.options.setName("archiveProvider"), this._hotspotObjectSource = null, this._layers = null, this.state.get("timeZone") && this.state.set("isInited", !0), this._regionTimestamp = null, this._sourceOptionMonitor = null, this._stateListener = null, this._stateMonitor = null, this._mapListener = null, this._timeZoneMonitor = null, this._repeatRequestTimeout = null, this._initialTimeMonitor = null, this._descriptionRequest = null
                };
                c(S, a, {
                    setMap: function (t) {
                        S.superclass.setMap.call(this, t), this._view.setMap(t), t && L.countByKey("modulesUsage", "trafficProvider.archive.create")
                    }, onAddToMap: function (t) {
                        this._hotspotObjectSource || (this._hotspotObjectSource = this._createSource()), this._sourceOptionMonitor = new o(this.options).add(["urlTemplate", "keyTemplate"], this._updateLayers, this).add("useMapMargin", this._updateRegionId, this), this._stateListener = this.state.events.group().add("change", this._onStateChange, this), this._stateMonitor = new o(this.state).add("timestamp", this._onTimestampChange, this).add(["regionIds"], this._updateRegionData, this), this._mapListener = t.events.group().add("boundschange", this._onMapBoundsChange, this).add("marginchange", this._updateRegionId, this), this._updateTimeZone(), this._checkInitialTime(), this._setupInitialTimeMonitor()
                    }, onRemoveFromMap: function (t) {
                        this._mapListener.removeAll(), this._stateListener.removeAll(), this._stateMonitor.removeAll(), this._sourceOptionMonitor.removeAll(), this._clearLastDescriptionRequest(), this._timeZoneMonitor && this._timeZoneMonitor.removeAll(), this._destroyInitialTimeMonitor(), this._repeatRequestTimeout && (window.clearTimeout(this._repeatRequestTimeout), this._repeatRequestTimeout = null), this._jsLayerHintShowedEvents && (this._jsLayerHintShowedEvents.removeAll(), this._jsLayerHintShowedEvents = null), this.state.set({
                            regionIds: null,
                            level: null,
                            iconStyle: null,
                            timeZone: null,
                            isInited: null
                        })
                    }, _onStateChange: function () {
                        var t = this.state;
                        t.get("isInited") || "undefined" != typeof t.get("timeZone") && (t.set("isInited", !0), this.events.fire("init"))
                    }, _onTimestampChange: function (t, e) {
                        this._layers || (this._layers = this._createLayers(), this._updateRegionId()), this.getMap() && (this._updateLayers(), this._updateRegionData()), this._updateHotspotObjectSource()
                    }, _updateLayers: function () {
                        this._closeLayersBalloon();
                        var t = this.options.get("urlTemplate"), e = this.options.get("keyTemplate"),
                            i = this._hotspotObjectSource;
                        this._layers.png.setTileUrlTemplate(this._processTemplate(t, w.png)), i && (i.setTileUrlTemplate(this._processTemplate(t)), i.setKeyTemplate(this._processTemplate(e)));
                        for (var s in this._layers) this._layers.hasOwnProperty(s) && this._layers[s].update()
                    }, _updateHotspotObjectSource: function () {
                        this._hotspotObjectSource.setTimestamp(this.state.get("timestamp"))
                    }, setTime: function (t, e) {
                        var i = this.state, s = i.get("timeZone");
                        if (null != s && this.getTime()) {
                            t = m(this.getTime(), t), t.minutes = 15 * Math.floor(t.minutes / 15);
                            var n = j.abbrToNumber(t.dayOfWeek), a = 24 * n * 60 * 60 + 3600 * t.hours + 60 * t.minutes,
                                r = "dst" == i.get("dst") ? 3600 : 0, l = i.get("timestamp"),
                                h = d(l + s - r, 0, 604800);
                            a != h && (d(a - s + r, 0, 604800), i.set("timestamp", d(a - s + r, 0, 604800))), e && e(t)
                        } else this._timeZoneMonitor || (this._timeZoneMonitor = new o(i)), this._timeZoneMonitor.removeAll(), this._timeZoneMonitor.add(["timeZone", "timestamp"], function (i, s) {
                            i && this.getTime() && (this.setTime(t, e), this._timeZoneMonitor.removeAll())
                        }, this)
                    }, getTime: function () {
                        var t = this.state, e = t.get("timestamp"), i = "dst" == t.get("dst") ? 3600 : 0,
                            s = t.get("timeZone");
                        if (null == s || null == e) return null;
                        var o = d(e + s - i, 0, 604800);
                        return {
                            dayOfWeek: j.numberToAbbr(Math.floor(o / 60 / 60 / 24) % 7),
                            hours: Math.floor(o / 60 / 60) % 24,
                            minutes: Math.floor(o / 60) % 60
                        }
                    }, getLayers: function () {
                        return this._layers
                    }, _updateRegionId: function () {
                        var t = [w.geoId, w.regionInfo], e = this.getMap();
                        if (e) {
                            var i = e.getCenter({useMapMargin: this.options.get("useMapMargin", !0)});
                            g.getLayersInfo(t, i, e.getZoom()).then(this._onRegionIdLoaded.bind(this))
                        }
                    }, _updateTimeZone: function () {
                        var t = this.getMap(), e = this._onTimeZoneLoaded.bind(this);
                        this._lastTimeZoneCallback = e, t && h.get(t.getCenter({useMapMargin: this.options.get("useMapMargin", !0)}), t.getZoom()).then(function (t) {
                            e == this._lastTimeZoneCallback && e(t.offset, t.dst)
                        }, function () {
                            e == this._lastTimeZoneCallback && e(null, null)
                        }, this)
                    }, _onRegionIdLoaded: function (t) {
                        var e = [], i = w.regionInfo;
                        if (t[i] && t[i].LayerMetaData) for (var s = 0, o = t[i].LayerMetaData.length; s < o; s++) e.push(t[i].LayerMetaData[s].geoId);
                        R(this.state.get("regionIds") || [], e) || this.state.set("regionIds", e)
                    }, _onTimeZoneLoaded: function (t, e) {
                        this.state.set({timeZone: t, dst: e})
                    }, _checkInitialTime: function () {
                        if (null == this.state.get("timestamp") && null != this.state.get("timeZone")) {
                            var t;
                            if (this.options.get("showCurrentTimeFirst", !0)) {
                                var e = new Date, i = e.getUTCHours() + ("dst" == this.state.get("dst") ? 1 : 0),
                                    s = e.getUTCMinutes(), o = e.getUTCDay();
                                o = o > 0 ? o - 1 : 6, s = 15 * Math.floor(s / 15), t = d(60 * s + 3600 * i + 24 * o * 3600, 0, 604800)
                            } else t = 28800;
                            this.state.set("timestamp", t), this._destroyInitialTimeMonitor(), this.getMap() && this._updateLayers()
                        }
                    }, _updateRegionData: function () {
                        var t = this.state.get("regionIds"), e = t && t.length;
                        if (this.state.set({
                            level: null,
                            iconStyle: null,
                            localtime: null,
                            isotime: null,
                            trafficDataLoading: e
                        }), e) {
                            if (this._clearLastDescriptionRequest(), !this.state.get("timestamp")) return;
                            this._descriptionRequestCallback = y.create(function (t) {
                                if (t.isRejected()) this.state.set("trafficDataLoading", !1); else {
                                    var e = t.valueOf().JamsMetaData;
                                    this.state.set({
                                        level: e.level,
                                        iconStyle: e.icon,
                                        localtime: e.localtime,
                                        isotime: e.isotime,
                                        trafficDataLoading: !1
                                    })
                                }
                            }, this), l.get(t, this._getDescriptionTemplate()).always(this._descriptionRequestCallback)
                        }
                    }, _getDescriptionTemplate: function () {
                        return this._processTemplate(this.options.get("descriptionUrlTemplate"))
                    }, _processTemplate: function (t, e) {
                        var i = this.state.get("timestamp"), s = {
                            timestamp: i,
                            timestampWithoutParam: i,
                            version: "5f82a212ae3a",
                            versionWithoutParam: "5f82a212ae3a"
                        };
                        return e && (s.layer = e), _(t, s)
                    }, _getStampTemplate: function () {
                        return this._processTemplate(this.options.get("stampUrlTemplate"))
                    }, _getObjectUrl: function (t) {
                        return this._processTemplate(this.options.get("objectUrlTemplate")).replace("%j", t)
                    }, _getDescriptionUrl: function (t) {
                        return this._getDescriptionTemplate().replace("%j", t)
                    }, _onMapBoundsChange: function (t) {
                        this.options.get("autoTimeZoneUpdate") && (this._updateRegionId(), this._updateTimeZone()), t.get("newZoom") != t.get("oldZoom") && this._closeLayersBalloon()
                    }, _closeLayersBalloon: function () {
                        var t = this._layers;
                        t.js.balloon && t.js.balloon.close()
                    }, _createSource: function () {
                        var t = new b(this._processTemplate(this.options.get("urlTemplate")), this._processTemplate(this.options.get("keyTemplate")));
                        return t.options.setParent(this.options), t
                    }, _createLayers: function () {
                        var t = this.options.get("tilesRoundingMethod"),
                            i = {png: new e(this._processTemplate(this.options.get("urlTemplate"), w.png), {tilesRoundingMethod: t})};
                        return i.png.options.setName("trafficImage"), i.js = new I(this._hotspotObjectSource, {tilesRoundingMethod: t}), i.js.options.setName("trafficJam"), this._jsLayerHintShowedEvents = Z(i.js), this._hotspotObjectSource.addLayer(w.js, i.js), i
                    }, _setupInitialTimeMonitor: function () {
                        "undefined" == typeof this.state.get("timestamp") && (this._initialTimeMonitor = new o(this.state), this._initialTimeMonitor.add(["dst", "timeZone"], this._checkInitialTime, this))
                    }, _destroyInitialTimeMonitor: function () {
                        this._initialTimeMonitor && (this._initialTimeMonitor.destroy(), this._initialTimeMonitor = null)
                    }, _clearLastDescriptionRequest: function () {
                        this._descriptionRequestCallback && (this._descriptionRequestCallback.cancel(), this._descriptionRequestCallback = null)
                    }
                }), s.setRule({name: "archiveProvider", rule: ["prefixed"]}), i.setRule({
                    name: "archiveProvider",
                    rule: ["prefixed", "plain"]
                }), r.add("traffic#archive", S), t(S)
            });
        }],
        ['(2', function (ym) {
            ym.modules.define("traffic.provider.Forecast", ["traffic.provider.storage", "traffic.provider.Actual"], function (r, f, a) {
                f.add("traffic#forecast", a), r(a)
            });
        }],
        ['(6', function (ym) {
            ym.modules.define("traffic.provider.storage", ["util.Storage"], function (e, i) {
                e(new i)
            });
        }],
        ['(q', function (ym) {
            ym.modules.define("util.augment", ["util.extend"], function (t, o) {
                var e = function (t, e, r) {
                    if (ym.env.debug) {
                        if (!e) throw new Error("util.augment: Родительский конструктор не передан");
                        if (!e.prototype) throw new Error("util.augment: Родительский конструктор не имеет прототипа")
                    }
                    return t.prototype = (Object.create || function (t) {
                        function o() {
                        }

                        return o.prototype = t, new o
                    })(e.prototype), t.prototype.constructor = t, t.superclass = e.prototype, t.superclass.constructor = e, r && o(t.prototype, r), t.prototype
                };
                t(e)
            });
        }],
        ['(i', function (ym) {
            ym.modules.define("util.bind", [], function (n) {
                var i;
                ym.env.debug && (i = function (n, i) {
                    if (!n) throw new Error("util.bind: не передан параметр func");
                    if (!i) throw new Error("util.bind: не передан параметр context")
                });
                var r = function (n, r) {
                    return ym.env.debug && i(n, r), arguments.length > 2 ? n.bind.apply(n, Array.prototype.slice.call(arguments, 1)) : n.bind(r)
                };
                n(r)
            });
        }],
        ['(Z', function (ym) {
            ym.modules.define("util.bounds", ["projection.wgs84Mercator", "util.math.cycleRestrict", "util.margin", "util.extend", "util.math.areEqual", "util.array", "util.pixelBounds", "util.bounds.components.coveringBounds", "util.bounds.components.getBoundsInZeroWorld", "util.bounds.components.glueBorderBounds", "util.bounds.components.getContainerScale"], function (n, t, o, e, r, l, i, a, s, u, c, h) {
                function f(n) {
                    var t = n[1], e = n[0];
                    m || (e = e.slice().reverse(), t = t.slice().reverse());
                    var r = o(t[0], e[0], e[0] + 360) - e[0], l = Math.abs(t[1] - e[1]);
                    return m ? [r, l] : [l, r]
                }

                function d(n) {
                    return n[0][0] = Math.round(n[0][0]), n[0][1] = Math.round(n[0][1]), n[1][0] = Math.round(n[1][0]), n[1][1] = Math.round(n[1][1]), n
                }

                function b(n) {
                    return Math.pow(2, n + 8)
                }

                var m = "latlong" != ym.env.coordinatesOrder, x = {
                    getCenterAndZoom: function (n, o, l, i) {
                        l || (l = t), i = r({
                            inscribe: !0,
                            preciseZoom: !1
                        }, "object" == typeof i ? i : {preciseZoom: i});
                        var s = i.hasOwnProperty("margin") ? e.correct(i.margin) : null;
                        s && (o = [Math.max(o[0] - (s[1] + s[3]), 1), Math.max(o[1] - (s[0] + s[2]), 1)]);
                        var u = this.toGlobalPixelBounds(n, 0, l), c = h(u, o, i),
                            f = l.fromGlobalPixels(a.getCenter(u), 0);
                        if (s) {
                            var d = l.toGlobalPixels(f, c);
                            d[0] += (s[1] - s[3]) / 2, d[1] += (s[2] - s[0]) / 2, f = l.fromGlobalPixels(d, c)
                        }
                        return {center: f, zoom: c}
                    }, toCenterAndSpan: function (n, t) {
                        if (t) {
                            var e = this.toGlobalPixelBounds(n, 0, t);
                            return {
                                ll: t.fromGlobalPixels([(e[1][0] + e[0][0]) / 2, (e[1][1] + e[0][1]) / 2], 0),
                                spn: f(n)
                            }
                        }
                        var r = m ? n[0][0] : n[0][1], l = m ? n[1][0] : n[1][1],
                            i = o((r + o(l, r, r + 360)) / 2, -180, 180), a = m ? n[0][1] : n[0][0],
                            s = m ? n[1][1] : n[1][0], u = (a + s) / 2;
                        return {ll: m ? [i, u] : [u, i], spn: f(n)}
                    }, fromPoints: function (n, o) {
                        var e = null;
                        if (n.length) {
                            o || (o = t);
                            var r = n, l = 23;
                            n = [];
                            for (var i = 0, a = r.length; i < a; i++) n[i] = o.toGlobalPixels(r[i], l);
                            e = s.fromPoints(n, b(l), o.isCycled()), e = this.fromGlobalPixelBounds(e, l, o)
                        } else e = [[0, 0], [0, 0]];
                        return e
                    }, fromBounds: function (n, o) {
                        if (1 == n.length) return this.clone(n[0]);
                        if (0 == n.length) return [[0, 0], [0, 0]];
                        o || (o = t);
                        var e = n, r = 23;
                        n = [], i.each(e, function (t, e) {
                            n[e] = this.toGlobalPixelBounds(t, r, o)
                        }, this);
                        var l = s.fromBounds(n, b(r), o.isCycled());
                        return this.fromGlobalPixelBounds(l, r, o)
                    }, clone: function (n) {
                        return [[n[0][0], n[0][1]], [n[1][0], n[1][1]]]
                    }, getCenter: function (n, o) {
                        return o || (o = t), n = this.toGlobalPixelBounds(n, 0, o), o.fromGlobalPixels([.5 * (n[0][0] + n[1][0]), .5 * (n[0][1] + n[1][1])], 0)
                    }, getSize: function (n, e) {
                        e || (e = t);
                        var r = [Math.abs(n[1][0] - n[0][0]), Math.abs(n[1][1] - n[0][1])], l = b(0) - 1e-10,
                            i = e.fromGlobalPixels([0, 0], 0), a = e.fromGlobalPixels([l, l], 0),
                            s = e.fromGlobalPixels([0, l], 0), u = e.isCycled();
                        return s[0] != i[0] && (u = [u[1], u[0]]), u[0] && (r[0] = o(n[1][0], n[0][0], n[0][0] + Math.abs(a[0]) + Math.abs(i[0])) - n[0][0]), u[1] && (r[1] = o(n[1][1], n[0][1], n[0][1] + Math.abs(a[1]) + Math.abs(i[1])) - n[0][1]), r
                    }, areIntersecting: function (n, o, e) {
                        e || (e = t);
                        var r = !1, l = 23, s = b(l), c = u(this.toGlobalPixelBounds(n, l, e), s),
                            h = u(this.toGlobalPixelBounds(o, l, e), s);
                        return i.each(c, function (n) {
                            return i.each(h, function (t) {
                                return r = a.areIntersecting(d(n), d(t)), !r
                            }), !r
                        }), r
                    }, getIntersections: function (n, o, e) {
                        e || (e = t);
                        var r = [], l = 23, s = b(l), h = u(this.toGlobalPixelBounds(n, l, e), s),
                            f = u(this.toGlobalPixelBounds(o, l, e), s);
                        return i.each(h, function (n) {
                            d(n), i.each(f, function (t) {
                                if (d(t), a.areIntersecting(n, t)) {
                                    var o = a.getIntersection(n, t);
                                    o && r.push(o)
                                }
                            })
                        }), h.length > 0 && f.length > 0 && r.length > 1 && (r = c(r, s)), i.each(r, function (n, t) {
                            r[t] = this.fromGlobalPixelBounds(n, l, e)
                        }, this), r
                    }, containsPoint: function (n, o, e) {
                        e || (e = t);
                        var r = !1, l = 23, s = b(l), o = e.toGlobalPixels(o, l),
                            c = u(this.toGlobalPixelBounds(n, l, e), s);
                        return i.each(c, function (n) {
                            return d(n), o[0] = Math.round(o[0]), o[1] = Math.round(o[1]), !(r = a.containsPoint(n, o))
                        }, this), r
                    }, containsBounds: function (n, o, e) {
                        e || (e = t);
                        var r = !1, l = 23, s = b(l), c = u(this.toGlobalPixelBounds(n, l, e), s),
                            h = u(this.toGlobalPixelBounds(o, l, e), s);
                        return i.each(c, function (n) {
                            return d(n), i.each(h, function (t) {
                                return !(r = a.containsBounds(n, d(t)))
                            }), !r
                        }), r
                    }, fromGlobalPixelBounds: function (n, o, e) {
                        e || (e = t);
                        var r = b(o), l = e.isCycled(),
                            i = [l[0] && Math.abs(n[1][0] - n[0][0]) >= r, l[1] && Math.abs(n[1][1] - n[0][1]) >= r],
                            a = [i[0] ? .5 * (n[0][0] + n[1][0]) - .5 * r + 1e-10 : Math.min(n[0][0], n[1][0]), i[1] ? .5 * (n[0][1] + n[1][1]) - .5 * r + 1e-10 : Math.min(n[0][1], n[1][1])],
                            s = [i[0] ? .5 * (n[0][0] + n[1][0]) + .5 * r - 1e-10 : Math.max(n[0][0], n[1][0]), i[1] ? .5 * (n[0][1] + n[1][1]) + .5 * r - 1e-10 : Math.max(n[0][1], n[1][1])];
                        s[0] == r && (s[0] -= 1e-10), s[1] == r && (s[1] -= 1e-10);
                        for (var u = [e.fromGlobalPixels(a, o), e.fromGlobalPixels(s, o)], c = 0, h = l.length; c < h; c++) if (!l[c]) {
                            var f = m ? c : h - 1 - c, d = u[0][f], x = u[1][f];
                            u[0][f] = Math.min(d, x), u[1][f] = Math.max(d, x)
                        }
                        return u
                    }, toGlobalPixelBounds: function (n, o, e) {
                        e || (e = t);
                        var r = e.toGlobalPixels(n[0], o), l = e.toGlobalPixels(n[1], o), i = e.isCycled(), a = b(o),
                            s = [r.slice(), l.slice()];
                        return r[0] > l[0] && (i[0] ? (s[0][0] = r[0], s[1][0] = l[0] + a) : (s[0][0] = l[0], s[1][0] = r[0])), r[1] > l[1] && (i[1] ? (s[0][1] = r[1], s[1][1] = l[1] + a) : (s[0][1] = l[1], s[1][1] = r[1])), s
                    }, contains: function (n, t, o) {
                        var e = o ? x : a;
                        return "number" == typeof t[0] ? e.containsPoint.apply(this, arguments) : e.containsBounds.apply(this, arguments)
                    }
                };
                n(x)
            });
        }],
        [')v', function (ym) {
            ym.modules.define("util.cursor.Accessor", ["event.Manager"], function (e, t) {
                var n = function (e) {
                    this._key = e, this.events = new t
                };
                n.prototype = {
                    setKey: function (e) {
                        this._key = e, this.events.fire("change", {target: this})
                    }, getKey: function () {
                        return this._key
                    }, remove: function () {
                        this.events.fire("remove", {target: this})
                    }
                }, e(n)
            });
        }],
        [')w', function (ym) {
            ym.modules.define("util.cursor.Manager", ["util.array", "util.dom.style", "util.cursor.storage", "util.cursor.Accessor", "event.Manager", "system.browser"], function (r, e, t, s, o, n, i) {
                var u = function (r) {
                    if (ym.env.debug && !r) throw new Error("util.cursor.Manager.constructor: не передан указатель на DOM элемент");
                    this._element = r, this._cursorStack = [], this.events = new n
                };
                u.svgCursorsSupported = "Presto" != i.engine && !i.isEdge && !i.isIE, u.svgWithHtmlCursorsSupported = u.svgCursorsSupported && !("Safari" == i.name && parseInt(i.version) < 10), u.dataUriCursorsSupported = !i.isEdge && !i.isIE, u.prototype = {
                    push: function (r) {
                        var e = new o(r), t = e.events, s = this._cursorStack;
                        return s.push(e), t.add("change", this._onCursorChange, this), t.add("remove", this._onCursorRemove, this), this._setupCursor(e), e
                    }, _onCursorChange: function (r) {
                        var t = r.get("target"), s = this._cursorStack, o = e.indexOf(s, t), n = s.length;
                        o != -1 && o == n - 1 && this._setupCursor(t)
                    }, _onCursorRemove: function (r) {
                        var t, s = r.get("target"), o = s.events, n = this._cursorStack, i = e.indexOf(n, s);
                        i != -1 && (n.splice(i, 1), t = n.length, t == i && (t ? this._setupCursor(n[t - 1]) : this._clearCursor()), o.remove("change", this._onCursorChange, this), o.remove("remove", this._onCursorRemove, this))
                    }, _setupCursor: function (r) {
                        var e = r.getKey(), o = "string" == typeof e ? s.get(e) : e;
                        if (o) {
                            var n, i = ym.env.browser;
                            o.cursor ? n = o.cursor : "Presto" == i.engine ? o.alternate && (n = o.alternate) : (n = "url(" + o.src + ")", !o.hotpoint || i.isIE || i.isEdge || (n = n + " " + o.hotpoint[0] + " " + o.hotpoint[1] + ", " + n), n += ", " + (o.alternate || "auto")), t.css(this._element, {cursor: n}), this.events.fire("change", {target: this})
                        }
                    }, _clearCursor: function () {
                        t.css(this._element, {cursor: ""}), this.events.fire("change", {target: this})
                    }
                }, r(u)
            });
        }],
        [')Y', function (ym) {
            ym.modules.define("util.Dragger", ["util.dragEngine.current", "event.Manager", "domEvent.manager", "util.extend", "util.dragger.component.defaultPreventer"], function (t, e, n, r, o, s) {
                function i(t) {
                    this._elementEventsGroup = null, this.events = new n;
                    var e;
                    t && t.tremor && (t.tremor.offset || t.tremor.time) && (e = t.tremor.offset), this._params = o({}, a, t), e && (this._params.tremor = e), this._autoStartElement = t ? t.autoStartElement : null, this._autoStartElement && this._setupAutoStartElement()
                }

                var a = {byRightButton: !1, tremor: 3, autoStartElement: null, disableBrowserBehavior: !1};
                i.prototype = {
                    isDragging: function () {
                        return e.isDragging(this)
                    }, start: function (t) {
                        e.start(this, t, this._params)
                    }, stop: function () {
                        e.stop(this)
                    }, destroy: function () {
                        this.stop(), this._clearAutoStartElement()
                    }, _setupAutoStartElement: function () {
                        var t = this._autoStartElement, e = "mousedown";
                        t.events ? (this._elementEventsGroup = t.events.group(), this._elementEventsGroup.add(e, function (t) {
                            this._onMouseDown(t.get("domEvent"))
                        }, this)) : (this._elementEventsGroup = r.group(t), this._elementEventsGroup.add(e, this._onMouseDown, this), s.enable(t))
                    }, _clearAutoStartElement: function () {
                        var t = this._autoStartElement;
                        t && !t.events && s.disable(t), this._elementEventsGroup && this._elementEventsGroup.removeAll()
                    }, _onMouseDown: function (t) {
                        var e = this._params, n = t.get("button"), r = e.byRightButton;
                        (r && 2 == n || !r && 0 == n) && (this.start(t), t.preventDefault())
                    }
                }, t(i)
            });
        }],
        [')6', function (ym) {
            ym.modules.define("util.fireWithBeforeEvent", ["util.extend", "Event"], function (e, t, n) {
                function r(e, r, l) {
                    l = l || {};
                    var a = "before" + r.type, u = t({}, r, {type: a}), c = l.mutableFields,
                        o = l.mutableHandlers || {}, s = new n(u, l.sourceEvent);
                    if (c) for (var v = 0, d = c.length; v < d; v++) {
                        var p = c[v];
                        u[f(p)] = function (e) {
                            return function (t) {
                                var n = s.get(e);
                                u[e] = t, o[e] && o[e](u, t, n)
                            }
                        }(p)
                    }
                    if (e.fire(a, s), c) {
                        r = t({}, r);
                        for (var v = 0, d = c.length; v < d; v++) {
                            var p = c[v];
                            r[p] = u[p]
                        }
                    }
                    s.isDefaultPrevented() ? i(l, "preventCallback", r, s) : i(l, "successCallback", r, s)
                }

                function i(e, t, n, r) {
                    if (e) {
                        var i = e.context, f = e[t];
                        f && ("undefined" != typeof i ? f.call(i, n, r) : f(n, r))
                    }
                }

                function f(e) {
                    return "set" + e.slice(0, 1).toUpperCase() + e.slice(1)
                }

                e(r)
            });
        }],
        ['0c', function (ym) {
            ym.modules.define("balloon.component.getBalloonMode", [], function (e) {
                e(function (e, n) {
                    var o = "default";
                    if (n) {
                        var t = e.container.getSize();
                        o = n >= t[0] * t[1] ? "panel" : "default"
                    }
                    return o
                })
            });
        }],
        ['0b', function (ym) {
            ym.modules.define("balloon.metaOptions", ["map.metaOptions", "map.optionMapper", "constants.zIndex", "interactivityModel.opaque", ym.modules.preload("map.pane.helper.balloon"), ym.modules.preload("map.pane.helper.shadows")], function (o, l, a, n, e) {
                l.set({
                    balloonOverlay: "html#balloon",
                    balloonPane: "balloon",
                    balloonShadowsPane: "shadows",
                    balloonLayout: "islands#balloon",
                    balloonPanelLayout: "islands#balloonPanel",
                    balloonContentLayout: "default#balloonContent",
                    balloonAutoPan: !0,
                    balloonAutoPanMargin: 34,
                    balloonPanelMaxMapArea: 16e4,
                    balloonPanelMaxHeightRatio: .5,
                    balloonZIndex: n.balloon,
                    balloonInteractivityModel: e,
                    balloonCloseButton: !0,
                    balloonMaxWidth: 400,
                    balloonMaxHeight: 400,
                    balloonMinWidth: 85,
                    balloonMinHeight: 30
                }), a.setRule({name: "balloon", rule: "prefixed"}).setRule({
                    name: "balloon",
                    key: ["projection"],
                    rule: "plain"
                }), o({})
            });
        }],
        ['0h', function (ym) {
            ym.modules.define("behavior.factory", ["util.defineClass", "collection.Item", "option.Manager", "util.extend", "theme.islands.behavior.meta"], function (i, t, n, e, s) {
                i({
                    create: function (i, a) {
                        var o = function (i, t) {
                            o.superclass.constructor.call(this, i), this._behaviorEnabled = t, "function" == typeof this.init && this.init(i, t)
                        };
                        return t(o, n, s({
                            createOptionManager: function (t) {
                                return new e(t, null, i)
                            }, onAddToMap: function () {
                                this._behaviorEnabled && this.startListening()
                            }, onRemoveFromMap: function () {
                                this._behaviorEnabled && this.stopListening()
                            }, enable: function () {
                                this._behaviorEnabled || (this._behaviorEnabled = !0, this.getMap() && this.startListening(), this.events.fire("enable"))
                            }, disable: function () {
                                this._behaviorEnabled && (this.getMap() && this.stopListening(), this._behaviorEnabled = !1, this.events.fire("disable"))
                            }, isEnabled: function () {
                                return this._behaviorEnabled
                            }, startListening: function () {
                            }, stopListening: function () {
                            }
                        }, a)), o
                    }
                })
            });
        }],
        [')r', function (ym) {
            ym.modules.define("util.coordinates.scaleInvert", [], function (e) {
                var n = {
                    centerToFixed: function (e, n, r) {
                        var t = [n[0] - e[0], n[1] - e[1]], i = r / (r - 1 || 1);
                        return [(e[0] + i * t[0]) * r, (e[1] + i * t[1]) * r]
                    }, fixedToCenter: function (e, n, r) {
                        var t = (r - 1) / r, i = [(n[0] - e[0]) * t, (n[1] - e[1]) * t];
                        return [(e[0] + i[0]) * r, (e[1] + i[1]) * r]
                    }
                };
                e(n)
            });
        }],
        [',)', function (ym) {
            ym.modules.define("yandex.counter", ["util.extend", "yandex.counterStorage"], function (t, e, n) {
                function r() {
                    u.countByKey.apply(u, arguments)
                }

                var o = ym.env.hosts.api, i = o.maps, a = o.statCounter + "counter/dtype=stred",
                    s = "all" == ym.env.counters ? 0 : Math.random(), u = {
                        count: function (t, e) {
                            var n, r, o, a = (new Date).getTime() + Math.round(100 * Math.random());
                            "string" == typeof e ? n = e : (e = e || {}, n = e.path, r = e.redirectUrl, o = e.additionalParams), n && (e.useVersionPrefix && (n = this.versionPrefix + "." + n), e.useCustomPrefix && ym.env.server.params.counter_prefix && (n = ym.env.server.params.counter_prefix + "." + n), t += "/path=" + n), o && (t += o), (r || "undefined" == typeof r) && (r = r || i, t += "/rnd=" + a, t += "/*" + r), this._count(t, e)
                        }, statfaceCount: function (t, e, n) {
                            var r = a + "/pid=" + t + "/cid=" + e;
                            this.count(r, n)
                        }, directCount: function (t, e) {
                            this._count(t, e)
                        }, countByKey: function (t, r) {
                            var o = n.get(t);
                            switch ("string" == typeof r && (r = {path: r}), o.type) {
                                case"direct":
                                    this.directCount(o.url);
                                    break;
                                default:
                                case"statface":
                                    this.statfaceCount(o.pid, o.cid, e({}, o.options, r))
                            }
                        }, versionPrefix: ym.env.version.replace(/\W/g, "_"), isActiveCounter: function (t) {
                            var e = n.get(t);
                            return !e || !e.options || "undefined" == typeof e.options.share || e.options.share > s
                        }, _count: function (t, e) {
                            if (!(e && "undefined" != typeof e.share && e.share < s)) {
                                var n = new Image;
                                n.src = t
                            }
                        }
                    };
                ym.count.provideImplementation(function (t) {
                    for (var e = 0; e < t.length; e++) r.apply(null, t[e]);
                    return r
                });
                try {
                    window.parent && window.parent.WebUI && u.countByKey("violators", {
                        path: "intranet.1C.2_1",
                        share: 1,
                        useCustomPrefix: !0
                    })
                } catch (c) {
                }
                t(u)
            });
        }],
        ['0d', function (ym) {
            ym.modules.define("behavior.action", ["util.defineClass", "map.action.Continuous"], function (i, t, e) {
                function o() {
                    o.superclass.constructor.call(this), this._timeoutID = 0, this._activeBehavior = null, this._activeBehaviorPriority = 0
                }

                t(o, e, {
                    capture: function (i, t, e) {
                        "undefined" == typeof e && (e = .5), this._activeBehaviorPriority <= e && (this._activeBehavior = t, this._activeBehaviorPriority = e, this._cancelStopping());
                        var o = this.getActionManager();
                        return o && o.getMap() != i && this.end(), this.isActive() || i.action.execute(this), this
                    }, tick: function (i, t) {
                        return t = t || {}, t.behavior != this._activeBehavior ? this : (this._cancelStopping(), o.superclass.tick.call(this, i), "undefined" != typeof t.autoStopTimeout && this._planStopping((i.duration || 0) + t.autoStopTimeout), this)
                    }, release: function (i) {
                        return i = i || {}, i.behavior && this._activeBehavior == i.behavior && (this._activeBehavior = null), this._activeBehaviorPriority = 0, this._cancelStopping(), this.isActive() && ("undefined" != typeof i.stopTimeout ? this._planStopping(i.stopTimeout) : this.end()), this
                    }, _planStopping: function (i) {
                        this._timeoutID = window.setTimeout(function () {
                            this._timeoutID = 0, this.end()
                        }.bind(this), i)
                    }, _cancelStopping: function () {
                        window.clearTimeout(this._timeoutID), this._timeoutID = 0
                    }
                }), i(new o)
            });
        }],
        [')J', function (ym) {
            ym.modules.define("util.math.cubicBezier", [], function (t) {
                t(function () {
                    function t(t) {
                        return h * Math.pow(t, 3) + p * Math.pow(t, 2) + l * t
                    }

                    function e(t) {
                        return g * Math.pow(t, 3) + b * Math.pow(t, 2) + M * t
                    }

                    function n(t) {
                        return l + t * (2 * p + 3 * t * h)
                    }

                    function r(e) {
                        for (var r, a = e, i = 0; i < 5 && (r = t(a) - e, !(Math.abs(r) < .001));) a -= r / n(a), i++;
                        return a
                    }

                    function a(n) {
                        return [t(n), e(n)]
                    }

                    function i(t) {
                        return e(r(t))
                    }

                    var o = {
                        linear: [0, 0, 1, 1],
                        ease: [.25, .1, .25, 1],
                        "ease-in": [.42, 0, 1, 1],
                        "ease-out": [0, 0, .58, 1],
                        "ease-in-out": [.42, 0, .58, 1]
                    }, u = o.linear;
                    if (arguments.length) {
                        var s, c = arguments[0],
                            f = /^cubic\-bezier\(([0-9\.]*[0-9]*),\s?([0-9\.]*[0-9]*),\s?([0-9\.]*[0-9]*),\s?([0-9\.]*[0-9]*)\)$/;
                        c instanceof Array ? u = c : c in o ? u = o[arguments[0]] : "string" == typeof c && (s = arguments[0].match(f)) && (u = [parseFloat(s[1]), parseFloat(s[2]), parseFloat(s[3]), parseFloat(s[4])])
                    }
                    var l = 3 * u[0], p = 3 * (u[2] - u[0]) - l, h = 1 - l - p, M = 3 * u[1], b = 3 * (u[3] - u[1]) - M,
                        g = 1 - M - b;
                    return {getPoint: a, getValue: i}
                })
            });
        }],
        ['0e', function (ym) {
            ym.modules.define("behavior.component.defaultMouseDownDispatcher", ["util.defineClass", "util.Associate"], function (e, n, t) {
                function i(e) {
                    e.events.add("mousedowndefaultaction", this._handle, this), this._handlers = {}
                }

                n(i, {
                    add: function (e, n, t) {
                        if (ym.env.debug && this._handlers[e]) throw new Error("behavior.component.defaultMouseDownDispatcher.add: Обработчик нажатия данной кнопки по умолчанию уже был добавлен ранее.");
                        return this._handlers[e] = [n, t], this
                    }, remove: function (e) {
                        return delete this._handlers[e], this
                    }, _handle: function (e) {
                        var n = this._handlers[e.get("originalEvent").get("domEvent").get("button")];
                        n && (n[1] ? n[0].call(n[1], e) : n[0](e))
                    }
                }), e(new t(function (e) {
                    return new i(e)
                }))
            });
        }],
        ['0k', function (ym) {
            ym.modules.define("behavior.magnifier.mouse.Component", ["util.defineClass", "util.Dragger", "domEvent.manager", "constants.zIndex", "constants.paneZIndex", "Monitor", "geometry.pixel.Rectangle", "pane.EventsPane", "behavior.component.defaultMouseDownDispatcher", "overlay.storage", "util.cancelableCallback", "yandex.counter", "map.pane.helper.controls"], function (t, e, s, o, i, n, a, r, h, _, l, c, u) {
                function g(t, e) {
                    this._owner = t, this._activeButton = e || 0, this._map = t.getMap(), 2 == this._activeButton ? _.get(this._map).add(2, function (t) {
                        return this._onMouseDown(t.get("originalEvent"))
                    }, this) : this._map.events.add("mousedown", this._onMouseDown, this), this._glassPane = null, this._cursor = null, this._monitor = null, this._startPosition = null, this._endPosition = null, this._dragger = null
                }

                e(g, {
                    destroy: function () {
                        this._dragger && this._clearDragger(), 2 == this._activeButton ? _.get(this._map).remove(2) : this._map.events.remove("mousedown", this._onMouseDown, this)
                    }, _onMouseDown: function (t) {
                        var e = t.get("domEvent");
                        e && e.get("button") == this._activeButton && (this._setupDragger(e), t.preventDefault())
                    }, _setupDragger: function (t) {
                        this._dragger = new s({
                            byRightButton: 2 == this._activeButton,
                            disableBrowserBehavior: !0
                        }), this._dragger.events.add("start", this._onDragStart, this).add("move", this._onDragMove, this).add("stop", this._onDragStop, this), this._dragger.start(t)
                    }, _clearDragger: function () {
                        this._dragger.isDragging() && this._dragger.stop(), this._dragger.events.remove("start", this._onDragStart, this).remove("move", this._onDragMove, this).remove("stop", this._onDragStop, this)
                    }, _onDragStart: function (t) {
                        this._map.action.stop(), this._canceled = !1, this._startPosition = this._endPosition = this._map.converter.pageToGlobal(t.get("position")), o.add(document, "keydown", this._onKeyDown, this), this._setupOverlay(), this._owner.events.fire("selectionstart", {activeButton: this._activeButton})
                    }, _onDragMove: function (t) {
                        this._endPosition = this._map.converter.pageToGlobal(t.get("position")), this._overlay && this._overlay.setBounds([this._startPosition, this._endPosition])
                    }, _onDragStop: function () {
                        this._clearOverlay(), o.remove(document, "keydown", this._onKeyDown, this), this._clearDragger();
                        var t = this._owner.options.get("tremor", 2),
                            e = Math.abs(this._endPosition[0] - this._startPosition[0]) <= t && Math.abs(this._endPosition[1] - this._startPosition[1]) <= t;
                        this._canceled || e ? this._owner.events.fire("selectioncancel", {activeButton: this._activeButton}) : (u.countByKey("control", "magnifier.action." + (this._activeButton ? "right" : "left")), this._apply(), this._owner.events.fire("selectionend", {activeButton: this._activeButton}))
                    }, _onKeyDown: function (t) {
                        27 == t.get("keyCode") && (t.callMethod("preventDefault"), this._canceled = !0, this._clearDragger())
                    }, _apply: function () {
                        var t = this._map,
                            e = [(this._endPosition[0] + this._startPosition[0]) / 2, (this._endPosition[1] + this._startPosition[1]) / 2],
                            s = this._computeZoom(), o = Math.pow(2, s - t.getZoom());
                        t.action.stop(), t.setGlobalPixelCenter([e[0] * o, e[1] * o], s, {
                            duration: this._owner.options.get("duration", 300),
                            checkZoomRange: !0
                        })
                    }, _computeZoom: function () {
                        var t = this._map.container.getSize(),
                            e = [Math.abs(this._endPosition[0] - this._startPosition[0]), Math.abs(this._endPosition[1] - this._startPosition[1])];
                        if (0 == e[0] || 0 == e[1]) return this._map.getZoom();
                        var s = t[0] / e[0], o = t[1] / e[1], i = Math.min(s, o),
                            n = this._map.getZoom() + Math.log(i) * Math.LOG2E;
                        return this._map.options.get("avoidFractionalZoom") && (n = Math.floor(n)), Math.max(n, this._map.getZoom())
                    }, _setupOverlay: function () {
                        this._setupGlassPane();
                        var t = l.get("html#rectangle");
                        null == t ? (this._overlayCallback = c.create(this._createOverlayInstance, this), l.require(["html#rectangle"]).spread(this._overlayCallback)) : this._createOverlayInstance(t)
                    }, _createOverlayInstance: function (t) {
                        this._overlayCallback = null, this._overlay = new t(this._createOverlayGeometry([this._startPosition, this._endPosition]), null, {
                            zIndex: -1,
                            pane: "controls",
                            eventsPane: "events"
                        }), this._overlay.options.setParent(this._owner.options), this._overlay.setMap(this._map), this._overlay.getLayout().then(function (t) {
                            this._overlay.getElement().style.visibility = "visible"
                        }, this)
                    }, _clearOverlay: function () {
                        this._overlayCallback ? this._overlayCallback.cancel() : (this._overlay.setMap(null), this._overlay.options.setParent(null), this._overlay = null), this._clearGlassPane()
                    }, _setupGlassPane: function () {
                        var t = this._map.panes.get("controls");
                        this._glassPane = new h(this._map, {zIndex: (t ? t.getZIndex() : n.controls) + 1}), this._map.panes.append("magnifier", this._glassPane), this._monitor = new a(this._owner.options).add("actionCursor", this._onActionCursorChange, this, {defaultValue: "crosshair"}), this._setupCursor(this._monitor.get("actionCursor"))
                    }, _clearGlassPane: function () {
                        this._clearCursor(), this._map.panes.remove(this._glassPane), this._glassPane.destroy()
                    }, _setupCursor: function (t) {
                        this._cursor = this._glassPane.cursors.push(t)
                    }, _clearCursor: function () {
                        this._cursor && this._cursor.remove()
                    }, _onActionCursorChange: function (t) {
                        this._clearCursor(), this._setupCursor(t)
                    }, _createOverlayGeometry: function (t) {
                        return new r([[Math.min(t[0][0], t[1][0]), Math.min(t[0][1], t[1][1])], [Math.max(t[0][0], t[1][0]), Math.max(t[0][1], t[1][1])]])
                    }
                }), t(g)
            });
        }],
        ['0p', function (ym) {
            ym.modules.define("behavior.MultiTouchEngine", ["util.defineClass", "behavior.BaseMultiEngine", "util.throttle"], function (t, i, o, s) {
                var e = function (t) {
                    e.superclass.constructor.call(this, t), this._behavior = t
                };
                i(e, o, {
                    startListening: function () {
                        e.superclass.startListening.call(this), this._onMoveThrottled = s(1e3 / this._behavior.options.get("actionsPerSecond", 20), this._onMove, {trailing: !1})
                    }, onMultiTouchStart: function (t) {
                        var i = t.get("originalEvent").get("domEvent");
                        i && (e.superclass.onMultiTouchStart.call(this, t), this._distance = this._getDistance(i), this._position = this._getPosition(i))
                    }, onMultiTouchMove: function (t) {
                        e.superclass.onMultiTouchMove.call(this, t), this._onMoveThrottled(t)
                    }, onMultiTouchEnd: function (t) {
                        e.superclass.onMultiTouchEnd.call(this, t)
                    }, _onMove: function (t) {
                        var i = this._getDistance(t), o = this._getPosition(t), s = i / this._distance;
                        this.processMove(o, s, [o[0] - this._position[0], o[1] - this._position[1]]), this._distance = i, this._position = o
                    }, _getDistance: function (t) {
                        var i = t.get("touches"), o = i[0], s = i[1], e = o.pageX - s.pageX, n = o.pageY - s.pageY,
                            a = Math.sqrt(e * e + n * n);
                        return Math.max(a, 1)
                    }, _getPosition: function (t) {
                        var i = t.get("touches"), o = i[0], s = i[1];
                        return [.5 * (o.pageX + s.pageX), .5 * (o.pageY + s.pageY)]
                    }
                }), t(e)
            });
        }],
        ['7Y', function (ym) {
            ym.modules.define("map.associate.serviceGeoObjects", ["util.Associate", "map.GeoObjects"], function (e, t, n) {
                var o = new t(function (e) {
                    return new n(e)
                });
                e({
                    get: function (e) {
                        if (ym.env.debug && !e) throw new Error("map.associate.serviceGeoObjects: передан пустой указатель на карту");
                        return o.get(e)
                    }
                })
            });
        }],
        ['0Q', function (ym) {
            ym.modules.define("constants.paneZIndex", [], function (o) {
                o({
                    phantom: 0,
                    vector: 90,
                    ground: 100,
                    areas: 200,
                    routerRoutes: 250,
                    shadows: 300,
                    shadowsSmooth: 301,
                    places: 400,
                    placesSmooth: 401,
                    editor: 450,
                    events: 500,
                    behaviors: 550,
                    overlaps: 600,
                    panoramaLayerGlass: 630,
                    editorGlass: 660,
                    routerEditorGlass: 660,
                    routerPoints: 670,
                    routerPointsSmooth: 671,
                    panoramaMinimapLayerGlass: 680,
                    ruler: 690,
                    balloon: 700,
                    outerBalloon: 800,
                    controls: 900,
                    copyrights: 1e3,
                    editorMenu: 1050,
                    editorActiveVertex: 1055,
                    hint: 1100,
                    outerHint: 1200,
                    search: 1300,
                    routePanel: 1400
                })
            });
        }],
        ['0z', function (ym) {
            ym.modules.define("constants.mapListenerPriority", [], function (e) {
                e({blocker: 1300, ruler: 1100, routeEditor: 1e3, panoramas: 850, behaviors: 800})
            });
        }],
        [':C', function (ym) {
            ym.modules.define("yandex.state.component.RulerBehavior", ["yandex.state.associate", "util.defineClass"], function (e, t, n) {
                function r(e) {
                    this._ruler = e, this._yandexState = null, this._rulerGeometryListeners = null, this._rulerListeners = null, this._setupListeners()
                }

                n(r, {
                    _setupListeners: function () {
                        this._rulerGeometryListeners = this._ruler.geometry.events.group().add("change", this._onRulerGeometryChange, this), this._rulerListeners = this._ruler.events.group().add("parentchange", this._onRulerParentChange, this)
                    }, _clearListeners: function () {
                        this._rulerGeometryListeners.removeAll(), this._rulerListeners.removeAll()
                    }, _onRulerParentChange: function (e) {
                        var n = e.get("newParent");
                        e.get("oldParent");
                        n && n.getMap() ? this._yandexState = t.get(n.getMap()) : this._yandexState && (this._clearRulerState(), this._yandexState = null)
                    }, _onRulerGeometryChange: function () {
                        this._yandexState && this._saveRulerState()
                    }, _saveRulerState: function () {
                        this._yandexState.setRulerState(this._ruler.getState())
                    }, _clearRulerState: function () {
                        this._yandexState.setRulerState(null)
                    }
                }), e(r)
            });
        }],
        ['0u', function (ym) {
            ym.modules.define("behavior.ruler.preset", ["option.presetStorage"], function (e, i) {
                i.add("ruler#line", {
                    coordRendering: "shortestPath",
                    simplification: !1,
                    geodesic: !0,
                    pixelRendering: "static"
                }), e({})
            });
        }],
        ['0y', function (ym) {
            ym.modules.define("behavior.scrollZoom.BaseZoomHandler", ["util.defineClass"], function (e, n) {
                var t = function (e) {
                    this._behavior = e
                };
                n(t, {
                    onBeforeWheel: function (e) {
                    }, onAfterWheel: function (e) {
                    }, teardownState: function () {
                    }, getTimeFilterValue: function () {
                        return 0
                    }, getZoomDuration: function (e, n) {
                        return 0
                    }, getNextZoom: function (e, n) {
                        return 0
                    }, _filterByZoomRange: function (e) {
                        var n = this._behavior.getMap().zoomRange.getCurrent();
                        return Math.min(Math.max(n[0], e), n[1])
                    }
                }), e(t)
            });
        }],
        [',a', function (ym) {
            ym.modules.define("util.math.getSign", [], function (n) {
                var t = function (n, t) {
                    return t && Math.abs(n) < 1e-10 ? 0 : n < 0 ? -1 : 1
                };
                n(t)
            });
        }],
        ['0T', function (ym) {
            ym.modules.define("clusterer.component.GridClusterer", ["util.defineClass", "clusterer.component.GridBoundsGetter", "clusterer.component.Grid", "component.tileBoundsGetter.util", "util.array", "util.bounds", "util.pixelBounds", "util.id", "util.margin", "util.extend", "util.math.areEqual", "event.Manager", "Monitor"], function (e, t, s, r, i, o, n, h, a, d, u, l, c, p) {
                function _(e, t) {
                    return h.containsPoint([e[0], [e[1][0] - 1, e[1][1] - 1]], t)
                }

                var g = function (e) {
                    this.options = e, this._gridBoundsGetter = new s(e), this._objectWrappers = [], this._unprocessedObjects = [], this._grid = new r, this.events = new c({context: this}), this._optionMonitor = null, this._createCellBindFunction = this._getCellData.bind(this), this._wrappersById = {}, this._clustersById = {}
                };
                t(g, {
                    add: function (e) {
                        var t, s, r = this._map, i = [];
                        for (t = 0, s = e.length; t < s; t++) "Point" == e[t].geometry.type && i.push(e[t]);
                        if (r) {
                            var n = this._getSortedObjectWrappers(i);
                            this._objectWrappers = o.merge(this._objectWrappers, n, f), this._generateObjectsGridNumbers(n);
                            var h = this._addToGrid(n, this._gridBoundsGetter.get());
                            this._regenerateClusters(h), this._checkBounds()
                        } else this._unprocessedObjects = this._unprocessedObjects.concat(i);
                        return this
                    }, remove: function (e) {
                        if (this._map) {
                            var t = this._removeObjectsFromGrid(e);
                            this._regenerateClusters(t)
                        } else this._removeUnprocessedObjects(e);
                        return this._removeObjectWrappers(e), this._checkBounds(), this
                    }, removeAll: function () {
                        return this._map && (this._fireRemoveAll(), this._grid.clearAll(), this._grid.createCells(this._createCellBindFunction, this._gridBoundsGetter.get()), this._checkBounds()), this._clustersById = {}, this._objectWrappers = [], this._unprocessedObjects = [], this._wrappersById = {}, this
                    }, setMap: function (e) {
                        this._map = e, e ? (this._gridBoundsGetter.setMap(e), this._addToMap(e)) : (this._removeFromMap(e), this._gridBoundsGetter.setMap(e))
                    }, getMap: function () {
                        return this._map
                    }, destroy: function () {
                        this._map && this._removeFromMap(this._map), this._map = null, this.removeAll(), this.events.fire("destroy")
                    }, getObjectState: function (e) {
                        return this._map && this._wrappersById[e] ? {
                            isShown: !!this._wrappersById[e].isShown,
                            isClustered: !!this._wrappersById[e].isClustered,
                            cluster: this._wrappersById[e].cluster
                        } : null
                    }, getObject: function (e) {
                        return e in this._wrappersById ? u({}, this._wrappersById[e].hash) : e in this._clustersById ? u({}, this._clustersById[e]) : null
                    }, getAll: function () {
                        for (var e = [], t = 0, s = this._objectWrappers.length; t < s; t++) e.push(this._objectWrappers[t].hash);
                        return e.concat(this._unprocessedObjects)
                    }, getBounds: function () {
                        if (this._map) {
                            for (var e = this.getAll(), t = [], s = 0, r = e.length; s < r; s++) t.push(e[s].geometry.coordinates);
                            return t.length > 0 ? n.fromPoints(t, this._map.options.get("projection")) : null
                        }
                        return null
                    }, getPixelBounds: function () {
                        if (this._map) {
                            for (var e = this.getAll(), t = [], s = this._map.getZoom(), r = this._map.options.get("projection"), i = 0, o = e.length; i < o; i++) t.push(r.toGlobalPixels(e[i].geometry.coordinates, s));
                            return h.fromPoints(t)
                        }
                        return null
                    }, _addToMap: function (e) {
                        if (this._applyGridSize(), this._setupOptionMonitor(), this._unprocessedObjects.length) {
                            var t = this._getSortedObjectWrappers(this._unprocessedObjects);
                            this._objectWrappers = o.merge(this._objectWrappers, t, f), this._unprocessedObjects = []
                        }
                        this._generateObjectsGridNumbers(this._objectWrappers), this._gridBoundsListener = this._gridBoundsGetter.events.group().add("gridboundschange", this._onGridBoundsChange, this);
                        var s = this._gridBoundsGetter.get();
                        this._grid.createCells(this._createCellBindFunction, s), this._addToGrid(this._objectWrappers, s), this._grid.forEach(this._generateClusters, this, s), this._showClusters()
                    }, _removeFromMap: function (e) {
                        this._clearOptionMonitor(), this._fireRemoveAll(), this._clearClusterData(), this._gridBoundsListener.removeAll(), this._grid.clearAll()
                    }, _getSortedObjectWrappers: function (e) {
                        for (var t = [], s = 0, r = e.length; s < r; s++) {
                            var i = {
                                hash: e[s],
                                pixelCoordsAtNull: this._map.options.get("projection").toGlobalPixels(e[s].geometry.coordinates, 0)
                            };
                            t.push(i), this._wrappersById[e[s].id] = i
                        }
                        return t.sort(f), t
                    }, _generateObjectsGridNumbers: function (e) {
                        for (var t = 0, s = e.length; t < s; t++) e[t].gridNumber = this._getGridNumber(e[t].pixelCoordsAtNull)
                    }, _getGridNumber: function (e) {
                        var t = this._currentGridSize, s = Math.pow(2, this._map.getZoom()), r = [e[0] * s, e[1] * s];
                        return r = [Math.floor(r[0] / t), Math.floor(r[1] / t)]
                    }, _addToGrid: function (e, t) {
                        for (var s = {}, r = this._getGridNumbersArray(e), i = 0, n = t.length; i < n; i++) for (var h = o.findAfterValue(r, t[i][0][0]), d = o.findAfterValue(r, t[i][1][0]), u = h; u < d; u++) {
                            var l = r[u];
                            if (_(t[i], l)) {
                                var c = this._grid.getCellData(l[0], l[1]), p = e[u].pixelCoordsAtNull, g = e[u].hash,
                                    f = Math.pow(2, this._map.getZoom());
                                s[a.get(c)] || (s[a.get(c)] = {
                                    cell: c,
                                    gridX: l[0],
                                    gridY: l[1]
                                }, this._removeCluster(c)), c.sumX += p[0] * f, c.sumY += p[1] * f, c.geoObjects.push(g)
                            }
                        }
                        return s
                    }, _getGridNumbersArray: function (e) {
                        for (var t = [], s = 0, r = e.length; s < r; s++) t.push(e[s].gridNumber);
                        return t
                    }, _removeCluster: function (e) {
                        if (e.clusters.length || e.geoObjectsWithoutClusters.length) {
                            for (var t = 0, s = e.clusters.length; t < s; t++) delete this._clustersById[e.clusters[t].id];
                            this._fireStateChange({
                                removed: e.geoObjectsWithoutClusters,
                                removedClusters: e.clusters
                            }), e.clusters = [], e.geoObjectsWithoutClusters = [];
                            for (var t = 0, s = e.geoObjects.length; t < s; t++) {
                                var r = this._wrappersById[e.geoObjects[t].id];
                                delete r.isShown, delete r.isClustered, delete r.cluster
                            }
                        }
                    }, _regenerateClusters: function (e) {
                        for (var t in e) e.hasOwnProperty(t) && (this._generateClusters(e[t].cell), this._showGridCluster(e[t].cell))
                    }, _generateClusters: function (e) {
                        if (this._map.getZoom() > this.options.get("maxZoom", Number.POSITIVE_INFINITY)) for (var t = e.geoObjects, s = 0, r = t.length; s < r; s++) {
                            e.geoObjectsWithoutClusters.push(t[s]);
                            var i = this._wrappersById[t[s].id];
                            i.isShown = !0, i.isClustered = !1
                        } else this.options.get("groupByCoordinates", !1) ? this._createGroupedByCoordinatesClusters(e) : this._createCellCluster(e)
                    }, _createGroupedByCoordinatesClusters: function (e) {
                        for (var t, s, r = {}, i = this._map.options.get("projection"), o = 0, n = e.geoObjects.length; o < n; o++) {
                            var h = e.geoObjects[o];
                            s = i.toGlobalPixels(h.geometry.coordinates, 23), t = [Math.floor(s[0]), Math.floor(s[1])].toString(), r[t] || (r[t] = []), r[t].push(h)
                        }
                        for (t in r) {
                            var a, d = r[t];
                            if (d.length >= this.options.get("minClusterSize", 2)) {
                                var u = this._createCluster(d[0].geometry.coordinates, d);
                                e.clusters.push(u);
                                for (var o = 0, n = d.length; o < n; o++) a = this._wrappersById[d[o].id], a.isClustered = !0, a.cluster = u, a.isShown = !0
                            } else {
                                e.geoObjectsWithoutClusters = e.geoObjectsWithoutClusters.concat(d);
                                for (var o = 0, n = d.length; o < n; o++) a = this._wrappersById[d[o].id], a.isClustered = !1, a.isShown = !0
                            }
                        }
                    }, _createCellCluster: function (e) {
                        if (e.geoObjects.length >= this.options.get("minClusterSize", 2)) {
                            var t = e.geoObjects.length, s = [e.sumX / t, e.sumY / t],
                                r = this._getCorrectMargin(this.options.get("margin", 10)), i = this._map.getZoom(),
                                o = this._currentGridSize / 2, n = e.center,
                                h = Math.max(Math.round(n[0] - (o - r[3])), s[0]);
                            h = Math.min(n[0] + (o - r[1]), h);
                            var a = Math.max(n[1] - (o - r[0]), s[1]);
                            a = Math.min(n[1] + (o - r[2]), a);
                            var d = this._map.options.get("projection").fromGlobalPixels([h, a], i),
                                u = this._createCluster(d, e.geoObjects);
                            e.clusters.push(u);
                            for (var l, c = 0, p = e.geoObjects.length; c < p; c++) l = this._wrappersById[e.geoObjects[c].id], l.isClustered = !0, l.cluster = u, l.isShown = !0
                        } else {
                            e.geoObjectsWithoutClusters = e.geoObjects.slice();
                            for (var l, c = 0, p = e.geoObjects.length; c < p; c++) l = this._wrappersById[e.geoObjects[c].id], l.isClustered = !1, l.isShown = !0
                        }
                    }, _createCluster: function (e, t) {
                        var s = {
                            id: a.gen(),
                            type: "Cluster",
                            geometry: {type: "Point", coordinates: e},
                            features: t,
                            number: t.length,
                            properties: {geoObjects: t, iconContent: t.length},
                            options: {}
                        };
                        return this._clustersById[s.id] = s, s
                    }, _showGridCluster: function (e) {
                        e.geoObjects.length && this._fireStateChange({
                            added: e.geoObjectsWithoutClusters,
                            addedClusters: e.clusters
                        })
                    }, _removeObjectWrappers: function (e) {
                        for (var t, s = [], r = 0, i = this._objectWrappers.length; r < i; r++) {
                            t = !1;
                            for (var o = 0, n = e.length; o < n && !t; o++) e[o].id == this._objectWrappers[r].hash.id && (delete this._wrappersById[e[o].id], t = !0);
                            t || s.push(this._objectWrappers[r])
                        }
                        this._objectWrappers = s
                    }, _removeObjectsFromGrid: function (e) {
                        var t = this._gridBoundsGetter.get();
                        if (t) {
                            for (var s = {}, r = this._getGridNumbersArray(this._objectWrappers), i = Math.pow(2, this._map.getZoom()), o = {}, n = 0, h = this._objectWrappers.length; n < h; n++) o[this._objectWrappers[n].hash.id] = n;
                            for (var n = 0, h = e.length; n < h; n++) {
                                var d = e[n], u = o[d.id], l = this._objectWrappers[u];
                                if (l && !l.deleted) {
                                    l.deleted = !0;
                                    for (var c = 0, p = t.length; c < p; c++) {
                                        var g = r[u];
                                        if (_(t[c], g)) {
                                            var f = this._grid.getCellData(g[0], g[1]), m = l.pixelCoordsAtNull;
                                            s[a.get(f)] || (s[a.get(f)] = {
                                                cell: f,
                                                gridX: g[0],
                                                gridY: g[1],
                                                removedObjects: {}
                                            }, this._removeCluster(f)), f.sumX -= m[0] * i, f.sumY -= m[1] * i, s[a.get(f)].removedObjects[d.id] = !0
                                        }
                                    }
                                }
                            }
                            for (var b = [], n = 0, h = this._objectWrappers.length; n < h; n++) this._objectWrappers.deleted || b.push(this._objectWrappers[n]);
                            this._objectWrappers = b;
                            for (var n in s) if (s.hasOwnProperty(n)) {
                                for (var v = [], j = s[n].cell.geoObjects, C = 0, h = j.length; C < h; C++) s[n].removedObjects[j[C].id] || v.push(j[C]);
                                s[n].cell.geoObjects = v
                            }
                            return s
                        }
                    }, _indexOfObject: function (e) {
                        for (var t = 0, s = this._objectWrappers.length; t < s;) {
                            if (e.id == this._objectWrappers[t].hash.id) return t;
                            t++
                        }
                        return -1
                    }, _onGridBoundsChange: function (e) {
                        e.get("oldZoom") != e.get("newZoom") ? this._refresh() : this._onGridBoundsMove(e)
                    }, _onGridBoundsMove: function (e) {
                        var t = i.getDisjointArea(e.get("newGridBounds"), e.get("oldGridBounds")), s = t.added;
                        this._grid.createCells(this._createCellBindFunction, s);
                        var r = this._addToGrid(this._objectWrappers, s);
                        this._regenerateClusters(r);
                        var o = t.removed;
                        this._grid.forEach(this._removeCluster, this, o), this._grid.clearCells(o)
                    }, _refresh: function () {
                        var e = this._getVisibleObjects();
                        this._clearClusterData(), this._grid.clearAll(), this._applyGridSize(), this._gridBoundsGetter.update();
                        var t = this._gridBoundsGetter.get();
                        this._grid.createCells(this._createCellBindFunction, t), this._generateObjectsGridNumbers(this._objectWrappers), this._addToGrid(this._objectWrappers, t), this._grid.forEach(this._generateClusters, this, t);
                        var s = this._getVisibleObjects(), r = this._getUpdatedObjectArrays(e.objects, s.objects);
                        this._fireStateChange({
                            added: r.added,
                            removed: r.removed,
                            update: r.update,
                            removedClusters: e.clusters,
                            addedClusters: s.clusters
                        })
                    }, _getVisibleObjects: function () {
                        var e = [], t = [];
                        return this._grid.forEach(function (s) {
                            e = e.concat(s.geoObjectsWithoutClusters), t = t.concat(s.clusters)
                        }, this), {objects: e, clusters: t}
                    }, _getUpdatedObjectArrays: function (e, t) {
                        e.sort(m), t.sort(m);
                        for (var s = [], r = [], i = [], o = 0, n = 0, h = e.length, a = t.length; o < h && n < a;) e[o].id < t[n].id ? (r.push(e[o]), o++) : e[o].id > t[n].id ? (s.push(t[n]), n++) : (i.push(e[o]), o++, n++);
                        return o != h && (r = r.concat(e.slice(o))), n != a && (s = s.concat(t.slice(n))), {
                            added: s,
                            removed: r,
                            update: i
                        }
                    }, _fireRemoveAll: function () {
                        var e = [], t = [];
                        this._grid.forEach(function (t) {
                            e = e.concat(t.geoObjectsWithoutClusters)
                        }, this);
                        for (var s in this._clustersById) t.push(this._clustersById[s]);
                        this._fireStateChange({removed: e, removedClusters: t, sync: !0})
                    }, _showClusters: function (e) {
                        this._grid.forEach(this._showGridCluster, this, e || this._gridBoundsGetter.get())
                    }, _getCorrectMargin: function (e) {
                        for (var t = this._currentGridSize / 2, s = d.correct(e), r = 0; r < 4; r++) s[r] = Math.min(s[r], t);
                        return s
                    }, _setupOptionMonitor: function () {
                        this._optionMonitor = new p(this.options).add(["gridSize", "viewportMargin", "margin", "minClusterSize", "maxZoom", "groupByCoordinates"], this._refresh, this)
                    }, _clearOptionMonitor: function () {
                        this._optionMonitor.destroy()
                    }, _fireStateChange: function (e) {
                        this.events.fire("statechange", {
                            added: e.added || [],
                            removed: e.removed || [],
                            addedClusters: e.addedClusters || [],
                            removedClusters: e.removedClusters || [],
                            update: e.update || [],
                            sync: e.sync
                        })
                    }, _getCellData: function (e, t) {
                        var s = this._currentGridSize;
                        return {
                            sumX: 0,
                            sumY: 0,
                            center: [e * s + s / 2, t * s + s / 2],
                            geoObjects: [],
                            clusters: [],
                            geoObjectsWithoutClusters: []
                        }
                    }, _removeUnprocessedObjects: function (e) {
                        for (var t, s = [], r = 0, i = this._unprocessedObjects.length; r < i; r++) {
                            t = !0;
                            for (var o = 0, n = e.length; o < n && !t; o++) e[o].id == this._unprocessedObjects[r].id && (t = !1);
                            t && s.push(this._unprocessedObjects[r])
                        }
                        this._unprocessedObjects = s
                    }, _applyGridSize: function () {
                        this._currentGridSize = Math.min(this.options.get("gridSize", 64), 256), this._currentGridSize = Math.max(this._currentGridSize, 2);
                        var e = Math.round(Math.log(this._currentGridSize) * Math.LOG2E);
                        this._currentGridSize = Math.pow(2, e)
                    }, _clearClusterData: function () {
                        this._clustersById = {};
                        for (var e in this._wrappersById) this._wrappersById[e].cluster = null, this._wrappersById[e].isClustered = !1, this._wrappersById[e].isShown = !1
                    }, _checkBounds: function () {
                        var e = this.getPixelBounds();
                        !!this._oldBounds == !!e && e && l(e[0], this._oldBounds[0]) && l(e[1], this._oldBounds[1]) || (this.events.fire("pixelboundschange"), this._oldBounds = e)
                    }
                });
                var f = function (e, t) {
                    return e.pixelCoordsAtNull[0] - t.pixelCoordsAtNull[0]
                }, m = function (e, t) {
                    return e.id > t.id ? 1 : e.id == t.id ? 0 : -1
                };
                e(g)
            });
        }],
        ['08', function (ym) {
            ym.modules.define("component.collection.ParentCollection", ["component.collection.BaseCollection", "component.parent.BaseParent"], function (t, e, n) {
                var o = function (t, o, a) {
                    this._callbacks = o || {}, this._parent = t, this._parentEvents = a, this._parentComponent = new n(t, {
                        callback: this._childParentChangeCallback,
                        context: this
                    }), this._baseCollectionComponent = new e({
                        onAdd: {callback: this._addCallback, context: this},
                        onRemove: {callback: this._removeCallback, context: this}
                    })
                };
                o.prototype = {
                    add: function (t) {
                        this._baseCollectionComponent.add(t)
                    }, remove: function (t) {
                        this._baseCollectionComponent.remove(t)
                    }, removeAll: function () {
                        this._baseCollectionComponent.removeAll()
                    }, getLength: function () {
                        return this._baseCollectionComponent.getLength()
                    }, getIterator: function () {
                        return this._baseCollectionComponent.getIterator()
                    }, each: function (t, e) {
                        this._baseCollectionComponent.each(t, e)
                    }, _addCallback: function (t) {
                        this._parentComponent.addChild(t);
                        var e = this._callbacks.onAdd;
                        e && e.callback.call(e.context, t)
                    }, _removeCallback: function (t) {
                        this._parentComponent.removeChild(t);
                        var e = this._callbacks.onRemove;
                        e && e.callback.call(e.context, t)
                    }, _childParentChangeCallback: function (t, e, n) {
                        this._parent == e && (t.events.setParent(null), t.options.setParent(null), this._baseCollectionComponent.remove(t)), this._parent == n && (t.events.setParent(this._parentEvents || this._parent.events), t.options.setParent(this._parent.options))
                    }
                }, t(o)
            });
        }],
        ['4S', function (ym) {
            ym.modules.define("geoObject.EventMappingTable", ["util.defineClass", "MapEvent"], function (e, n, t) {
                function i(e) {
                    this._geoObject = e, this.parentchange = !1, this.mapchange = !1, this.optionschange = !1, this.boundschange = !1, this.pixelboundschange = !1, this["*"] = this._defaultMapping
                }

                n(i, {
                    _defaultMapping: function (e) {
                        return new t({currentTarget: this._geoObject}, e)
                    }
                }), e(i)
            });
        }],
        ['0M', function (ym) {
            ym.modules.define("clusterer.optionMapper", ["option.Mapper"], function (e, n) {
                e(new n)
            });
        }],
        ['1Z', function (ym) {
            ym.modules.define("event.globalize", ["util.defineClass", "util.Associate", "event.Manager"], function (n, e, t, a) {
                function i() {
                    this.globalEventManager = null
                }

                var l = new t(function () {
                    return new i
                });
                e(i, {
                    onBeforeEventFiring: function (n, e, t) {
                        this.globalEventManager && this.globalEventManager.fire(e, t)
                    }
                }), n(function (n) {
                    var e = l.get(n);
                    return n.getMetaEventManager = function () {
                        return e.globalEventManager || (e.globalEventManager = new a)
                    }, e
                })
            });
        }],
        ['1I', function (ym) {
            ym.modules.define("error", ["util.defineClass", "util.extend"], function (r, e, t) {
                function o(r, e) {
                    function t(e) {
                        Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = (new Error).stack, this.name = r, this.message = e
                    }

                    return e && (t.errorClass = e), n[r] = t, t
                }

                var n = {
                    create: function (r, e) {
                        return n[r] ? new n[r](e) : void n.log("ProcessError", r + ": is undefined error type")
                    }, throwException: function (r, e) {
                        if (ym.env.debug) throw"object" == typeof r ? r : n.create(r, e)
                    }, throwExceptionIf: function (r, e, t) {
                        r && n.throwException(e, t)
                    }, warn: function (r, e) {
                        if (ym.env.debug && "object" == typeof console && console.warn) {
                            var t = "object" == typeof r ? r : n.create(r, e), o = new Error(t.name + ": " + t.message);
                            o.stack = t.stack, console.warn(o)
                        }
                    }, warnIf: function (r, e, t) {
                        r && n.warn(e, t)
                    }
                }, a = o("_YMError");
                e(a, Error);
                var c = o("ClientError");
                e(c, a);
                var i = o("InputError", "ClientError");
                e(i, c);
                var s = o("StateError", "ClientError");
                e(s, c);
                var E = o("ProcessError", "ClientError");
                e(E, c);
                var v = o("StorageItemAccessError", "ClientError");
                e(v, c);
                var l = o("FeatureRemovedError", "ClientError");
                e(l, c);
                var u = o("ExternalError");
                e(u, a);
                var f = o("RequestError", "ExternalError");
                e(f, u);
                var p = o("DataProcessingError", "ExternalError");
                e(p, u);
                var d = o("AccessError", "ExternalError");
                e(d, u);
                var w = o("NotSupportedError", "ExternalError");
                e(w, u);
                var g = o("Reject");
                e(g, a);
                var j = o("OperationUnallowedReject", "Reject");
                e(j, g);
                var R = o("OperationCanceledReject", "Reject");
                e(R, g);
                var m = o("EmptyResultReject", "Reject");
                e(m, g);
                var h = o("OperationUnavailableReject", "Reject");
                e(h, g);
                var x = o("Warning");
                e(x, a);
                var C = o("DeprecationWarning", "Warning");
                e(C, x);
                var y = o("OveruseWarning", "Warning");
                e(y, x), r(n)
            });
        }],
        ['!h', function (ym) {
            ym.modules.define("theme.islands.cluster.metaOptions", ["map.metaOptions", "option.presetStorage", "util.extend", "theme.islands.cluster.layout.preset", "theme.islands.cluster.icon.preset.standard", "theme.islands.cluster.invertedIcon.preset.standard"], function (e, t, s, n) {
                function r(e) {
                    var t = {};
                    for (var a in e) e.hasOwnProperty(a) && ("preset" == a ? n(t, r(s.get(e[a]))) : t["geoObject" + a.slice(0, 1).toUpperCase() + a.slice(1)] = e[a]);
                    return t
                }

                t.set(r(s.get("islands#blueClusterIcons"))), t.set(s.get("cluster#options")), e(!0)
            });
        }],
        ['_X', function (ym) {
            ym.modules.define("popup.addonBuilder", ["event.Mapper", "popup.managerStorage", "util.defineProperty", "util.id", "Event"], function (e, t, n, a, r, o) {
                function i(e, t) {
                    return e + t.charAt(0).toUpperCase() + t.substring(1)
                }

                function g(e) {
                    return "string" == typeof e && (e = n.get(e)), e
                }

                function s(e) {
                    function t(e) {
                        var t = e.get("target");
                        s(t), t.events && t.events.add("optionschange", d)
                    }

                    function n(e) {
                        var t = e.get("target");
                        u(t), t.events && t.events.remove("optionschange", d)
                    }

                    function s(e) {
                        var t = r.get(e), n = !!e.options.get(E, !0);
                        if (!h[t] && n) {
                            var o = h[t] = {managerClass: g(e.options.get(M, y))};
                            m ? a(e, c, function () {
                                return o.manager || (o.manager = p(e, o.managerClass))
                            }, null, {configurable: !0}) : e[c] = p(e, o.managerClass)
                        }
                    }

                    function u(e) {
                        var t = r.get(e), n = h[t];
                        if (n) {
                            var a = m ? n.manager : e[c];
                            a && (l && a.events.remove(l, f, e), a.destroy()), delete h[t], delete e[c]
                        }
                    }

                    function p(e, t) {
                        if (ym.env.debug && "function" != typeof t) throw new Error("popup.addonBuilder.initManager: Не удалось получить конструктор менеджера инфо-объекта.");
                        var n = new t(e);
                        return l && n.events.add(l, f, e), n
                    }

                    function v(e) {
                        return e[c] || s(e), e[c]
                    }

                    function d(e) {
                        var t = e.get("target"), n = h[r.get(t)], a = !!t.options.get(E, !0);
                        if (a) {
                            var o = g(t.options.get(M, y));
                            n ? n.managerClass != o && (u(t), s(t)) : s(t)
                        } else n && u(t)
                    }

                    function f(e) {
                        var t = c + e.get("type");
                        this.events.fire(t, new o({type: t, currentTarget: this.events.params.context}, e))
                    }

                    var c = e.type, l = e.fireEvents || ["open", "close"], m = e.lazyInit, y = e.defaultManager,
                        E = i("has", c), M = e.popupManagerOption || c + "Manager", h = {};
                    return e.metaEventManager && (e.metaEventManager.add("create", t).add("destroy", n), m && e.initEvents && e.metaEventManager.add(e.initEvents, function (e) {
                        v(e.get("target"))
                    })), {get: v}
                }

                e({build: s})
            });
        }],
        ['0K', function (ym) {
            ym.modules.define("сlusterer.Balloon", ["util.defineClass", "Balloon", "component.sharedEntity.captor.Balloon", "event.Manager", "map.addon.balloon", "option.Manager", "util.component", "util.extend", "util.array", "projection.idle", "util.preset", "Monitor", "popup.managerStorage", "clusterer.DataManager", "vow", "popup.component.checkEmptiness", "balloon.component.getBalloonMode"], function (t, e, o, n, s, i, r, a, l, p, c, h, u, _, g, d, f, M) {
                function m(t) {
                    this._clusterer = t, this.events = new s({context: this}), this._clusterWithOpenBalloon = null, this._clusterListener = null, this._balloonCaptorListener = null, this._setupCaptor(), this._setupListeners()
                }

                function v(t, e) {
                    return p.indexOf(t.getClusters(), e) != -1
                }

                var C = {visible: !1};
                e(m, a.createProxyMethods(function () {
                    return this._captor
                }, ["getOverlay", "getOverlaySync", "autoPan", "getOwner", "setPosition", "getPosition", "setData", "getData", "setOptions", "getOptions"]), {
                    destroy: function () {
                        this._clearListeners(), this._clearCaptor()
                    }, open: function (t) {
                        var e = d.defer(),
                            o = this._captor.open(t.geometry.getPixelGeometry().getCoordinates(), this._specifyData(t), new r({projection: c}, t.options, "balloon"));
                        return o.then(function () {
                            this._onOpen(t), e.resolve()
                        }, function (t) {
                            e.reject(t)
                        }, this), e.promise()
                    }, close: function (t) {
                        var e = this._captor.close(t), o = d.defer();
                        return e.then(function () {
                            this._onClose(), o.resolve()
                        }, function () {
                            o.reject()
                        }, this), o.promise()
                    }, isOpen: function (t) {
                        return this._clusterWithOpenBalloon == t
                    }, isEmpty: function (t) {
                        var e = this._specifyData(t);
                        return e.options = new r({
                            projection: c,
                            panelMode: "panel" == M(t.getMap(), t.options.get("balloonPanelMaxMapArea"))
                        }, t.options, "balloon"), f(this._clusterer.getMap(), "balloon", t.geometry.getPixelGeometry().getCoordinates(), e)
                    }, _setupCaptor: function () {
                        var t = this._clusterer.getMap(), e = t && i.get(t);
                        this._captor = new n(this, this._clusterer, "balloon", e), this._captor.events.add(["open", "close"], function (t) {
                            t.stopImmediatePropagation()
                        }).add("release", function () {
                            this._onClose()
                        }, this)
                    }, _clearCaptor: function () {
                        this._captor.close(), this._captor.destroy(), this._captor = null
                    }, _setupListeners: function () {
                        this._clusterer.events.add("mapchange", this._onMapChange, this).add("click", this._onClick, this)
                    }, _clearListeners: function () {
                        this._clusterer.events.remove("click", this._onClick, this).remove("mapchange", this._onMapChange, this)
                    }, _onClick: function (t) {
                        if (!t.isDefaultPrevented()) {
                            var e = t.get("target");
                            v(this._clusterer, e) && e.options.get("openBalloonOnClick", !0) && e != this._clusterWithOpenBalloon && (t.preventDefault(), e.options.get("openEmptyBalloon", !1) ? this.open(e) : this.isEmpty(e).then(function (t) {
                                t || this.open(e)
                            }, this))
                        }
                    }, _onOpen: function (t) {
                        this._clusterWithOpenBalloon && this._onClose(), this._clusterWithOpenBalloon = t, t.state.set("balloon"), this._clusterListener = t.events.group().add("mapchange", this._onClusterMapChange, this), this.getOptions().get("autoPan") && this._captor.getPopup().autoPan(), this._balloonCaptorListener = this._captor.getPopup().events.group().add("userclose", this._onUserClose, this), t.options.get("hideIconOnBalloonOpen") && (this._panelModeMonitor = new u(this._captor.getPopup().getOverlaySync().options).add("panelMode", function (e) {
                            this._toggleIcon(t, e)
                        }, this), this._captor.getPopup().getOverlaySync().options.get("panelMode") || this._toggleIcon(t)), this.events.fire("open", {cluster: t})
                    }, _onClose: function () {
                        this._clusterWithOpenBalloon && (this._showIcon(this._clusterWithOpenBalloon), this._clusterListener.removeAll(), this.events.fire("close", {cluster: this._clusterWithOpenBalloon}), this._clusterWithOpenBalloon = null), this._panelModeMonitor && (this._panelModeMonitor.removeAll(), this._panelModeMonitor = null), this._balloonCaptorListener && this._balloonCaptorListener.removeAll(), this._propertiesDataManger && this._propertiesDataManger.destroy()
                    }, _onMapChange: function () {
                        this._clusterer.getMap() ? this._setupSharingManager() : this.close()
                    }, _setupSharingManager: function () {
                        this._captor.setSharingManager(i.get(this._clusterer.getMap()))
                    }, _onUserClose: function () {
                        this._onClose()
                    }, _specifyData: function (t) {
                        return this._propertiesDataManger = new g(t.properties), {
                            geometry: t.geometry,
                            state: t.state,
                            properties: this._propertiesDataManger,
                            cluster: t
                        }
                    }, _toggleIcon: function (t, e) {
                        e ? this._showIcon(t) : this._hideIcon(t)
                    }, _hideIcon: function (t) {
                        h.addTo(t.options, C)
                    }, _showIcon: function (t) {
                        h.removeFrom(t.options, C)
                    }, _onClusterMapChange: function () {
                        this.close()
                    }
                }), _.add("clusterer#balloon", m), t(m)
            });
        }],
        ['0W', function (ym) {
            ym.modules.define("сlusterer.Hint", ["util.defineClass", "Hint", "component.sharedEntity.captor.Popup", "event.Manager", "map.addon.hint", "option.Manager", "util.component", "util.extend", "util.array", "vow", "projection.idle", "util.preset", "popup.managerStorage", "popup.component.checkEmptiness", "util.cancelableCallback", "util.id", "clusterer.DataManager"], function (t, e, s, i, n, r, o, a, c, l, h, p, u, _, g, C, f, d) {
                function v(t) {
                    this._clusterer = t, this.events = new n({context: this}), this._clusterListeners = {}, this._captorListeners = {}, this._setupListeners(), this._clusterWithOpenHint = null, this._isEmptyCheckCallback = null, this._activeCluster = null
                }

                function m(t, e) {
                    return l.indexOf(t.getClusters(), e) != -1
                }

                v.HintWasClosedError = function () {
                    return new Error("Hint was closed.")
                }, e(v, a.createProxyMethods(function () {
                    return this._captor
                }, ["open", "close", "isOpen", "getOverlay", "getOverlaySync", "getOwner", "setPosition", "getPosition", "setData", "getData", "setOptions", "getOptions"]), {
                    destroy: function () {
                        this.close(!0), this._clearListeners(), this._captor && (this._clearCaptorListeners(this._captor), this._destroyCaptor(this._captor), this._captor = null)
                    }, open: function (t, e) {
                        this._activeCluster = t;
                        var s = h.defer();
                        this._clusterListeners[f.get(t)] = t.events.group().add("mapchange", this._onClusterMapChange, this), this._captor && this._clusterWithOpenHint != t && (this._destroyCaptor(this._captor), this._clearCaptorListeners(this._captor)), this._clusterWithOpenHint == t && this._captor || (this._captor = this._createCaptor(t), this._setupCaptorListeners(this._captor));
                        var i = this._captor.open(e || t.geometry.getPixelGeometry().getCoordinates(), this._specifyData(t), new o({projection: p}, t.options, "hint"));
                        return i.then(function () {
                            this._onOpen(t), s.resolve()
                        }, function (e) {
                            this._onOpenReject(t), s.reject(e)
                        }, this), s.promise()
                    }, close: function (t) {
                        if (this._captor) {
                            var e = h.defer(), s = this._captor.close(t);
                            return s.then(function () {
                                this._onClose(), e.resolve()
                            }, function (t) {
                                e.reject(t)
                            }, this), e.promise()
                        }
                        return h.resolve()
                    }, isOpen: function (t) {
                        return !(!this._captor || !this._captor.isOpen() || this._clusterWithOpenHint != t)
                    }, isEmpty: function (t) {
                        var e = this._specifyData(t);
                        return e.options = new o({projection: p}, t.options, "hint"), g(this._clusterer.getMap(), "hint", t.geometry.getPixelGeometry().getCoordinates(), e)
                    }, _createCaptor: function (t) {
                        var e = this._clusterer.getMap(), s = e && r.get(e), n = new i(this, t, "hint", s);
                        return n
                    }, _destroyCaptor: function (t) {
                        t.close(!0), t.destroy()
                    }, _setupCaptorListeners: function (t) {
                        this._captorListeners[f.get(t)] = t.events.group().add(["open", "close"], function (t) {
                            t.stopImmediatePropagation()
                        }).add("release", this._onClose, this).add("capture", function () {
                            this.close(!0)
                        }, this)
                    }, _clearCaptorListeners: function (t) {
                        var e = f.get(t);
                        this._captorListeners[e].removeAll(), delete this._captorListeners[e]
                    }, _setupListeners: function () {
                        this._clustererListener = this._clusterer.events.group().add("mapchange", this._onMapChange, this).add("mouseenter", this._onMouseEnter, this).add("mousemove", this._onMouseMove, this).add("balloonopen", this._onBalloonOpen, this).add("mouseleave", this._onMouseLeave, this)
                    }, _clearListeners: function () {
                        this._clustererListener.removeAll()
                    }, _onMouseEnter: function (t) {
                        if (!t.isDefaultPrevented()) {
                            var e = t.get("target");
                            this._isBalloonOpen(e) || m(this._clusterer, e) && e.options.get("openHintOnHover", !0) && (t.preventDefault(), e.options.get("openEmptyHint", !1) ? this.open(e) : (this._isEmptyCheckCallback = C.create(function (s) {
                                s || this.open(e, t.get("globalPixels"))
                            }, this), this.isEmpty(e).then(this._isEmptyCheckCallback)))
                        }
                    }, _onMouseMove: function (t) {
                        this._captor && this.setPosition(t.get("globalPixels"))
                    }, _onMapChange: function () {
                        this._clusterer.getMap() ? this._setupSharingManager() : this.close(!0)
                    }, _setupSharingManager: function () {
                        this._captor && this._captor.setSharingManager(r.get(this._clusterer.getMap()))
                    }, _specifyData: function (t) {
                        return this._propertiesDataManger = new d(t.properties), {
                            geometry: t.geometry,
                            state: t.state,
                            properties: this._propertiesDataManger,
                            cluster: t
                        }
                    }, _onOpen: function (t) {
                        this._clusterWithOpenHint != t && (this._clusterWithOpenHint = t, this.events.fire("open", {cluster: t}))
                    }, _onOpenReject: function (t) {
                        this._activeCluster == t && (this._activeCluster = null), this._clearClusterListeners(t)
                    }, _onBalloonOpen: function (t) {
                        this._isEmptyCheckCallback && (this._isEmptyCheckCallback.cancel(), this._isEmptyCheckCallback = null), t.get("cluster") == this._activeCluster && this.close(!0)
                    }, _onClose: function () {
                        var t = this._clusterWithOpenHint;
                        t && (this._activeCluster == t && (this._activeCluster = null), this._clearClusterListeners(t), this._clusterWithOpenHint = null, this._propertiesDataManger && this._propertiesDataManger.destroy(), this.events.fire("close", {cluster: t}))
                    }, _clearClusterListeners: function (t) {
                        var e = f.get(t);
                        this._clusterListeners[e] && (this._clusterListeners[e].removeAll(), delete this._clusterListeners[e])
                    }, _onClusterMapChange: function (t) {
                        this.close(!0)
                    }, _onMouseLeave: function (t) {
                        this._isEmptyCheckCallback && (this._isEmptyCheckCallback.cancel(), this._isEmptyCheckCallback = null), this.close(!1)
                    }, _isBalloonOpen: function (t) {
                        return this._clusterer.balloon && this._clusterer.balloon.isOpen(t)
                    }
                }), _.add("clusterer#hint", v), t(v)
            });
        }],
        ['0O', function (ym) {
            ym.modules.define("cluster.optionMapper", ["option.Mapper"], function (e, n) {
                e(new n)
            });
        }],
        ['0P', function (ym) {
            ym.modules.define("clusterPlacemark.View", ["util.defineClass", "vow", "util.callbackChunker", "util.cancelableCallback", "constants.zIndex", "option.Manager", "option.Mapper", "Monitor", "geoObject.view.component.Dragger", "overlay.storage", "event.Mapper", "geoObject.view.component.OverlayEventMappingTable"], function (e, t, r, i, n, s, a, l, o, v, c, h, _) {
                function u(e, t) {
                    return t + e.slice(0, 1).toUpperCase() + e.slice(1)
                }

                var y = {defaultValue: !0}, p = function (e) {
                    this._cluster = e, this._overlay = null, this._overlayData = null, this._cancelableCallback = null, this._chunker = i.get(this._cluster.getMap()), this._chunkerCallbackId = NaN, this._optionMonitor = new o(this._cluster.options), this._startOverlayCreating(), this._setupVisibilityListener(), this._overlayEventsListener = null, this._previousZIndex = null
                };
                p.GeoObjectIsHiddenError = function () {
                    return new Error("GeoObject is not visible")
                }, p.GeoObjectRemovedFromMapError = function () {
                    return new Error("GeoObject was removed from map")
                }, p.OverlayWasntFoundError = function () {
                    return new Error("Overlay wasn't found")
                }, t(p, {
                    getOverlay: function () {
                        return this._overlayDeferred || (this._overlayDeferred = r.defer(), this._overlayRejectMessageFunc ? this._overlayDeferred.reject(this._overlayRejectMessageFunc()) : this._overlay && this._overlayDeferred.resolve(this._overlay)), this._overlayDeferred.promise()
                    }, getOverlaySync: function () {
                        return this._overlay || null
                    }, destroy: function () {
                        this._optionMonitor.removeAll(), this._rejectOverlayPromises(p.GeoObjectRemovedFromMapError), this._clearOverlayAndFire(), this._clearOverlayOptionManager(), this._overlayData = null
                    }, _startOverlayCreating: function () {
                        this._overlayDeferred = null, this._constructOverlay()
                    }, _clearOverlayAndFire: function () {
                        this._overlayDeferred = null;
                        var e = !!this._overlay;
                        this._overlay && (this._overlay.events.setParent(null), this._overlay.setMap(null), this._overlay.options.setParent(null), this._stopOverlayEventsListening(), this._clearHoverZIndex()), this._overlay = null, e > 0 && this._fireOverlayChange()
                    }, _constructOverlay: function () {
                        this._overlayRejectMessageFunc = null;
                        var e = this._cluster.options.get("pointOverlay");
                        if ("string" == typeof e) {
                            var t = e;
                            if (e = c.get(t), "undefined" == typeof e) return this._cancelableCallback = n.create(this._createOverlay, this), void c.require([t]).spread(this._cancelableCallback, function () {
                                this._rejectOverlayPromises(p.OverlayWasntFoundError)
                            }, this)
                        }
                        this._createOverlay(e)
                    }, _createOverlay: function (e) {
                        this._cancelableCallback = null, this._overlayClass = e, this._cluster.options.get("syncOverlayInit") ? this._setupOverlay() : this._chunkerCallbackId = this._chunker.addCallback(this._setupOverlay, this)
                    }, _fulfillOverlayPromises: function () {
                        this._overlayDeferred && this._overlayDeferred.resolve(this._overlay)
                    }, _rejectOverlayPromises: function (e) {
                        this._clearAsyncOperations(), this._overlayRejectMessageFunc = e, this._overlayDeferred && this._overlayDeferred.reject(e())
                    }, _clearAsyncOperations: function () {
                        this._cancelableCallback && (this._cancelableCallback.cancel(), this._cancelableCallback = null), this._chunkerCallbackId && (this._chunker.removeCallback(this._chunkerCallbackId), this._chunkerCallbackId = NaN)
                    }, _setupOverlay: function () {
                        this._chunkerCallbackId = NaN;
                        var e = this._overlayData || (this._overlayData = {
                            geometry: this._cluster.geometry,
                            properties: this._cluster.properties,
                            state: this._cluster.state,
                            geoObject: this._cluster
                        }), t = new this._overlayClass(this._cluster.geometry.getPixelGeometry(), e);
                        this._setupOverlayOptionManager(), this._setupMappingRules(t.options.getName()), t.options.setParent(this._overlayOptionManager), t.setMap(this._cluster.getMap()), t.events.setParent(new h(this._cluster.events, new _(this._cluster))), this._overlay = t, this._startOverlayEventsListening(), this._fulfillOverlayPromises(), this._fireOverlayChange()
                    }, _fireOverlayChange: function () {
                        this._cluster.events.fire("overlaychange", {overlay: this._overlay || null})
                    }, _setupVisibilityListener: function () {
                        this._optionMonitor.add("visible", this._onVisibilityChange, this, y)
                    }, _clearVisibilityListener: function () {
                        this._optionMonitor.remove("visible")
                    }, _onVisibilityChange: function () {
                        this._optionMonitor.get("visible") ? this._startOverlayCreating() : (this._rejectOverlayPromises(p.GeoObjectIsHiddenError), this._clearOverlayAndFire())
                    }, _setupOverlayOptionManager: function () {
                        this._overlayOptionManager && null != this._overlayOptionManager.getParent() || (this._overlayOptionNames = {}, this._overlayOptionMapper = new l, this._overlayOptionManager = new a(null, this._cluster.options, null, this._overlayOptionMapper))
                    }, _clearOverlayOptionManager: function () {
                        this._overlayOptionManager && this._overlayOptionManager.setParent(null)
                    }, _setupMappingRules: function (e) {
                        this._overlayOptionMapper.setRule({
                            name: e, rule: function (e) {
                                return [u(e, "icon"), e]
                            }
                        }), this._overlayOptionMapper.setRule({name: e, key: "projection", rule: "plain"})
                    }, _startOverlayEventsListening: function () {
                        this._overlayEventsListener = this._overlay.events.group().add(["mouseenter", "mouseleave"], this._onOverlayHoverChange, this)
                    }, _stopOverlayEventsListening: function () {
                        this._overlayEventsListener.removeAll()
                    }, _onOverlayHoverChange: function (e) {
                        "mouseenter" == e.get("type") ? this._setupHoverZIndex() : this._clearHoverZIndex()
                    }, _setupHoverZIndex: function () {
                        this._previousZIndex = this._overlay.options.get("zIndex", 0), this._overlay.options.set("zIndex", this._overlay.options.get("zIndexHover", s.hover))
                    }, _clearHoverZIndex: function () {
                        null !== this._previousZIndex && (this._overlay.options.set("zIndex", this._previousZIndex), this._previousZIndex = null)
                    }
                }), e(p)
            });
        }],
        ['00', function (ym) {
            ym.modules.define("collection.EventMappingTable", ["util.defineClass", "Event"], function (t, n, e) {
                function i(t) {
                    this._currentTarget = t, this.parentchange = !1, this.mapchange = !1, this.optionschange = !1, this["*"] = this._defaultMapping
                }

                n(i, {
                    _defaultMapping: function (t) {
                        return new e({currentTarget: this._currentTarget}, t)
                    }
                }), t(i)
            });
        }],
        ['1O', function (ym) {
            ym.modules.define("control.Selectable", ["util.defineClass", "control.Base"], function (e, t, s) {
                var i = function (e) {
                    i.superclass.constructor.call(this, e), this.state.get("enabled", !0) && this.enable(), this.state.events.add("change", this._onStateChange, this), this._selected = this.state.get("selected"), this._enabled = this.state.get("enabled"), this._setupSelectableEventRules()
                };
                t(i, s, {
                    select: function () {
                        this.isSelected() || this.state.set("selected", !0)
                    }, deselect: function () {
                        this.isSelected() && this.state.set("selected", !1)
                    }, isSelected: function () {
                        return this.state.get("selected", !1)
                    }, enable: function () {
                        this.state.set("enabled", !0)
                    }, disable: function () {
                        this.state.set("enabled", !1)
                    }, isEnabled: function () {
                        return this.state.get("enabled", !0)
                    }, _onStateChange: function () {
                        this.state.get("selected") != this._selected && (this._selected = this.state.get("selected"), this.events.fire(this._selected ? "select" : "deselect")), this.state.get("enabled") != this._enabled && (this._enabled = this.state.get("enabled"), this.events.fire(this._enabled ? "enable" : "disable"))
                    }, _setupSelectableEventRules: function () {
                        this.eventProxy.disableEventFiring("select").setCallback("select", this.select, this).disableEventFiring("deselect").setCallback("deselect", this.deselect, this).disableEventFiring("enable").setCallback("enable", this.enable, this).disableEventFiring("disable").setCallback("disable", this.disable, this)
                    }
                }), e(i)
            });
        }],
        ['1m', function (ym) {
            ym.modules.define("control.component.ToolBarButton", ["Monitor", "util.array"], function (t, e, i) {
                function n(t, e) {
                    var n = t.options.get("maxWidth") || 90;
                    if (i.isArray(n)) {
                        if (t.getParent()) {
                            var o = i.indexOf(t.getParent().options.get("states"), e);
                            return n[o]
                        }
                        return n[n.length - 1]
                    }
                    return n
                }

                var o = function (t) {
                    this._context = t, t.events.add("parentchange", this._onParentChange, this), t.options.events.add("change", this._checkOptionSize, this), this._parentStateMonitor = null, this._contextOptionsMonitor = null
                };
                o.prototype = {
                    _onParentChange: function (t) {
                        var i = t.get("newParent");
                        i ? (this._optionSize = this._context.options.get("size"), this._applyStateSizeAndMaxWidth(), this._parentStateMonitor = new e(i.state).add("size", this._applyStateSizeAndMaxWidth, this), this._contextOptionsMonitor = new e(this._context.options).add("maxWidth", this._applyStateMaxWidth, this)) : (this._parentStateMonitor.destroy(), this._contextOptionsMonitor.destroy())
                    }, _checkOptionSize: function () {
                        var t = this._context.options.get("size");
                        t != this._optionSize && (this._optionSize = t, this._applyStateSizeAndMaxWidth())
                    }, _applyStateSizeAndMaxWidth: function () {
                        var t = this._context.options.get("size", "auto");
                        if ("auto" == t) {
                            var e = this._context.getParent();
                            this._context.state.set("size", e ? e.state.get("size", "large") : "large")
                        } else this._context.state.set("size", t);
                        this._applyStateMaxWidth()
                    }, _applyStateMaxWidth: function () {
                        var t = this._context.state.get("size", "large");
                        this._context.state.set("maxWidth", n(this._context, t))
                    }
                }, t(o)
            });
        }],
        ['1v', function (ym) {
            ym.modules.define("control.optionMapper", ["option.Mapper"], function (o, n) {
                o(new n)
            });
        }],
        ['1b', function (ym) {
            ym.modules.define("control.BaseGroup", ["util.defineClass", "util.array", "control.storage", "component.array.ParentArray", "control.childElementController.GroupController", "control.Base", "Event", "event.Mapper", "control.EventMappingTable", "util.id", "util.cancelableCallback", "util.extend"], function (t, e, n, i, o, l, r, a, s, c, h, d, u) {
                function m(t, e) {
                    return t.options.get("positionIndex", 0) - e.options.get("positionIndex", 0)
                }

                var C = function (t) {
                    var e;
                    if (n.isArray(t) && (e = t, t = {}), t && t.items && (t = u({}, t), e = t.items, delete t.items), C.superclass.constructor.call(this, t), this._childElementController = new l(this), this._collectionImplementation = new o([], this, {
                        onAdd: {
                            callback: this.onChildAdd,
                            context: this
                        }, onRemove: {callback: this.onChildRemove, context: this}
                    }, new s(this.events, new c(this))), this._topContainer = null, this._setupGroupLayoutEventRules(), e) for (var i = 0, r = e.length; i < r; ++i) this.add(e[i])
                };
                e(C, r, {
                    add: function (t) {
                        return this._childElementController.insert(t), this._collectionImplementation.add(t), this
                    }, remove: function (t) {
                        return this._collectionImplementation.remove(t), this
                    }, removeAll: function () {
                        return this._collectionImplementation.removeAll(), this
                    }, getIterator: function () {
                        return this._collectionImplementation.getIterator()
                    }, each: function (t, e) {
                        return this._collectionImplementation.each(t, e), this
                    }, getLength: function () {
                        return this._collectionImplementation.getLength()
                    }, filter: function (t) {
                        for (var e, n = this.getIterator(), i = []; (e = n.getNext()) != n.STOP_ITERATION;) t(e) && i.push(e);
                        return i
                    }, get: function (t) {
                        return "string" == typeof t ? this._controlsByKey[t] : this._collectionImplementation.get(t)
                    }, getAll: function () {
                        for (var t, e = this.getIterator(), n = []; (t = e.getNext()) != e.STOP_ITERATION;) n.push(t);
                        return n
                    }, indexOf: function (t) {
                        return this._collectionImplementation.indexOf(t)
                    }, onChildAdd: function (t, e) {
                        this._collectionImplementation.quickSort(m), this.events.fire("add", {child: e}), e.events.add("update", this._onChildUpdate, this)
                    }, onChildRemove: function (t, e) {
                        this._childElementController.remove(e), this.events.fire("remove", {child: e}), e.events.remove("update", this._onChildUpdate, this)
                    }, getContainer: function () {
                        return this._topContainer
                    }, getChildElement: function (t) {
                        return this._childElementController.getElement(t)
                    }, onAddToMap: function (t) {
                        C.superclass.onAddToMap.call(this, t), this._cancelableCallback = d.create(function (t) {
                            this._cancelableCallback = null, this._setChildContainer(t.getChildContainerElement())
                        }, this), this.getLayout().then(this._cancelableCallback)
                    }, onRemoveFromMap: function (t) {
                        this._cancelableCallback && (this._cancelableCallback.cancel(), this._cancelableCallback = null), C.superclass.onRemoveFromMap.call(this, t)
                    }, _onChildUpdate: function (t) {
                        this.events.fire("update", {originalEvent: t})
                    }, _setupGroupLayoutEventRules: function () {
                        this.eventProxy.disableEventFiring("childcontainerchange").setCallback("childcontainerchange", this._onChildContainerSet, this)
                    }, _onChildContainerSet: function (t) {
                        this._setChildContainer(t.get("newChildContainerElement"))
                    }, _setChildContainer: function (t) {
                        if (this._topContainer != t) {
                            var e = this._topContainer;
                            this._topContainer = t, this._setChildElementsParent(t), this.events.fire("childcontainerchange", new a({
                                newChildContainerElement: this._topContainer,
                                oldChildContainerElement: e
                            }))
                        }
                    }, _setChildElementsParent: function (t) {
                        this._childElementController.setParentElement(t)
                    }
                }), t(C)
            });
        }],
        ['1f', function (ym) {
            ym.modules.define("control.component.CollapseOnBlur", ["Monitor", "domEvent.manager", "util.id", "util.cancelableCallback", "util.dom.style"], function (t, n, e, o, l, i) {
                var s = function (t, n) {
                    this._context = t, this._optionMonitor = null, this._controlElementListener = null, this._documentListener = null, this._cancelableCallback = null, this._listening = !1, this._callback = n || this._context.collapse, t.events.add("mapchange", this._onMapChange, this)
                };
                s.prototype = {
                    _onMapChange: function (t) {
                        var e = t.get("newMap");
                        e ? (this._optionMonitor = new n(this._context.options).add("collapseOnBlur", this._checkCollapseOnBlur, this), this._checkCollapseOnBlur()) : (this._optionMonitor.removeAll(), this._context.options.get("collapseOnBlur", !0) && this._stopMouseDownListening())
                    }, _checkCollapseOnBlur: function () {
                        this._context.options.get("collapseOnBlur", !0) ? this._startMouseDownListening() : this._stopMouseDownListening()
                    }, _startMouseDownListening: function () {
                        this._listening || (this._listening = !0, this._cancelableCallback = l.create(function (t) {
                            this._controlElementListener = e.group(t).add("mousedown", function (t) {
                                var n = t.get("propagatedData");
                                n.targetControlId = o.get(this._context)
                            }, this), this._documentListener = e.group(window.document.documentElement).add("mousedown", function (t) {
                                var n = t.get("propagatedData");
                                n.targetControlId != o.get(this._context) && this._callback.call(this._context)
                            }, this)
                        }, this), this._context.getParent().getChildElement(this._context).then(this._cancelableCallback))
                    }, _stopMouseDownListening: function () {
                        this._cancelableCallback && (this._cancelableCallback.cancel(), this._cancelableCallback = null), this._controlElementListener && (this._controlElementListener.removeAll(), this._documentListener.removeAll()), this._listening = !1
                    }
                }, t(s)
            });
        }],
        ['1s', function (ym) {
            ym.modules.define("control.manager.toolbarElementController", ["util.defineClass", "control.childElementController.Base", "Monitor", "util.id"], function (t, i, n, e, o) {
                var s = function (t, i) {
                    s.superclass.constructor.call(this, t), this._side = i, this._childPositionMonitors = {}
                };
                i(s, n, {
                    insert: function (t, i) {
                        s.superclass.insert.call(this, t, i), this.getParentElement() && this._setupChildMonitor(t)
                    }, remove: function (t) {
                        this.getParentElement() && this._clearChildMonitor(t), s.superclass.remove.call(this, t)
                    }, getChildIndex: function (t) {
                        return this.getParent().indexOf(t)
                    }, comparator: function (t, i) {
                        var n = t.options.get("floatIndex", 0), e = this.getChildIndex(t),
                            o = i.options.get("floatIndex", 0), s = this.getChildIndex(i);
                        return "left" == this._side ? o - n || s - e : n - o || e - s
                    }, setParentElement: function (t) {
                        var i = this.getParentElement();
                        s.superclass.setParentElement.call(this, t), i && !t && this._clearChildMonitors(), !i && t && this._setupChildMonitors()
                    }, _setupChildMonitors: function () {
                        this.getParent().each(function (t) {
                            this._setupChildMonitor(t)
                        }.bind(this))
                    }, _clearChildMonitors: function () {
                        this.getParent().each(function (t) {
                            this._clearChildMonitor(t)
                        }.bind(this))
                    }, _setupChildMonitor: function (t) {
                        this._childPositionMonitors[o.get(t)] = new e(t.options).add("floatIndex", function () {
                            this.onChildPositionChange(t)
                        }, this)
                    }, _clearChildMonitor: function (t) {
                        var i = o.get(t);
                        this._childPositionMonitors[i].destroy(), delete this._childPositionMonitors[i]
                    }
                });
                var r = {
                    create: function (t, i) {
                        return new s(t, i)
                    }
                };
                t(r)
            });
        }],
        ['1d', function (ym) {
            ym.modules.define("control.childElementController.Base", ["util.defineClass", "util.dom.element", "util.id", "util.List", "vow"], function (e, t, n, i, r, l) {
                var s = function (e) {
                    this._parent = e, this._childElements = {}, this._childList = new r, this._parentElementDeferred = l.defer()
                };
                t(s, {
                    setParentElement: function (e) {
                        this._parentElement != e && (this._parentElementDeferred.promise().isResolved() && (this._parentElementDeferred = l.defer()), this._setupParentElement(e))
                    }, getParentElement: function () {
                        return this._parentElement
                    }, getElement: function (e) {
                        var t = l.defer();
                        return this._parentElement ? t.resolve(this._getElementSync(e)) : this._parentElementDeferred.promise().then(function () {
                            t.resolve(this._getElementSync(e))
                        }, this), t.promise()
                    }, getParent: function () {
                        return this._parent
                    }, insert: function (e, t) {
                        var r = i.get(e);
                        this._childElements[r] = t || n.create(), this._childList.insert(e, this._getBeforeChild(e)), this._parentElement && this._appendToParentByOrder(e)
                    }, remove: function (e) {
                        var t = i.get(e);
                        this._childElements[t] && (this._parentElement && this._removeFromParent(e), this._childList.remove(e), delete this._childElements[t])
                    }, onChildPositionChange: function (e) {
                        this._childList.insert(e, this._getBeforeChild(e)), this._removeFromParent(e), this._appendToParentByOrder(e)
                    }, _appendToParentByOrder: function (e) {
                        var t = this._getElementSync(e), n = this._getBeforeElement(e);
                        null == n ? this._parentElement.appendChild(t) : this._parentElement.insertBefore(t, n)
                    }, _removeFromParent: function (e) {
                        var t = this._getElementSync(e);
                        t.parentNode.removeChild(t)
                    }, _getBeforeChild: function (e) {
                        var t = this.getChildIndex(e);
                        if (null == t) return null;
                        for (var n, i = this._childList.getIterator(); (n = i.getNext()) != i.STOP_ITERATION;) if (n != e && this.comparator(e, n) < 0) return n;
                        return null
                    }, _getBeforeElement: function (e) {
                        for (var t, n = this._childList.getIterator(); (t = n.getNext()) != n.STOP_ITERATION;) if (t == e) {
                            var i = n.getNext();
                            return i == n.STOP_ITERATION ? null : this._getElementSync(i)
                        }
                    }, _setupParentElement: function (e) {
                        var t, n;
                        if (e) for (t = this._childList.getIterator(); (n = t.getNext()) != t.STOP_ITERATION;) e.appendChild(this._getElementSync(n)); else for (t = this._childList.getIterator(); (n = t.getNext()) != t.STOP_ITERATION;) this._removeFromParent(n);
                        this._parentElement = e, e && this._parentElementDeferred.resolve(e)
                    }, _getElementSync: function (e) {
                        return this._childElements[i.get(e)]
                    }, getChildIndex: function (e) {
                        return null
                    }, comparator: function (e, t) {
                        return this.getChildIndex(e) < this.getChildIndex(t) ? -1 : this.getChildIndex(e) > this.getChildIndex(t) ? 1 : 0
                    }
                }), e(s)
            });
        }],
        ['1u', function (ym) {
            ym.modules.define("control.manager.predefinedSets", ["util.Storage"], function (e, n) {
                e(new n)
            });
        }],
        ['03', function (ym) {
            ym.modules.define("component.array.BaseArray", ["util.defineClass", "util.array", "util.ArrayIterator"], function (t, n, e, i) {
                function r(t, n) {
                    this._children = t || [], this._callbacks = n || {}
                }

                n(r, {
                    set: function (t, n) {
                        this._set(t, n)
                    }, get: function (t) {
                        return this._children[t]
                    }, add: function (t, n) {
                        this._add(t, "undefined" != typeof n ? n : this._children.length)
                    }, remove: function (t) {
                        this._remove(e.indexOf(this._children, t))
                    }, removeAll: function () {
                        for (; this._children.length > 0;) "undefined" != typeof this._children[this._children.length - 1] ? this._remove(this._children.length - 1) : this._children.length--
                    }, splice: function (t, n) {
                        for (var e = [], i = Array.prototype.slice.call(arguments, 2), r = i.length, h = 0; h < n && t < this._children.length; h++) e.push(h < r ? this._set(t++, i[h]) : this._remove(t));
                        for (; h < r; h++) this._add(i[h], t++);
                        return e
                    }, getLength: function () {
                        return this._children.length
                    }, getIterator: function () {
                        return new i(this._children)
                    }, each: function (t, n) {
                        e.each(this._children, t, n)
                    }, indexOf: function (t) {
                        return e.indexOf(this._children, t)
                    }, sort: function (t) {
                        this._children.sort(t)
                    }, quickSort: function (t) {
                        return this._children = e.quickSort(this._children, t), this._children
                    }, toArray: function () {
                        return this._children.slice()
                    }, _add: function (t, n) {
                        this._children.length < n && (this._children.length = n), this._children.splice(n, 0, t);
                        var e = this._callbacks.onAdd;
                        e && e.callback.call(e.context, n, t)
                    }, _remove: function (t) {
                        var n = this._children.splice(t, 1)[0], e = this._callbacks.onRemove;
                        return e && e.callback.call(e.context, t, n), n
                    }, _set: function (t, n) {
                        var e = this._children[t], i = this._callbacks.onSet;
                        return this._children[t] = n, i && i.callback.call(i.context, t, e, n), e
                    }
                }), t(r)
            });
        }],
        ['7Q', function (ym) {
            ym.modules.define("map.pane.helper.controls", ["pane.StaticPane", "constants.paneZIndex", "map.pane.helper.storage", "pane.controls.css"], function (n, e, o, t) {
                t.add("controls", function (n) {
                    return new e(n, {zIndex: o.controls, css: {width: "100%"}})
                }), n({})
            });
        }],
        ['1a', function (ym) {
            ym.modules.define("control.EventMappingTable", ["util.defineClass", "MapEvent"], function (t, n, e) {
                function i(t) {
                    this._controlManager = t, this.add = !1, this.remove = !1, this.parentchange = !1, this.mapchange = !1, this.optionschange = !1, this.destroy = !1, this["*"] = this._defaultMapping
                }

                n(i, {
                    _defaultMapping: function (t) {
                        return new e({currentTarget: this._controlManager}, t)
                    }
                }), t(i)
            });
        }],
        [':8', function (ym) {
            ym.modules.define('control.manager.css', ["control-manager"], function (provide) {
                provide({});
            });
        }],
        ['0I', function (ym) {
            ym.modules.define("control.BaseBehaviorButton", ["util.defineClass", "control.Button", "control.optionMapper"], function (e, t, s, a) {
                var i = function (e) {
                    i.superclass.constructor.call(this, e), this.options.setName("behaviorButton")
                };
                t(i, s, {
                    getBehaviorName: function () {
                        return ""
                    }, select: function () {
                        i.superclass.select.call(this);
                        var e = this.getMap();
                        if (e) {
                            var t = this.getBehaviorName();
                            e.behaviors.isEnabled(t) || e.behaviors.enable(t)
                        }
                    }, deselect: function () {
                        i.superclass.deselect.call(this);
                        var e = this.getMap();
                        if (e) {
                            var t = this.getBehaviorName();
                            e.behaviors.isEnabled(t) && e.behaviors.disable(t)
                        }
                    }, onAddToMap: function (e) {
                        i.superclass.onAddToMap.call(this, e), this._createMapListeners(e)
                    }, onRemoveFromMap: function (e) {
                        this._clearMapListeners(), i.superclass.onRemoveFromMap.call(this, e)
                    }, _createMapListeners: function (e) {
                        var t = this.getBehaviorName(), s = e.behaviors.get(t);
                        this._behaviorListeners = s.events.group().add("enable", function () {
                            this.select()
                        }, this).add("disable", function () {
                            this.deselect()
                        }, this), e.behaviors.isEnabled(t) && this.select()
                    }, _clearMapListeners: function () {
                        this._behaviorListeners.removeAll()
                    }
                }), a.setRule({name: "behaviorButton", rule: "prefixed"}), a.setRule({
                    name: "behaviorButton",
                    key: ["adjustMapMargin"],
                    rule: ["prefixed", "plain"]
                }), e(i)
            });
        }],
        ['0Z', function (ym) {
            ym.modules.define("control.Base", ["util.defineClass", "collection.Item", "data.Manager", "layout.storage", "control.optionMapper", "vow", "util.dom.className", "Monitor", "util.cancelableCallback", "control.component.EventProxy", "util.css", "theme.islands.control.meta"], function (t, e, a, o, i, n, l, s, r, u, h, c) {
                var y = function (t) {
                    t = t || {}, this.state = new o(t.state), this.data = new o(t.data), y.superclass.constructor.call(this, t.options), this.eventProxy = new h(this.events), this.options.setMapper(n), this._layout = null, this._layoutDeferred = null
                };
                y.ControlWithoutMapError = function () {
                    return new Error("Control wasn't added to map")
                }, y.ControlCanceledError = function () {
                    return new Error("Canceled")
                }, y.LayoutNotFound = function () {
                    return new Error("Layout wasn't found")
                }, e(y, a, {
                    getLayout: function () {
                        return this._layoutDeferred ? this._layoutDeferred.promise() : l.reject(y.ControlWithoutMapError())
                    }, getLayoutSync: function () {
                        return this._layout
                    }, onAddToMap: function () {
                        this._setupLayout(), this._visibilityMonitor = new r(this.options), this._visibilityMonitor.add("visible", this._onVisibilityChange, this)
                    }, onRemoveFromMap: function (t) {
                        this._destroyLayout(), this._visibilityMonitor.destroy()
                    }, createLayoutData: function () {
                        return {control: this, options: this.options, data: this.data, state: this.state}
                    }, createLayoutParameters: function () {
                        return null
                    }, _setupLayout: function () {
                        var t = this.createLayoutData();
                        this._layoutCancelableCallback = u.create(function (e) {
                            try {
                                this._createLayout(e[0], e[1] && e[1][0] || o, t)
                            } catch (a) {
                                ym.logger.warning("Failed to create control. " + a.stack)
                            }
                        }, this);
                        var e, a = [this.getParent().getChildElement(this)], o = this.options.get("layout");
                        this._layoutDeferred = l.defer(), "string" == typeof o && (e = o, o = i.get(e, t), "undefined" == typeof o && a.push(i.require({
                            keys: [e],
                            data: t
                        }))), l.all(a).then(this._layoutCancelableCallback, function () {
                            this._layoutCancelableCallback = null, this._layoutDeferred.reject(y.LayoutNotFound())
                        }, this)
                    }, _destroyLayout: function () {
                        this._layoutCancelableCallback ? (this._layoutDeferred.reject(y.ControlCanceledError()), this._layoutCancelableCallback.cancel(), this._layoutCancelableCallback = null) : this._layout && (this.eventProxy.removeChildEventManager(this._layout.events), this._layout.destroy(), this._layout = null, this._fireLayoutChangeEvent()), this._layoutDeferred = null
                    }, _createLayout: function (t, e, a) {
                        this._layoutCancelableCallback = null, this._layout = new e(a, this.createLayoutParameters()), this.eventProxy.addChildEventManager(this._layout.events), this._layout.setParentElement(t), this.events.fire("layoutmapchange"), this._setVisibleState(this.options.get("visible", !0)), this._layoutDeferred.resolve(this._layout), this._fireLayoutChangeEvent()
                    }, _onVisibilityChange: function (t, e) {
                        this._layout && this._setVisibleState(t), this.events.fire("visibilitychange")
                    }, _setVisibleState: function (t) {
                        var e = this._layout.getParentElement();
                        e && (t ? s.remove(e, c.addPrefix("controls__control_visibility_hidden")) : s.add(e, c.addPrefix("controls__control_visibility_hidden")))
                    }, _fireLayoutChangeEvent: function () {
                        this.events.fire("layoutchange", {layout: this._layout})
                    }
                }), t(y)
            });
        }],
        ['1y', function (ym) {
            ym.modules.define("control.RoutePanelComponent", ["vow", "util.defineClass", "util.extend", "event.Manager", "Monitor", "data.Sync", "data.Manager", "option.Mapper", "option.Manager", "GeoObjectCollection", "map.associate.serviceGeoObjects", "yandex.counter"], function (t, e, o, i, s, n, a, r, u, h, d, l, _) {
                function c(t, o, i) {
                    this._control = t, this._parameters = i, this.events = new s, this.state = new r(o), this.options = new h({}, t.options, c.OPTIONS_NAME), this._routeContainer = new d, this._routeDeferred = e.defer(), this._route = null, this._layout = null, this._loaded = !1, this._geolocateOnLoad = {
                        from: !1,
                        to: !1
                    }, this._stateMonitor = new n(this.state).add("editing", function (t) {
                        t ? this._startEditor() : this._stopEditor()
                    }, this, {defaultValue: !1}), this._optionsMonitor = new n(this.options).add("reverseGeocoding", this._updateReverseGeocoding, this, {defaultValue: !0})
                }

                c.OPTIONS_NAME = "routePanel", o(c, {
                    initializeRoute: function (t) {
                        this._route || (this._route = new t({
                            referencePoints: [],
                            params: {routingMode: "masstransit", avoidTrafficJams: !0}
                        }), this._routeEvents = this._route.events.group().add("update", function () {
                            this._count(this._route.model.getParams().routingMode)
                        }, this), this._updateReverseGeocoding(this._optionsMonitor.get("reverseGeocoding")), this._routeContainer.add(this._route), this._routeDeferred.resolve(this._route), this._stateMonitor.get("editing") && this._startEditor(), this._updateLoaded())
                    }, destroy: function () {
                        this._optionsMonitor.destroy(), this._stateMonitor.destroy(), this._routeEvents.removeAll(), this._unsetLayout()
                    }, _updateReverseGeocoding: function (t) {
                        if (this._route) {
                            var e = i({}, this._route.model.getParams(), {reverseGeocoding: t});
                            this._route.model.setParams(e)
                        }
                    }, _count: function (t) {
                        var e = this._parameters.counterPath + "." + t;
                        _.countByKey(this._parameters.counterKey, e)
                    }, onAddToMap: function (t) {
                        this._stateMonitor.get("editing") && this._startEditor(), l.get(t).add(this._routeContainer), this._count("create")
                    }, onRemoveFromMap: function (t) {
                        this._stopEditor(), l.get(t).remove(this._routeContainer), this._unsetLayout()
                    }, getRoute: function () {
                        return this._route
                    }, getRouteAsync: function () {
                        return this._routeDeferred.promise()
                    }, isEnabled: function () {
                        return this._loaded
                    }, enable: function () {
                        return this._parameters.load()
                    }, setLayout: function (t) {
                        this._layout = t;
                        var e = (new u).setRule({rule: "plain", name: this._layout.options.getName()});
                        this._stateSync = new a([this.state, this._layout.state], ["fromEnabled", "from", "toEnabled", "to", "type"]), this._layoutEvents = this._layout.events.group().add("geolocationclick", function () {
                            _.countByKey("modulesUsage", "geolocation.routeInput")
                        }, this), this.options.setMapper(e), this._layout.options.setParent(this.options), this._updateLoaded()
                    }, geolocate: function (t) {
                        return this._layout ? this._layout.geolocate(t) : void (this._geolocateOnLoad[t] = !0)
                    }, switchPoints: function () {
                        if (this._layout) this._layout.switchPoints(); else {
                            var t = this.state.get("from"), e = this.state.get("to");
                            this.state.set({from: e, to: t})
                        }
                    }, focus: function () {
                        return this._layout ? this._layout.focus() : null
                    }, saveFocusState: function () {
                        return this._layout ? this._layout.saveFocusState() : null
                    }, restoreFocusState: function (t, e) {
                        this._layout && this._layout.restoreFocusState(t, e)
                    }, isClickUnderLayout: function () {
                        return !!this._layout && this._layout.isClickUnderLayout()
                    }, _updateLoaded: function () {
                        var t = this._loaded;
                        this._loaded = Boolean(this._layout && this._route), t !== this._loaded && (this.events.fire(this._loaded ? "enable" : "disable"), this._geolocateOnLoad.from && this.geolocate("from"), this._geolocateOnLoad.to && this.geolocate("to"), this._geolocateOnLoad = {
                            from: !1,
                            to: !1
                        })
                    }, _unsetLayout: function () {
                        this._layout && (this._layout.options.setParent(null), this.options.setMapper(null), this._layout = null, this._layoutEvents.removeAll(), this._layoutEvents = null, this._stateSync.destroy(), this._stateSync = null, this._updateLoaded())
                    }, _startEditor: function () {
                        this._route && this._route.editor.start({
                            dragWayPoints: !0,
                            addWayPoints: !1,
                            removeWayPoints: !1,
                            dragViaPoints: !1,
                            removeViaPoints: !1,
                            addMidPoints: !1
                        })
                    }, _stopEditor: function () {
                        this._route && this._route.editor.stop()
                    }
                }), t(c)
            });
        }],
        ['!C', function (ym) {
            ym.modules.define("theme.islands.control.layout.routePanel.Button", ["util.defineClass", "layout.storage", "templateLayoutFactory", "localization.common.current", "constants.paneZIndex", "error", "util.array", "util.extend", "util.css", "util.dom.element", "util.dom.className", "util.dom.style", "data.Manager", "option.Mapper", "Monitor", "data.Sync", "theme.islands.control.layout.Popup", "theme.islands.control.layout.Button", "theme.islands.control.layout.routePanel.Button.html", "theme.islands.control.layout.routePanel.Button.css"], function (t, e, o, a, n, u, s, i, l, p, r, d, h, c, y, _, L, f, g, P) {
                var m = (new y).setRule({rule: "prefixed", name: f.OPTIONS_NAME}), b = a.createClass(P, {
                    createTemplateDataManager: function (t) {
                        this._buttonState = new c({selected: !1, enabled: !0});
                        var e = this.getParameters().lazy;
                        return a.createTemplateDataManager.call(this, t).set({
                            buttonState: this._buttonState,
                            buttonData: new c({
                                content: n.Control.RoutePanel.Routes,
                                title: n.Control.RoutePanel.Routes,
                                iconType: "routes"
                            }),
                            internal: new c({
                                routePanelZIndex: u.routePanel,
                                popupIconClassName: p.addPrefix("route-panel-button__panel-icon"),
                                lazy: "undefined" == typeof e || e
                            })
                        })
                    }, build: function () {
                        b.superclass.build.call(this);
                        var t = this.getData();
                        this._buttonLayout = this.getSublayout("button"), this._popupLayout = this.getSublayout("popup"), this._popupLayout.options.set("bottomGap", 30), this._routePanelLayout = null, this._popupLayout.getContentLayout().done(function (e) {
                            this._routePanelLayout = e, this._updateRoutePanelLayoutFullscreen(), this._popupLayout.isExpanded() && t.options.get("autofocus", !0) && this._routePanelLayout.focus()
                        }, function (t) {
                            if (!(t instanceof s.OperationCanceledReject)) throw t
                        }, this), t.options.setMapper(m), this._popupLayout.options.setParent(t.options), this._popupLayout.events.add(["expand", "collapse"], this._onPopupExpandCollapse, this), this._popupStateMonitor = new _(this._popupLayout.state).add("fullscreen", this._updateRoutePanelLayoutFullscreen, this), this._buttonStateSync = new L([t.state, this._buttonState], ["size"]), this._buttonLayout.events.add("click", this._toggle, this), this._stateMonitor = new _(t.state).add("expanded", this._updateExpanded, this, {
                            init: !0,
                            defaultValue: !1
                        }).add("size", this._updateAnchor, this, {init: !0}), this._optionsMonitor = new _(t.options).add("float", function (t) {
                            var e = "right" == t ? "left" : "right";
                            this._popupLayout.options.set("preferredFloat", e)
                        }, this, {init: !0, defaultValue: "right"}).add("position", function (t) {
                            this._popupLayout.options.set("autoAdjustHeight", "object" != typeof t)
                        }, this, {init: !0})
                    }, rebuild: function () {
                    }, clear: function () {
                        this._optionsMonitor.destroy(), this._stateMonitor.destroy(), this.events.remove("click", this._toggle, this), this._buttonStateSync.destroy(), b.superclass.clear.call(this)
                    }, getRoutePanelLayout: function () {
                        return this._popupLayout.getContentLayout()
                    }, forceCreateRoutePanelLayout: function () {
                        return this._popupLayout.forceCreateContentLayout()
                    }, isClickUnderLayout: function () {
                        return this._popupLayout.isClickUnderLayout() || this._routePanelLayout && this._routePanelLayout.isClickUnderLayout()
                    }, isInFullscreen: function () {
                        return this._popupLayout.state.get("fullscreen")
                    }, _updateRoutePanelLayoutFullscreen: function () {
                        this._routePanelLayout && this._routePanelLayout.state.set("fullscreen", this.isInFullscreen())
                    }, _toggle: function () {
                        this.getData().state.set("expanded", !this._stateMonitor.get("expanded"))
                    }, _updateExpanded: function (t) {
                        this._popupLayout.toggle(t), this._buttonState.set("selected", t)
                    }, _onPopupExpandCollapse: function (t) {
                        var e = this.getData();
                        e.state.set("expanded", "expand" == t.get("type")), this._routePanelLayout && ("expand" == t.get("type") ? e.options.get("autofocus", !0) && this._routePanelLayout.focus() : this._routePanelLayout.blur())
                    }, _updateAnchor: function (t) {
                        var e = this._buttonLayout.getTextElement(), o = this._buttonLayout.getIconElement(),
                            a = "medium" == t ? e : o;
                        this._popupLayout.setAnchor(a)
                    }
                });
                o.add("islands#controlRoutePanelButtonLayout", b), t(b)
            });
        }],
        [',i', function (ym) {
            ym.modules.define("yandex.geocodeProvider.storage", ["util.AsyncStorage"], function (e, o) {
                e(new o("yandex.geocodeProvider"))
            });
        }],
        [':u', function (ym) {
            ym.modules.define("yandex.searchProvider.storage", ["util.AsyncStorage"], function (e, r) {
                e(new r("yandex.searchProvider"))
            });
        }],
        ['1K', function (ym) {
            ym.modules.define("control.searchControl.GeocodeProvider", ["control.searchControl.BaseProvider", "control.optionMapper", "map.metaOptions", "yandex.geocodeProvider.storage", "geocode", "util.extend", "vow", "util.defineClass"], function (e, t, r, s, o, i, n, d, a) {
                function c(e) {
                    c.superclass.constructor.call(this, e), this._control = e, this.options.setName("geocodeProvider")
                }

                a(c, t, {
                    load: function (e, t) {
                        if ("string" == typeof e) t = t || {}, t = this._getRequestOptions(this._control.options, t), this._clearData(), this.state.set({
                            request: e,
                            searchOptions: t
                        }); else {
                            if (ym.env.debug && !this.isLoaded()) throw new Error("control.searchControl.Provider: Для дозагрузки данных сначала нужно загрузить запрос");
                            var r, s = this.state.get("results", []), o = this.options.get("results"),
                                a = this.state.get("searchOptions");
                            r = {
                                skip: s.length,
                                results: this._control.options.get("results", o)
                            }, t = "object" == typeof e ? n({}, a, r, e) : n({}, a, r), e = this.state.get("request")
                        }
                        this._deferred && !this._deferred.promise().isResolved() && this._deferred.reject("control.searchControl.GeocodeProvider: New request");
                        var c = this._deferred = d.defer();
                        return i(e, t).then(function (e) {
                            c.promise().isRejected() || (this._onLoad(e), c.resolve(e))
                        }, function (e) {
                            c.reject(e), this._onLoadError(e)
                        }, this), this.events.fire("submit"), c.promise()
                    }, destroy: function () {
                        this._clearData(), c.superclass.destroy.call(this)
                    }, getLoadDefer: function () {
                        return this._deferred
                    }, _onLoad: function (e) {
                        var t = e.metaData.geocoder;
                        return this._updateResults(e.geoObjects, t.skip), this.state.set({
                            isLoaded: !0,
                            request: t.request,
                            correction: t.suggest,
                            suggest: t.suggest,
                            found: t.found,
                            results: this.getResults(),
                            responseMetaData: t
                        }), this.events.fire("load", {skip: t.skip, count: t.results}), e
                    }, _onLoadError: function (e) {
                        this.events.fire("error", {error: e})
                    }, _getRequestOptions: function (e, t) {
                        return n({
                            provider: e.get("provider"),
                            boundedBy: e.get("boundedBy"),
                            strictBounds: e.get("strictBounds"),
                            kind: e.get("kind"),
                            results: e.get("results", this.options.get("results")),
                            searchCoordOrder: e.get("searchCoordOrder", this.options.get("coordOrder")),
                            origin: "jsapi2searchcontrol"
                        }, t)
                    }, _updateResults: function (e, t) {
                        var r = t || 0, s = this.state.get("results", []);
                        e.each(function (e) {
                            s[r] = e, r++
                        }), this.state.set("results", s)
                    }, _clearData: function () {
                        this.state.unsetAll()
                    }
                }), r.setRule({name: "geocodeProvider", rule: ["prefixed"]}), r.setRule({
                    name: "geocodeProvider",
                    key: ["adjustMapMargin"],
                    rule: ["prefixed", "plain"]
                }), s.set({
                    searchControlGeocodeProviderProviderStorage: o,
                    searchControlGeocodeProviderCoordOrder: "latlong",
                    searchControlGeocodeProviderResults: 10,
                    searchControlGeocodeProviderSuggestResults: 5
                }), e(c)
            });
        }],
        ['1M', function (ym) {
            ym.modules.define("control.searchControl.SearchProvider", ["control.searchControl.BaseProvider", "control.optionMapper", "map.metaOptions", "search", "yandex.searchProvider.storage", "localization.common.current", "formatter", "util.array", "yandex.counter", "util.cancelableCallback", "util.extend", "vow", "util.defineClass", "meta.internal"], function (e, t, s, o, r, n, i, a, l, u, c, d, h, p, g) {
                function _(e) {
                    _.superclass.constructor.call(this, e), this._control = e, this.options.setName("searchProvider"), this._isLoadMoreRequest = null, this._requestCallback = null, this._setupListeners(), u.countByKey("modulesUsage", "searchProvider.create")
                }

                var b = "loadmore", v = "boundschange", y = i.ppo.Card;
                p(_, t, {
                    getType: function () {
                        return "search"
                    }, load: function (e, t) {
                        var s = this._control.options, o = "string" == typeof e;
                        if (u.countByKey("business_search", "search." + (e && e.type || "direct")), o) t = t || {}, t = this._getRequestOptions(s, t), this._clearData(), this.state.set({
                            request: e,
                            searchOptions: t
                        }); else {
                            if (ym.env.debug && !this.isLoaded()) throw new Error("control.searchControl.SearchProvider: Для дозагрузки данных сначала нужно загрузить запрос");
                            var n = this.state, i = n.get("requestContext"), a = n.get("display"),
                                l = n.get("searchOptions");
                            l.origin = "jsapi2SearchControlIndirect";
                            var p, g = this.options.get("results"), _ = n.get("results", []).length,
                                v = d({}, l, {context: i}), y = this._control.getMap();
                            this._isLoadMoreRequest = e && e.type == b, !this._isLoadMoreRequest && y && (v.boundedBy = y.getBounds(), l.boundedBy = v.boundedBy), ("multiple" != a || this._isLoadMoreRequest) && (p = e && e.results ? e.results : this._isLoadMoreRequest ? s.get("loadMoreResults") : s.get("results", g), d(v, {
                                results: p,
                                skip: _
                            })), t = "object" == typeof e ? d(v, e) : v, e = this.state.get("request")
                        }
                        this._deferred && !this._deferred.promise().isResolved() && this._deferred.reject("control.searchControl.SearchProvider: new request.");
                        var f = this._deferred = h.defer();
                        return this._requestCallback = c.create(function (e) {
                            f.promise().isRejected() || (this._onLoad(e, o), f.resolve(e))
                        }, this), r(e, t, "searchProvider").then(this._requestCallback, function (e) {
                            f.reject(e), this._onLoadError(e)
                        }, this), this.events.fire("submit"), f.promise()
                    }, destroy: function () {
                        this._requestCallback && this._requestCallback.cancel(), this._clearData(), this._clearListeners(), _.superclass.destroy.call(this)
                    }, getLoadDefer: function () {
                        return this._deferred
                    }, _clearData: function () {
                        this._isLoadMoreRequest = null, this.state.unsetAll()
                    }, _setupListeners: function () {
                        var e = this._control;
                        e.getMap() && this._setupMapListeners(), this._controlListeners = e.events.group().add("mapchange", this._onMapChange, this)
                    }, _clearListeners: function () {
                        this._clearMapListeners(), this._controlListeners.removeAll()
                    }, _setupMapListeners: function () {
                        var e = this._control.getMap();
                        this._mapListeners = e.events.group().add("boundschange", this._onBoundsChange, this).add("balloonopen", this._onMapBalloonOpen, this)
                    }, _clearMapListeners: function () {
                        this._mapListeners && this._mapListeners.removeAll()
                    }, _onMapChange: function (e) {
                        var t = e.get("newMap");
                        this._clearMapListeners(), t && this._setupMapListeners()
                    }, _onBoundsChange: function () {
                        var e = this._control, t = this.state.get("originalDisplay"), s = e.getMap();
                        !this.isLoaded() || "multiple" != t || e.state.get("processing") || s.balloon.isOpen() || this.load({type: v})
                    }, _onMapBalloonOpen: function () {
                        this._deferred && !this._deferred.promise().isResolved() && this._requestCallback.cancel()
                    }, _getRequestOptions: function (e, t) {
                        var s = this._control.getMap();
                        return "undefined" == typeof t.boundedBy && s && (t.boundedBy = s.getBounds()), d({
                            provider: e.get("provider"),
                            boundedBy: e.get("boundedBy"),
                            results: e.get("results", this.options.get("results")),
                            searchCoordOrder: e.get("searchCoordOrder", this.options.get("coordOrder")),
                            origin: "jsapi2SearchControl"
                        }, t)
                    }, _onLoad: function (e, t) {
                        var s, o = e.geoObjects, r = o.properties.getAll(), n = r.resultsArray.slice();
                        "multiple" != r.display || this._isLoadMoreRequest ? (l.each(n, this._prepareItem, this), s = this.state.get("results", []), s = s.concat(n)) : (s = n, l.each(s, this._prepareItem, this));
                        var i = d({}, r, {isLoaded: !0, results: s, correction: r.suggest});
                        return t && (i.originalDisplay = r.display), this.state.set(i), this.events.fire("load", {
                            skip: r.skip || 0,
                            count: r.results
                        }), r.counter && u.directCount(r.counter), e
                    }, _onLoadError: function (e) {
                        this.events.fire("error", {error: e})
                    }, _prepareItem: function (e) {
                        "business" == e.properties.get("type") && this._setLocalization(e), this._setBalloonOptions(e)
                    }, _setLocalization: function (e) {
                        var t = e.properties, s = t.get("rating.reviews", 0), o = t.get("rating.ratings", 0);
                        e.properties.set("loc", {
                            timeClosedUntil: y.timeClosedUntil.replace("%s", t.get("workingStatus.time", "")),
                            timeOpenUntil: y.timeOpenUntil.replace("%s", t.get("workingStatus.time", "")),
                            ratingReviews: a.numeral(s, y.ratingReviews),
                            ratingRatings: a.numeral(o, y.ratingRatings)
                        })
                    }, _setBalloonOptions: function (e) {
                        var t = this.options, s = e.properties.get("type"), o = this._control.getMap();
                        o && (e.options.set("balloonDisplayAdvert", g.displayAdvert || o.options.get("forceAdvert")), "public-map-object" != s && "toponym" != s && "business" != s || e.options.set({
                            balloonContentLayout: t.get("balloonContentLayout"),
                            balloonCardContactsLayout: t.get("balloonContactsLayout"),
                            balloonCardStatusLayout: t.get("balloonStatusLayout"),
                            balloonCardMetroLayout: t.get("balloonMetroLayout"),
                            balloonCardOpenInYmapsLayout: t.get("balloonOpenInYmapsLayout"),
                            balloonCardInceptionOrgButtonsLayout: t.get("balloonInceptionOrgButtonsLayout"),
                            balloonMaxHeight: t.get("balloonMaxHeight"),
                            balloonMinWidth: t.get("balloonMinWidth"),
                            balloonMaxWidth: t.get("balloonMaxWidth")
                        }), "business" == s && e.options.set("balloonPanelMaxMapArea", t.get("balloonBusinessPanelMaxMapArea")))
                    }
                }), s.setRule({
                    name: "searchProvider",
                    rule: ["prefixed"]
                }), o.set({
                    searchControlSearchProviderProviderStorage: n,
                    searchControlSearchProviderCoordOrder: "latlong",
                    searchControlSearchProviderResults: 20,
                    searchControlSearchProviderSuggestResults: 5
                }), e(_)
            });
        }],
        ['1F', function (ym) {
            ym.modules.define("control.searchControl.component.SearchGeoObjects", ["control.searchControl.component.BaseGeoObjects", "util.cancelableCallback", "yandex.counter", "vow", "util.array", "util.defineClass", "system.browser", "searchResult.util", "searchResult.transportDataProvider", "control.searchControl.SearchBalloonManager", "helper.theme.islands.islets.search.layout.Card"], function (e, t, o, s, n, i, r, a, l, c, h, d) {
                function u(e) {
                    this._controlListeners = null, this._geoObjectListeners = null, this._deferredBalloonOpen = null, this._isFirstLoad = null, u.superclass.constructor.call(this, e)
                }

                r(u, t, {
                    show: function (e) {
                        var t, o = this.getControl(), s = this.getCollection(),
                            n = o.getResponseMetaData().SearchResponse.display, i = o.getResultsArray()[e],
                            r = this._getInnerGeoObjectIndex(i), a = i;
                        return r != -1 && (a = s.get(r)), this._setProcessingState(), a.balloon.isOpen() ? t = a.balloon.autoPan().then(this._unsetProcessingState, this) : ("multiple" != n && (this._clearCollection(), s.add(a), this.isCollectionAddedToMap() || this.addCollectionToMap()), t = a.getOverlay().then(function () {
                            return this._openBalloon(a)
                        }, this)), t.then(function () {
                            this.fireShow(e)
                        }, this)
                    }, hide: function (e) {
                        var t = this.getControl(), o = t.getMap(), s = n.resolve();
                        return o && (o.balloon.isOpen() && (s = o.balloon.close()), e && (this.removeCollectionFromMap(), this._clearCollection())), s
                    }, initComponent: function () {
                        var e = this.getControl(), t = this.getCollection(), o = e.state,
                            s = o.get("request") && o.get("found");
                        s && !t.getLength() && this._addItems(), this._setupListeners(), this._setupCollectionOptions(), u.superclass.initComponent.call(this)
                    }, destroy: function () {
                        this.isInited() && (this._requestCallback && (this._requestCallback.cancel(), this._requestCallback = null), this._clearGeoObjectListeners(), this._clearListeners()), u.superclass.destroy.call(this)
                    }, _setupCollectionOptions: function () {
                        var e = this.getCollection(), t = this.getControl();
                        "yandex#search" == t.options.get("provider") ? e.options.set({
                            preset: t.options.get("geoObjectStandardPreset"),
                            balloonManager: "searchControl#searchBalloonManager"
                        }) : e.options.set({preset: t.options.get("geoObjectStandardPreset")})
                    }, _setupListeners: function () {
                        var e = this.getControl(), t = this.getCollection();
                        this._controlListeners = e.events.group().add("submit", this._onSubmit, this).add("load", this._onLoad, this).add("mapchange", this._onMapChange, this), this._collectionListeners = t.events.group().add("click", this._onGeoObjectClick, this).add("balloonopen", this._onBalloonOpen, this)
                    }, _onBalloonOpen: function (e) {
                        var t = e.get("target");
                        this._countCardShow(t)
                    }, _clearListeners: function () {
                        this._controlListeners.removeAll(), this._collectionListeners.removeAll()
                    }, _onSubmit: function () {
                        this.removeCollectionFromMap(), this._clearCollection(), this._isFirstLoad = !0
                    }, _onLoad: function (e) {
                        var t = this.getControl(), o = t.getMap(), s = t.getResponseMetaData().SearchResponse,
                            n = "multiple" == s.display, i = e.get("skip");
                        if (i) n && this._addItems(i); else {
                            this._addItemsDiff(), n && this.addCollectionToMap();
                            var r = s.boundedBy || 1 == s.found;
                            if (this._isFirstLoad && s.found && r) {
                                var a;
                                if (this._setProcessingState(), s.boundedBy) a = o.setBounds(s.boundedBy, {checkZoomRange: !0}); else {
                                    var l = t.getResultsArray()[0], c = l.geometry.getCoordinates();
                                    a = o.setCenter(c)
                                }
                                1 == s.found && (a = a.then(function () {
                                    this.show(0)
                                }, this)), a.done(this._unsetProcessingState, this)
                            }
                        }
                        this._isFirstLoad = !1
                    }, _onMapChange: function (e) {
                        var t = e.get("oldMap"), o = e.get("newMap"), s = this.getCollection(), n = this.getControl(),
                            i = n.state, r = i.get("request") && i.get("found");
                        t && this.isCollectionAddedToMap() && this.removeCollectionFromMap(t), o && (r && !s.getLength() && this._addItems(), this.addCollectionToMap())
                    }, _countCardShow: function (e) {
                        var t = d.getCardType(e.properties),
                            o = t == d.CARD_TYPES.transport ? t : e.properties.get("type", "unknown"),
                            n = o + "." + a.platform;
                        e.properties.get("advert") && s.countByKey("modulesUsage", {
                            path: "search.showCard.privileged." + n,
                            share: .1
                        }), s.countByKey("modulesUsage", {path: "search.showCard." + n, share: .1})
                    }, _openBalloon: function (e) {
                        var t = n.defer(), o = e.getMap();
                        return this._deferredBalloonOpen && this._deferredBalloonOpen.reject("show: new request"), this._clearGeoObjectListeners(), o ? (c.remoteExtendSearchResultWithTransport(e, o.getZoom()).then(function (e) {
                            return e.balloon.open()
                        }).then(this._unsetProcessingState, this).then(function () {
                            t.resolve(!0)
                        }), this._geoObjectListeners = e.events.group().add("balloonclose", this._onBalloonClose, this)) : t.reject("show: map not found"), this._deferredBalloonOpen = t, t.promise()
                    }, _clearGeoObjectListeners: function () {
                        this._geoObjectListeners && this._geoObjectListeners.removeAll()
                    }, _setProcessingState: function () {
                        var e = this.getControl();
                        e.state.set("processing", !0)
                    }, _unsetProcessingState: function () {
                        var e = this.getControl();
                        e.state.set("processing", !1)
                    }, _clearCollection: function () {
                        var e = this.getCollection();
                        e.removeAll(), this._clearGeoObjectListeners()
                    }, _onGeoObjectClick: function (e) {
                        var t, o = e.get("target");
                        o.balloon.isOpen() || (t = this._getGeoObjectIndex(o), this.fireShow(t)), this._clearGeoObjectListeners(), this._geoObjectListeners = o.events.group().add("balloonclose", this._onBalloonClose, this)
                    }, _onBalloonClose: function (e) {
                        var t = e.get("target"), o = this._getGeoObjectIndex(t);
                        this.events.fire("hide", {index: o}), this._clearGeoObjectListeners()
                    }, _addItems: function (e) {
                        var t = this.getControl(), o = t.getResultsArray();
                        e && (o = o.slice(e)), i.each(o, this._addItem, this)
                    }, _addItemsDiff: function () {
                        var e = this.getControl(), t = this.getCollection(), o = e.getResultsArray(), s = [], n = {};
                        t.each(function (e) {
                            var t = e.properties.get("id");
                            t ? n[t] = {geoObject: e, needToRemove: !0} : s.push(e)
                        });
                        for (var r = 0, a = o.length; r < a; r++) {
                            var l = o[r], c = l.properties.get("id");
                            n[c] ? n[c].needToRemove = !1 : this._addItem(l)
                        }
                        for (var h in n) if (n.hasOwnProperty(h)) {
                            var d = n[h];
                            d.needToRemove && t.remove(d.geoObject)
                        }
                        s.length && i.each(s, t.remove, t)
                    }, _addItem: function (e) {
                        this._isGeoProduct(e) && e.options.set("preset", this.getControl().options.get("geoObjectGeoproductPreset")), this.getCollection().add(e)
                    }, _isGeoProduct: function (e) {
                        return e.properties.get("advert") && e.options.get("balloonDisplayAdvert")
                    }, _getGeoObjectIndex: function (e) {
                        var t = this.getControl(), o = t.getResultsArray(), s = i.indexOf(o, e);
                        return s != -1 ? s : this._findGeoObjectIndex(o, e)
                    }, _getInnerGeoObjectIndex: function (e) {
                        var t = [], o = this.getCollection(), s = o.indexOf(e), n = e.properties.get("id");
                        return s == -1 && "undefined" != typeof n && (o.each(function (e) {
                            t.push(e)
                        }), s = this._findGeoObjectIndex(t, e)), s
                    }, _findGeoObjectIndex: function (e, t) {
                        var o = t.properties.get("id"), s = function (e) {
                            return e.properties.get("id") == o
                        };
                        return i.findIndex(e, s)
                    }
                }), e(u)
            });
        }],
        ['1E', function (ym) {
            ym.modules.define("control.searchControl.component.GeocodeGeoObjects", ["control.searchControl.component.BaseGeoObjects", "util.cancelableCallback", "util.defineClass", "vow"], function (t, e, o, n, l) {
                function a(t) {
                    this._controlListeners = null, this._currentGeoObject = null, this._openBalloonCallback = null, a.superclass.constructor.call(this, t)
                }

                n(a, e, {
                    show: function (t) {
                        this.hide();
                        var e, o, n = this.getControl(), a = n.getMap(), s = n.getResultsArray()[t],
                            i = this.getCollection(), c = n.options, r = c.get("noCentering"), h = c.get("noPlacemark");
                        if (!r) {
                            var u = s.properties.get("boundedBy") || s.geometry.getBounds();
                            e = a.setBounds(u, {
                                checkZoomRange: !0,
                                zoomMargin: c.get("zoomMargin", 0),
                                useMapMargin: c.get("useMapMargin", !0)
                            }), o = e
                        }
                        if (!h) if (this._currentGeoObject = s, i.add(s), r) s.options.set("balloonAutoPan", !1), o = s.balloon.open().then(function () {
                            s.options.set("balloonAutoPan", !0)
                        }); else {
                            var p = this._geoOpenBalloonCancelableCallback();
                            e.then(p)
                        }
                        return o || (o = l.resolve(!0)), o.then(function () {
                            this.fireShow(t)
                        }, this)
                    }, hide: function () {
                        var t = this._currentGeoObject, e = this.getCollection();
                        t && (this._openBalloonCallback && (this._openBalloonCallback.cancel(), this._openBalloonCallback = null), this._requestCallback && (this._requestCallback.cancel(), this._requestCallback = null), e.removeAll(), this._currentGeoObject = null)
                    }, initComponent: function () {
                        a.superclass.initComponent.call(this), this._setupListeners()
                    }, destroy: function () {
                        this.isInited() && (this._openBalloonCallback && (this._openBalloonCallback.cancel(), this._openBalloonCallback = null), this._clearListeners()), a.superclass.destroy.call(this)
                    }, _setupListeners: function () {
                        var t = this.getControl();
                        this._controlListeners = t.events.group().add("submit", this._onSubmit, this).add("load", this._onLoad, this).add("mapchange", this._onMapChange, this)
                    }, _clearListeners: function () {
                        this._controlListeners.removeAll()
                    }, _onSubmit: function () {
                        this.hide()
                    }, _onLoad: function (t) {
                        var e = this.getControl();
                        0 != t.get("skip") || 1 != e.state.get("found") || e.options.get("noSelect") || this.show(0)
                    }, _onMapChange: function (t) {
                        var e = t.get("oldMap"), o = t.get("newMap"), n = this._currentGeoObject,
                            l = this.getControl().state, a = this.getCollection(),
                            s = l.get("request") && l.get("found");
                        e && this.isCollectionAddedToMap() && this.removeCollectionFromMap(e), o && (s && !a.getLength() && n && a.add(n), this.addCollectionToMap())
                    }, _geoOpenBalloonCancelableCallback: function () {
                        var t = this._currentGeoObject;
                        return this._openBalloonCallback && this._openBalloonCallback.cancel(), this._openBalloonCallback = o.create(function () {
                            this._openBalloonCallback = null, t.getMap() && t.balloon.open()
                        }, this), this._openBalloonCallback
                    }
                }), t(a)
            });
        }],
        [':D', function (ym) {
            ym.modules.define("yandex.state.component.SearchControl", ["util.defineClass", "yandex.state.associate", "util.extend", "util.coordinates.toLatLong"], function (t, e, s, n, o) {
                function i(t) {
                    this._searchControl = t, this._yandexState = s.get(t.getMap()), this._model = n({}, r), this._setupListeners(), this._init()
                }

                var r = {request: null, context: null, resultId: null, resultLayer: null, resultCoordinates: null},
                    a = {resultId: null, resultLayer: null, resultCoordinates: null};
                e(i, {
                    destroy: function () {
                        this._clearListeners()
                    }, _init: function () {
                        var t, e = this._searchControl, s = e.state.get("currentIndex"), o = null;
                        "number" == typeof s && (t = e.getResultsArray()[s], o = this._getResultInfo(t)), n(this._model, {
                            request: e.getRequestString(),
                            context: this._getContext()
                        }, o), this._setYandexState()
                    }, _setupListeners: function () {
                        var t = this._searchControl;
                        this._controlListeners = t.events.group().add("submit", this._onSearch, this).add("load", this._onLoad, this).add("resultshow", this._onResultShow, this).add("resulthide", this._onResultHide, this).add("clearstate", this._onStateClear, this)
                    }, _clearListeners: function () {
                        this._controlListeners.removeAll()
                    }, _getResultInfo: function (t) {
                        var e = t.properties, s = e.get("type", null), n = this._searchControl.options.get("provider"),
                            i = {resultId: e.get("id", null)};
                        if ("yandex#search" == n || "yandex#map" == n) {
                            switch (s) {
                                case"business":
                                    i.resultLayer = "biz";
                                    break;
                                case"public-map-object":
                                    i.resultLayer = "psearch";
                                    break;
                                default:
                                    i.resultLayer = "geo"
                            }
                            i.resultCoordinates = o(t.geometry.getCoordinates())
                        }
                        return i
                    }, _getContext: function () {
                        var t = this._searchControl.getProvider();
                        return t && t.state.get("requestContext") || null
                    }, _onSearch: function () {
                        this._model.request = this._searchControl.getRequestString(), this._setYandexState()
                    }, _onLoad: function () {
                        this._model.context = this._getContext(), this._setYandexState()
                    }, _onResultShow: function (t) {
                        var e = this._searchControl.getResultsArray()[t.get("index")];
                        n(this._model, this._getResultInfo(e)), this._setYandexState()
                    }, _onResultHide: function () {
                        n(this._model, a), this._setYandexState()
                    }, _onStateClear: function () {
                        n(this._model, r), this._setYandexState()
                    }, _setYandexState: function () {
                        this._yandexState.setSearch(this._model)
                    }
                }), t(i)
            });
        }],
        ['(h', function (ym) {
            ym.modules.define("theme.islands.search.meta", ["map.metaOptions", "option.presetStorage", "theme.islands.search.preset"], function (e, s, t) {
                s.set(t.get("islands#controls.search")), e({})
            });
        }],
        ['1h', function (ym) {
            ym.modules.define("control.component.exclusiveMode", ["util.defineClass", "util.array", "util.Associate"], function (t, e, n, i) {
                function r() {
                    this._current = null, this._listeners = {}
                }

                e(r, {
                    register: function (t, e, n) {
                        this._listeners[t] = this._listeners[t] || [], this._listeners[t].push([e, n])
                    }, unregister: function (t, e, i) {
                        var r = this._listeners[t];
                        if (r) {
                            var s = n.findIndex(r, function (t) {
                                return t[0] == e && t[1] == i
                            });
                            s != -1 && r.splice(s, 1), r.length || delete this._listeners[t]
                        }
                    }, switchOff: function (t) {
                        this._current == t && this._clearCurrentMode()
                    }, switchOn: function (t) {
                        this._current !== t && this._setCurrentMode(t)
                    }, _clearCurrentMode: function () {
                        this._setCurrentMode(null)
                    }, _setCurrentMode: function (t) {
                        var e = this._current;
                        if (this._current = t, null != e) for (var n = this._listeners[e] || [], i = 0, r = n.length; i < r; i++) n[i][0].call(n[i][1])
                    }
                }), t(new i(function () {
                    return new r
                }))
            });
        }],
        ['(H', function (ym) {
            ym.modules.define("theme.islands.traffic.metaOptions", ["map.metaOptions", "option.presetStorage", "theme.islands.traffic.preset"], function (e, t, s) {
                t.set(s.get("islands#traffic")), e(!0)
            });
        }],
        ['1U', function (ym) {
            ym.modules.define("coordSystem.Cartesian", ["util.extend"], function (t, n) {
                function e(t) {
                    t = t || [1, 1], this._scale = "number" == typeof t ? [t, t] : t
                }

                function i(t) {
                    var n = Math.sqrt(Math.pow(t[0], 2) + Math.pow(t[1], 2));
                    return [t[0] / n, t[1] / n]
                }

                n(e.prototype, {
                    solveDirectProblem: function (t, n, e) {
                        n = i(n);
                        var o = n[0] * e / this._scale[0], r = n[1] * e / this._scale[1];
                        return {
                            startPoint: t,
                            startDirection: n,
                            endPoint: [t[0] + o, t[1] + r],
                            endDirection: n,
                            distance: e,
                            pathFunction: function (e) {
                                return {point: [t[0] + o * e, t[1] + r * e], direction: n}
                            }
                        }
                    }, solveInverseProblem: function (t, n) {
                        var e = n[0] - t[0], i = n[1] - t[1], o = this._getUnitDistance(t, n), r = [e / o, i / o];
                        return {
                            startPoint: t,
                            startDirection: r,
                            endPoint: n,
                            endDirection: r,
                            distance: this.getDistance(t, n),
                            pathFunction: function (n) {
                                return {point: [t[0] + e * n, t[1] + i * n], direction: r}
                            }
                        }
                    }, getDistance: function (t, n) {
                        return Math.sqrt(Math.pow((n[0] - t[0]) * this._scale[0], 2) + Math.pow((n[1] - t[1]) * this._scale[1], 2))
                    }, _getUnitDistance: function (t, n) {
                        return Math.sqrt(Math.pow(n[0] - t[0], 2) + Math.pow(n[1] - t[1], 2))
                    }
                }), e.prototype.distance = e.prototype.getDistance, t(e)
            });
        }],
        ['1X', function (ym) {
            ym.modules.define("data.BaseManager", ["util.defineClass", "util.array", "event.manager.Base", "Event", "component.EventFreezer"], function (e, n, t, r, i, s) {
                function f() {
                    this.events = new r, this._internalFreezer = new s(h, this), this._freezer = new s(a, this)
                }

                function h() {
                    this._freezer.fire()
                }

                function a() {
                    this.events.fire("change", new i({type: "change", target: this}))
                }

                n(f, {
                    set: function (e, n) {
                        if ("string" == typeof e || e instanceof String) this.singleSet(e, n); else {
                            this._internalFreezer.freeze();
                            for (var t in e) e.hasOwnProperty(t) && this.singleSet(t, e[t]);
                            this._internalFreezer.unfreeze()
                        }
                        return this
                    }, singleSet: function (e, n) {
                    }, unset: function (e) {
                        if (t.isArray(e)) {
                            this._internalFreezer.freeze();
                            for (var n = 0, r = e.length; n < r; n++) this.singleUnset(e[n]);
                            this._internalFreezer.unfreeze()
                        } else this.singleUnset(e);
                        return this
                    }, singleUnset: function (e) {
                    }, freeze: function () {
                        return this._freezer.freeze(), this
                    }, unfreeze: function () {
                        return this._freezer.unfreeze(), this
                    }, isFrozen: function () {
                        return this._freezer.isFrozen()
                    }, fireChangeEvent: function () {
                        this._internalFreezer.fire()
                    }, destroy: function () {
                    }
                }), e(f)
            });
        }],
        [',v', function (ym) {
            ym.modules.define("util.safeAccess", [], function (e) {
                e(function (e, n) {
                    if (e instanceof Object) {
                        var t = ".", f = [];
                        if ("string" == typeof n) {
                            if (n.indexOf(t) == -1) return e[n];
                            f = n.split(t)
                        } else f = n;
                        for (var i = 0, r = f.length; i < r; i++) {
                            if (!(e instanceof Object)) return;
                            e = e[f[i]]
                        }
                        return e
                    }
                })
            });
        }],
        ['1(', function (ym) {
            ym.modules.define("domEvent.multiPointer.overrideStorage", ["util.Storage"], function (e, o) {
                e(new o)
            });
        }],
        ['1@', function (ym) {
            ym.modules.define("domEvent.pointer.overrideStorage", ["util.Storage"], function (e, o) {
                e(new o)
            });
        }],
        ['7A', function (ym) {
            ym.modules.define("localization.units.current", function (n) {
                return ["localization.units." + n.env.lang.substr(0, 2)]
            }, function (n, i) {
                n(i || {})
            });
        }],
        ['7w', function (ym) {
            ym.modules.define("localization.lib", [], function (e) {
                function t(e, t) {
                    this.value = e, this.name = t
                }

                function a(e) {
                    for (var t = 0; t < e.length; ++t) if ("+" == e.charAt(t) || "-" == e.charAt(t) || "*" == e.charAt(t) || "/" == e.charAt(t)) return t;
                    return e.length
                }

                function m(e, t) {
                    if (0 === e.length) return t;
                    if (e.charAt(0) >= "0" && e.charAt(0) < "9") return e;
                    var r = a(e.substring(1, e.length)), s = e.substring(1, r + 1);
                    return "+" == e.charAt(0) ? m(r == e.length ? "" : e.substring(r + 1, e.length), t + parseFloat(s)) : "-" == e.charAt(0) ? m(r == e.length ? "" : e.substring(r + 1, e.length), t - parseFloat(s)) : "*" == e.charAt(0) ? m(r == e.length ? "" : e.substring(r + 1, e.length), t * parseFloat(s)) : "/" == e.charAt(0) ? m(r == e.length ? "" : e.substring(r + 1, e.length), t / parseFloat(s)) : t
                }

                function r(e, a, r) {
                    e.length > 8 && "-x-local" == e.substr(e.length - 8, e.length) && (e = e.substr(e, e.length - 8));
                    var s = e.search("-"), o = e.search("_");
                    if (-1 != s ? e = e.substr(s + 1, e.length) : -1 != o && (e = e.substr(o + 1, e.length)), "duration" == a) {
                        var n = [], u = 0;
                        return 0 !== Math.floor(r / 31536e3) && (n[u] = [], n[u].value = Math.floor(r / 31536e3), n[u].name = "years", ++u, r %= 31536e3), 0 !== Math.floor(r / 86400) && (n[u] = [], n[u].value = Math.floor(r / 86400), n[u].name = "days", ++u, r %= 86400), 0 !== Math.floor(r / 3600) && (n[u] = [], n[u].value = Math.floor(r / 3600), n[u].name = "hours", ++u, r %= 3600), 0 !== Math.floor(r / 60) && (n[u] = [], n[u].value = Math.floor(r / 60), n[u].name = "minutes", ++u, r %= 60), n
                    }
                    for (var i = "System" + y.ISO[e].system, l = y.Systems[i][a].num, b = new Array(l), u = 1; u <= l; ++u) {
                        var d = y.Systems[i][a]["unit" + u].name, F = y.Systems[i][a]["unit" + u].factor;
                        b[u - 1] = new t(m(F, r), d)
                    }
                    for (var u = l - 1; u >= 0; --u) if (Math.abs(b[u].value) < 1) return u != l - 1 && b[u + 1].value < 1e3 ? b[u + 1] : b[u];
                    return b[0]
                }

                function s(e, t, a, m) {
                    var r = e.split("\t", 11), o = [];
                    o.w = r[0], o.m = r[1], o.d = r[2], o.H = r[3], o.I = r[4], o.M = r[5], o.p = r[6], o.S = r[7], o.T = r[8], o.y = r[9], o.Y = r[10];
                    for (var n = "", u = 0; u < a.length; ++u) "%" == a.charAt(u) ? (++u, "a" == a.charAt(u) ? n += y.ISODateTime[t].dayAbbr[o.w] : "A" == a.charAt(u) ? n += y.ISODateTime[t].dayName[o.w] : "b" == a.charAt(u) ? n += y.ISODateTime[t].monthAbbr[o.m - 1] : "B" == a.charAt(u) ? n += y.ISODateTime[t].monthGenitive[o.m - 1] : "d" == a.charAt(u) ? n += o.d : "e" == a.charAt(u) ? n += o.d : "H" == a.charAt(u) ? n += o.H : "I" == a.charAt(u) ? n += o.I : "m" == a.charAt(u) ? n += o.m : "M" == a.charAt(u) ? n += o.M : "p" == a.charAt(u) ? n += o.p : "S" == a.charAt(u) ? n += o.S : "T" == a.charAt(u) ? n += o.T : "X" == a.charAt(u) ? m || (n += s(e, t, y.ISODateTime[t].timeFormat, 1)) : "y" == a.charAt(u) ? n += o.y : "Y" == a.charAt(u) ? n += o.Y : "Z" == a.charAt(u) || (n += "%" + a.charAt(u))) : n += a.charAt(u);
                    return n
                }

                function o(e, t, a) {
                    t.length > 8 && "-x-local" == t.substr(t.length - 8, t.length) && (t = t.substr(t, t.length - 8));
                    var m = t.search("-");
                    -1 != m && (t = t.replace(t.charAt(m), "_")), "full" == a ? a = y.ISODateTime[t].fullDateTimeFormat : "date" == a ? a = y.ISODateTime[t].dateFormat : "time" == a ? a = y.ISODateTime[t].timeFormat : "datetime" == a && (a = y.ISODateTime[t].fullDateFormat);
                    var r = n(1e3 * e, "en-US", "%w\t%m\t%d\t%H\t%I\t%M\t%p\t%S\t%T\t%y\t%Y"), o = s(r, t, a, 0);
                    return o
                }

                var n = function () {
                    var e = {};
                    return e.util = {}, e.util.xPad = function (e, t, a) {
                        for ("undefined" == typeof a && (a = 10); parseInt(e, 10) < a && a > 1; a /= 10) e = t.toString() + e;
                        return e.toString()
                    }, e.locales = {}, e.locales.en = {
                        a: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
                        A: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
                        b: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
                        B: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
                        c: "%a %d %b %Y %T %Z",
                        p: ["AM", "PM"],
                        P: ["am", "pm"],
                        x: "%d/%m/%y",
                        X: "%T"
                    }, e.locales["en-US"] = e.locales.en, e.locales["en-US"].c = "%a %d %b %Y %r %Z", e.locales["en-US"].x = "%D", e.locales["en-US"].X = "%r", e.locales["en-GB"] = e.locales.en, e.locales["en-AU"] = e.locales["en-GB"], e.formats = {
                        a: function (t) {
                            return e.locales[t.locale].a[t.getUTCDay()]
                        }, A: function (t) {
                            return e.locales[t.locale].A[t.getUTCDay()]
                        }, b: function (t) {
                            return e.locales[t.locale].b[t.getUTCMonth()]
                        }, B: function (t) {
                            return e.locales[t.locale].B[t.getUTCMonth()]
                        }, c: "toUTCString", C: function (t) {
                            return e.util.xPad(parseInt(t.getUTCFullYear() / 100, 10), 0)
                        }, d: ["getUTCDate", "0"], e: ["getUTCDate", " "], g: function (t) {
                            return e.util.xPad(parseInt(e.util.G(t) / 100, 10), 0)
                        }, G: function (t) {
                            var a = t.getUTCFullYear(), m = parseInt(e.formats.V(t), 10),
                                r = parseInt(e.formats.W(t), 10);
                            return r > m ? a++ : 0 === r && m >= 52 && a--, a
                        }, H: ["getUTCHours", "0"], I: function (t) {
                            var a = t.getUTCHours() % 12;
                            return e.util.xPad(0 === a ? 12 : a, 0)
                        }, j: function (t) {
                            var a = t - new Date("" + t.getUTCFullYear() + "/1/1 GMT");
                            a += 6e4 * t.getTimezoneOffset();
                            var m = parseInt(a / 6e4 / 60 / 24, 10) + 1;
                            return e.util.xPad(m, 0, 100)
                        }, m: function (t) {
                            return e.util.xPad(t.getUTCMonth() + 1, 0)
                        }, M: ["getUTCMinutes", "0"], p: function (t) {
                            return e.locales[t.locale].p[t.getUTCHours() >= 12 ? 1 : 0]
                        }, P: function (t) {
                            return e.locales[t.locale].P[t.getUTCHours() >= 12 ? 1 : 0]
                        }, S: ["getUTCSeconds", "0"], u: function (e) {
                            var t = e.getUTCDay();
                            return 0 === t ? 7 : t
                        }, U: function (t) {
                            var a = parseInt(e.formats.j(t), 10), m = 6 - t.getUTCDay(), r = parseInt((a + m) / 7, 10);
                            return e.util.xPad(r, 0)
                        }, V: function (t) {
                            var a = parseInt(e.formats.W(t), 10),
                                m = new Date("" + t.getUTCFullYear() + "/1/1").getUTCDay(),
                                r = a + (m > 4 || m <= 1 ? 0 : 1);
                            return 53 == r && new Date("" + t.getUTCFullYear() + "/12/31").getUTCDay() < 4 ? r = 1 : 0 === r && (r = e.formats.V(new Date("" + (t.getUTCFullYear() - 1) + "/12/31"))), e.util.xPad(r, 0)
                        }, w: "getUTCDay", W: function (t) {
                            var a = parseInt(e.formats.j(t), 10), m = 7 - e.formats.u(t), r = parseInt((a + m) / 7, 10);
                            return e.util.xPad(r, 0, 10)
                        }, y: function (t) {
                            return e.util.xPad(t.getUTCFullYear() % 100, 0)
                        }, Y: "getUTCFullYear", z: function (t) {
                            var a = t.getTimezoneOffset(), m = e.util.xPad(parseInt(Math.abs(a / 60), 10), 0),
                                r = e.util.xPad(a % 60, 0);
                            return (a > 0 ? "-" : "+") + m + r
                        }, Z: function (e) {
                            return e.toString().replace(/^.*\(([^)]+)\)$/, "$1")
                        }, "%": function (e) {
                            return "%"
                        }
                    }, e.aggregates = {
                        c: "locale",
                        D: "%m/%d/%y",
                        h: "%b",
                        n: "\n",
                        r: "%I:%M:%S %p",
                        R: "%H:%M",
                        t: "\t",
                        T: "%H:%M:%S",
                        x: "locale",
                        X: "locale"
                    }, e.aggregates.z = e.formats.z(new Date), e.aggregates.Z = e.formats.Z(new Date), e.unsupported = {}, function (t, a, m) {
                        a = a || "", m = m || "";
                        var r = new Date(t);
                        r.locale = a, a in e.locales || (a = a.replace(/-[a-zA-Z]+$/, "") in e.locales ? a.replace(/-[a-zA-Z]+$/, "") : "en-GB");
                        for (; m.match(/%[cDhnrRtTxXzZ]/);) m = m.replace(/%([cDhnrRtTxXzZ])/g, function (t, a) {
                            var m = e.aggregates[a];
                            return "locale" == m ? e.locales[r.locale][a] : m
                        });
                        var s = m.replace(/%([aAbBCdegGHIjmMpPSuUVwWyY%])/g, function (t, a) {
                            var m = e.formats[a];
                            return "string" == typeof m ? r[m]() : "function" == typeof m ? m.call(r, r) : "object" == typeof m && "string" == typeof m[0] ? e.util.xPad(r[m[0]](), m[1]) : a
                        });
                        return r = null, s
                    }
                }(), y = {
                    ISO: {
                        AD: {system: 2},
                        AE: {system: 2},
                        AF: {system: 2},
                        AG: {system: 2},
                        AI: {system: 2},
                        AL: {system: 2},
                        AM: {system: 2},
                        AO: {system: 2},
                        AR: {system: 2},
                        AT: {system: 2},
                        AU: {system: 2},
                        AW: {system: 2},
                        AZ: {system: 2},
                        BA: {system: 2},
                        BB: {system: 2},
                        BD: {system: 2},
                        BE: {system: 2},
                        BF: {system: 2},
                        BG: {system: 2},
                        BH: {system: 2},
                        BI: {system: 2},
                        BJ: {system: 2},
                        BM: {system: 2},
                        BN: {system: 2},
                        BO: {system: 2},
                        BR: {system: 2},
                        BS: {system: 2},
                        BT: {system: 2},
                        BW: {system: 2},
                        BY: {system: 2},
                        BZ: {system: 2},
                        CA: {system: 2},
                        CC: {system: 2},
                        CD: {system: 2},
                        CF: {system: 2},
                        CG: {system: 2},
                        CH: {system: 2},
                        CI: {system: 2},
                        CK: {system: 2},
                        CL: {system: 2},
                        CM: {system: 2},
                        CN: {system: 2},
                        CO: {system: 2},
                        CR: {system: 2},
                        CU: {system: 2},
                        CV: {system: 2},
                        CY: {system: 2},
                        CZ: {system: 2},
                        DE: {system: 2},
                        DJ: {system: 2},
                        DK: {system: 2},
                        DM: {system: 2},
                        DO: {system: 2},
                        DZ: {system: 2},
                        EC: {system: 2},
                        EE: {system: 2},
                        EG: {system: 2},
                        EH: {system: 2},
                        ER: {system: 2},
                        ES: {system: 2},
                        ET: {system: 2},
                        FI: {system: 2},
                        FJ: {system: 2},
                        FK: {system: 2},
                        FM: {system: 2},
                        FR: {system: 2},
                        GA: {system: 2},
                        GB: {system: 1},
                        GD: {system: 2},
                        GE: {system: 2},
                        GF: {system: 2},
                        GH: {system: 2},
                        GI: {system: 2},
                        GL: {system: 2},
                        GM: {system: 2},
                        GN: {system: 2},
                        GP: {system: 2},
                        GQ: {system: 2},
                        GR: {system: 2},
                        GT: {system: 2},
                        GU: {system: 2},
                        GW: {system: 2},
                        GY: {system: 2},
                        HK: {system: 2},
                        HN: {system: 2},
                        HR: {system: 2},
                        HT: {system: 2},
                        HU: {system: 2},
                        ID: {system: 2},
                        IE: {system: 2},
                        IL: {system: 2},
                        IN: {system: 2},
                        IQ: {system: 2},
                        IR: {system: 2},
                        IS: {system: 2},
                        IT: {system: 2},
                        JM: {system: 2},
                        JO: {system: 2},
                        JP: {system: 2},
                        KE: {system: 2},
                        KG: {system: 2},
                        KH: {system: 2},
                        KI: {system: 2},
                        KM: {system: 2},
                        KN: {system: 2},
                        KP: {system: 2},
                        KR: {system: 2},
                        KW: {system: 2},
                        KY: {system: 2},
                        KZ: {system: 2},
                        LA: {system: 2},
                        LB: {system: 2},
                        LC: {system: 2},
                        LI: {system: 2},
                        LK: {system: 2},
                        LR: {system: 1},
                        LS: {system: 2},
                        LT: {system: 2},
                        LU: {system: 2},
                        LV: {system: 2},
                        LY: {system: 2},
                        MA: {system: 2},
                        MC: {system: 2},
                        MD: {system: 2},
                        ME: {system: 2},
                        MG: {system: 2},
                        MH: {system: 2},
                        MK: {system: 2},
                        ML: {system: 2},
                        MM: {system: 1},
                        MN: {system: 2},
                        MQ: {system: 2},
                        MR: {system: 2},
                        MS: {system: 2},
                        MT: {system: 2},
                        MU: {system: 2},
                        MV: {system: 2},
                        MW: {system: 2},
                        MX: {system: 2},
                        MY: {system: 2},
                        MZ: {system: 2},
                        NA: {system: 2},
                        NC: {system: 2},
                        NE: {system: 2},
                        NF: {system: 2},
                        NG: {system: 2},
                        NI: {system: 2},
                        NL: {system: 2},
                        NO: {system: 2},
                        NP: {system: 2},
                        NR: {system: 2},
                        NU: {system: 2},
                        NZ: {system: 2},
                        OM: {system: 2},
                        PA: {system: 2},
                        PE: {system: 2},
                        PF: {system: 2},
                        PG: {system: 2},
                        PH: {system: 2},
                        PK: {system: 2},
                        PL: {system: 2},
                        PR: {system: 2},
                        PS: {system: 2},
                        PT: {system: 2},
                        PW: {system: 2},
                        PY: {system: 2},
                        QA: {system: 2},
                        RE: {system: 2},
                        RO: {system: 2},
                        RS: {system: 2},
                        RU: {system: 2},
                        RW: {system: 2},
                        SA: {system: 2},
                        SB: {system: 2},
                        SC: {system: 2},
                        SD: {system: 2},
                        SE: {system: 2},
                        SG: {system: 2},
                        SI: {system: 2},
                        SK: {system: 2},
                        SL: {system: 2},
                        SM: {system: 2},
                        SN: {system: 2},
                        SO: {system: 2},
                        SR: {system: 2},
                        ST: {system: 2},
                        SV: {system: 2},
                        SY: {system: 2},
                        SZ: {system: 2},
                        TC: {system: 2},
                        TD: {system: 2},
                        TG: {system: 2},
                        TH: {system: 2},
                        TJ: {system: 2},
                        TL: {system: 2},
                        TM: {system: 2},
                        TN: {system: 2},
                        TO: {system: 2},
                        TR: {system: 2},
                        TT: {system: 2},
                        TV: {system: 2},
                        TW: {system: 2},
                        TZ: {system: 2},
                        UA: {system: 2},
                        UG: {system: 2},
                        US: {system: 1},
                        UY: {system: 2},
                        UZ: {system: 2},
                        VA: {system: 2},
                        VC: {system: 2},
                        VE: {system: 2},
                        VG: {system: 2},
                        VI: {system: 2},
                        VN: {system: 2},
                        VU: {system: 2},
                        WS: {system: 2},
                        YE: {system: 2},
                        YT: {system: 2},
                        ZA: {system: 2},
                        ZM: {system: 2}
                    },
                    Systems: {
                        System1: {
                            distance: {
                                unit1: {name: "miles", factor: "*0.00062"},
                                unit2: {name: "feet", factor: "*3.281"},
                                unit3: {name: "inches", factor: "*39.37"},
                                num: 3
                            },
                            temperature: {unit1: {name: "fahrenheits", factor: "*1.8+32"}, num: 1},
                            velocity: {unit1: {name: "miles per hour", factor: "*2.237"}, num: 1}
                        },
                        System2: {
                            distance: {
                                unit1: {name: "kilometers", factor: "*0.001"},
                                unit2: {name: "meters", factor: "*1"},
                                unit3: {name: "centimeters", factor: "*100"},
                                num: 3
                            },
                            temperature: {unit1: {name: "celsiuses", factor: "*1"}, num: 1},
                            velocity: {unit1: {name: "kilometers per hour", factor: "*3.6"}, num: 1}
                        }
                    },
                    ISODateTime: {
                        be_BY: {
                            monthAbbr: {
                                0: "сту",
                                1: "лют",
                                2: "сак",
                                3: "кра",
                                4: "тра",
                                5: "чэр",
                                6: "ліп",
                                7: "жні",
                                8: "вер",
                                9: "кас",
                                10: "ліс",
                                11: "сне"
                            },
                            monthGenitive: {
                                0: "студзеня",
                                1: "лютага",
                                2: "сакавіка",
                                3: "красавіка",
                                4: "траўня",
                                5: "чэрвеня",
                                6: "ліпеня",
                                7: "жніўня",
                                8: "верасня",
                                9: "кастрычніка",
                                10: "лістапада",
                                11: "снежня"
                            },
                            dayAbbr: {0: "нд ", 1: "пн ", 2: "аў ", 3: "ср ", 4: "чц ", 5: "пт ", 6: "сб "},
                            dayName: {
                                0: "нядзеля",
                                1: "панядзелак",
                                2: "аўторак",
                                3: "серада",
                                4: "чацвер",
                                5: "пятніца",
                                6: "субота"
                            },
                            timeFormat: "%H:%M:%S",
                            dateFormat: "%d.%m.%y",
                            fullDateFormat: "%a %e %b %X %Y",
                            amFormat: "am",
                            pmFormat: "pm",
                            fullDateTimeFormat: "%a %e %b %Y %X %Z",
                            monthNominative: {
                                0: "студзень",
                                1: "люты",
                                2: "сакавік",
                                3: "красавік",
                                4: "травень",
                                5: "чэрвень",
                                6: "ліпень",
                                7: "жнівень",
                                8: "верасень",
                                9: "кастрычнік",
                                10: "лістапад",
                                11: "снежань"
                            },
                            dmFormat: "dm",
                            twelveTimeFormat: "%I:%M:%S %p"
                        },
                        cs_CZ: {
                            monthAbbr: {
                                0: "led",
                                1: "úno",
                                2: "bře",
                                3: "dub",
                                4: "kvě",
                                5: "črv",
                                6: "čvc",
                                7: "srp",
                                8: "zář",
                                9: "říj",
                                10: "lis",
                                11: "pro"
                            },
                            monthGenitive: {
                                0: "ledna",
                                1: "února",
                                2: "března",
                                3: "dubna",
                                4: "května",
                                5: "června",
                                6: "července",
                                7: "srpna",
                                8: "září",
                                9: "října",
                                10: "listopadu",
                                11: "prosince"
                            },
                            dayAbbr: {0: "ne", 1: "po", 2: "út", 3: "st", 4: "čt", 5: "pá", 6: "so"},
                            dayName: {
                                0: "neděle",
                                1: "pondělí",
                                2: "úterý",
                                3: "středa",
                                4: "čtvrtek",
                                5: "pátek",
                                6: "sobota"
                            },
                            timeFormat: "%H:%M:%S",
                            dateFormat: "%Y/%m/%d",
                            fullDateFormat: "%a %e %b %X %Y",
                            amFormat: "dp",
                            pmFormat: "od",
                            fullDateTimeFormat: "%a %e. %B %Y %X %Z",
                            monthNominative: {
                                0: "leden",
                                1: "únor",
                                2: "březen",
                                3: "duben",
                                4: "květen",
                                5: "červen",
                                6: "červenec",
                                7: "srpen",
                                8: "září",
                                9: "říjen",
                                10: "listopad",
                                11: "prosinec"
                            },
                            dmFormat: "dm",
                            twelveTimeFormat: "%I:%M:%S %p"
                        },
                        de_DE: {
                            monthAbbr: {
                                0: "Jan",
                                1: "Feb",
                                2: "Mär",
                                3: "Apr",
                                4: "Mai",
                                5: "Jun",
                                6: "Jul",
                                7: "Aug",
                                8: "Sep",
                                9: "Okt",
                                10: "Nov",
                                11: "Dez"
                            },
                            monthGenitive: {
                                0: "Januar",
                                1: "Februar",
                                2: "März",
                                3: "April",
                                4: "Mai",
                                5: "Juni",
                                6: "Juli",
                                7: "August",
                                8: "September",
                                9: "Oktober",
                                10: "November",
                                11: "Dezember"
                            },
                            dayAbbr: {0: "So", 1: "Mo", 2: "Di", 3: "Mi", 4: "Do", 5: "Fr", 6: "Sa"},
                            dayName: {
                                0: "Sonntag",
                                1: "Montag",
                                2: "Dienstag",
                                3: "Mittwoch",
                                4: "Donnerstag",
                                5: "Freitag",
                                6: "Samstag"
                            },
                            timeFormat: "%H:%M:%S",
                            dateFormat: "%d.%m.%Y",
                            fullDateFormat: "%a %e %b %X %Y",
                            amFormat: "am",
                            pmFormat: "pm",
                            fullDateTimeFormat: "%a %e %b %Y %X %Z",
                            monthNominative: {
                                0: "Januar",
                                1: "Februar",
                                2: "März",
                                3: "April",
                                4: "Mai",
                                5: "Juni",
                                6: "Juli",
                                7: "August",
                                8: "September",
                                9: "Oktober",
                                10: "November",
                                11: "Dezember"
                            },
                            dmFormat: "dm",
                            twelveTimeFormat: "%I:%M:%S %p"
                        },
                        en_AU: {
                            monthAbbr: {
                                0: "Jan",
                                1: "Feb",
                                2: "Mar",
                                3: "Apr",
                                4: "May",
                                5: "Jun",
                                6: "Jul",
                                7: "Aug",
                                8: "Sep",
                                9: "Oct",
                                10: "Nov",
                                11: "Dec"
                            },
                            monthGenitive: {
                                0: "January",
                                1: "February",
                                2: "March",
                                3: "April",
                                4: "May",
                                5: "June",
                                6: "July",
                                7: "August",
                                8: "September",
                                9: "October",
                                10: "November",
                                11: "December"
                            },
                            dayAbbr: {0: "Sun", 1: "Mon", 2: "Tue", 3: "Wed", 4: "Thu", 5: "Fri", 6: "Sat"},
                            dayName: {
                                0: "Sunday",
                                1: "Monday",
                                2: "Tuesday",
                                3: "Wednesday",
                                4: "Thursday",
                                5: "Friday",
                                6: "Saturday"
                            },
                            timeFormat: "%H:%M:%S",
                            dateFormat: "%d/%m/%Y",
                            fullDateFormat: "%a %e %b %X %Y",
                            amFormat: "am",
                            pmFormat: "pm",
                            fullDateTimeFormat: "%a %e %b %Y %X %Z",
                            monthNominative: {
                                0: "January",
                                1: "February",
                                2: "March",
                                3: "April",
                                4: "May",
                                5: "June",
                                6: "July",
                                7: "August",
                                8: "September",
                                9: "October",
                                10: "November",
                                11: "December"
                            },
                            dmFormat: "dm",
                            twelveTimeFormat: "%I:%M:%S %p"
                        },
                        en_CA: {
                            monthAbbr: {
                                0: "Jan",
                                1: "Feb",
                                2: "Mar",
                                3: "Apr",
                                4: "May",
                                5: "Jun",
                                6: "Jul",
                                7: "Aug",
                                8: "Sep",
                                9: "Oct",
                                10: "Nov",
                                11: "Dec"
                            },
                            monthGenitive: {
                                0: "January",
                                1: "February",
                                2: "March",
                                3: "April",
                                4: "May",
                                5: "June",
                                6: "July",
                                7: "August",
                                8: "September",
                                9: "October",
                                10: "November",
                                11: "December"
                            },
                            dayAbbr: {0: "Sun", 1: "Mon", 2: "Tue", 3: "Wed", 4: "Thu", 5: "Fri", 6: "Sat"},
                            dayName: {
                                0: "Sunday",
                                1: "Monday",
                                2: "Tuesday",
                                3: "Wednesday",
                                4: "Thursday",
                                5: "Friday",
                                6: "Saturday"
                            },
                            timeFormat: "%H:%M:%S",
                            dateFormat: "%d/%m/%Y",
                            fullDateFormat: "%a %e %b %X %Y",
                            amFormat: "am",
                            pmFormat: "pm",
                            fullDateTimeFormat: "%a %e %b %Y %X %Z",
                            monthNominative: {
                                0: "January",
                                1: "February",
                                2: "March",
                                3: "April",
                                4: "May",
                                5: "June",
                                6: "July",
                                7: "August",
                                8: "September",
                                9: "October",
                                10: "November",
                                11: "December"
                            },
                            dmFormat: "dm",
                            twelveTimeFormat: "%I:%M:%S %p"
                        },
                        en_GB: {
                            monthAbbr: {
                                0: "Jan",
                                1: "Feb",
                                2: "Mar",
                                3: "Apr",
                                4: "May",
                                5: "Jun",
                                6: "Jul",
                                7: "Aug",
                                8: "Sep",
                                9: "Oct",
                                10: "Nov",
                                11: "Dec"
                            },
                            monthGenitive: {
                                0: "January",
                                1: "February",
                                2: "March",
                                3: "April",
                                4: "May",
                                5: "June",
                                6: "July",
                                7: "August",
                                8: "September",
                                9: "October",
                                10: "November",
                                11: "December"
                            },
                            dayAbbr: {0: "Sun", 1: "Mon", 2: "Tue", 3: "Wed", 4: "Thu", 5: "Fri", 6: "Sat"},
                            dayName: {
                                0: "Sunday",
                                1: "Monday",
                                2: "Tuesday",
                                3: "Wednesday",
                                4: "Thursday",
                                5: "Friday",
                                6: "Saturday"
                            },
                            timeFormat: "%H:%M:%S",
                            dateFormat: "%d/%m/%Y",
                            fullDateFormat: "%a %e %b %X %Y",
                            amFormat: "am",
                            pmFormat: "pm",
                            fullDateTimeFormat: "%a %e %b %Y %X %Z",
                            monthNominative: {
                                0: "January",
                                1: "February",
                                2: "March",
                                3: "April",
                                4: "May",
                                5: "June",
                                6: "July",
                                7: "August",
                                8: "September",
                                9: "October",
                                10: "November",
                                11: "December"
                            },
                            dmFormat: "dm",
                            twelveTimeFormat: "%I:%M:%S %p"
                        },
                        en_IE: {
                            monthAbbr: {
                                0: "Jan",
                                1: "Feb",
                                2: "Mar",
                                3: "Apr",
                                4: "May",
                                5: "Jun",
                                6: "Jul",
                                7: "Aug",
                                8: "Sep",
                                9: "Oct",
                                10: "Nov",
                                11: "Dec"
                            },
                            monthGenitive: {
                                0: "January",
                                1: "February",
                                2: "March",
                                3: "April",
                                4: "May",
                                5: "June",
                                6: "July",
                                7: "August",
                                8: "September",
                                9: "October",
                                10: "November",
                                11: "December"
                            },
                            dayAbbr: {0: "Sun", 1: "Mon", 2: "Tue", 3: "Wed", 4: "Thu", 5: "Fri", 6: "Sat"},
                            dayName: {
                                0: "Sunday",
                                1: "Monday",
                                2: "Tuesday",
                                3: "Wednesday",
                                4: "Thursday",
                                5: "Friday",
                                6: "Saturday"
                            },
                            timeFormat: "%H:%M:%S",
                            dateFormat: "%d/%m/%Y",
                            fullDateFormat: "%a %e %b %X %Y",
                            amFormat: "am",
                            pmFormat: "pm",
                            fullDateTimeFormat: "%a %e %b %Y %X %Z",
                            monthNominative: {
                                0: "January",
                                1: "February",
                                2: "March",
                                3: "April",
                                4: "May",
                                5: "June",
                                6: "July",
                                7: "August",
                                8: "September",
                                9: "October",
                                10: "November",
                                11: "December"
                            },
                            dmFormat: "dm",
                            twelveTimeFormat: "%I:%M:%S %p"
                        },
                        en_NZ: {
                            monthAbbr: {
                                0: "Jan",
                                1: "Feb",
                                2: "Mar",
                                3: "Apr",
                                4: "May",
                                5: "Jun",
                                6: "Jul",
                                7: "Aug",
                                8: "Sep",
                                9: "Oct",
                                10: "Nov",
                                11: "Dec"
                            },
                            monthGenitive: {
                                0: "January",
                                1: "February",
                                2: "March",
                                3: "April",
                                4: "May",
                                5: "June",
                                6: "July",
                                7: "August",
                                8: "September",
                                9: "October",
                                10: "November",
                                11: "December"
                            },
                            dayAbbr: {0: "Sun", 1: "Mon", 2: "Tue", 3: "Wed", 4: "Thu", 5: "Fri", 6: "Sat"},
                            dayName: {
                                0: "Sunday",
                                1: "Monday",
                                2: "Tuesday",
                                3: "Wednesday",
                                4: "Thursday",
                                5: "Friday",
                                6: "Saturday"
                            },
                            timeFormat: "%H:%M:%S",
                            dateFormat: "%d/%m/%Y",
                            fullDateFormat: "%a %e %b %X %Y",
                            amFormat: "am",
                            pmFormat: "pm",
                            fullDateTimeFormat: "%a %e %b %Y %X %Z",
                            monthNominative: {
                                0: "January",
                                1: "February",
                                2: "March",
                                3: "April",
                                4: "May",
                                5: "June",
                                6: "July",
                                7: "August",
                                8: "September",
                                9: "October",
                                10: "November",
                                11: "December"
                            },
                            dmFormat: "dm",
                            twelveTimeFormat: "%I:%M:%S %p"
                        },
                        en_RU: {
                            monthAbbr: {
                                0: "Jan",
                                1: "Feb",
                                2: "Mar",
                                3: "Apr",
                                4: "May",
                                5: "Jun",
                                6: "Jul",
                                7: "Aug",
                                8: "Sep",
                                9: "Oct",
                                10: "Nov",
                                11: "Dec"
                            },
                            monthGenitive: {
                                0: "January",
                                1: "February",
                                2: "March",
                                3: "April",
                                4: "May",
                                5: "June",
                                6: "July",
                                7: "August",
                                8: "September",
                                9: "October",
                                10: "November",
                                11: "December"
                            },
                            dayAbbr: {0: "Sun", 1: "Mon", 2: "Tue", 3: "Wed", 4: "Thu", 5: "Fri", 6: "Sat"},
                            dayName: {
                                0: "Sunday",
                                1: "Monday",
                                2: "Tuesday",
                                3: "Wednesday",
                                4: "Thursday",
                                5: "Friday",
                                6: "Saturday"
                            },
                            timeFormat: "%H:%M:%S",
                            dateFormat: "%d.%m.%Y",
                            fullDateFormat: "%A, %e %B %Y y. %X",
                            amFormat: "",
                            pmFormat: "",
                            fullDateTimeFormat: "%A, %e %B %Y y. %X (%Z)",
                            monthNominative: {
                                0: "January",
                                1: "February",
                                2: "March",
                                3: "April",
                                4: "May",
                                5: "June",
                                6: "July",
                                7: "August",
                                8: "September",
                                9: "October",
                                10: "November",
                                11: "December"
                            },
                            dmFormat: "dm",
                            twelveTimeFormat: ""
                        },
                        en_US: {
                            monthAbbr: {
                                0: "Jan",
                                1: "Feb",
                                2: "Mar",
                                3: "Apr",
                                4: "May",
                                5: "Jun",
                                6: "Jul",
                                7: "Aug",
                                8: "Sep",
                                9: "Oct",
                                10: "Nov",
                                11: "Dec"
                            },
                            monthGenitive: {
                                0: "January",
                                1: "February",
                                2: "March",
                                3: "April",
                                4: "May",
                                5: "June",
                                6: "July",
                                7: "August",
                                8: "September",
                                9: "October",
                                10: "November",
                                11: "December"
                            },
                            dayAbbr: {0: "Sun", 1: "Mon", 2: "Tue", 3: "Wed", 4: "Thu", 5: "Fri", 6: "Sat"},
                            dayName: {
                                0: "Sunday",
                                1: "Monday",
                                2: "Tuesday",
                                3: "Wednesday",
                                4: "Thursday",
                                5: "Friday",
                                6: "Saturday"
                            },
                            timeFormat: "%H:%M:%S",
                            dateFormat: "%m/%d/%Y",
                            fullDateFormat: "%a %b %e %X %Y",
                            amFormat: "AM",
                            pmFormat: "PM",
                            fullDateTimeFormat: "%a %b %e %X %Z %Y",
                            monthNominative: {
                                0: "January",
                                1: "February",
                                2: "March",
                                3: "April",
                                4: "May",
                                5: "June",
                                6: "July",
                                7: "August",
                                8: "September",
                                9: "October",
                                10: "November",
                                11: "December"
                            },
                            dmFormat: "md",
                            twelveTimeFormat: "%I:%M:%S %p"
                        },
                        fr_FR: {
                            monthAbbr: {
                                0: "jan",
                                1: "fév",
                                2: "mar",
                                3: "avr",
                                4: "mai",
                                5: "jui",
                                6: "jul",
                                7: "aoû",
                                8: "sep",
                                9: "oct",
                                10: "nov",
                                11: "déc"
                            },
                            monthGenitive: {
                                0: "janvier",
                                1: "février",
                                2: "mars",
                                3: "avril",
                                4: "mai",
                                5: "juin",
                                6: "juillet",
                                7: "août",
                                8: "septembre",
                                9: "octobre",
                                10: "novembre",
                                11: "décembre"
                            },
                            dayAbbr: {0: "Dim", 1: "Lun", 2: "Mar", 3: "Mer", 4: "Jeu", 5: "Ven", 6: "Sam"},
                            dayName: {
                                0: "Dimanche",
                                1: "Lundi",
                                2: "Mardi",
                                3: "Mercredi",
                                4: "Jeudi",
                                5: "Vendredi",
                                6: "Samedi"
                            },
                            timeFormat: "%H:%M:%S",
                            dateFormat: "%d.%m.%Y",
                            fullDateFormat: "%a %e %b %X %Y",
                            amFormat: "",
                            pmFormat: "",
                            fullDateTimeFormat: "%a %e %b %Y %X %Z",
                            monthNominative: {
                                0: "janvier",
                                1: "février",
                                2: "mars",
                                3: "avril",
                                4: "mai",
                                5: "juin",
                                6: "juillet",
                                7: "août",
                                8: "septembre",
                                9: "octobre",
                                10: "novembre",
                                11: "décembre"
                            },
                            dmFormat: "dm",
                            twelveTimeFormat: ""
                        },
                        hy_AM: {
                            monthAbbr: {
                                0: "Հնվ",
                                1: "Փտր",
                                2: "Մրտ",
                                3: "Ապր",
                                4: "Մյս",
                                5: "Հնս",
                                6: "Հլս",
                                7: "Օգս",
                                8: "Սպտ",
                                9: "Հկտ",
                                10: "Նյմ",
                                11: "Դկտ"
                            },
                            monthGenitive: {
                                0: "Հունվար",
                                1: "Փետրվար",
                                2: "Մարտ",
                                3: "Ապրիլ",
                                4: "Մայիս",
                                5: "Հունիս",
                                6: "Հուլիս",
                                7: "Օգոստոս",
                                8: "Սեպտեմբեր",
                                9: "Հոկտեմբեր",
                                10: "Նոյեմբեր",
                                11: "Դեկտեմբեր"
                            },
                            dayAbbr: {0: "Կրկ", 1: "Երկ", 2: "Երք", 3: "Չրք", 4: "Հնգ", 5: "Ուր", 6: "Շբթ"},
                            dayName: {
                                0: "Կիրակի",
                                1: "Երկուշաբթի",
                                2: "Երեքշաբթի",
                                3: "Չորեքշաբթի",
                                4: "Հինգշաբթի",
                                5: "Ուրբաթ",
                                6: "Շաբաթ"
                            },
                            timeFormat: "%H:%M:%S",
                            dateFormat: "%d.%m.%Y",
                            fullDateFormat: "%A, %e %B %Y ի. %X",
                            amFormat: "",
                            pmFormat: "",
                            fullDateTimeFormat: "%A, %e %B %Y թ. %X (%Z)",
                            monthNominative: {
                                0: "Հունվար",
                                1: "Փետրվար",
                                2: "Մարտ",
                                3: "Ապրիլ",
                                4: "Մայիս",
                                5: "Հունիս",
                                6: "Հուլիս",
                                7: "Օգոստոս",
                                8: "Սեպտեմբեր",
                                9: "Հոկտեմբեր",
                                10: "Նոյեմբեր",
                                11: "Դեկտեմբեր"
                            },
                            dmFormat: "dm",
                            twelveTimeFormat: ""
                        },
                        kk_KZ: {
                            monthAbbr: {
                                0: "қаң",
                                1: "ақп",
                                2: "нау",
                                3: "сәу",
                                4: "мам",
                                5: "мау",
                                6: "шіл",
                                7: "там",
                                8: "қыр",
                                9: "қаз",
                                10: "қар",
                                11: "жел"
                            },
                            monthGenitive: {
                                0: "қаңтар",
                                1: "ақпан",
                                2: "наурыз",
                                3: "сәуір",
                                4: "мамыр",
                                5: "маусым",
                                6: "шілде",
                                7: "тамыз",
                                8: "қыркүйек",
                                9: "қазан",
                                10: "қараша",
                                11: "желтоқсан"
                            },
                            dayAbbr: {0: "жк", 1: "дс", 2: "сс", 3: "ср", 4: "бс", 5: "жм", 6: "сн"},
                            dayName: {
                                0: "жексенбі",
                                1: "дүйсенбі",
                                2: "сейсенбі",
                                3: "сәрсенбі",
                                4: "бейсенбі",
                                5: "жұма",
                                6: "сенбі"
                            },
                            timeFormat: "%H:%M:%S",
                            dateFormat: "%d.%m.%Y",
                            fullDateFormat: "%A, %e %B %Y ж. %X",
                            amFormat: "",
                            pmFormat: "",
                            fullDateTimeFormat: "%A, %e %B %Y ж. %X (%Z)",
                            monthNominative: {
                                0: "қантар",
                                1: "ақпан",
                                2: "наурыз",
                                3: "сәуір",
                                4: "мамыр",
                                5: "маусым",
                                6: "шілде",
                                7: "тамыз",
                                8: "қыркүйек",
                                9: "қазан",
                                10: "қараша",
                                11: "желтоқсан"
                            },
                            dmFormat: "dm",
                            twelveTimeFormat: ""
                        },
                        ru_RU: {
                            monthAbbr: {
                                0: "янв",
                                1: "фев",
                                2: "мар",
                                3: "апр",
                                4: "май",
                                5: "июн",
                                6: "июл",
                                7: "авг",
                                8: "сен",
                                9: "окт",
                                10: "ноя",
                                11: "дек"
                            },
                            monthGenitive: {
                                0: "января",
                                1: "февраля",
                                2: "марта",
                                3: "апреля",
                                4: "мая",
                                5: "июня",
                                6: "июля",
                                7: "августа",
                                8: "сентября",
                                9: "октября",
                                10: "ноября",
                                11: "декабря"
                            },
                            dayAbbr: {0: "вс", 1: "пн", 2: "вт", 3: "ср", 4: "чт", 5: "пт", 6: "сб"},
                            dayName: {
                                0: "воскресенье",
                                1: "понедельник",
                                2: "вторник",
                                3: "среда",
                                4: "четверг",
                                5: "пятница",
                                6: "суббота"
                            },
                            timeFormat: "%H:%M:%S",
                            dateFormat: "%d.%m.%Y",
                            fullDateFormat: "%A, %e %B %Y г. %X",
                            amFormat: "",
                            pmFormat: "",
                            fullDateTimeFormat: "%A, %e %B %Y г. %X (%Z)",
                            monthNominative: {
                                0: "январь",
                                1: "февраль",
                                2: "март",
                                3: "апрель",
                                4: "май",
                                5: "июнь",
                                6: "июль",
                                7: "август",
                                8: "сентябрь",
                                9: "октябрь",
                                10: "ноябрь",
                                11: "декабрь"
                            },
                            dmFormat: "dm",
                            twelveTimeFormat: ""
                        },
                        ru_UA: {
                            monthAbbr: {
                                0: "янв",
                                1: "фев",
                                2: "мар",
                                3: "апр",
                                4: "май",
                                5: "июн",
                                6: "июл",
                                7: "авг",
                                8: "сен",
                                9: "окт",
                                10: "ноя",
                                11: "дек"
                            },
                            monthGenitive: {
                                0: "января",
                                1: "февраля",
                                2: "марта",
                                3: "апреля",
                                4: "мая",
                                5: "июня",
                                6: "июля",
                                7: "августа",
                                8: "сентября",
                                9: "октября",
                                10: "ноября",
                                11: "декабря"
                            },
                            dayAbbr: {0: "вс", 1: "пн", 2: "вт", 3: "ср", 4: "чт", 5: "пт", 6: "сб"},
                            dayName: {
                                0: "воскресенье",
                                1: "понедельник",
                                2: "вторник",
                                3: "среда",
                                4: "четверг",
                                5: "пятница",
                                6: "суббота"
                            },
                            timeFormat: "%H:%M:%S",
                            dateFormat: "%d.%m.%Y",
                            fullDateFormat: "%A, %e %B %Y г. %X",
                            amFormat: "",
                            pmFormat: "",
                            fullDateTimeFormat: "%A, %e %B %Y г. %X (%Z)",
                            monthNominative: {
                                0: "январь",
                                1: "февраль",
                                2: "март",
                                3: "апрель",
                                4: "май",
                                5: "июнь",
                                6: "июль",
                                7: "август",
                                8: "сентябрь",
                                9: "октябрь",
                                10: "ноябрь",
                                11: "декабрь"
                            },
                            dmFormat: "dm",
                            twelveTimeFormat: ""
                        },
                        sr_RS: {
                            monthAbbr: {
                                0: "јан",
                                1: "феб",
                                2: "мар",
                                3: "апр",
                                4: "мај",
                                5: "јун",
                                6: "јул",
                                7: "авг",
                                8: "сеп",
                                9: "окт",
                                10: "нов",
                                11: "дец"
                            },
                            monthGenitive: {
                                0: "јануaр",
                                1: "фебруар",
                                2: "март",
                                3: "април",
                                4: "мај",
                                5: "јуни",
                                6: "јули",
                                7: "август",
                                8: "септембар",
                                9: "октобар",
                                10: "новембар",
                                11: "децембар"
                            },
                            dayAbbr: {0: "нед", 1: "пон", 2: "уто", 3: "сре", 4: "чет", 5: "пет", 6: "суб"},
                            dayName: {
                                0: "недеља",
                                1: "понедељак",
                                2: "уторак",
                                3: "среда",
                                4: "четвртак",
                                5: "петак",
                                6: "субота"
                            },
                            timeFormat: "%H:%M:%S",
                            dateFormat: "%d.%m.%Y",
                            fullDateFormat: "%a %e %b %X %Y",
                            amFormat: "",
                            pmFormat: "",
                            fullDateTimeFormat: "%a %e %b %Y %X %Z",
                            monthNominative: {
                                0: "јануaр",
                                1: "фебруар",
                                2: "март",
                                3: "април",
                                4: "мај",
                                5: "јуни",
                                6: "јули",
                                7: "август",
                                8: "септембар",
                                9: "октобар",
                                10: "новембар",
                                11: "децембар"
                            },
                            dmFormat: "dm",
                            twelveTimeFormat: ""
                        },
                        tr_TR: {
                            monthAbbr: {
                                0: "Oca",
                                1: "Şub",
                                2: "Mar",
                                3: "Nis",
                                4: "May",
                                5: "Haz",
                                6: "Tem",
                                7: "Ağu",
                                8: "Eyl",
                                9: "Eki",
                                10: "Kas",
                                11: "Ara"
                            },
                            monthGenitive: {
                                0: "Ocak",
                                1: "Şubat",
                                2: "Mart",
                                3: "Nisan",
                                4: "Mayıs",
                                5: "Haziran",
                                6: "Temmuz",
                                7: "Ağustos",
                                8: "Eylül",
                                9: "Ekim",
                                10: "Kasım",
                                11: "Aralık"
                            },
                            dayAbbr: {0: "Paz", 1: "Pts", 2: "Sal", 3: "Çar", 4: "Per", 5: "Cum", 6: "Cts"},
                            dayName: {
                                0: "Pazar",
                                1: "Pazartesi",
                                2: "Salı",
                                3: "Çarşamba",
                                4: "Perşembe",
                                5: "Cuma",
                                6: "Cumartesi"
                            },
                            timeFormat: "%H:%M:%S",
                            dateFormat: "%d/%m/%Y",
                            fullDateFormat: "%a %e %b %X %Y",
                            amFormat: "AM",
                            pmFormat: "PM",
                            fullDateTimeFormat: "%e %b %Y %a %Z %X",
                            monthNominative: {
                                0: "Ocak",
                                1: "Subat",
                                2: "Mart",
                                3: "Nisan",
                                4: "Mayis",
                                5: "Haziran",
                                6: "Temmuz",
                                7: "Agustos",
                                8: "Eylul",
                                9: "Ekim",
                                10: "Kasim",
                                11: "Aralik"
                            },
                            dmFormat: "dm",
                            twelveTimeFormat: "%I:%M:%S %p"
                        },
                        tt_RU: {
                            monthAbbr: {
                                0: "гыйнв",
                                1: "фев",
                                2: "мар",
                                3: "апр",
                                4: "май",
                                5: "июн",
                                6: "июл",
                                7: "авг",
                                8: "сен",
                                9: "окт",
                                10: "ноя",
                                11: "дек"
                            },
                            monthGenitive: {
                                0: "гыйнвар",
                                1: "февраль",
                                2: "март",
                                3: "апрель",
                                4: "май",
                                5: "июнь",
                                6: "июль",
                                7: "август",
                                8: "сентябрь",
                                9: "октябрь",
                                10: "ноябрь",
                                11: "декабрь"
                            },
                            dayAbbr: {0: "яб", 1: "дб", 2: "сб", 3: "чб", 4: "пб", 5: "җ", 6: "сб"},
                            dayName: {
                                0: "якшәмбе",
                                1: "дүшәмбе",
                                2: "сишәмбе",
                                3: "чәршәмбе",
                                4: "пәнҗешәмбе",
                                5: "җомга",
                                6: "шимбә"
                            },
                            timeFormat: "%H:%M:%S",
                            dateFormat: "%d.%m.%Y",
                            fullDateFormat: "%A, %e %B %Y г. %X",
                            amFormat: "",
                            pmFormat: "",
                            fullDateTimeFormat: "%A, %e %B %Y г. %X (%Z)",
                            monthNominative: {
                                0: "гыйнвар",
                                1: "февраль ",
                                2: "март",
                                3: "апрель",
                                4: "май ",
                                5: "июнь ",
                                6: "июль ",
                                7: "август",
                                8: "сентябрь",
                                9: "октябрь",
                                10: "ноябрь ",
                                11: "декабрь"
                            },
                            dmFormat: "dm",
                            twelveTimeFormat: ""
                        },
                        uk_RU: {
                            monthAbbr: {
                                0: "січ",
                                1: "лют",
                                2: "бер",
                                3: "кві",
                                4: "тра",
                                5: "чер",
                                6: "лип",
                                7: "сер",
                                8: "вер",
                                9: "жов",
                                10: "лис",
                                11: "гру"
                            },
                            monthGenitive: {
                                0: "січня",
                                1: "лютого",
                                2: "березня",
                                3: "квітня",
                                4: "травня",
                                5: "червня",
                                6: "липня",
                                7: "серпня",
                                8: "вересня",
                                9: "жовтня",
                                10: "листопада",
                                11: "грудня"
                            },
                            dayAbbr: {0: "нд", 1: "пн", 2: "вт", 3: "ср", 4: "чт", 5: "пт", 6: "сб"},
                            dayName: {
                                0: "неділя",
                                1: "понеділок",
                                2: "вівторок",
                                3: "середа",
                                4: "четвер",
                                5: "п'ятниця",
                                6: "субота"
                            },
                            timeFormat: "%H:%M:%S",
                            dateFormat: "%d.%m.%Y",
                            fullDateFormat: "%a %e %b %X %Y",
                            amFormat: "",
                            pmFormat: "",
                            fullDateTimeFormat: "%a %e %b %Y %X %Z",
                            monthNominative: {
                                0: "січень",
                                1: "лютий",
                                2: "березень",
                                3: "квітень",
                                4: "травень",
                                5: "червень",
                                6: "липень",
                                7: "серпень",
                                8: "вересень",
                                9: "жовтень",
                                10: "листопад",
                                11: "грудень"
                            },
                            dmFormat: "dm",
                            twelveTimeFormat: ""
                        },
                        uk_UA: {
                            monthAbbr: {
                                0: "січ",
                                1: "лют",
                                2: "бер",
                                3: "кві",
                                4: "тра",
                                5: "чер",
                                6: "лип",
                                7: "сер",
                                8: "вер",
                                9: "жов",
                                10: "лис",
                                11: "гру"
                            },
                            monthGenitive: {
                                0: "січня",
                                1: "лютого",
                                2: "березня",
                                3: "квітня",
                                4: "травня",
                                5: "червня",
                                6: "липня",
                                7: "серпня",
                                8: "вересня",
                                9: "жовтня",
                                10: "листопада",
                                11: "грудня"
                            },
                            dayAbbr: {0: "нд", 1: "пн", 2: "вт", 3: "ср", 4: "чт", 5: "пт", 6: "сб"},
                            dayName: {
                                0: "неділя",
                                1: "понеділок",
                                2: "вівторок",
                                3: "середа",
                                4: "четвер",
                                5: "п'ятниця",
                                6: "субота"
                            },
                            timeFormat: "%H:%M:%S",
                            dateFormat: "%d.%m.%Y",
                            fullDateFormat: "%a %e %b %X %Y",
                            amFormat: "",
                            pmFormat: "",
                            fullDateTimeFormat: "%a %e %b %Y %X %Z",
                            monthNominative: {
                                0: "січень",
                                1: "лютий",
                                2: "березень",
                                3: "квітень",
                                4: "травень",
                                5: "червень",
                                6: "липень",
                                7: "серпень",
                                8: "вересень",
                                9: "жовтень",
                                10: "листопад",
                                11: "грудень"
                            },
                            dmFormat: "dm",
                            twelveTimeFormat: ""
                        },
                        uz_UZ: {
                            monthAbbr: {
                                0: "yan",
                                1: "fev",
                                2: "mar",
                                3: "apr",
                                4: "may",
                                5: "iyn",
                                6: "iyl",
                                7: "avg",
                                8: "sen",
                                9: "okt",
                                10: "noy",
                                11: "dek"
                            },
                            monthGenitive: {
                                0: "yanvar",
                                1: "fevral",
                                2: "mart",
                                3: "aprel",
                                4: "may",
                                5: "iyun",
                                6: "iyul",
                                7: "avgust",
                                8: "sentabr",
                                9: "oktabr",
                                10: "noyabr",
                                11: "dekabr"
                            },
                            dayAbbr: {0: "yak", 1: "du", 2: "se", 3: "cho", 4: "pay", 5: "ju", 6: "sha"},
                            dayName: {
                                0: "yakshanba",
                                1: "dushanba",
                                2: "seshanba",
                                3: "chorshanba",
                                4: "payshanba",
                                5: "juma",
                                6: "shanba"
                            },
                            timeFormat: "%H:%M:%S",
                            dateFormat: "%d/%m/%Y",
                            fullDateFormat: "%T, %d %B, %Y yil, %A",
                            amFormat: "",
                            pmFormat: "",
                            fullDateTimeFormat: "%d %B, %Y yil, %A",
                            monthNominative: {
                                0: "yanvar",
                                1: "fevral",
                                2: "mart",
                                3: "aprel",
                                4: "may",
                                5: "iyun",
                                6: "iyul",
                                7: "avgust",
                                8: "sentabr",
                                9: "oktabr",
                                10: "noyabr",
                                11: "dekabr"
                            },
                            dmFormat: "dm",
                            twelveTimeFormat: ""
                        }
                    }
                };
                e({UnitsTransform: r, FormatDatetime: o})
            });
        }],
        [',q', function (ym) {
            ym.modules.define("yandex.geocodeProvider.metaOptions", ["map.metaOptions"], function (e, o) {
                o.set("geocodeProvider", "yandex#map"), e(!0)
            });
        }],
        ['_V', function (ym) {
            ym.modules.define("poi.fetcher", ["util.defineClass", "data.Manager", "yandex.searchProvider.search", "util.safeAccess", "util.array", "util.extend", "util.coordinates.toLatLong", "meta.internal", "error", "vow", "localization.common.current", "formatter", "util.coordinates.convert", "searchResult.transportDataProvider", "searchResult.util", "yandex.masstransitStopProvider", "util.coordinates.reverse"], function (e, t, r, n, i, o, a, s, u, c, g, p, l, d, f, m, h, v) {
                function y(e, t) {
                    var r = R(e, t);
                    return B[r] || (B[r] = P(e, t))
                }

                function R(e, t) {
                    return U(e.getProperties()) || e.getGeometry().coordinates.join(",") + "_" + t
                }

                function U(e) {
                    return i(e, "URIMetaData.URIs.0.uri")
                }

                function x(e) {
                    for (var t = i(e.getProperties(), "URIMetaData.URIs"), r = 0, n = t.length; r < n; r++) if (t[r].uri.indexOf("transit/stop") != -1) return !0;
                    return !1
                }

                function M(e) {
                    return e.properties
                }

                function P(e, t) {
                    var r = e.getProperties(), n = (i(r, "HotspotMetaData.tags"), U(r)),
                        o = s(e.getGeometry().coordinates);
                    return x(e) ? D(o, t, r, n).then(M) : n ? w(n).then(f.remoteExtendOrgWithTransport).then(M).fail(function () {
                        return O(o, t, r, n).then(M)
                    }) : O(o, t, r, n).then(f.remoteExtendWithTaxi).then(M)
                }

                function w(e) {
                    return n.search(null, a({uri: e, source: "poi"}, S)).then(function (t) {
                        var r = t.geoObjects.get(0);
                        return r ? (r.properties.set({
                            uri: e,
                            point: s(r.geometry.getCoordinates()).reverse()
                        }), m.isBusiness(r.properties) && j(r), r) : g.reject("Nothing found")
                    })
                }

                function D(e, t, r, n) {
                    var o = d(e, "latlong", ym.env.coordinatesOrder), a = f.requestMetroCoverage(o, t),
                        s = O(e, t, r, n), u = h.getStopByUri(n).then(void 0, function (e) {
                            return null
                        });
                    return g.all([s, u, a]).then(function (e) {
                        var t = e[0], r = e[1], n = e[2], o = i(r, "properties.StopMetaData");
                        return o ? f.extendWithStop(t, o, n && n.length > 0) : t
                    })
                }

                function O(e, t, o, s) {
                    return n.search(e.join(","), a({
                        source: "poi",
                        zoom: t,
                        boundedBy: [[e[0] - C, e[1] - C], [e[0] + C, e[1] + C]]
                    }, S)).then(function (t) {
                        var n = t.geoObjects.get(0), u = {uri: s, point: v(e), type: "poi"};
                        if (!n) return new r(a(u, o));
                        var c = n.properties, g = o.name, p = i(o, "HotspotMetaData.TagsMetaData.org_type");
                        return c.set(u), (g || p) && (c.set({
                            name: g || p,
                            address: c.get("name")
                        }), p && c.set("categoriesText", p)), n
                    })
                }

                function j(e) {
                    var t = e.properties, r = p.ppo.Card, n = t.get("rating.reviews", 0),
                        i = t.get("rating.ratings", 0);
                    t.set("loc", {
                        timeClosedUntil: r.timeClosedUntil.replace("%s", t.get("workingStatus.time", "")),
                        timeOpenUntil: r.timeOpenUntil.replace("%s", t.get("workingStatus.time", "")),
                        ratingReviews: l.numeral(n, r.ratingReviews),
                        ratingRatings: l.numeral(i, r.ratingRatings)
                    })
                }

                var C = .001, S = {origin: "jsapi2Poi", results: 1, pin: !0}, B = {};
                e({getProperties: y, searchByUri: w})
            });
        }],
        ['.b', function (ym) {
            ym.modules.define("searchResult.transportDataProvider", ["vow", "searchResult.util", "yandex.taxi.fetchRouteInfo", "yandex.taxi.constructLink", "yandex.timetableProvider", "util.coordinates.convert", "util.safeAccess", "localization.common.current", "yandex.coverage", "util.array", "localization.common.current", "util.extend", "meta.internal", "meta", "yandex.yandexMapUrlProvider"], function (e, t, r, n, o, a, i, p, u, s, d, l, c, m, g, S) {
                var f = {};
                f.requestTimetable = function (e) {
                    var t, n = e.geometry.getCoordinates(), o = i(n, ym.env.coordinatesOrder, "latlong"),
                        p = {lang: ym.env.lang};
                    return t = r.isAirport(e.properties) ? a.getNearestAirport(o[0], o[1], p) : r.isRailwayTerminal(e.properties) ? a.getNearestTrainStation(o[0], o[1], p) : a.getNearestTrainStop(o[0], o[1], p), t.then(void 0, function (e) {
                        return null
                    })
                }, f.requestMetroCoverage = function (e, t) {
                    var r = i(e, ym.env.coordinatesOrder, "longlat");
                    return s.getLayersInfo(["metro"], r, t).then(void 0, function (e) {
                        return null
                    })
                }, f.remoteExtendWithTimetable = function (e) {
                    return f.canShowTimetable() && a.isLangAcceptable(ym.env.lang) ? f.requestTimetable(e).then(function (t) {
                        if (t) {
                            var r = a.getStationUrl(t);
                            e.properties.set({timetableStationUrl: S.addFromParamToStringUrl(r)})
                        }
                        return e
                    }) : t.resolve(e)
                }, f.remoteExtendWithTaxi = function (e) {
                    var r = e.geometry.getCoordinates();
                    i(r, ym.env.coordinatesOrder, "longlat");
                    return m.suppressTaxiDistribution ? t.resolve(e) : n(r).then(function (t) {
                        var n = p(t, "options"), a = n && t.options[0] ? t.options[0] : null;
                        return a && (a.currency = t.currency, a.openTaxiAppUrl = o(void 0, r), e.properties.set({taxiInfo: a})), e
                    }, function (t) {
                        return e
                    })
                }, f.remoteExtendWithTaxiAndTimetable = function (e) {
                    var r = f.remoteExtendWithTimetable(e), n = f.remoteExtendWithTaxi(e);
                    return t.all([r, n]).then(function (t) {
                        return e
                    })
                }, f.remoteExtendOrgWithTransport = function (e) {
                    return r.isAirportOrRailwayTerminal(e.properties) ? f.remoteExtendWithTaxiAndTimetable(e) : r.isPoiOrBusinessButNotTransport(e.properties) ? f.remoteExtendWithTaxi(e) : t.resolve(e)
                }, f.remoteExtendSearchResultWithStop = function (e, n) {
                    if (r.isSearchKindMetro(e.properties)) {
                        var o = e.geometry.getCoordinates();
                        return f.requestMetroCoverage(o, n).then(function (t) {
                            return f.extendSearchResultWithStop(e, t && t.length > 0)
                        })
                    }
                    return r.isSearchKindRailway(e.properties) ? f.remoteExtendWithTimetable(e).then(function (e) {
                        return f.extendSearchResultWithStop(e)
                    }) : t.resolve(e)
                }, f.remoteExtendSearchResultWithTransport = function (e, n) {
                    var o = e.properties;
                    return r.isStop(o) ? t.resolve(e) : r.isSearchKindMetro(o) || r.isSearchKindRailway(o) ? f.remoteExtendSearchResultWithStop(e, n) : f.remoteExtendOrgWithTransport(e)
                }, f.extendSearchResultWithStop = function (e, t) {
                    if (r.isSearchKindMetro(e.properties) || r.isSearchKindRailway(e.properties)) {
                        var n = e.properties.get("name"), o = {};
                        if (r.isSearchKindMetro(e.properties)) {
                            var a = f._getUndergroundLineMetaFromSearchData(e);
                            o = f.createUndergroundStopData(void 0, n, !1, t, a.name, a.color)
                        } else o = f.createStopData(void 0, "railway", n);
                        return e.properties.set(o), e = f._filterSameUndergroundStops(e)
                    }
                    return e
                }, f.extendWithStop = function (e, t, n) {
                    var o = {}, a = t.name || e.properties.get("name"), i = "underground" == t.type,
                        u = Boolean(t.id.match(/^exit/)), s = t.id, d = f._getMtrStopNameLocalized(a, t.type, i && u);
                    if (i) {
                        var l = t.Transport[0];
                        o = f.createUndergroundStopData(s, d, u, n, p(l, "name"), p(l, "Style.color"))
                    } else {
                        if ("railway" == t.type && f.canShowTimetable()) {
                            var c = r.getMtrTimetableUrl(t);
                            e.properties.set({timetableStationUrl: S.addFromParamToStringUrl(c)})
                        }
                        o = f.createStopData(s, t.type, d)
                    }
                    return e.properties.set(o), e = f._filterSameUndergroundStops(e)
                }, f.createStopData = function (e, t, r, n) {
                    var o = {type: "stop", mtrData: {id: e, type: t, title: r}};
                    return o.mtrData = c(o.mtrData, n), o
                }, f.createUndergroundStopData = function (e, t, r, n, o, a) {
                    return f.createStopData(e, "underground", t, {
                        isUndergroundExit: r,
                        hasMetroAppSupport: n,
                        undergroundLineMeta: {name: o, color: a}
                    })
                }, f.canShowTimetable = function () {
                    return "RU" == g.countryCode || "UA" == g.countryCode
                }, f._filterSameUndergroundStops = function (e) {
                    if ("underground" == e.properties.get("mtrData.type")) {
                        var t = f._getUniqUndergroundStops(e);
                        e.properties.set({stops: t})
                    }
                    return e
                }, f._getUndergroundLineMetaFromSearchData = function (e) {
                    var t = e.properties.get("responseMetaData.Address.Components", []), r = d.find(t, function (e) {
                        return "route" == e.kind
                    }), n = r ? r.name : null, o = e.properties.get("stops", []), a = d.find(o, function (e) {
                        return 0 == parseInt(e.distance)
                    }), i = a ? a.color : null;
                    return {name: n, color: i}
                }, f._getMtrStopNameLocalized = function (e, t, r) {
                    return f._getMtrStopNameTemplate(t, r).replace("%name", e)
                }, f._STOP_NAME_PREFIX = {
                    underground: l.ppo.Card.stopTypeMetro,
                    undergroundExit: l.ppo.Card.stopTypeMetroExit,
                    railway: l.ppo.Card.stopTypeRailway,
                    urban: l.ppo.Card.stopTypeUrban
                }, f._getMtrStopNameTemplate = function (e, t) {
                    return t ? f._STOP_NAME_PREFIX.undergroundExit : f._STOP_NAME_PREFIX[e]
                }, f._getUniqUndergroundStops = function (e) {
                    var t = e.properties.get("stops"), r = e.properties.get("mtrData.undergroundLineMeta", {}),
                        n = e.properties.get("name"), o = r.color;
                    return t && n && o ? d.filter(t, function (e) {
                        return 0 != parseInt(e.distance) && !(e.name.toLowerCase() == n.toLowerCase() && e.color == o)
                    }) : t
                }, e(f)
            });
        }],
        [':v', function (ym) {
            ym.modules.define("yandex.state.associate", ["yandex.State", "util.Associate"], function (e, t, n) {
                var a = new n(function (e) {
                    return new t(e)
                });
                e({
                    get: function (e) {
                        if (ym.env.debug && !e) throw new Error("yandex.state.associate: передан пустой указатель на карту");
                        return a.get(e)
                    }
                })
            });
        }],
        ['2A', function (ym) {
            var images = ym.modules.importImages({geolocationIcon: {src: "geolocation/YaRu.svg"}});
            ym.modules.define("geolocationPreset.standard.ru", ["option.presetStorage", "layout.Image"], function (o, e, a) {
                e.add("islands#geolocationIcon", {
                    iconLayout: a,
                    iconImageHref: images.get("geolocationIcon"),
                    iconImageSize: [22, 22],
                    iconImageOffset: [-11, -11],
                    cursor: "inherit"
                }), o(!0)
            });
        }],
        ['0-', function (ym) {
            ym.modules.define("component.EventFreezer", ["util.defineClass"], function (e, t) {
                function n(e, t) {
                    this._frozen = !1, this._changed = !1, this._eventCallback = e, this._context = t, this._eventData = null
                }

                t(n, {
                    freeze: function () {
                        this._frozen = !0
                    }, unfreeze: function () {
                        this._frozen = !1, this._changed && (this._changed = !1, this._fire())
                    }, isFrozen: function () {
                        return this._frozen
                    }, fire: function (e, t, n) {
                        if ("undefined" != typeof e) {
                            this._eventData = this._eventData || {};
                            var i = "old" + e;
                            "undefined" == typeof this._eventData[i] && (this._eventData[i] = t), this._eventData["new" + e] = n
                        }
                        this._frozen ? this._changed = !0 : this._fire()
                    }, _fire: function () {
                        if (this._eventCallback) {
                            var e = this._eventData;
                            this._eventData = null, this._eventCallback.call(this._context, e)
                        }
                    }
                }), e(n)
            });
        }],
        ['2P', function (ym) {
            ym.modules.define("geometry.component.commonMethods.circle", [], function (t) {
                t({
                    contains: function (t, n, o) {
                        return !(!t || !n) && Math.sqrt(Math.pow(o[0] - t[0], 2) + Math.pow(o[1] - t[1], 2)) < n
                    }, getClosest: function (t, n, o) {
                        if (!t || !n) return null;
                        var e = [o[0] - t[0], o[1] - t[1]], i = Math.sqrt(e[0] * e[0] + e[1] * e[1]);
                        return 0 == i ? {
                            position: [t[0], t[1] + n],
                            distance: n
                        } : {position: [t[0] + e[0] * n / i, t[1] + e[1] * n / i], distance: Math.abs(i - n)}
                    }, calculateBounds: function (t, n) {
                        return t ? [[t[0] - n, t[1] - n], [t[0] + n, t[1] + n]] : null
                    }
                })
            });
        }],
        [')n', function (ym) {
            ym.modules.define("util.coordinates.encode", ["util.base64"], function (n, r) {
                function t(n) {
                    for (var r = [], t = u(n), e = 0, a = t.length; e < a; e++) r = r.concat(o(t[e][0]), o(t[e][1]));
                    return r
                }

                function o(n) {
                    for (var r = [], t = 0; t < 4; t++) r[t] = 255 & n, n >>= 8;
                    return r
                }

                function u(n) {
                    for (var r = [], t = 0, o = n.length, u = [0, 0], a = [0, 0]; t < o; t++) {
                        var c = [Math.round((n[t][0] - u[0]) * e), Math.round((n[t][1] - u[1]) * e)],
                            d = [c[0] / e, c[1] / e], f = [d[0] + a[0], d[1] + a[1]],
                            i = [n[t][0] - f[0], n[t][1] - f[1]], h = [Math.round(i[0] * e), Math.round(i[1] * e)];
                        (h[0] || h[t]) && (c[0] += h[0], c[1] += h[1], d = [c[0] / e, c[1] / e], f = [d[0] + a[0], d[1] + a[1]]), r.push(c), u = n[t], a = f
                    }
                    return r
                }

                var e = 1e6, a = function (n) {
                    return r.encode(t(n), !0)
                };
                n(a)
            });
        }],
        ['2O', function (ym) {
            ym.modules.define("geometry.component.findClosestPathPosition", ["util.vector"], function (t, n) {
                var e = n.length2;
                t(function (t, n) {
                    if (!t.length) return null;
                    for (var o, i, r = t[0], c = [n[0] - r[0], n[1] - r[1]], s = e(c), d = {
                        position: r,
                        vector: c,
                        closestPointIndex: 0,
                        distance: s
                    }, v = 1, x = t.length; v < x; v++) if (i = t[v], r[0] != i[0] || r[1] != i[1]) {
                        var P, a = [i[0] - r[0], i[1] - r[1]], l = [n[0] - r[0], n[1] - r[1]],
                            I = (a[0] * l[0] + a[1] * l[1]) / (a[0] * a[0] + a[1] * a[1]);
                        I < 0 ? P = {
                            position: r,
                            vector: [r[0] - n[0], r[1] - n[1]],
                            closestPointIndex: v - 1
                        } : I > 1 ? P = {
                            position: i,
                            vector: [i[0] - n[0], i[1] - n[1]],
                            closestPointIndex: v
                        } : (o = [a[0] * I - l[0], a[1] * I - l[1]], P = {
                            vector: o,
                            prevPointIndex: v - 1,
                            nextPointIndex: v
                        }), P.distance = P.vector[0] * P.vector[0] + P.vector[1] * P.vector[1], P.distance < s && (s = P.distance, d = P), r = i
                    }
                    if (d.nextPointIndex) {
                        o = d.vector, r = t[d.prevPointIndex], i = t[d.nextPointIndex];
                        var f = [n[0] + o[0], n[1] + o[1]], p = [f[0] - r[0], f[1] - r[1]],
                            u = [f[0] - i[0], f[1] - i[1]];
                        d.position = f, d.closestPointIndex = e(p) < e(u) ? d.prevPointIndex : d.nextPointIndex
                    }
                    return d.distance = Math.sqrt(d.distance), d
                })
            });
        }],
        ['2N', function (ym) {
            ym.modules.define("geometry.component.closedPathDecode", ["util.coordinates.decode", "util.math.areEqual"], function (e, o, t) {
                var n = 1e6, c = 1 / n + 1e-12;
                e(function (e) {
                    var n = o(e), a = n.length - 1;
                    return a < 0 ? [] : (t(n[0], n[a], c) && (n[a] = n[0].slice()), n)
                })
            });
        }],
        ['2T', function (ym) {
            ym.modules.define("geometry.component.CoordPath", [], function (t) {
                var n = function (t, n, s) {
                    this._coordinates = t, this._bounds = null, this._changeCallback = n, this._boundsCallback = s
                };
                n.prototype = {
                    getBounds: function () {
                        return this._bounds || (this._bounds = this._boundsCallback.callback.call(this._boundsCallback.context, this._coordinates))
                    }, set: function (t, n) {
                        var s = this._coordinates;
                        this._coordinates = this._coordinates.slice(), this._coordinates[t] = n, this._bounds = null, this._changeCallback.callback.call(this._changeCallback.context, s, this._coordinates)
                    }, get: function (t) {
                        return this._coordinates[t]
                    }, splice: function (t, n) {
                        var s = this._coordinates;
                        this._coordinates = this._coordinates.slice();
                        var o = arguments.length > 2 ? this._coordinates.splice.apply(this._coordinates, arguments) : this._coordinates.splice(t, n);
                        return this._bounds = null, this._changeCallback.callback.call(this._changeCallback.context, s, this._coordinates), o
                    }, setCoordinates: function (t) {
                        var n = this._coordinates;
                        this._coordinates = t, this._bounds = null, this._changeCallback.callback.call(this._changeCallback.context, n, this._coordinates)
                    }, getCoordinates: function () {
                        return this._coordinates
                    }, getLength: function () {
                        return this._coordinates.length
                    }
                }, t(n)
            });
        }],
        ['2M', function (ym) {
            ym.modules.define("geometry.component.ChildPath", ["util.array"], function (t, e) {
                function i(t, i, l) {
                    if (e.indexOf(this._changeEvents, i) != -1) {
                        var n = l.get("target"), h = e.indexOf(this._children, n);
                        this._changeCallback.callback.call(this._changeCallback.context, n, h)
                    }
                }

                function l(t, e) {
                    t.callback && t.callback.call(t.context, e)
                }

                var n = function (t, e, l, n, h) {
                    this._children = t, this._setupChildren(t), this._childClass = e, this._changeEvents = l, this._changeCallback = n, this._eventCallbacks = h, this._childEventController = {onAfterEventFiring: i.bind(this)}
                };
                n.prototype = {
                    setChild: function (t, e) {
                        this._children[t] && this._clearChild(this._children[t]), this._children[t] = e, e && this._setupChild(e)
                    }, getChild: function (t) {
                        return this._children[t]
                    }, createChild: function (t, e) {
                        var i = null;
                        return e && (i = new this._childClass(e), this._setupChild(i)), this._children[t] = i
                    }, splice: function (t, e) {
                        var i;
                        return arguments.length > 2 ? (this._setupChildren(Array.prototype.slice.call(arguments, 2)), i = this._children.splice.apply(this._children, arguments)) : i = this._children.splice(t, e), this._clearChildren(i), i
                    }, setChildren: function (t) {
                        var e = this._children;
                        this._children = [], this._clearChildren(e), this._children = t, this._setupChildren(t)
                    }, _setupChild: function (t) {
                        t.events && t.events.addController(this._childEventController), this._eventCallbacks && this._eventCallbacks.onChildSetup && l(this._eventCallbacks.onChildSetup, t)
                    }, _clearChild: function (t) {
                        t.events && t.events.removeController(this._childEventController), this._eventCallbacks && this._eventCallbacks.onChildClear && l(this._eventCallbacks.onChildClear, t)
                    }, _setupChildren: function (t) {
                        for (var e = 0, i = t.length; e < i; e++) t[e] && this._setupChild(t[e])
                    }, _clearChildren: function (t) {
                        for (var e = 0, i = t.length; e < i; e++) t[e] && this._clearChild(t[e])
                    }, each: function (t, i) {
                        e.each(this._children, t, i)
                    }, getLength: function () {
                        return this._children.length
                    }
                }, t(n)
            });
        }],
        ['2U', function (ym) {
            ym.modules.define("geometry.component.FillRule", [], function (l) {
                var e = ["evenOdd", "nonZero"], i = function (l, i) {
                    if (this._fillRule = l || e[0], ym.env.debug) {
                        for (var t, n = 0, o = e.length; n < o; n++) if (this._fillRule == e[n]) {
                            t = !0;
                            break
                        }
                        if (!t) throw new Error("geometry.component.FillRule: неверное значение параметра fillRule " + this._fillRule)
                    }
                    this._changeCallback = i
                };
                i.prototype = {
                    setFillRule: function (l) {
                        if (ym.env.debug) {
                            for (var i, t = 0, n = e.length; t < n; t++) if (l == e[t]) {
                                i = !0;
                                break
                            }
                            if (!i) throw new Error("geometry.component.FillRule.setFillRule: неверное значение параметра fillRule " + l)
                        }
                        var o = this._fillRule;
                        this._fillRule = l, this._changeCallback.callback.call(this._changeCallback.context, o, this._fillRule)
                    }, getFillRule: function () {
                        return this._fillRule
                    }
                }, l(i)
            });
        }],
        [')m', function (ym) {
            ym.modules.define("util.coordinates.decode", ["util.base64"], function (e, r) {
                var o = 1e6, t = function (e) {
                    for (var t = r.decode(e, !0), d = t.length, a = 0, n = [0, 0], u = []; a < d;) {
                        for (var c = 0, i = 0, s = 0, f = t.substr(a, 8); s < 4;) c |= f.charCodeAt(s) << 8 * s, i |= f.charCodeAt(s + 4) << 8 * s, s++;
                        var h = [c / o, i / o], l = [h[0] + n[0], h[1] + n[1]];
                        n = l, u.push(l), a += 8
                    }
                    return u
                };
                e(t)
            });
        }],
        ['2R', function (ym) {
            ym.modules.define("geometry.component.commonMethods.polygon", ["geometry.component.pointInPolygon", "geometry.component.findClosestPathPosition", "util.pixelBounds"], function (n, o, t, e) {
                n({
                    contains: function (n, t, e) {
                        return o(t, n, e)
                    }, getClosest: function (n, o) {
                        for (var e = null, r = 0, i = n.length; r < i; r++) {
                            var l = t(n[r], o);
                            l && (!e || l.distance < e.distance) && (e = l, e.pathIndex = r)
                        }
                        return e
                    }, calculateBounds: function (n) {
                        for (var o = null, t = 0, r = n.length; t < r; t++) {
                            var i = e.fromPoints(n[t]);
                            i && (o = o ? e.fromBounds([o, i]) : i)
                        }
                        return o
                    }
                })
            });
        }],
        ['2S', function (ym) {
            ym.modules.define("geometry.component.commonMethods.rectangle", ["util.pixelBounds", "geometry.component.findClosestPathPosition"], function (n, t, o) {
                n({
                    contains: function (n, o) {
                        return t.containsPoint(this.calculateBounds(n), o)
                    }, getClosest: function (n, t) {
                        var e = this.calculateBounds(n), i = [e[0], [e[1][0], e[0][1]], e[1], [e[0][0], e[1][1]], e[0]],
                            s = o(i, t);
                        return {position: s.position, distance: s.distance}
                    }, calculateBounds: function (n) {
                        return t.fromPoints(n || [])
                    }
                })
            });
        }],
        ['2_', function (ym) {
            ym.modules.define("geometry.component.renderFlowManager", ["util.id", "option.Manager", "event.Manager", "util.WeakMap"], function (e, t, n, r, o) {
                var a = {}, i = new o, g = {
                    events: new r({context: this}), add: function (e, t, n, r) {
                        var o = {
                            geometry: e,
                            pixelGeometryChangeCallback: r,
                            ignoreCacheFrom: 0,
                            optionsByStage: {},
                            observingOptions: {},
                            stages: [],
                            cache: [],
                            removed: !1
                        };
                        i.set(e, o), e.events.add("optionschange", g._onOptionsChange);
                        for (var a = 0, s = t.length; a < s; a++) {
                            var c = t[a], p = c.options, v = c.event;
                            if (o.stages.push(c.stage), p) {
                                for (var l = 0, f = p.length; l < f; l++) {
                                    var u = p[l];
                                    g._parseOption(o, u, n[u], a)
                                }
                                o.optionsByStage[a] = p
                            }
                            v && g._setupEvent(o, v, a)
                        }
                        g._run(o)
                    }, clear: function (e) {
                        var t = i.get(e);
                        t && g._setIgnoreCacheFrom(t, 0)
                    }, fetchStageCache: function (e, t) {
                        var n = i.get(e);
                        if (n) for (var r = n.cache, o = n.ignoreCacheFrom, a = n.stages, g = 0, s = a.length; g < s; g++) if (g < o) {
                            var c = n.optionsByStage[g];
                            if (c) for (var p = 0, v = c.length; p < v; p++) if (c[p] == t) return r[g]
                        }
                        return null
                    }, remove: function (e, t) {
                        var n = i.get(e);
                        n.removed = !0, i.remove(e), e.events.remove("optionschange", g._onOptionsChange);
                        for (var r = 0, o = t.length; r < o; r++) {
                            var a = t[r].event;
                            a && g._clearEvent(n, a)
                        }
                    }, getPixelGeometry: function (e, t) {
                        var r = i.get(e), o = r ? r.pixelGeometry : null;
                        return "object" == typeof t && (r.tmpOptions = new n(t, r.geometry.options), g._useChangedOptions(e, r.tmpOptions) && (o = g._run(r)), r.tmpOptions.setParent(null), r.tmpOptions = null), o
                    }, _onOptionsChange: function (e) {
                        var t = e.get("target");
                        g._useChangedOptions(t) && g._runAndFire(i.get(t))
                    }, _useChangedOptions: function (e, t) {
                        t = t || e.options;
                        var n = i.get(e), r = n.observingOptions, o = !1;
                        for (var a in r) if (r.hasOwnProperty(a)) {
                            var s = r[a], c = t.get(a, s.defaultValue);
                            s.cached != c && (n.tmpOptions || (s.cached = c), g._setIgnoreCacheFrom(n, s.affectsStage), o = !0)
                        }
                        return o
                    }, _parseOption: function (e, t, n, r) {
                        e.observingOptions[t] ? e.observingOptions[t].affectsStage > r && (e.observingOptions[t].affectsStage = r) : e.observingOptions[t] = {
                            cached: e.geometry.options.get(t, n),
                            defaultValue: n,
                            affectsStage: r
                        }
                    }, _run: function (e) {
                        for (var t = e.ignoreCacheFrom, n = e.stages, r = e.geometry, o = e.cache, a = [], i = 0, s = n.length; i < s; i++) a[i] = o[i] && i < t ? o[i] : n[i].call(r, a[i - 1], g._getAffectingOptions(e, i), e.tmpOptions);
                        return e.tmpOptions || (e.cache = a, e.pixelGeometry = a[s - 1]), e.ignoreCacheFrom = s, a[i - 1]
                    }, _setupEvent: function (e, n, r) {
                        var o = "map" == n.target ? e.geometry.getMap() : e.geometry, i = n.event,
                            s = {callback: n.callback, geometry: e.geometry, phase: r}, c = t.get(o) + i;
                        a[c] ? a[c].push(s) : (a[c] = [s], o.events.add(i, g._eventHandler, this))
                    }, _clearEvent: function (e, n) {
                        var r = "map" == n.target ? e.geometry.getMap() : e.geometry, o = t.get(r) + n.event, i = a[o],
                            s = i.length;
                        if (i) {
                            for (var c = -1, p = 0; p < s; p++) {
                                var v = i[p];
                                if (v.geometry == e.geometry) {
                                    c = p;
                                    break
                                }
                            }
                            c > -1 && (1 == s ? (i.pop(), r.events.remove(n.event, g._eventHandler, this), delete a[o]) : i.splice(c, 1))
                        }
                    }, _eventHandler: function (e) {
                        var n, r, o = e.get("target"), s = t.get(o) + e.get("type"), c = a[s], p = [];
                        if (c) for (n = 0, r = c.length; n < r; n++) {
                            var v = c[n], l = v.geometry, f = i.get(l), u = v.phase;
                            f.updating || v.callback && !v.callback.call(l, e, f.cache[u - 1], g._getAffectingOptions(f, u)) || (g._setIgnoreCacheFrom(f, u), f.updating || (f.updating = 1, p.push(l)))
                        }
                        this.calculate(p, e.get("type"))
                    }, calculate: function (e, t) {
                        if (e.length) {
                            this.events.fire("renderstart", {targets: e, trigger: t});
                            for (var n = 0, r = e.length; n < r; ++n) {
                                var o = i.get(e[n]);
                                o.removed || (o.updating = 0, g._runAndFire(o))
                            }
                            this.events.fire("renderend", {targets: e, trigger: t})
                        }
                    }, _setIgnoreCacheFrom: function (e, t) {
                        e.ignoreCacheFrom > t && (e.ignoreCacheFrom = t)
                    }, _runAndFire: function (e) {
                        g._run(e), e.pixelGeometryChangeCallback.call(e.geometry, e.pixelGeometry)
                    }, _getAffectingOptions: function (e, t) {
                        var n = {}, r = e.optionsByStage[t];
                        if (r) for (var o = 0, a = r.length; o < a; o++) {
                            var i = r[o];
                            n[i] = e.tmpOptions ? e.tmpOptions.get(i, e.observingOptions[i].defaultValue) : e.observingOptions[i].cached
                        }
                        return n
                    }
                };
                e(g)
            });
        }],
        ['2W', function (ym) {
            ym.modules.define("geometry.component.pixelGeometryGeodesic.circle", ["geometry.component.pixelGeometryGeodesic.storage", "geometry.pixel.Polygon", "geometry.component.ShortestPath"], function (e, o, t, r) {
                function n(e, o, n) {
                    var c, i, l = [], m = n.projection.getCoordSystem(), s = 2 * Math.PI, a = Math.PI / 40;
                    if (ym.env.debug && "function" != typeof m.solveDirectProblem) throw new Error("geometry.component.pixelGeometryGeodesic.circle: Отсутствует обязательный метод solveDirectProblem у координатной системы.");
                    for (var y = 0; y <= s; y += a) i = "latlong" == ym.env.coordinatesOrder ? [Math.cos(y), Math.sin(y)] : [Math.sin(y), Math.cos(y)], c = m.solveDirectProblem(e, i, o), l.push(n.projection.toGlobalPixels(c.endPoint, 0));
                    return l = (new r).calculate(l, n.projection.isCycled()), new t([l], "nonZero")
                }

                o.add("Circle", n), e(n)
            });
        }],
        ['2$', function (ym) {
            ym.modules.define("geometry.component.renderFlow.stageShift", ["geometry.component.PixelGeometryShift"], function (t, i) {
                function e(t, e) {
                    return this._shiftCalculator = this._shiftCalculator || new i, this._shiftCalculator.calculateShift(t, e, this.getMap())
                }

                t({
                    onActionEnd: function (t, i, n) {
                        if ("static" == n.pixelRendering) return !1;
                        var h = this._tmpShift = e.call(this, i, n.projection);
                        return h[0] != this._lastShift[0] || h[1] != this._lastShift[1]
                    }, apply: function (t, i, n) {
                        var h = [0, 0], o = t;
                        if ("static" != i.pixelRendering && (h = this._tmpShift, h && !n || (h = e.call(this, t, i.projection)), this._tmpShift = null, h[0] || h[1])) {
                            var s = Math.pow(2, 8 + this.getMap().getZoom());
                            o = t.shift([h[0] * s, h[1] * s])
                        }
                        return n || (this._lastShift = h), o
                    }
                })
            });
        }],
        ['2(', function (ym) {
            ym.modules.define("geometry.defaultOptions", ["projection.wgs84Mercator"], function (e, o) {
                e({
                    projection: o,
                    coordRendering: "shortestPath",
                    geodesic: !1,
                    simplification: !0,
                    cureSelfIntersections: !0,
                    pixelRendering: "jumpy"
                })
            });
        }],
        ['2L', function (ym) {
            ym.modules.define("geometry.component.boundsFromPixels", ["util.bounds"], function (e, o) {
                function n(e) {
                    var n = e.getPixelGeometry({simplification: !1, pixelRendering: "static"});
                    if (n) {
                        var t = n.getBounds();
                        return t ? o.fromGlobalPixelBounds(t, e.getMap().getZoom(), e.options.get("projection")) : null
                    }
                    throw new Error("geometry.component.getBoundsFromPixels: Расчет границ не возможен без добавления на карту.")
                }

                e({get: n})
            });
        }],
        [')-', function (ym) {
            ym.modules.define("util.getPixelRadius", ["geometry.component.ShortestPath"], function (e, t) {
                e(function (e, o, l, n) {
                    var i = "latlong" == ym.env.coordinatesOrder ? [0, 1] : [1, 0],
                        a = l.getCoordSystem().solveDirectProblem(e, i, o).endPoint,
                        r = (new t).calculate([l.toGlobalPixels(e, n), l.toGlobalPixels(a, n)], l.isCycled());
                    return Math.abs(r[0][0] - r[1][0])
                })
            });
        }],
        ['2V', function (ym) {
            ym.modules.define("geometry.component.pixelContains", [], function (o) {
                o(function (o, e) {
                    var t = o.getMap();
                    if ("undefined" == typeof t) throw new Error("geometry.component.pixelContains: Для рассчета вхождения точки геометрия должна быть добавлена на карту.");
                    for (var n = o.getPixelGeometry({
                        simplification: !1,
                        pixelRendering: "static",
                        geodesic: o.options.get("geodesic")
                    }), i = 256 * Math.pow(2, t.getZoom()), r = n.getBounds(), a = [[Math.floor(r[0][0] / i), Math.floor(r[0][1] / i)], [Math.floor(r[1][0] / i), Math.floor(r[1][1] / i)]], f = o.options.get("projection"), l = f.isCycled(), s = l[0] ? 1 : 0, g = l[1] ? 1 : 0, p = f.toGlobalPixels(e, t.getZoom()), c = a[0][0]; c <= a[1][0]; c++) for (var m = a[0][1]; m <= a[1][1]; m++) if (n.contains([p[0] + s * c * i, p[1] + g * m * i])) return !0;
                    return !1
                })
            });
        }],
        [',e', function (ym) {
            ym.modules.define("util.matrix.2d", ["util.matrix.lineStorage"], function (n, t) {
                var r = {
                    create: function () {
                        return new t(9)
                    }, clone: function (n, r) {
                        return n = n || new t(9), n[0] = r[0], n[1] = r[1], n[2] = r[2], n[3] = r[3], n[4] = r[4], n[5] = r[5], n[6] = r[6], n[7] = r[7], n[8] = r[8], n
                    }, identity: function (n) {
                        return n = n || r.create(), n[0] = 1, n[1] = 0, n[2] = 0, n[3] = 0, n[4] = 1, n[5] = 0, n[6] = 0, n[7] = 0, n[8] = 1, n
                    }, transpose: function (n, t) {
                        if (n === t) {
                            var r = t[1], e = t[2], u = t[5];
                            n[1] = t[3], n[2] = t[6], n[3] = r, n[5] = t[7], n[6] = e, n[7] = u
                        } else n[0] = t[0], n[1] = t[3], n[2] = t[6], n[3] = t[1], n[4] = t[4], n[5] = t[7], n[6] = t[2], n[7] = t[5], n[8] = t[8];
                        return n
                    }, invert: function (n, t) {
                        var r = t[0], e = t[1], u = t[2], i = t[3], a = t[4], o = t[5], c = t[6], f = t[7], l = t[8],
                            v = l * a - o * f, s = -l * i + o * c, d = f * i - a * c, m = r * v + e * s + u * d;
                        return m ? (m = 1 / m, n[0] = v * m, n[1] = (-l * e + u * f) * m, n[2] = (o * e - u * a) * m, n[3] = s * m, n[4] = (l * r - u * c) * m, n[5] = (-o * r + u * i) * m, n[6] = d * m, n[7] = (-f * r + e * c) * m, n[8] = (a * r - e * i) * m, n) : null
                    }, adjoint: function (n, t) {
                        var r = t[0], e = t[1], u = t[2], i = t[3], a = t[4], o = t[5], c = t[6], f = t[7], l = t[8];
                        return n[0] = a * l - o * f, n[1] = u * f - e * l, n[2] = e * o - u * a, n[3] = o * c - i * l, n[4] = r * l - u * c, n[5] = u * i - r * o, n[6] = i * f - a * c, n[7] = e * c - r * f, n[8] = r * a - e * i, n
                    }, determinant: function (n) {
                        var t = n[0], r = n[1], e = n[2], u = n[3], i = n[4], a = n[5], o = n[6], c = n[7], f = n[8];
                        return t * (f * i - a * c) + r * (-f * u + a * o) + e * (c * u - i * o)
                    }, multiply: function (n, t, r) {
                        var e = t[0], u = t[1], i = t[2], a = t[3], o = t[4], c = t[5], f = t[6], l = t[7], v = t[8],
                            s = r[0], d = r[1], m = r[2], p = r[3], y = r[4], h = r[5], g = r[6], w = r[7], x = r[8];
                        return n[0] = s * e + d * a + m * f, n[1] = s * u + d * o + m * l, n[2] = s * i + d * c + m * v, n[3] = p * e + y * a + h * f, n[4] = p * u + y * o + h * l, n[5] = p * i + y * c + h * v, n[6] = g * e + w * a + x * f, n[7] = g * u + w * o + x * l, n[8] = g * i + w * c + x * v, n
                    }, translate: function (n, t, r) {
                        var e = t[0], u = t[1], i = t[2], a = t[3], o = t[4], c = t[5], f = t[6], l = t[7], v = t[8],
                            s = r[0], d = r[1];
                        return n[0] = e, n[1] = u, n[2] = i, n[3] = a, n[4] = o, n[5] = c, n[6] = s * e + d * a + f, n[7] = s * u + d * o + l, n[8] = s * i + d * c + v, n
                    }, rotate: function (n, t, r, e) {
                        var u = t[0], i = t[1], a = t[2], o = t[3], c = t[4], f = t[5], l = t[6], v = t[7], s = t[8],
                            d = Math.sin(r) * (e ? -1 : 1), m = Math.cos(r);
                        return n[0] = m * u + d * o, n[1] = m * i + d * c, n[2] = m * a + d * f, n[3] = m * o - d * u, n[4] = m * c - d * i, n[5] = m * f - d * a, n[6] = l, n[7] = v, n[8] = s, n
                    }, scale: function (n, t, r) {
                        var e = r[0], u = r[1];
                        return n[0] = e * t[0], n[1] = e * t[1], n[2] = e * t[2], n[3] = u * t[3], n[4] = u * t[4], n[5] = u * t[5], n[6] = t[6], n[7] = t[7], n[8] = t[8], n
                    }, applyToPoint: function (n, t, r) {
                        var e = t[0], u = t[1];
                        return n[0] = r[0] * e + r[3] * u + r[6], n[1] = r[1] * e + r[4] * u + r[7], n
                    }, applyToPoints: function (n, t, r) {
                        for (var n = n || [], e = 0, u = t.length; e < u; ++e) {
                            n[e] = n[e] || [0, 0];
                            var i = t[e][0], a = t[e][1];
                            n[e][0] = r[0] * i + r[3] * a + r[6], n[e][1] = r[1] * i + r[4] * a + r[7]
                        }
                        return n
                    }
                };
                n(r)
            });
        }],
        ['2I', function (ym) {
            ym.modules.define("geometry.serializer", ["util.Storage"], function (e, r, i, t, n, o, a, y, l, s) {
                var g = new r;
                g.deserialize = function (e) {
                    var r = this.get(e.type);
                    if (ym.env.debug && !r) throw new Error("geometry.serializer.deserialize: неизвестный тип геометрии " + e.type);
                    return r.deserialize(e)
                }, g.applyTo = function (e, r) {
                    var i = this.get(r.type);
                    if (ym.env.debug && !i) throw new Error("geometry.serializer.applyTo: неизвестный тип геометрии " + r.type);
                    return i.applyTo(e, r)
                }, g.serialize = function (e) {
                    var r = this.get(e.getType());
                    if (ym.env.debug && !r) throw new Error("geometry.serializer.serialize: неизвестный тип геометрии " + e.getType());
                    return r.serialize(e)
                }, e(g)
            });
        }],
        ['2-', function (ym) {
            ym.modules.define("geometry.component.renderFlow.stageSimplification", ["geometry.component.pixelGeometrySimplification.storage"], function (e, i) {
                function t(e, t) {
                    if (!t.simplification) return n;
                    if (!e._simplificator && (e._simplificator = i.get(e.getType()), ym.env.debug && !e._simplificator)) throw new Error("geometry.component.renderFlow.stageSimplification: Не найден симплификатор для геометрии " + e.getType());
                    return e._simplificator
                }

                var r = {
                    prepare: function (e, i) {
                        return t(e, i).prepare(e, i)
                    }, apply: function (e, i) {
                        return t(e, i).apply(e, i, this.getMap().getZoom())
                    }
                }, n = {
                    prepare: function (e) {
                        return e
                    }, apply: function (e) {
                        return e
                    }
                };
                e(r)
            });
        }],
        ['2X', function (ym) {
            ym.modules.define("geometry.component.pixelGeometryGeodesic.lineString", ["geometry.component.pixelGeometryGeodesic.storage", "geometry.component.ShortestPath", "util.math.cycleRestrict"], function (e, t, n, o) {
                function i(e, t) {
                    var o = t.getCoordSystem(), i = e.getCoordinates(), a = e.getMetaData().originalIndexes || [],
                        l = new n;
                    if (!i.length) return e;
                    if (ym.env.debug && "function" != typeof o.solveDirectProblem) throw new Error("geometry.component.pixelGeometryGeodesic.lineString: Отсутствует обязательный метод solveDirectProblem у координатной системы.");
                    for (var c, s, d, h, p = t.fromGlobalPixels(i[0], 0), u = {
                        pixelPath: [i[0]],
                        indexes: [a[0] || 0]
                    }, m = t.isCycled(), f = 1, g = i.length; f < g; f++) {
                        c = t.fromGlobalPixels(i[f], 0), s = m[0] && Math.abs(i[f][0] - i[f - 1][0]) > 128 || m[1] && Math.abs(i[f][1] - i[f - 1][1]) > 128, d = r(o, p, c, s), h = [];
                        for (var P = 1, x = d.length, y = x - 1; P < x; P++) h.push(t.toGlobalPixels(d[P], 0)), u.indexes.push(P < y ? -1 : a[f] || f);
                        s || (h.unshift(i[f - 1]), h = l.calculate(h, m, {unbounded: !0}), h.shift()), u.pixelPath = u.pixelPath.concat(h), p = c
                    }
                    return e.clone(u.pixelPath, {originalIndexes: u.indexes})
                }

                function r(e, t, n, o) {
                    for (var i = e.solveInverseProblem(t, n, o), r = [t], l = 0, c = 3; l < c; l++) r = r.concat(a(i.pathFunction, l / c, (l + 1) / c, 0 == l ? {
                        point: i.startPoint,
                        direction: i.startDirection
                    } : null, l == c - 1 ? {point: i.endPoint, direction: i.endDirection} : null));
                    return r
                }

                function a(e, t, n, i, r) {
                    i = i || e(t), r = r || e(n);
                    var l, c, s, d = Math.PI / 60, h = Math.PI / 4, p = [],
                        u = Math.abs(o(Math.atan2(i.direction[0], i.direction[1]) - Math.atan2(r.direction[0], r.direction[1]), -Math.PI, Math.PI)),
                        m = 0;
                    if (Math.abs(u - Math.PI) < 1e-10) {
                        var f, g;
                        "latlong" == ym.env.coordinatesOrder ? (f = [90 * i.direction[0], i.point[1]], g = [90 * i.direction[0], r.point[1]]) : (f = [i.point[0], 90 * i.direction[1]], g = [r.point[0], 90 * i.direction[1]]), p.push(f, g, r.point)
                    } else if (u > d) if (c = Math.ceil(u / d), c < h / d) {
                        l = (n - t) / c;
                        for (var P = 1; P <= c; P++) p.push(e(t + l * P).point)
                    } else l = (n - t) / 2, m = t + l, s = e(m), p = p.concat(a(e, t, m, i, s)), p = p.concat(a(e, m, n, s, r)); else p.push(r.point);
                    return p
                }

                t.add("LineString", i), e(i)
            });
        }],
        ['2!', function (ym) {
            ym.modules.define("geometry.component.ShortestPath", ["geometry.component.anchor", "util.math.cycleRestrict"], function (t, e, o) {
                var n = function () {
                    this.basePoint = null, this.baseWorld = null
                };
                n.prototype = {
                    reset: function () {
                        this.basePoint = null, this.baseWorld = null
                    }, calculate: function (t, n, s) {
                        s = s || {};
                        for (var l, r, i = [], a = [0, 0], h = this.baseWorld, u = this.basePoint, c = s.worldSize || 256, d = 0, b = t.length; d < b; ++d) r = s.unbounded ? t[d] : [n[0] ? o(t[d][0], 0, c) : t[d][0], n[1] ? o(t[d][1], 0, c) : t[d][1]], l = [r[0], r[1]], u && (a = [n[0] ? h[0] + e.getShortestPathWorld(l[0], u[0], c) : 0, n[1] ? h[1] + e.getShortestPathWorld(l[1], u[1], c) : 0], a[0] && (l[0] += a[0] * c), a[1] && (l[1] += a[1] * c)), i[d] = l, u = r, h = a;
                        return this.basePoint = u, this.baseWorld = h, i
                    }
                }, t(n)
            });
        }],
        ['3b', function (ym) {
            ym.modules.define("geometry.pixel.MultiGeometry", ["util.defineClass", "geometry.base.MultiGeometry", "util.array", "util.extend", "util.pixelBounds", "event.Manager"], function (t, n, e, i, u, s, r) {
                var o = function (t, n) {
                    o.superclass.constructor.call(this, null), this._metadata = n, this._pixelBounds = null, this.events = new r, t && this.update(t)
                };
                n(o, e, {
                    getType: function () {
                        return "MultiGeometry"
                    }, isContainer: function () {
                        return !0
                    }, update: function (t) {
                        return this.clearChildren(), i.each(t, function (t, n) {
                            this.insert(n, t)
                        }, this), this
                    }, getBounds: function () {
                        if (!this._pixelBounds) {
                            var t = [];
                            this.each(function (n) {
                                var e = n.getBounds();
                                e && t.push(e)
                            }), t.length && (this._pixelBounds = s.fromBounds(t))
                        }
                        return this._pixelBounds
                    }, getMetaData: function () {
                        return this._metaData
                    }, getCoordinates: function () {
                        var t = [];
                        return this.each(function (n) {
                            t.push(n.getCoordinates())
                        }), t
                    }, setCoordinates: function (t) {
                    }, scale: function (t) {
                        var n = [];
                        return this.each(function (e) {
                            n.push(e.scale(t))
                        }), this.clone(n)
                    }, shift: function (t) {
                        var n = [];
                        return this.each(function (e) {
                            n.push(e.shift(t))
                        }), this.clone(n)
                    }, clone: function (t, n) {
                        return new this.constructor(t || this._cloneInternal(), n ? u({}, this._metaData, n) : this._metaData)
                    }, _cloneInternal: function () {
                        var t = [];
                        return this.each(function (n) {
                            t.push(n.clone())
                        }), t
                    }, equals: function (t) {
                        if (this.getType() != t.getType()) return !1;
                        var n = [], e = [];
                        if (this.each(function (t) {
                            n.push(t)
                        }), t.each(function (t) {
                            e.push(t)
                        }), n.length != e.length) return !1;
                        for (var i = 0; i < n.length; ++i) if (!n[i].equals(e[i])) return !1;
                        return !0
                    }
                }), t(o)
            });
        }],
        ['2Y', function (ym) {
            ym.modules.define("geometry.component.pixelGeometryGeodesic.polygon", ["geometry.component.pixelGeometryGeodesic.lineString", "geometry.component.pixelGeometryGeodesic.storage", "geometry.pixel.LineString"], function (e, n, o, i) {
                function t(e, n) {
                    for (var o, i = e.getCoordinates(), t = e.getMetaData().originalIndexes || [], l = {
                        pixelPaths: [],
                        indexes: []
                    }, s = 0, g = i.length; s < g; s++) o = r(new a(i[s], {originalIndexes: t[s] || []}), n), l.pixelPaths.push(o.getCoordinates()), l.indexes.push(o.getMetaData().originalIndexes);
                    return e.clone(l.pixelPaths, null, {originalIndexes: l.indexes})
                }

                var r = n, a = i;
                o.add("Polygon", t), e(t)
            });
        }],
        ['2.', function (ym) {
            ym.modules.define("geometry.component.selfIntersection", ["graphics.csg", "graphics.Path"], function (e, n, r) {
                function i(e, n, r) {
                    for (var i = [], t = 0; t < e.length; ++t) i.push(n[r[e[t]]]);
                    return i
                }

                var t = {
                    prepare: function (e, i) {
                        var t = 0, s = {
                            intersections: [],
                            intersectionFixedPoints: [],
                            originalIndexes: [],
                            hasIntersections: !0
                        }, o = [];
                        if ("nonZero" != e.getFillRule() && i.cureSelfIntersections) for (var o = [], l = e.getCoordinates(), a = e.getMetaData().originalIndexes || [], u = 0, h = l.length; u < h; ++u) {
                            var g = l[u];
                            if (g.length > 0) {
                                var c = r.fromArray(g);
                                c.indexes.push(0);
                                var d = n.internalShapes(c);
                                if (d.interiors && d.interiors.length > 0) {
                                    t++, o.push(d.coordinates);
                                    var f = [];
                                    f.push(d.exterior.indexes);
                                    for (var p = 0, v = d.interiors.length; p < v; ++p) d.interiors[p].indexes.length > 1 && f.push(d.interiors[p].indexes);
                                    for (var x = [], I = 0, p = 0; p < d.coordinates.length; ++p) d.newPointsIndexes[I] == p && I++, x[p] = a[p - I] || p;
                                    s.intersections[u] = f, s.intersectionFixedPoints[u] = d.newPointsIndexes, s.originalIndexes[u] = x
                                } else o.push(g), s.originalIndexes[u] = a[p]
                            } else o.push([])
                        }
                        return t ? e.clone(o, null, s) : e.clone(null, null, null)
                    }, apply: function (e, n) {
                        var r = e.getMetaData(), t = e.getCoordinates(), s = r.intersections,
                            o = (r.originalIndexes, r.removedPoints || []), l = [];
                        if (s && 0 != s.length) {
                            for (var a = 0; a < t.length; ++a) {
                                var u = s[a], h = t[a], g = [], c = o[a];
                                if (u) {
                                    for (var d = 0, f = 0, p = h.length; d < p; ++d) c[f] == d && (f++, p++), g.push(d - f);
                                    for (var d = 0; d < u.length; ++d) l.push(i(u[d], h, g))
                                } else l.push(h)
                            }
                            return e.clone(l, null, null)
                        }
                        return e.clone(null, null, null)
                    }
                };
                e(t)
            });
        }],
        ['2K', function (ym) {
            ym.modules.define("geometry.component.anchor", [], function (t) {
                var o = {
                    getAnchor: function (t, o, r) {
                        var e, n = Math.floor(o / r), h = (e = o % r) >= 0 ? e : r + e,
                            a = (e = t % r) >= 0 ? e : r + e, c = this.getShortestPathWorld(a, h, r);
                        return a + r * (n + c)
                    }, getShortestPathWorld: function (t, o, r) {
                        var e = r / 2;
                        return t >= e == o >= e ? 0 : t < e ? o - t <= e ? 0 : 1 : o < e ? t - o <= e ? 0 : -1 : 0
                    }
                };
                t(o)
            });
        }],
        ['2@', function (ym) {
            ym.modules.define("geometry.MultiGeometry", ["util.defineClass", "option.Manager", "component.EventFreezer", "geometry.base.MultiGeometry", "geometry.pixel.MultiGeometry", "geometry.component.boundsFromPixels", "geometry.component.renderFlowManager", "geometry.component.ShortestPath", "util.array", "Event"], function (e, t, s, i, n, r, h, o, a, l, c) {
                function u() {
                    this.events.fire("optionschange")
                }

                function p(e) {
                    this._pixelFreezer.fire("pixelgeometry", null, e)
                }

                function d(e) {
                    this._bounds = null, this.events.fire("pixelgeometrychange", new c({
                        pixelGeometry: e.newPixelgeometry,
                        type: "pixelgeometrychange",
                        target: this
                    }))
                }

                function f() {
                    this._inRenderStage ? this._childPixelsUpdated++ : p.call(this, this.getPixelGeometry())
                }

                function g(e) {
                    if (this._inRenderStage++, 1 == this._inRenderStage) {
                        if (!this.getLength()) return !1;
                        if (e) {
                            var t = e.get("targets"), s = this.getChildGeometry(0);
                            if (l.indexOf(t, s) < 0) return !1
                        }
                        this._shortestPath.reset();
                        var i = this.options.get("projection");
                        if (i) {
                            var n = i.isCycled(), r = this._shortestPath;
                            this.each(function (e) {
                                var t = o.fetchStageCache(e, "sharedShortestPath");
                                if (!t) return !1;
                                var s = t.getBounds();
                                s && r.calculate(s, n)
                            })
                        }
                    }
                }

                function m(e) {
                    var t = e.get("target");
                    l.remove(this._shortestPathBase, t)
                }

                function _() {
                    this._inRenderStage--, !this._inRenderStage && this._childPixelsUpdated && (this._shortestPathBase = [], this.each(function (e) {
                        this._shortestPathBase.push(e)
                    }, this), p.call(this, this.getPixelGeometry()), this._childPixelsUpdated = 0)
                }

                function y() {
                    this._bounds = null
                }

                var P = function (e) {
                    P.superclass.constructor.call(this), this._map = null, this.options = new s(e), this.options.events.add("change", u, this), this._pixelFreezer = new i(d, this), this._shortestPath = new a, this.options.set("sharedShortestPath", this._shortestPath), this._childPixelsUpdated = 0, this._inRenderStage = 0, this._shortestPathBase = []
                };
                t(P, n, {
                    getType: function () {
                        return "MultiGeometry"
                    }, getInnerType: function () {
                        return "*"
                    }, isContainer: function () {
                        return !0
                    }, getBounds: function () {
                        return this._bounds || (this._bounds = h.get(this))
                    }, onChildSetup: function (e) {
                        e.events.add("pixelgeometrychange", f, this).add("change", m, this), e.setMap(this._map), e.options.setParent(this.options), e.options.set("sharedShortestPath", this._shortestPath), y.call(this), P.superclass.onChildSetup.call(this, e)
                    }, onChildClear: function (e) {
                        e.events.remove("pixelgeometrychange", f, this).remove("change", m, this), e.options.unset("sharedShortestPath"), e.options.setParent(null), e.setMap(null), y.call(this), P.superclass.onChildClear.call(this, e), p.call(this, this.getPixelGeometry())
                    }, insert: function (e, t) {
                        return P.superclass.insert.call(this, e, t), this
                    }, getPixelGeometry: function (e) {
                        var t = [];
                        return this.each(function (s) {
                            var i = s.getPixelGeometry(e);
                            t.push(i)
                        }), this._pixelGeometry = new r, this._pixelGeometry.update(t)
                    }, setMap: function (e) {
                        var t = this._map;
                        t && this._clearRenderFlow(), this._map = e, this.each(function (t) {
                            t.setMap(e)
                        }), e && this._setupRenderFlow(), this.events.fire("mapchange", new c({
                            newMap: this._map,
                            oldMap: t,
                            target: this,
                            type: "mapchange"
                        }))
                    }, getMap: function () {
                        return this._map
                    }, applyProjectedTransformation: function (e) {
                        this.freeze(), this._shortestPath.reset(), this.each(function (t) {
                            t.applyProjectedTransformation(e)
                        }), this.unfreeze()
                    }, freeze: function () {
                        P.superclass.freeze.call(this), this._pixelFreezer.freeze()
                    }, unfreeze: function () {
                        g.call(this), this._pixelFreezer.unfreeze(), P.superclass.unfreeze.call(this), _.call(this)
                    }, _setupRenderFlow: function () {
                        o.events.add("renderstart", g, this).add("renderend", _, this)
                    }, _clearRenderFlow: function () {
                        this._pixelGeometry && (this._pixelGeometry = null), o.events.remove("renderstart", g, this).remove("renderend", _, this)
                    }
                }), e(P)
            });
        }],
        ['2,', function (ym) {
            ym.modules.define("geometry.GeometryCollection.validTypes", [], function (o) {
                o({
                    Point: !0,
                    Polygon: !0,
                    LineString: !0,
                    MultiPoint: !0,
                    MultiPolygon: !0,
                    MultiLineString: !0,
                    GeometryCollection: !0
                })
            });
        }],
        ['3k', function (ym) {
            ym.modules.define("geometryEditor.Base", ["util.defineClass", "event.Manager", "data.Manager", "option.Manager", "geometryEditor.options.mapper", "Monitor", "util.cancelableCallback", "vow", "yandex.counter", "theme.islands.geometryEditor.meta"], function (e, t, i, r, s, n, o, a, d, h) {
                function l(e, t) {
                    this.geometry = e, this.options = new s(t, null, "editor", n), this.state = new r(this.initialState), this.events = new i({context: this}), this._viewDeferred = null, this._modelDeferred = null, this._editingDeferred = null, this._drawingDeferred = null, this._framingDeferred = null, this._stateEventData = {}, this._stateEventMonitor = new o(this.state), this._stateEventMonitor.add(Object.keys(this.initialState), v, this), this.state.events.add("change", w, this), this.options.events.add("change", c, this), this._stateActionMonitor = new o(this.state), this._stateActionMonitor.add("drawing", _, this).add("editing", f, this).add("framing", u, this)
                }

                function f(e, t) {
                    if (e) {
                        if (ym.env.debug && !this.geometry.getMap()) throw new Error("geometryEditor.Base: геометрия не имеет ссылки на карту.");
                        this.state.get("framing") && this.state.set("framing", !1), this._modelDeferred = d.defer(), this._viewDeferred = d.defer(), this._loadModulesCallback = a.create(g, this), this.getModelClass().done(this._loadModulesCallback)
                    } else this.state.get("drawing", !1) && this.state.set("drawing", !1), null != this._model && (this._model.destroy(), this._model = null), null != this._view && (this._view.destroy(), this._view = null), this._loadModulesCallback ? (this._loadModulesCallback.cancel(), this._loadModulesCallback = null, this._modelDeferred.reject(l.EditorCanceledError()), this._viewDeferred.reject(l.EditorCanceledError()), this._editingDeferred && this._editingDeferred.reject(l.EditorCanceledError())) : this.events.fire("editingstop"), this._viewDeferred = null, this._modelDeferred = null, this._editingDeferred = null
                }

                function g(e) {
                    this._model = new e(this.geometry, this), this._modelDeferred.resolve(this._model), this._loadModulesCallback = a.create(m, this), d.all({
                        viewClass: this.getViewClass(this._model),
                        controllerClass: this.getControllerClass()
                    }).done(this._loadModulesCallback)
                }

                function m(e) {
                    this._loadModulesCallback = null, this._view = new e.viewClass(this._model, this), this._view.setController(new e.controllerClass), this._viewDeferred.resolve(this._view), this._editingDeferred || (this._editingDeferred = d.defer()), this._editingDeferred.resolve(), this._drawingDeferred || (this._drawingDeferred = d.defer()), this._drawingDeferred.resolve(), this.events.fire("editingstart"), this.state.get("drawing", !1) && this.events.fire("drawingstart")
                }

                function _(e, t) {
                    e ? (this.state.get("framing") && this.state.set("framing", !1), this.state.get("editing") || this.state.set("editing", !0), null == this._loadModulesCallback && this.events.fire("drawingstart")) : null == this._loadModulesCallback ? this.events.fire("drawingstop") : (this._drawingDeferred && this._drawingDeferred.reject(l.EditorCanceledError()), this._drawingDeferred = null)
                }

                function u(e) {
                    return e ? (this.state.get("editing") && this.state.set("editing", !1), this._frameDeferred = d.defer(), ym.modules.require(["geometryEditor.FrameEditor"]).spread(function (e) {
                        this._frameEditor = new e(this.geometry, this), this.onFramingComponentStart(this._frameEditor), this._frameDeferred.resolve(), this.events.fire("framingstart")
                    }, this)) : (this._frameEditor && (this.onFramingComponentStop(this._frameEditor), this._frameEditor.stop(), this._frameEditor = null, this.events.fire("framingstop")), this._frameDeferred && this._frameDeferred.reject(l.EditorCanceledError()), this._frameDeferred = null, void 0)
                }

                function c() {
                    this.events.fire("optionschange")
                }

                function w() {
                    var e = this._stateEventData;
                    e.target = this, this._stateEventData = {}, this.events.fire("statechange", e)
                }

                function v(e, t) {
                    for (var i in e) if (e.hasOwnProperty(i)) {
                        var r = D(i, "old"), s = D(i, "new");
                        "undefined" == typeof this._stateEventData[r] && (this._stateEventData[r] = t[i]), this._stateEventData[s] = e[i]
                    }
                }

                function D(e, t) {
                    return t + e.slice(0, 1).toUpperCase() + e.slice(1)
                }

                l.EditorCanceledError = function () {
                    return new Error("Canceled")
                }, l.EditorWasNotStartedError = function () {
                    return new Error("Editor wasn't started")
                }, t(l, {
                    initialState: {drawing: !1, editing: !1, framing: !1}, getModelClass: function () {
                    }, getControllerClass: function () {
                    }, getModel: function () {
                        return this._modelDeferred ? this._modelDeferred.promise() : d.reject(l.EditorWasNotStartedError())
                    }, getModelSync: function () {
                        return this._model
                    }, getView: function () {
                        return this._viewDeferred ? this._viewDeferred.promise() : d.reject(l.EditorWasNotStartedError())
                    }, getViewSync: function () {
                        return this._view
                    }, startEditing: function () {
                        return h.countByKey("modulesUsage", "geometryEditor.editing." + this.geometry.getType()), this.state.set("editing", !0), this._editingDeferred || (this._editingDeferred = d.defer()), this._editingDeferred.promise()
                    }, stopEditing: function () {
                        this.state.set("editing", !1)
                    }, startDrawing: function () {
                        return h.countByKey("modulesUsage", "geometryEditor.drawing." + this.geometry.getType()), this.state.set("drawing", !0), this._drawingDeferred || (this._drawingDeferred = d.defer()), this._drawingDeferred.promise()
                    }, stopDrawing: function () {
                        this.state.set("drawing", !1)
                    }, startFraming: function () {
                        return h.countByKey("modulesUsage", "geometryEditor.framing." + this.geometry.getType()), this.state.set("framing", !0), this._framingDeferred || (this._framingDeferred = d.defer()), this._framingDeferred.promise()
                    }, stopFraming: function () {
                        return this.state.set("framing", !1), d.resolve(!0)
                    }, destroy: function () {
                        this.state.set("editing", !1), this.state.set("framing", !1), this._stateActionMonitor.destroy(), this.options.events.remove("change", c, this), this.state.events.remove("change", w, this), this._stateEventMonitor.destroy()
                    }, onFramingComponentStart: function (e) {
                    }, onFramingComponentStop: function (e) {
                    }
                }), e(l)
            });
        }],
        ['3s', function (ym) {
            ym.modules.define("geometryEditor.storage", ["util.Storage"], function (e, o) {
                e(new o)
            });
        }],
        ['4t', function (ym) {
            ym.modules.define("geoObject.abstract.GeoObject", ["util.defineClass", "geoObject.component.castGeometry", "geoObject.component.castProperties", "data.Manager", "option.Manager", "geoObject.optionMapper", "event.Manager", "geoObject.component.ObjectImplementation", "Event"], function (e, t, n, o, a, r, c, i, s, g) {
                function p(e, t) {
                    this.geometry = n(e && e.geometry), this.properties = o(e && e.properties), this.state = new a, this.options = new r(t, null, "geoObject", c), this.events = new i({context: this}), this._geoObjectComponent = this.createGeoObjectComponent()
                }

                t(p, {
                    setParent: function (e) {
                        return this._geoObjectComponent.setParent(e), this
                    }, getParent: function () {
                        return this._geoObjectComponent.getParent()
                    }, getMap: function () {
                        return this._geoObjectComponent.getMap()
                    }, getOverlay: function () {
                        return this._geoObjectComponent.getOverlay()
                    }, getOverlaySync: function () {
                        return this._geoObjectComponent.getOverlaySync()
                    }, getOverlays: function () {
                        return this._geoObjectComponent.getOverlays()
                    }, getOverlaysSync: function () {
                        return this._geoObjectComponent.getOverlaysSync()
                    }, createGeoObjectComponent: function () {
                        return new s(this, this.geometry, this.properties, this.options, this.events, this.state, {
                            onParentChange: {
                                callback: this.parentChangeCallback,
                                context: this
                            }, onMapChange: {callback: this.mapChangeCallback, context: this}
                        })
                    }, parentChangeCallback: function (e, t) {
                        this.events.fire("parentchange", new g({
                            type: "parentchange",
                            target: this,
                            oldParent: e,
                            newParent: t
                        }))
                    }, mapChangeCallback: function (e, t) {
                        this.events.fire("mapchange", new g({type: "mapchange", target: this, oldMap: e, newMap: t}))
                    }
                }), e(p)
            });
        }],
        ['*v', function (ym) {
            ym.modules.define("theme.islands.geoObject.meta.full", ["option.presetStorage", "map.metaOptions", "theme.islands.geoObject.meta.standard", "theme.islands.geoObject.meta.editor", "theme.islands.geoObject.preset.stretchyIcon"], function (e) {
                e(!0)
            });
        }],
        ['(;', function (ym) {
            ym.modules.define("util.Associate", ["util.id"], function (e, t) {
                function n(e, n) {
                    if (ym.env.debug && !e) throw new Error("util.Associate: Передан пустой указатель на rule");
                    var r = t.get(e);
                    this.get = function (t) {
                        if (ym.env.debug && !t) throw new Error("util.Associate: Передан пустой указатель на объект");
                        var o = t[i] || (t[i] = {});
                        return o[r] || (o[r] = e.apply(n, arguments))
                    }, this.hasInstanceFor = function (e) {
                        return Boolean(e[i] && e[i][r])
                    }
                }

                var i = t.prefix() + t.gen();
                e(n)
            });
        }],
        [')D', function (ym) {
            ym.modules.define("util.defineProperty", [], function (e) {
                e(function (e, t, n, f, o) {
                    var i = o || {};
                    "function" == typeof n && (i.get = n), "function" == typeof f && (i.set = f), Object.defineProperty(e, t, i)
                })
            });
        }],
        [')3', function (ym) {
            ym.modules.define("util.EventPropagator", [], function (t) {
                function e(t, e, o, f, i) {
                    var r = function (t) {
                        var r = t.get("type"), a = n(r, e, f), c = i.callback.call(i.context, t, r, a);
                        o.fire(a, c)
                    };
                    t.add(e, r), this.destroy = function () {
                        t.remove(e, r)
                    }
                }

                function n(t, e, n) {
                    var o;
                    if ("function" == typeof n) o = n(t); else if ("string" == typeof e && t == e) o = n; else for (var f = 0, i = e.length; f < i; f++) e[f] == t && (o = n[f]);
                    return o
                }

                t(e)
            });
        }],
        ['3l', function (ym) {
            ym.modules.define("geometryEditor.Circle", ["util.defineClass", "geometryEditor.Base", "geometryEditor.storage", "vow", "geometryEditor.view.сircleTransformationFeedback"], function (e, r, o, t, n, i) {
                function l(e) {
                    if (this._frameModel) {
                        var r = e.get("target");
                        if (i(r, this._frameModel)) return !0
                    }
                    e.preventDefault()
                }

                var s = {model: null, view: null, controller: null}, m = function (e, r) {
                    m.superclass.constructor.call(this, e, r)
                };
                r(m, o, {
                    getModelClass: function () {
                        return null != s.model ? n.resolve(s.model) : ym.modules.require(["geometryEditor.model.RootCircle", "geometryEditor.view.Circle", "geometryEditor.controller.Circle"]).spread(function (e) {
                            return s.model = e, e
                        }, this)
                    }, getViewClass: function (e) {
                        return null != s.view ? n.resolve(s.view) : ym.modules.require(["geometryEditor.view.Circle"]).spread(function (e) {
                            return s.view = e, e
                        }, this)
                    }, getControllerClass: function () {
                        return null != s.controller ? n.resolve(s.controller) : ym.modules.require(["geometryEditor.controller.Circle"]).spread(function (e) {
                            return s.controller = e, e
                        }, this)
                    }, onFramingComponentStart: function (e) {
                        e.events.add("beforeonframetransformation", l, this), this.getModelClass().then(function () {
                            this._frameModel = new s.model(this.geometry, this)
                        }, this)
                    }, onFramingComponentStop: function (e) {
                        e.events.remove("beforeonframetransformation", l, this), this._frameModel && (this._frameModel.destroy(), this._frameModel = 0)
                    }
                }), t.add("Circle", m), e(m)
            });
        }],
        ['3o', function (ym) {
            ym.modules.define("geometryEditor.MultiGeometry", ["util.defineClass", "event.Manager", "data.Manager", "option.Manager", "geometryEditor.options.mapper", "Monitor", "util.EventPropagator", "util.id", "util.cancelableCallback", "vow", "Event", "localization.common.current", "util.matrix.2d", "geometryEditor.storage", "yandex.counter", "geometryEditor.MultiGeometry.allowedTypes"], function (t, e, i, r, s, n, a, o, d, g, h, f, c, u, l, m, v) {
                function y(t, e) {
                    this.geometry = t, this.options = new s(e, null, "editor", n), this.state = new r(this.initialState), this.events = new i({context: this}), this._subEditors = {}, this._editingDeferred = null, this._drawingDeferred = null, this._framingDeferred = null, this._activeAndAlive = !1, this._stateEventData = {}, this._stateEventMonitor = new a(this.state), this._stateEventMonitor.add(Object.keys(this.initialState), T, this), this.state.events.add("change", A, this), this.options.events.add("change", M, this), this._stateActionMonitor = new a(this.state), this._stateActionMonitor.add("drawing", D, this).add("editing", w, this).add("framing", b, this)
                }

                function p(t) {
                    var e = d.get(t);
                    return this._subEditors[e] || (this._subEditors[e] = _.call(this, t)), this._subEditors[e].editor
                }

                function _(t) {
                    var e, i = l.get(t.getType());
                    if (i) {
                        e = new i(t, {}), e.options.setParent(this.options), e.options.set({
                            geoObject: null,
                            editorIsDependedInstance: !0,
                            frameMenuEnabled: !0,
                            frameCloseOnDoubleClick: !0
                        }), I.call(this, e), e.events.add("statechange", C, this).add("subeditorstatechange", x, this);
                        var r = new o(e.events, ["beforevertexadd", "vertexadd", "beforevertexdraw", "vertexdraw", "beforeedgedragstart", "edgedragstart", "beforeedgedrag", "edgedrag", "edgedragend", "beforevertexdragstart", "vertexdragstart", "beforevertexdrag", "vertexdrag", "vertexdragend"], this.events, function (t) {
                            return "" + t
                        }, {
                            callback: function (e, i, r) {
                                return new f({type: r, target: t}, e)
                            }, context: this
                        });
                        return {editor: e, propagator: r, object: t}
                    }
                    return null
                }

                function E(t) {
                    var e = d.get(t);
                    if (this._subEditors[e]) {
                        var i = this._subEditors[e].editor, r = this._subEditors[e].propagator;
                        r.destroy(), i.events.remove("statechange", C, this).remove("subeditorstatechange", x, this), i.destroy(), i.options.setParent(null), delete this._subEditors[e]
                    }
                }

                function w(t, e) {
                    if (t) {
                        if (ym.env.debug && !this.geometry.getMap()) throw new Error("geometryEditor.Multi: геометрия не имеет ссылки на карту.");
                        this.state.get("framing") && this.state.set("framing", !1), h.all(this._forEach(function (t) {
                            return t.startEditing()
                        })).then(function () {
                            this._editingDeferred && this._editingDeferred.resolve(), this.events.fire("editingstart")
                        }, this)
                    } else this.state.get("drawing", !1) && this.state.set("drawing", !1), this._forEach(function (t) {
                        t.stopEditing()
                    }), this._editingDeferred && this._editingDeferred.reject(), this.events.fire("editingstop");
                    P.call(this)
                }

                function D(t, e) {
                    if (t) {
                        this.state.get("framing") && this.state.set("framing", !1), this.state.get("editing") || this.state.set("editing", !0);
                        var i, r = this.geometry.getLength();
                        if (0 == r) {
                            if (i = G.call(this), !i) return void this.state.set("drawing", !1)
                        } else {
                            var s = p.call(this, this.geometry.getChildGeometry(r - 1));
                            this._forEach(function (t) {
                                if (t.state.get("drawing")) return s = t, !1
                            }), i = s.startDrawing()
                        }
                        i.then(function () {
                            this._drawingDeferred.resolve(), this.events.fire("drawingstart")
                        }, this)
                    } else this._forEach(function (t) {
                        t.stopDrawing()
                    }), this._drawingDeferred && this._drawingDeferred.reject(), this.events.fire("drawingstop");
                    P.call(this)
                }

                function b(t) {
                    return t ? (this.state.get("editing") && this.state.set("editing", !1), this._frameDeferred = h.defer(), ym.modules.require(["geometryEditor.FrameEditor"]).spread(function (t) {
                        this._frameEditor = new t(this.geometry, this), this._frameDeferred.resolve(), this.events.fire("framingstart")
                    }, this)) : (this._frameEditor && (this._frameEditor.stop(), this._frameEditor = null, this.events.fire("framingstop")), void (this._framingDeferred && this._framingDeferred.reject()))
                }

                function M() {
                    this.events.fire("optionschange")
                }

                function C(t) {
                    var e = t.get("target"), i = t.get("newFraming"), r = t.get("newDrawing"), s = t.get("newEditing");
                    this.events.fire("subeditorstatechange", new f({
                        type: "subeditorstatechange",
                        target: this,
                        child: e
                    }, t)), t.get("oldFraming") == i || i || (this.state.get("editing") ? e.startEditing() : this.stopFraming()), t.get("oldDrawing") != r && (r ? (this._forEach(function (t) {
                        t !== e && t.stopDrawing()
                    }), this.startDrawing()) : this.stopDrawing()), t.get("oldEditing") != s && !s
                }

                function x(t) {
                    this.events.fire("subeditorstatechange", new f({
                        type: "subeditorstatechange",
                        target: this,
                        child: t.get("target")
                    }, t))
                }

                function A() {
                    var t = this._stateEventData;
                    t.target = this, this._stateEventData = {}, this.events.fire("statechange", t)
                }

                function T(t, e) {
                    for (var i in t) if (t.hasOwnProperty(i)) {
                        var r = k(i, "old"), s = k(i, "new");
                        "undefined" == typeof this._stateEventData[r] && (this._stateEventData[r] = e[i]), this._stateEventData[s] = t[i]
                    }
                }

                function k(t, e) {
                    return e + t.slice(0, 1).toUpperCase() + t.slice(1)
                }

                function G(t) {
                    var e = this.geometry;
                    return !(!t && !(t = e.createInnerType())) && (e.insert(e.getLength(), t), p.call(this, t).startDrawing())
                }

                function F(t, e, i) {
                    var r = (e.editor.geometry, i || t.geometry.createInnerType());
                    r.getType();
                    G.call(t, r)
                }

                function P() {
                    this.state.get("drawing") || this.state.get("editing") ? this._activeAndAlive || (this.geometry.events.add("childchange", j, this), this._activeAndAlive = !0) : this._activeAndAlive && (this.geometry.each(function (t) {
                        E.call(this, t)
                    }, this), this.geometry.events.remove("childchange", j, this), this._activeAndAlive = !1)
                }

                function j() {
                    var t = this.state.get("editing"), e = {};
                    this._forEach(function (i) {
                        t && i.startEditing(), e[d.get(i.geometry)] = i
                    });
                    for (var i in this._subEditors) this._subEditors.hasOwnProperty(i) && (e[i] || E.call(this, this._subEditors[i].object))
                }

                function I(t) {
                    var e = this;
                    t.options.set("menuManager", function (t, i) {
                        for (var r = e.options.get("menuManager"), s = !1, n = i.editor.geometry.getType(), a = 0; a < t.length; ++a) if ("removeGeometry" == t[a].id) {
                            s = !0;
                            break
                        }
                        if (s || ("Point" != n && t.push({
                            id: "frameState",
                            title: S.startFraming,
                            onClick: function () {
                                i.editor.startFraming()
                            }
                        }), t.push({
                            id: "removeGeometry", title: S["remove" + n], onClick: function () {
                                e.geometry.remove(i.editor.geometry)
                            }
                        })), !e.options.get("editorIsDependedInstance")) if ("GeometryCollection" == e.geometry.getType()) for (var a = 0; a < v.length; ++a) {
                            var o = v[a];
                            t.push({
                                id: "addGeometry" + o,
                                title: S["add" + o.type],
                                geometryType: o,
                                onClick: function () {
                                    F(e, i, new this.geometryType.Class)
                                }
                            })
                        } else t.push({
                            id: "addGeometry", title: S["add" + n], onClick: function () {
                                F(e, i)
                            }
                        });
                        return r && (t = r(t, i)), t
                    })
                }

                var S = c.Editor;
                y.EditorCanceledError = function () {
                    return new Error("Canceled")
                }, y.EditorWasNotStartedError = function () {
                    return new Error("Editor wasn't started")
                }, e(y, {
                    initialState: {drawing: !1, editing: !1, framing: !1}, startEditing: function () {
                        return m.countByKey("modulesUsage", "geometryEditor.editing." + this.geometry.getType()), this.state.set("editing", !0), this._editingDeferred || (this._editingDeferred = h.defer()), this._editingDeferred.promise()
                    }, stopEditing: function () {
                        this.state.set("editing", !1)
                    }, startDrawing: function () {
                        return m.countByKey("modulesUsage", "geometryEditor.drawing." + this.geometry.getType()), this.state.set("drawing", !0), this._drawingDeferred || (this._drawingDeferred = h.defer()), this._drawingDeferred.promise()
                    }, stopDrawing: function () {
                        this.state.set("drawing", !1)
                    }, startFraming: function () {
                        return m.countByKey("modulesUsage", "geometryEditor.framing." + this.geometry.getType()), this.state.set("framing", !0), this._framingDeferred || (this._framingDeferred = h.defer()), this._framingDeferred.promise()
                    }, stopFraming: function () {
                        return this.state.set("framing", !1), h.resolve(!0)
                    }, destroy: function () {
                        this.state.set("editing", !1), this.state.set("framing", !1), this._stateActionMonitor.destroy(), this.options.events.remove("change", M, this), this.state.events.remove("change", A, this), this._stateEventMonitor.destroy()
                    }, _forEach: function (t) {
                        var e = [];
                        return this.geometry.each(function (i, r) {
                            e.push(t.call(this, p.call(this, i, r)))
                        }, this), e
                    }
                }), l.add("MultiPolygon", y), l.add("MultiLineString", y), l.add("MultiPoint", y), l.add("GeometryCollection", y), t(y)
            });
        }],
        ['0!', function (ym) {
            ym.modules.define("component.sharedEntity.captor.Balloon", ["util.defineClass", "component.sharedEntity.captor.Popup", "vow"], function (t, o, n, e) {
                function a(t, o, n, e) {
                    a.superclass.constructor.call(this, t, o, n, e)
                }

                o(a, n, {
                    getBalloon: function () {
                        return this.getPopup()
                    }, autoPan: function () {
                        var t = this.getBalloon();
                        return t ? t.autoPan() : e.reject("Balloon is not captured.")
                    }
                }), t(a)
            });
        }],
        ['4G', function (ym) {
            ym.modules.define("geoObject.balloonPositioner.storage", ["util.Storage"], function (e, o) {
                var n = new o;
                e(n)
            });
        }],
        ['_4', function (ym) {
            ym.modules.define("projection.idle", ["coordSystem.cartesian"], function (e, n) {
                e({
                    toGlobalPixels: function (e, n) {
                        return e.slice()
                    }, fromGlobalPixels: function (e, n) {
                        return e.slice()
                    }, isCycled: function () {
                        return [!1, !1]
                    }, getCoordSystem: function () {
                        return n
                    }
                })
            });
        }],
        [')g', function (ym) {
            ym.modules.define("util.component", [], function (n) {
                n({
                    createProxyMethods: function (n, t) {
                        for (var e, r, o = {}, u = 0, c = t.length; u < c; u++) "string" == typeof t[u] ? r = e = t[u] : (r = Object.keys(t[u])[0], e = t[u][r]), o[r] = function (t) {
                            return function () {
                                var e = n.call(this);
                                return e[t].apply(e, arguments)
                            }
                        }(e);
                        return o
                    }
                })
            });
        }],
        [',l', function (ym) {
            ym.modules.define("util.preset", ["util.array"], function (e, t) {
                var r = {
                    add: function (e, r, n) {
                        var i = [];
                        return i = t.isArray(e) ? e.slice() : "undefined" != typeof e ? [e] : [], "undefined" == typeof n ? i.push(r) : i.splice(n, 0, r), i
                    }, remove: function (e, r) {
                        var n = [];
                        if ("undefined" != typeof e) {
                            n = t.isArray(e) ? e.slice() : [e];
                            var i = t.indexOf(n, r);
                            i != -1 && (n.splice(i, 1), n.length < 2 && (n = n[0]))
                        }
                        return n
                    }, prependTo: function (e, t) {
                        e.set("preset", r.add(e.get("preset"), t, 0))
                    }, addTo: function (e, t) {
                        e.set("preset", r.add(e.get("preset"), t))
                    }, removeFrom: function (e, t) {
                        e.set("preset", r.remove(e.get("preset"), t))
                    }
                };
                e(r)
            });
        }],
        ['_0', function (ym) {
            ym.modules.define("popup.managerStorage", ["util.Storage"], function (e, n) {
                e(new n)
            });
        }],
        ['_Y', function (ym) {
            ym.modules.define("popup.component.checkEmptiness", ["overlay.storage", "vow", "Hint", "Balloon"], function (e, n, t, o, s) {
                e(function (e, i, r, c) {
                    function p(n) {
                        if (n.hasOwnProperty("checkEmptiness")) a.resolve(n.checkEmptiness(c)); else {
                            var t = "hint" == i ? new o(e) : new s(e);
                            t.setPosition(r), t.setData(c), t.options.setParent(c.options), t.getOverlay().done(function (e) {
                                a.resolve(e.isEmpty())
                            }, function (e) {
                                a.reject(e)
                            })
                        }
                    }

                    var a = t.defer(), f = c.options.get("overlay"), u = n.get(f, c);
                    return "undefined" == typeof u ? n.require({keys: [f], data: c}).spread(p, function (e) {
                        a.reject(e)
                    }, this).done() : p(u), a.promise()
                })
            });
        }],
        ['4A', function (ym) {
            ym.modules.define("geoObject.balloonPositioner.circle", ["geoObject.balloonPositioner.storage"], function (o, e) {
                var t = {
                    calculatePosition: function (o, e) {
                        var t = o.getCoordinates(), i = o.getRadius(), n = [e[0] - t[0], e[1] - t[1]],
                            a = Math.sqrt(n[0] * n[0] + n[1] * n[1]);
                        return a < i ? e : [t[0] + n[0] * i / a, t[1] + n[1] * i / a]
                    }
                };
                e.add("Circle", t), o(t)
            });
        }],
        ['4D', function (ym) {
            ym.modules.define("geoObject.balloonPositioner.point", ["geoObject.balloonPositioner.storage"], function (o, e) {
                var n = {
                    calculatePosition: function (o) {
                        return o.getCoordinates()
                    }
                };
                e.add("Point", n), o(n)
            });
        }],
        ['4E', function (ym) {
            ym.modules.define("geoObject.balloonPositioner.polygon", ["geoObject.balloonPositioner.storage", "geometry.component.pointInPolygon"], function (o, e, n) {
                var t = {
                    calculatePosition: function (o, e) {
                        if (n(e, o.getCoordinates(), o.getFillRule())) return e;
                        var t = o.getClosest(e);
                        return t ? t.position : null
                    }
                };
                e.add("Polygon", t), o(t)
            });
        }],
        ['4B', function (ym) {
            ym.modules.define("geoObject.balloonPositioner.lineString", ["geoObject.balloonPositioner.storage", "geometry.component.findClosestPathPosition"], function (o, n, e) {
                var t = {
                    calculatePosition: function (o, n) {
                        var t = e(o.getCoordinates(), n);
                        return t ? t.position : null
                    }
                };
                n.add("LineString", t), o(t)
            });
        }],
        ['4F', function (ym) {
            ym.modules.define("geoObject.balloonPositioner.rectangle", ["geoObject.balloonPositioner.storage", "geometry.component.findClosestPathPosition", "util.pixelBounds"], function (o, n, e, t) {
                var i = {
                    calculatePosition: function (o, n) {
                        var i = o.getBounds();
                        return t.containsPoint(i, n) ? n : e([i[0], [i[0][0], i[1][1]], i[1], [i[1][0], i[0][1]], i[0]], n).position
                    }
                };
                n.add("Rectangle", i), o(i)
            });
        }],
        ['4C', function (ym) {
            ym.modules.define("geoObject.balloonPositioner.multi", ["geoObject.balloonPositioner.storage"], function (o, t) {
                var e = {
                    calculatePosition: function (o, t) {
                        if (o.contains(t)) return t;
                        var e = o.getClosest(t);
                        return e ? e.position : null
                    }
                };
                t.add("MultiGeometry", e), t.add("MultiLineString", e), t.add("MultiPolygon", e), t.add("MultiPoint", e), t.add("MultiGeometry", e), t.add("GeometryCollection", e), o(e)
            });
        }],
        ['0*', function (ym) {
            ym.modules.define("component.sharedEntity.captor.Popup", ["util.defineClass", "event.Manager", "event.Mapper", "Event", "sharedEntity.CaptorAccessor", "option.Manager", "projection.idle", "vow", "util.cancelableCallback", "util.extend", "error"], function (t, e, n, s, i, p, r, o, a, u, h, c) {
                function _(t, e, s, i) {
                    this._manager = t, this._popupOwner = e, this._optionManagerName = s, this._sharingManager = i, this.events = new n({context: this}), this._popup = null, this._accessor = null, this._setupAccessor(), this._setupEventMapper()
                }

                e(_, {
                    destroy: function () {
                        this._sharingManager && this._sharingManager.getOwner() == this._popupOwner && this._sharingManager.capture(null), this._clearEventMapper(), this._accessor = null
                    }, setSharingManager: function (t) {
                        this._sharingManager = t
                    }, open: function (t, e, n) {
                        this._cancelCaptureRequest();
                        var s = a.defer();
                        if (this._popup) s.resolve(this._openCaptured(t, e, n)); else {
                            if (this._openDeferred = s, this._captureCallback = u.create(function (i) {
                                this._openDeferred = this._captureCallback = null, this._onCapture(i);
                                var p = i.isOpen(), r = this._openCaptured(t, e, n);
                                p && r.then(this._fireOpen, this), s.resolve(r)
                            }, this), ym.env.debug && (!this._sharingManager || "function" != typeof this._sharingManager.capture)) throw new Error("component.sharedEntity.captor.Popup.open: Не найден менеджер разделяемого инфо-объекта.");
                            this._sharingManager.capture(this._accessor).then(this._captureCallback)
                        }
                        return s.promise()
                    }, close: function (t) {
                        return this._popup ? this._popup.close(t) : (this._cancelCaptureRequest(), a.resolve())
                    }, isOpen: function () {
                        return this._popup && this._popup.isOpen()
                    }, setPosition: function (t) {
                        return this._position = t, this._popup ? a.resolve(this._popup.setPosition(this._position)) : a.reject(c.create("StateError", "Popup is not captured at the moment"))
                    }, setData: function (t) {
                        return this._data = t, this._popup ? a.resolve(this._popup.setData(this._data)) : a.reject(c.create("StateError", "Popup is not captured at the moment"))
                    }, setOptions: function (t) {
                        return this._options = this._specifyOptions(t || {}), this._popup.options.setParent(this._options), a.resolve()
                    }, getPosition: function () {
                        return this._position || null
                    }, getData: function () {
                        return this._data || null
                    }, getOptions: function () {
                        return this._options || null
                    }, getPopup: function () {
                        return this._popup || null
                    }, getOwner: function () {
                        return this._popupOwner
                    }, getOverlay: function () {
                        return this._popup ? this._popup.getOverlay() : a.reject(c.create("StateError", "Popup is not captured at the moment"))
                    }, getOverlaySync: function () {
                        return this._popup ? this._popup.getOverlaySync() : null
                    }, setMasterAccessor: function (t) {
                        this._accessor.setMaster(t)
                    }, _setupAccessor: function () {
                        var t = function () {
                            return this._sharingManager.capture(null)
                        }, e = function (t) {
                            return t ? a.resolve() : this.close(!0)
                        };
                        this._accessor = new p(this._popupOwner, {capture: e, open: t, close: t}, this._onRelease, this)
                    }, _setupEventMapper: function () {
                        var t = this._popupOwner;
                        this.events.setParent(new s(this._manager.events, {
                            "*": function (e) {
                                return new i({type: e.get("type"), target: t})
                            }
                        }))
                    }, _clearEventMapper: function () {
                        this.events.setParent(null)
                    }, _onCapture: function (t) {
                        this._popup = t, t.events.setParent(this.events), this.events.fire("capture")
                    }, _onRelease: function () {
                        this._popup ? (this.isOpen() && this._fireClose(), this._popup.events.setParent(null), this._popup = null, this.events.fire("release")) : this._cancelCaptureRequest()
                    }, _cancelCaptureRequest: function () {
                        this._captureCallback && (this._captureCallback.cancel(), this._captureCallback = null), this._openDeferred && (this._openDeferred.reject(c.create("OperationCanceledReject", "Capturing/opening was canceled")), this._openDeferred = null)
                    }, _openCaptured: function (t, e, n) {
                        if (this._position = t, this._data = e, this._options = this._specifyOptions(n), this.isOpen()) {
                            var s = this._popup.getOverlaySync(), i = s.getMap();
                            return s.setMap(null), this._popup.options.setParent(this._options), this._popup.setData(e), this._popup.setPosition(t), s.setMap(i), this._popup.open()
                        }
                        return this._popup.options.setParent(this._options), this._popup.open(t, e)
                    }, _specifyOptions: function (t) {
                        var e = {projection: o};
                        return t && "function" == typeof t.get || (t = new r(t ? h(e, t) : e, this._popupOwner.options, this._optionManagerName)), t
                    }, _fireOpen: function () {
                        this.events.fire("open")
                    }, _fireClose: function () {
                        this.events.fire("close")
                    }
                }), t(_)
            });
        }],
        ['4u', function (ym) {
            ym.modules.define("geoObject.abstract.Sequence", ["util.defineClass", "geoObject.abstract.GeoObject", "geoObject.component.BoundsAggregator", "component.array.ParentArray", "event.Mapper", "geoObject.EventMappingTable"], function (n, t, e, o, i, s, c) {
                function r(n, t) {
                    r.superclass.constructor.call(this, n, t), this._boundsAggregator = null, this._collectionComponent = this.createCollectionComponent(n && n.children || [])
                }

                t(r, e, {
                    get: function (n) {
                        return this._collectionComponent.get(n)
                    }, getLength: function () {
                        return this._collectionComponent.getLength()
                    }, each: function (n, t) {
                        return this._collectionComponent.each(n, t), this
                    }, getIterator: function () {
                        return this._collectionComponent.getIterator()
                    }, indexOf: function (n) {
                        return this._collectionComponent.indexOf(n)
                    }, getPixelBounds: function () {
                        return this._boundsAggregator ? this._boundsAggregator.getPixelBounds() : null
                    }, getBounds: function () {
                        return this._boundsAggregator ? this._boundsAggregator.getBounds() : null
                    }, createCollectionComponent: function (n) {
                        return new i(n, this, {}, new s(this.events, new c(this)))
                    }, toArray: function () {
                        return this._collectionComponent.toArray()
                    }, mapChangeCallback: function (n, t) {
                        n && (this._boundsAggregator.destroy(), this._boundsAggregator = null), r.superclass.mapChangeCallback.call(this, n, t), t && (this._boundsAggregator = new o(this, {
                            onPixelBoundsChange: {
                                callback: this._pixelBoundsChangeCallback,
                                context: this
                            }, onGeoBoundsChange: {callback: this._geoBoundsChangeCallback, context: this}
                        }))
                    }, _pixelBoundsChangeCallback: function () {
                        this.events.fire("pixelboundschange")
                    }, _geoBoundsChangeCallback: function () {
                        this.events.fire("boundschange")
                    }
                }), n(r)
            });
        }],
        ['04', function (ym) {
            ym.modules.define("component.array.ParentArray", ["util.defineClass", "component.array.BaseArray", "component.parent.BaseParent"], function (t, e, n, a) {
                function r(t, e, r, o, s) {
                    t = t || [], this._callbacks = r || {}, this._parent = e, this._parentEvents = o, this._parentOptions = s, this._parentComponent = new a(e, {
                        callback: this._childParentChangeCallback,
                        context: this
                    });
                    for (var i = 0, c = t.length; i < c; i++) this._parentComponent.addChild(t[i]);
                    this._baseArrayComponent = new n(t, {
                        onAdd: {callback: this._addCallback, context: this},
                        onRemove: {callback: this._removeCallback, context: this},
                        onSet: {callback: this._setCallback, context: this}
                    })
                }

                e(r, {
                    get: function (t) {
                        return this._baseArrayComponent.get(t)
                    }, set: function (t, e) {
                        return this._parent == e.getParent() && this._baseArrayComponent.remove(e), this._baseArrayComponent.set(t, e)
                    }, add: function (t, e) {
                        this._parent == t.getParent() && this._baseArrayComponent.remove(t), this._baseArrayComponent.add(t, e)
                    }, remove: function (t) {
                        this._baseArrayComponent.remove(t)
                    }, removeAll: function () {
                        this._baseArrayComponent.removeAll()
                    }, splice: function (t, e) {
                        for (var n = Array.prototype.slice.call(arguments, 2), a = 0, r = n.length; a < r; a++) {
                            var o = n[a];
                            this._parent == o.getParent() && this._baseArrayComponent.remove(o)
                        }
                        return this._baseArrayComponent.splice.apply(this._baseArrayComponent, arguments)
                    }, getLength: function () {
                        return this._baseArrayComponent.getLength()
                    }, getIterator: function () {
                        return this._baseArrayComponent.getIterator()
                    }, each: function (t, e) {
                        this._baseArrayComponent.each(t, e)
                    }, indexOf: function (t) {
                        return this._baseArrayComponent.indexOf(t)
                    }, sort: function (t) {
                        this._baseArrayComponent.sort(t)
                    }, quickSort: function (t) {
                        this._baseArrayComponent.quickSort(t)
                    }, toArray: function () {
                        return this._baseArrayComponent.toArray()
                    }, _addCallback: function (t, e) {
                        this._parentComponent.addChild(e);
                        var n = this._callbacks.onAdd;
                        n && n.callback.call(n.context, t, e)
                    }, _removeCallback: function (t, e) {
                        this._parentComponent.removeChild(e);
                        var n = this._callbacks.onRemove;
                        n && n.callback.call(n.context, t, e)
                    }, _setCallback: function (t, e, n) {
                        this._parentComponent.removeChild(e), this._parentComponent.addChild(n);
                        var a = this._callbacks.onSet;
                        a && a.callback.call(a.context, t, e, n)
                    }, _childParentChangeCallback: function (t, e, n) {
                        this._parent == e && (t.events.setParent(null), t.options.setParent(null), this._baseArrayComponent.indexOf(t) != -1 && this._baseArrayComponent.remove(t)), this._parent == n && (t.events.setParent(this._parentEvents || this._parent.events), t.options.setParent(this._parentOptions || this._parent.options))
                    }
                }), t(r)
            });
        }],
        [')q', function (ym) {
            ym.modules.define("util.List", ["util.defineClass", "util.id"], function (t, s, i) {
                function e(t) {
                    this._list = t
                }

                function r() {
                    this.first = null, this.last = null, this.hash = {}, this.length = 0
                }

                s(e, {
                    STOP_ITERATION: {}, getNext: function () {
                        if ("undefined" == typeof this._current) return this._current = this._list.first, this._current ? this._current.obj : this.STOP_ITERATION;
                        if (!this._current || this._current === this._list.last) return this.STOP_ITERATION;
                        var t = this._current;
                        if (t.removed) {
                            for (; t && t.removed;) t = t.prev;
                            this._current = t ? t.next : this._list.first
                        } else this._current = t.next;
                        return this._current ? this._current.obj : this.STOP_ITERATION
                    }
                }), s(r, {
                    insert: function (t, s) {
                        var e = i.get(t), r = {obj: t, next: null, prev: null}, h = s ? this.hash[i.get(s)] : null;
                        return this.hash[e] && this.remove(t), h ? (h.prev && (h.prev.next = r, r.prev = h.prev), r.next = h, h.prev = r, h == this.first && (this.first = r)) : this.last ? (this.last.next = r, r.prev = this.last, this.last = r) : this.first = this.last = r, this.hash[e] = r, this.length++, r
                    }, remove: function (t) {
                        var s = i.get(t), e = this.hash[s];
                        return e ? (e.next ? e.next.prev = e.prev : e == this.last && (this.last = e.prev), e.prev ? e.prev.next = e.next : e == this.first && (this.first = e.next), e.removed = !0, delete this.hash[s], this.length--, e) : null
                    }, removeAll: function () {
                        this.hash = {}, this.length = 0, this.first = null, this.last = null
                    }, contains: function (t) {
                        return this.hash[i.get(t)]
                    }, getIterator: function () {
                        return new e(this)
                    }, forEach: function (t, s) {
                        for (var i = this.first; i && (t.call(s, i.obj), i != this.last);) i = i.next
                    }
                }), t(r)
            });
        }],
        ['(:', function (ym) {
            ym.modules.define("util.ArrayIterator", [], function (t) {
                function e(t) {
                    var e = 0;
                    this.getNext = function () {
                        return e < t.length ? t[e++] : this.STOP_ITERATION
                    }
                }

                e.prototype.STOP_ITERATION = {}, t(e)
            });
        }],
        ['4!', function (ym) {
            ym.modules.define("geoQueryResult.component.search", ["geoQueryResult.component.util"], function (e, n) {
                function u(e) {
                    var n = e.match(/^([\w.]*)\s*(<|<\=|\=|\=\=|\!\=|>\=|>|rlike|regexp)\s*([\w.]*|".*"|'.*')$/i),
                        u = n[1], r = l[n[2].toLowerCase()], o = n[3];
                    return o = '"' == o.charAt(0) || "'" == o.charAt(0) ? o.slice(1, o.length - 1) : i[o] ? i[o].value : Number(o), function (e) {
                        return r(t(e, u), o)
                    }
                }

                var t = n.getFieldValue, r = function (e, n) {
                    for (var t = "string" == typeof n ? u(n) : n, r = [], l = e.getIterator(), o = 0, i = l.getNext(); i != l.STOP_ITERATION;) t(i, o, this) && r.push(i), i = l.getNext(), o++;
                    return r
                }, l = {
                    "<": function (e, n) {
                        return null != e && null != n && e < n
                    }, "<=": function (e, n) {
                        return null != e && null != n && e <= n
                    }, "==": function (e, n) {
                        return e == n
                    }, "!=": function (e, n) {
                        return e != n
                    }, ">=": function (e, n) {
                        return null != e && null != n && e >= n
                    }, ">": function (e, n) {
                        return null != e && null != n && e > n
                    }, regexp: function (e, n) {
                        return e && e.match && null != e.match(new RegExp(n))
                    }
                };
                l["="] = l["=="], l.rlike = l.regexp;
                var o, i = {"true": {value: !0}, "false": {value: !1}, "null": {value: null}, undefined: {value: o}};
                e(r)
            });
        }],
        ['4$', function (ym) {
            ym.modules.define("geoQueryResult.component.contain", ["projection.wgs84Mercator", "util.bounds", "coordSystem.geo", "geometry.component.pointInPolygon", "util.math.calculateLineIntersection"], function (e, t, n, r, o, i) {
                function a(e, t) {
                    switch (e.getType()) {
                        case"Point":
                            var n = e.getCoordinates(), r = t.getCoordinates();
                            return n[0] == r[0] && n[1] == r[1];
                        case"LineString":
                            return e.getClosest(t.getCoordinates()).distance < u;
                        case"Polygon":
                        case"Rectangle":
                        case"Circle":
                        case"LinearRing":
                            return e.contains(t.getCoordinates());
                        default:
                            return !1
                    }
                }

                function s(e, t) {
                    if (!e.contains) return !1;
                    if (!e.contains(t[0])) return !1;
                    switch (e.getType()) {
                        case"Circle":
                        case"Rectangle":
                            for (var n = 1, r = t.length; n < r; n++) if (!e.contains(t[n])) return !1;
                            return !0;
                        case"LinearRing":
                            return c(e.getCoordinates(), t);
                        case"Polygon":
                            for (var o = e.getCoordinates(), n = 0, r = o.length; n < r; n++) if (!c(o[n], t)) return !1;
                            return !0;
                        default:
                            return !1
                    }
                }

                function c(e, t) {
                    for (var n = 1, r = e.length; n < r; n++) for (var a = 1, s = t.length; a < s; a++) {
                        var c = i(e[n], e[n - 1], t[a], t[a - 1]);
                        if (c) {
                            if (!(c.b < u || 1 - c.b < u)) return !1;
                            var g = [(t[a][0] + t[a - 1][0]) / 2, (t[a][1] + t[a - 1][1]) / 2];
                            if (!o(g, [e])) return !1
                        }
                    }
                    return !0
                }

                function g(e) {
                    var t = e.getCoordinates();
                    return [t[0], [t[0][0], t[1][1]], t[1], [t[1][0], t[0][1]], t[0]]
                }

                var u = .01, f = function (e, o) {
                    var i = e.options.get("projection") || o.options.get("projection");
                    if ("Point" != e.getType() && "Point" != o.getType() && !n.areIntersecting(e.getBounds(), o.getBounds(), i || t)) return !1;
                    switch (o.getType()) {
                        case"Point":
                            return a(e, o);
                        case"LineString":
                        case"LinearRing":
                            return s(e, o.getCoordinates());
                        case"Rectangle":
                            if (!e.contains) return !1;
                            for (var c = g(o), u = 0, f = c.length; u < f; u++) if (!e.contains(c[u])) return !1;
                            return !0;
                        case"Polygon":
                            if (!e.contains) return !1;
                            for (var c = o.getCoordinates(), u = 0, f = c.length; u < f; u++) if (!s(e, c[u])) return !1;
                            return !0;
                        case"Circle":
                            if (!e.contains || !e.contains(o.getCenter())) return !1;
                            var l = e.getClosest(o.getCenter()), i = o.options.get("projection"),
                                d = i ? i.getCoordSystem() : r, C = d.getDistance(l.position, o.getCenter());
                            return C >= o.getRadius();
                        default:
                            return !1
                    }
                };
                e(f)
            });
        }],
        ['4-', function (ym) {
            ym.modules.define("geoQueryResult.component.distance", ["util.vector", "util.math.calculateLineIntersection", "util.array", "geometry.component.findClosestPathPosition", "geoQueryResult.component.geometryPicker", "coordSystem.geo", "geometry.LineString"], function (e, t, n, r, o, s, a, i) {
                function u(e, t) {
                    switch (t.getType()) {
                        case"Point":
                            return m(e, t.getCoordinates(), t.options.get("projection"));
                        case"Circle":
                        case"Polygon":
                        case"Rectangle":
                            return t.contains(e) ? 0 : t.getClosest(e).distance;
                        case"LineString":
                            return t.getClosest(e).distance;
                        default:
                            return null
                    }
                }

                function c(e, t) {
                    var n = u(e.getCenter(), t), r = e.getRadius();
                    return n <= r ? 0 : n - r
                }

                function g(e, t) {
                    var n = e.getCoordinates(), r = new i(n[0]);
                    r.options.setParent(e.options), r.setMap(e.getMap());
                    for (var o = f(r, t), s = 1, a = n.length; s < a; s++) {
                        r.setCoordinates(n[1]);
                        var u = f(r, t);
                        u < o && (o = u)
                    }
                    return o
                }

                function l(e, t) {
                    var n = e.getCoordinates(), r = new i([n[0], [n[0][0], n[1][1]], n[1], [n[1][0], n[0][1]], n[0]]);
                    return r.options.setParent(e.options), r.setMap(e.getMap()), f(r, t)
                }

                function f(e, t) {
                    switch (t.getType()) {
                        case"Point":
                            return u(t.getCoordinates(), e);
                        case"Circle":
                            return c(t, e);
                        case"Polygon":
                            return g(t, e);
                        case"Rectangle":
                        case"LineString":
                            var n = d(e.getPixelGeometry().getCoordinates(), y(t)),
                                r = t.options.get("projection") || e.options.get("projection"),
                                o = t.getMap() || e.getMap();
                            return m(r.fromGlobalPixels(n[0], o.getZoom()), r.fromGlobalPixels(n[1], o.getZoom()), r);
                        default:
                            return null
                    }
                }

                function d(e, t) {
                    for (var n = C(t, e[0]), r = n.distance, o = [n.position, e[0]], s = 1, a = e.length; s < a; s++) n = C(t, e[s]), n.distance < r && (r = n.distance, o = [n.position, e[s]]);
                    for (var s = 0, a = t.length; s < a; s++) n = C(e, t[s]), n.distance < r && (r = n.distance, o = [n.position, t[s]]);
                    return o
                }

                function m(e, t, n) {
                    var r = n ? n.getCoordSystem() : a;
                    return r.getDistance(e, t)
                }

                function y(e) {
                    var t = e.getPixelGeometry(), n = t.getCoordinates();
                    return "Rectangle" == t.getType() && (n = [n[0], [n[0][0], n[1][1]], n[1], [n[1][0], n[0][1]], n[0]]), n
                }

                var p, h, C = o;
                r.isArray;
                "latlong" == ym.env.coordinatesOrder ? (p = 0, h = 1) : (p = 1, h = 0);
                var b = {
                    getCentralObject: function (e, t) {
                        if (!e.getLength()) return null;
                        var n = t.getCenter(), r = function (e) {
                            return u(n, e.geometry)
                        };
                        return this._getClosestObject(e, r)
                    }, getExtreme: function (e, t) {
                        var n = e.getBounds();
                        switch (t) {
                            case"top":
                                return n[1][p];
                            case"right":
                                return n[1][h];
                            case"bottom":
                                return n[0][p];
                            case"left":
                                return n[0][h];
                            default:
                                throw new Error("geoQueryResult.getExtreme: неверное значение ключа.")
                        }
                    }, getExtremeObject: function (e, t) {
                        if (!e.getLength()) return null;
                        var n, r = e.getBounds();
                        switch (t) {
                            case"top":
                                n = function (e) {
                                    return Math.abs(r[1][p] - e.geometry.getBounds()[1][p])
                                };
                                break;
                            case"right":
                                n = function (e) {
                                    return Math.abs(r[1][h] - e.geometry.getBounds()[1][h])
                                };
                                break;
                            case"bottom":
                                n = function (e) {
                                    return Math.abs(r[0][p] - e.geometry.getBounds()[0][p])
                                };
                                break;
                            case"left":
                                n = function (e) {
                                    return Math.abs(r[0][h] - e.geometry.getBounds()[0][h])
                                };
                                break;
                            default:
                                throw new Error("geoQueryResult.getExtremeObject: неверное значение ключа.")
                        }
                        return this._getClosestObject(e, n)
                    }, getClosestTo: function (e, t) {
                        var n = s(t), r = function (e) {
                            return n == e.geometry ? -1 : this.getDistance(n, e.geometry)
                        }.bind(this);
                        return this._getClosestObject(e, r)
                    }, getDistance: function (e, t) {
                        switch (e.getType()) {
                            case"Point":
                                return u(e.getCoordinates(), t);
                            case"Circle":
                                return c(e, t);
                            case"Polygon":
                                return g(e, t);
                            case"LineString":
                                return f(e, t);
                            case"Rectangle":
                                return l(e, t);
                            default:
                                return null
                        }
                    }, _getClosestObject: function (e, t) {
                        if (!e.getLength()) return null;
                        for (var n, r = e.getIterator(), o = r.getNext(), s = t(o); (n = r.getNext()) != r.STOP_ITERATION;) {
                            var a = t(n);
                            a != -1 && (s == -1 || a < s) && (s = a, o = n)
                        }
                        return s > -1 ? o : null
                    }
                };
                e(b)
            });
        }],
        ['4.', function (ym) {
            ym.modules.define("geoQueryResult.component.intersect", ["projection.wgs84Mercator", "coordSystem.geo", "util.bounds", "util.math.calculateLineIntersection", "geoQueryResult.component.distance", "geoQueryResult.component.contain"], function (e, t, r, n, o, c, i) {
                function a(e, t, r) {
                    switch (t.getType()) {
                        case"Point":
                            var n = e.getCoordinates(), o = t.getCoordinates();
                            return n[0] == o[0] && n[1] == o[1];
                        case"LineString":
                            return t.getClosest(e.getCoordinates()).distance < x;
                        case"LinearRing":
                        case"Rectangle":
                        case"Polygon":
                            return !(!r.considerOccurance || !i(t, e)) || t.getClosest(e.getCoordinates()).distance < x;
                        case"Circle":
                            return d(t, e, r);
                        default:
                            return !1
                    }
                }

                function s(e, t, r) {
                    switch (t.getType()) {
                        case"Point":
                            return a(t, e, r);
                        case"LineString":
                        case"LinearRing":
                            return y(e.getPixelGeometry().getCoordinates(), t.getPixelGeometry().getCoordinates());
                        case"Circle":
                            return d(t, e, r);
                        case"Polygon":
                            return !(!r.considerOccurance || !i(t, e)) || C(t.getPixelGeometry(), e.getPixelGeometry().getCoordinates());
                        case"Rectangle":
                            return !(!r.considerOccurance || !i(t, e)) || y(e.getPixelGeometry().getCoordinates(), f(t));
                        default:
                            return !1
                    }
                }

                function g(e, t, r) {
                    switch (t.getType()) {
                        case"Point":
                            return a(t, e, r);
                        case"LineString":
                            return !(!r.considerOccurance || !i(e, t)) || y(t.getPixelGeometry().getCoordinates(), e.getPixelGeometry().getCoordinates());
                        case"LinearRing":
                            return !(!r.considerOccurance || !i(e, t) && !i(t, e)) || y(t.getPixelGeometry().getCoordinates(), e.getPixelGeometry().getCoordinates());
                        case"Circle":
                            return d(t, e, r);
                        case"Polygon":
                            return !(!r.considerOccurance || !i(e, t) && !i(t, e)) || C(t.getPixelGeometry(), e.getPixelGeometry().getCoordinates());
                        case"Rectangle":
                            return !(!r.considerOccurance || !i(e, t) && !i(t, e)) || y(e.getPixelGeometry().getCoordinates(), f(t));
                        default:
                            return !1
                    }
                }

                function u(e, t, r) {
                    switch (t.getType()) {
                        case"Point":
                            return a(t, e, r);
                        case"LineString":
                            return !(!r.considerOccurance || !i(e, t)) || y(t.getPixelGeometry().getCoordinates(), f(e));
                        case"LinearRing":
                            return !(!r.considerOccurance || !i(e, t) && !i(t, e)) || y(t.getPixelGeometry().getCoordinates(), f(e));
                        case"Circle":
                            return d(t, e, r);
                        case"Polygon":
                            return !(!r.considerOccurance || !i(e, t) && !i(t, e)) || C(t.getPixelGeometry(), f(e));
                        case"Rectangle":
                            return !(!r.considerOccurance || !i(e, t) && !i(t, e)) || y(f(t), f(e));
                        default:
                            return !1
                    }
                }

                function l(e, t, r) {
                    switch (t.getType()) {
                        case"Point":
                            return a(t, e, r);
                        case"LineString":
                            return !(!r.considerOccurance || !i(e, t)) || C(e.getPixelGeometry(), t.getPixelGeometry().getCoordinates());
                        case"LinearRing":
                            return !(!r.considerOccurance || !i(e, t) && !i(t, e)) || C(e.getPixelGeometry(), t.getPixelGeometry().getCoordinates());
                        case"Circle":
                            return d(t, e, r);
                        case"Polygon":
                            if (r.considerOccurance && (i(e, t) || i(t, e))) return !0;
                            for (var n = t.getPixelGeometry().getCoordinates(), o = 0, c = n.length; o < c; o++) if (C(e.getPixelGeometry(), n[o])) return !0;
                            return !1;
                        case"Rectangle":
                            return !(!r.considerOccurance || !i(e, t) && !i(t, e)) || C(e.getPixelGeometry(), f(t));
                        default:
                            return !1
                    }
                }

                function d(e, t, n) {
                    switch (t.getType()) {
                        case"Point":
                            var o = e.options.get("projection") || t.options.get("projection"),
                                c = o ? o.getCoordSystem() : r,
                                a = c.getDistance(e.getCoordinates(), t.getCoordinates()), s = e.getRadius();
                            return n.considerOccurance ? a <= s : Math.abs(a - s) < x;
                        case"LineString":
                            var g = i(e, t);
                            return g ? !!n.considerOccurance : G(t, e) < x;
                        case"LinearRing":
                        case"Rectangle":
                        case"Polygon":
                            var g = i(e, t) || i(t, e);
                            return g ? !!n.considerOccurance : G(t, e) < x;
                        case"Circle":
                            return P(e, t, n);
                        default:
                            return !1
                    }
                }

                function y(e, t) {
                    for (var r = 1, n = e.length; r < n; r++) for (var c = 1, i = t.length; c < i; c++) if (o(e[r], e[r - 1], t[c], t[c - 1])) return !0;
                    return !1
                }

                function P(e, t, n) {
                    var o = e.options.get("projection") || t.options.get("projection"), c = o ? o.getCoordSystem() : r,
                        i = c.getDistance(e.getCenter(), t.getCenter()), a = e.getRadius(), s = t.getRadius(),
                        g = Math.abs(a - s) >= i;
                    return g ? !!n.considerOccurance : i <= a + s
                }

                function C(e, t) {
                    for (var r = e.getCoordinates(), n = 0, o = r.length; n < o; n++) if (y(r[n], t)) return !0;
                    return !1
                }

                function f(e) {
                    var t = e.getPixelGeometry(), r = t.getCoordinates();
                    return "Rectangle" == t.getType() && (r = m(r)), r
                }

                function m(e) {
                    return [e[0], [e[0][0], e[1][1]], e[1], [e[1][0], e[0][1]], e[0]]
                }

                function p(e) {
                    return [[e[0][0] - x, e[0][1] - x], [e[1][0] + x, e[1][1] + x]]
                }

                var x = .001, G = c.getDistance, R = function (e, r, o) {
                    if (o = o || {}, "Point" != e.getType() && "Point" != r.getType()) {
                        var c = e.options.get("projection") || r.options.get("projection");
                        if (!n.areIntersecting(p(e.getBounds()), p(r.getBounds()), c || t)) return !1
                    }
                    switch (e.getType()) {
                        case"Point":
                            return a(e, r, o);
                        case"LineString":
                            return s(e, r, o);
                        case"LinearRing":
                            return g(e, r, o);
                        case"Rectangle":
                            return u(e, r, o);
                        case"Polygon":
                            return l(e, r, o);
                        case"Circle":
                            return d(e, r, o);
                        default:
                            return !1
                    }
                };
                e(R)
            });
        }],
        ['4*', function (ym) {
            ym.modules.define("geoQueryResult.component.util", [], function (e) {
                var t = {
                    getFieldValue: function (e, t) {
                        if (r[t]) return r[t](e);
                        var n = t.indexOf("."), o = i[t.slice(0, n)], g = t.slice(n + 1);
                        return o(e, g)
                    }
                }, n = "latlong" == ym.env.coordinatesOrder ? 0 : 1, o = 0 == n ? 1 : 0, r = {
                    lat: function (e) {
                        return "Point" == e.geometry.getType() ? e.geometry.getCoordinates()[n] : null
                    }, lng: function (e) {
                        return "Point" == e.geometry.getType() ? e.geometry.getCoordinates()[o] : null
                    }, x: function (e) {
                        return "Point" == e.geometry.getType() ? e.geometry.getPixelGeometry().getCoordinates()[0] : null
                    }, y: function (e) {
                        return "Point" == e.geometry.getType() ? e.geometry.getPixelGeometry().getCoordinates()[1] : null
                    }
                }, i = {
                    geometry: function (e, t) {
                        var n, o = t.split("."), r = o[0];
                        if ("type" == r) n = e.geometry.getType(); else if ("coordinates" == r) {
                            n = e.geometry.getCoordinates();
                            for (var i = 1; i < o.length; i++) n = n[o[i]]
                        }
                        return n
                    }, properties: function (e, t) {
                        return e.properties.get(t)
                    }, options: function (e, t) {
                        return e.options.get(t)
                    }
                };
                r["long"] = r.lng, e(t)
            });
        }],
        ['4_', function (ym) {
            ym.modules.define("geoQueryResult.component.geometryPicker", ["geometry.Circle", "geometry.Rectangle", "geometry.LineString", "geometry.Polygon", "geometry.Point", "util.array", "geoObject.geometryFactory"], function (e, t, o, r, n, y, g, i) {
                e(function (e) {
                    if (e.getZoom) {
                        var t = new o(e.getBounds(), {coordRendering: "boundsPath"});
                        return t.options.setParent(e.options), t.setMap(e), t
                    }
                    return e.geometry ? e.geometry : "function" == typeof e.getType ? e : g.isArray(e) ? g.isArray(e[0]) ? new o(e) : new y(e) : i.createGeometry(e)
                })
            });
        }],
        ['4,', function (ym) {
            ym.modules.define("geoXml.getJson", ["util.jsonp", "vow"], function (e, n, o) {
                function r(e) {
                    return n({
                        url: s, requestParams: {url: e, key: ym.env.key}, postprocessUrl: function (e) {
                            return ym.env.hostConfigQuery ? e + "&" + ym.env.hostConfigQuery : e
                        }
                    })
                }

                var s = ym.env.hosts.api.services.geoxml + "1.2/geoxml.xml";
                e(r)
            });
        }],
        ['4z', function (ym) {
            ym.modules.define("geoXml.util", ["option.presetStorage"], function (e, t) {
                var a = {
                    checkStyle: function (e) {
                        if (e && !t.get(e)) {
                            var a = {};
                            e.replace(/^default#(?:([a-z]+)(?:Small)?|([a-zA-Z]+))(?:Point|Icon)$/, function (e, n, r) {
                                var l = "islands#" + (n || r) + "Icon";
                                t.get(l) && (a.preset = l)
                            }), t.add(e, a)
                        }
                    }, resolveUrl: function (e, t) {
                        if (/^https?:\/\//.test(e)) return e;
                        for (var a, n = /^((?:[^\/]+):\/\/(?:[^\/]+))(\/(?:.*))$/.exec(t), r = n[1], l = n[2].split("/"), s = e.split("/"), i = l.slice(1, l.length - 1), o = 0, c = s.length; o < c; o++) switch (a = s[o]) {
                            case"":
                                0 == o ? i = [] : o == c - 1 && i.push(a);
                                break;
                            case".":
                                break;
                            case"..":
                                i.pop();
                                break;
                            default:
                                i.push(a)
                        }
                        return r + "/" + i.join("/")
                    }
                };
                e(a)
            });
        }],
        [')U', function (ym) {
            ym.modules.define("util.dom.viewport", [], function (e) {
                function t() {
                    return document.documentElement
                }

                var n = {
                    getSize: function () {
                        return this.element || (this.element = t()), [window.innerWidth || this.element.clientWidth, window.innerHeight || this.element.clientHeight]
                    }, getScrollOffsets: function () {
                        return [window.pageXOffset || document.documentElement.scrollLeft || document.body.scrollLeft, window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop]
                    }, hasScroll: function () {
                        return this.element || (this.element = t()), [this.element.scrollWidth > this.element.clientWidth, this.element.scrollHeight > this.element.clientHeight]
                    }
                };
                e(n)
            });
        }],
        ['5z', function (ym) {
            ym.modules.define("hint.metaOptions", ["map.metaOptions", "map.optionMapper", "constants.zIndex", "interactivityModel.opaque", "map.pane.helper.hint"], function (t, n, e, i, a) {
                n.set({
                    hintOverlay: "html#hint",
                    hintOpenTimeout: 300,
                    hintCloseTimeout: 700,
                    hintOffset: [10, 10],
                    hintPane: "outerHint",
                    hintZIndex: i.hint,
                    hintInteractivityModel: a,
                    hintLayout: "islands#hint",
                    hintContentLayout: "default#content",
                    hintMaxWidth: 400,
                    hintMaxHeight: 400
                }), e.setRule({name: "hint", rule: "prefixed"}).setRule({
                    name: "hint",
                    key: ["projection"],
                    rule: "plain"
                }), t({})
            });
        }],
        ['0q', function (ym) {
            ym.modules.define("constants.hotspotEvents", [], function (e) {
                e({
                    types: {
                        mouseenter: !0,
                        mousemove: !0,
                        mouseleave: !0,
                        mousedown: !0,
                        mouseup: !0,
                        click: !0,
                        contextmenu: !0,
                        dblclick: !0,
                        wheel: !0,
                        multitouchstart: !0,
                        multitouchmove: !0,
                        multitouchend: !0
                    },
                    order: ["mousedown", "mousemove", "multitouchstart", "multitouchmove", "multitouchend", "mouseup", "wheel", "click", "contextmenu", "dblclick"]
                })
            });
        }],
        ['6m', function (ym) {
            ym.modules.define("hotspot.manager.ContainerList", ["util.defineClass", "util.List", "util.id", "util.math.areEqual", "event.Manager", "util.extend", "hotspot.counter", "interactivityModel.geoObject"], function (t, e, i, n, o, s, a, r, h) {
                function c(t, e) {
                    t.events.add("positionchange", this._onPositionChange, this), this._pane = e, this._map = e.getMap(), this._list = new i, this._containerListeners = {}, this.events = new s({context: this}), this._positionStack = [], this._containerZIndex = {}
                }

                e(c, {
                    clear: function () {
                        for (var t, e = this._list.getIterator(); (t = e.getNext()) != e.STOP_ITERATION;) t.clear()
                    }, getObjectInPosition: function (t, e) {
                        for (var i, o, s = this._list.getIterator(), a = null, h = null; (i = s.getNext()) != s.STOP_ITERATION;) {
                            var c = this._containerZIndex[n.get(i)];
                            if (a && "number" == typeof o && o > c) return a;
                            "number" == typeof o && o != c && (h = null);
                            var u = i.getObjectInPosition(t, e, h);
                            if (u) {
                                var l = u.getZIndex() || 0;
                                "number" != typeof h || l > h ? (a = u, h = l, o = c) : l == h && r.getNumber(u) > r.getNumber(a) && (a = u)
                            }
                        }
                        return a || null
                    }, insert: function (t, e) {
                        this._list.insert(t, this._getNextObject(e));
                        var i = n.get(t);
                        this._containerZIndex[i] = e || 0, this._containerListeners[i] = t.events.group().add("dataload", this._onDataLoaded, this), t.setParent(this)
                    }, remove: function (t) {
                        this._list.remove(t);
                        var e = n.get(t);
                        this._containerListeners[e].removeAll(), delete this._containerListeners[e], delete this._containerZIndex[e], t.setParent(null)
                    }, _onPositionChange: function (t) {
                        if (t.get("pane") == this._pane) {
                            var e, i, n = t.get("added"), o = t.get("removed"), s = [];
                            for (e = 0, i = this._positionStack.length; e < i; e++) {
                                for (var a = !1, r = 0, h = o.length; r < h; r++) this._posEquals(this._positionStack[e], o[r]) && (a = !0);
                                a || s.push(this._positionStack[e])
                            }
                            for (this._positionStack = s, e = 0, i = n.length; e < i; e++) this._positionStack.push(n[e]);
                            this.events.fire("positionchange", {added: n, removed: o})
                        }
                    }, _onDataLoaded: function (t) {
                        for (var e = {}, i = this._map.getZoom(), n = 0, o = this._positionStack.length; n < o; n++) {
                            var s = this._positionStack[n], r = this.getObjectInPosition(s.position, i);
                            r && (e[s.type] = a(s, {activeObject: r}))
                        }
                        this.events.fire("found", {found: e}), this._positionStack = []
                    }, _posEquals: function (t, e) {
                        return t.zoom == e.zoom && t.type == e.type && o(t.position, e.position)
                    }, _getNextObject: function (t) {
                        for (var e, i = this._list.getIterator(); (e = i.getNext()) != i.STOP_ITERATION;) if (this._containerZIndex[n.get(e)] <= t) return e;
                        return null
                    }
                }), t(c)
            });
        }],
        ['6n', function (ym) {
            ym.modules.define("hotspot.manager.EventController", ["util.defineClass", "constants.hotspotEvents"], function (t, e, o) {
                function s(t, e) {
                    this._pane = t, this._manager = e
                }

                function n(t) {
                    return t.isImmediatePropagationStopped && t.isImmediatePropagationStopped()
                }

                e(s, {
                    onBeforeEventFiring: function (t, e, s) {
                        if (o.types[e] && "hotspots" != s.get("origin") && !n(s)) {
                            if (this._testFiredAs(e, s)) return;
                            "mouseenter" == e ? this._manager.focus(e, s) : "mouseleave" == e ? this._manager.blur(e, s) : this._manager.process(e, s)
                        }
                    }, _testFiredAs: function (t, e) {
                        var o = e.get("domEvent");
                        if (o) {
                            var s = o.get("propagatedData");
                            if (s.hotspotFiredAs || (s.hotspotFiredAs = {}), s.hotspotFiredAs[t]) return !0;
                            s.hotspotFiredAs[t] = !0
                        }
                        return !1
                    }
                }), t(s)
            });
        }],
        ['5J', function (ym) {
            ym.modules.define("hotspot.container.Internal", ["util.defineClass", "event.Manager", "hotspot.counter", "util.array", "util.PrTree", "util.scheduler.manager", "util.id"], function (e, t, r, s, n, i, o, h) {
                function a() {
                    this._prTree = new i, this.events = new r({context: this}), this._operations = [], this._unordered = [], this._wrappers = {}
                }

                t(a, {
                    add: function (e) {
                        this._operations.push({type: "add", hotspots: e}), this._triggerChange()
                    }, remove: function (e) {
                        this._operations.push({type: "remove", hotspots: e}), this._triggerChange()
                    }, clear: function () {
                        this._wrappers = {}, this._unordered = [], this._operations = [], this._prTree.removeAll(), o.unschedule("raf", this._flatten, this)
                    }, getObjectInPosition: function (e, t, r) {
                        return n.reduce(this._getObjectsInPosition(e, r), function (e, t) {
                            if (e) {
                                var r = e.getZIndex() || 0, n = t.getZIndex() || 0;
                                (n > r || n == r && s.getNumber(t) > s.getNumber(e)) && (e = t)
                            } else e = t;
                            return e
                        }, null)
                    }, getObjectsInPosition: function (e, t, r) {
                        return this._getObjectsInPosition(e, r).sort(function (e, t) {
                            var r = t.getZIndex() - e.getZIndex();
                            return r || s.getNumber(t) - s.getNumber(e)
                        })
                    }, setUnordered: function (e) {
                        var t = h.get(e);
                        this._wrappers[t] && this._unordered.push(e), this._triggerChange()
                    }, forEach: function (e, t) {
                        this._flatten(), this._prTree.each(function (r) {
                            e.call(t, r.hotspot)
                        })
                    }, _getObjectsInPosition: function (e, t) {
                        this._flatten();
                        var r = [], s = this._prTree.search([e, e]);
                        if (!s.length) return r;
                        t = t || -(1 / 0);
                        for (var n = 0; n < s.length; n++) {
                            var i = s[n].hotspot;
                            if (i.getShape().contains(e)) {
                                var o = i.getZIndex() || 0;
                                o > t && r.push(i)
                            }
                        }
                        return r
                    }, _flatten: function () {
                        if (o.unschedule("raf", this._flatten, this), this._unordered.length) {
                            this._removeHotspots(this._unordered, !0);
                            for (var e = 0; e < this._unordered.length; e++) this._getWrapper(this._unordered[e], !0);
                            this._operations.unshift({type: "add", hotspots: this._unordered}), this._unordered = []
                        }
                        var t = this._filterOperations(this._operations),
                            r = 0 == this._prTree.getLength() && 0 == t.added.length;
                        this._operations = [], t.removed.length && this._removeHotspots(t.removed), t.added.length && this._prTree.insert(t.added), r || 0 != this._prTree.getLength() || this.events.fire("empty")
                    }, _removeHotspots: function (e, t) {
                        for (var r = 0, s = e.length; r < s; r++) {
                            var n = h.get(e[r]), i = this._wrappers[n];
                            i && (this._prTree.remove(i), t || delete this._wrappers[n])
                        }
                    }, _triggerChange: function () {
                        o.schedule("raf", this._flatten, this)
                    }, _filterOperations: function (e) {
                        var t = this._flattenOperations(e);
                        return this._filterNulls(t)
                    }, _flattenOperations: function (e) {
                        for (var t = [], r = [], s = {}, n = {}, i = 0, o = 0, a = e.length; o < a; o++) for (var p = e[o], d = "add" == p.type ? s : n, u = "add" == p.type ? n : s, _ = 0, g = p.hotspots.length; _ < g; _++) {
                            var l = p.hotspots[_], f = h.get(l);
                            f in d && delete t[d[f]], d[f] = i, f in u && (delete t[u[f]], delete u[f]), t[i] = l, r[i] = p.type, i++
                        }
                        return {hotspots: t, types: r, addIndex: s, removeIndex: n}
                    }, _filterNulls: function (e) {
                        for (var t = [], r = [], s = 0, n = e.hotspots.length; s < n; s++) {
                            var i = e.hotspots[s];
                            i && ("add" == e.types[s] ? t.push(this._getWrapper(i)) : r.push(i))
                        }
                        return {added: t, removed: r}
                    }, _getWrapper: function (e, t) {
                        var r = h.get(e);
                        return this._wrappers[r] ? t && (this._wrappers[r].bbox = e.getShape().getBounds()) : this._wrappers[r] = {
                            hotspot: e,
                            bbox: e.getShape().getBounds()
                        }, this._wrappers[r]
                    }
                }), e(a)
            });
        }],
        ['5I', function (ym) {
            ym.modules.define("hotspot.counter", [], function (t) {
                var e = new function () {
                    this._currentNumber = -1, this._prefix = "hotspotSerialNumber_" + (new Date).getTime() + Math.round(1e4 * Math.random()), this.setNumber = function (t) {
                        t[this._prefix] = ++this._currentNumber
                    }, this.getNumber = function (t) {
                        return t[this._prefix]
                    }
                };
                t(e)
            });
        }],
        ['0i', function (ym) {
            ym.modules.define("constants.mapDomEvents", [], function (e) {
                e(["click", "dblclick", "contextmenu", "mousedown", "mouseup", "mousemove", "mouseenter", "mouseleave", "wheel", "multitouchstart", "multitouchmove", "multitouchend"])
            });
        }],
        ['6d', function (ym) {
            ym.modules.define("hotspot.layer.Container", ["util.defineClass", "hotspot.Container", "event.Manager", "util.math.cycleRestrict", "util.math.areEqual"], function (t, e, o, i, n, s) {
                function r(t, e) {
                    o.call(this, e), this.events = new i({context: this}), this._tile = null, this._zoom = null, this._missedPosition = null, this._layer = t, this._listener = t.events.group().add("dataload", this._onDataLoaded, this).add("update", this._onLayerUpdate, this).add(["addtomap", "removefrommap"], this._onMapChange, this), this._location = null, this._projection = null
                }

                e(r, o, {
                    getObjectInPosition: function (t, e, o) {
                        var i = this._fixPositionAndZoom(t, e);
                        return r.superclass.getObjectInPosition.call(this, i.position, i.zoom, o)
                    }, getObjectsInPosition: function (t, e, o) {
                        var i = this._fixPositionAndZoom(t, e);
                        return r.superclass.getObjectsInPosition.call(this, i.position, i.zoom, o)
                    }, _fixPositionAndZoom: function (t, e) {
                        var o, i, n = this._convertPosition(t, e), s = this._layer.getMap().getZoom(),
                            r = this._roundZoom(s), l = r - s, a = this._toZeroWorld(n);
                        return l && (o = Math.pow(2, l), a = [o * a[0], o * a[1]]), i = [Math.floor(a[0] / 256), Math.floor(a[1] / 256)], this.setActiveTileAndZoom(i, r), {
                            position: a,
                            zoom: r
                        }
                    }, setParent: function (t) {
                        t ? (this._containerListListener = t.events.group().add("positionchange", this._onPositionChange, this), this._resolveProjection()) : this._containerListListener.removeAll()
                    }, getLayer: function () {
                        return this._layer
                    }, remove: function () {
                        if (ym.env.debug) throw new Error("hotspot.container.HotspotLayerContainer.remove: Объекты класса не поддерживают удаление элементов по одному.")
                    }, setActiveTileAndZoom: function (t, e) {
                        this._equals(t, this._tile) && this._zoom == e ? this._requestedTile && (this._requestedTile = null) : (this._zoom = e, this._equals(t, this._requestedTile) || (this._requestedTile = t, this.events.fire("datarequest", {
                            tile: t,
                            zoom: e
                        })))
                    }, getActiveTileAndZoom: function () {
                        return {tile: this._requestedTile || this._tile, zoom: this._zoom}
                    }, _onPositionChange: function (t) {
                        var e = t.get("added");
                        if (e.length > 0) {
                            var o = e[e.length - 1], i = o.zoom,
                                n = this._toZeroWorld(this._convertPosition(o.position, i)), s = this._roundZoom(i),
                                r = 256 * Math.pow(2, i - s), l = [Math.floor(n[0] / r), Math.floor(n[1] / r)];
                            this.setActiveTileAndZoom(l, s)
                        }
                    }, _onLayerUpdate: function () {
                        this.clear();
                        var t = this._layer.getMap();
                        t ? (this._requestedTile || this._tile) && (this._requestedTile || (this._requestedTile = this._tile), this._tile = null, this.events.fire("datarequest", {
                            tile: this._requestedTile,
                            zoom: this._roundZoom(this._layer.getMap().getZoom())
                        })) : this._tile = null
                    }, _onMapChange: function () {
                        this._requestedTile = null
                    }, _onDataLoaded: function (t) {
                        var e = t.get("tile"), o = t.get("zoom");
                        if (this._equals(e, this._requestedTile) && o == this._zoom) {
                            this._tile = e;
                            for (var i = t.get("objects"), n = [], s = 0, r = i.length; s < r; s++) n.push(i[s].getHotspot());
                            this.clear(), this.add(n), this._requestedTile = null, this.events.fire("dataload", {
                                tile: e,
                                zoom: o
                            })
                        }
                    }, _equals: function (t, e) {
                        return !(!t || !e) && s(t, e)
                    }, _toZeroWorld: function (t) {
                        for (var e = this._layer.getMap(), o = e.options.get("projection").isCycled(), i = 256 * Math.pow(2, e.getZoom()), s = [], r = 0; r < 2; r++) o[r] ? s[r] = n(t[r], 0, i - 1) : s[r] = t[r];
                        return s
                    }, _convertPosition: function (t, e) {
                        if (!this._projection.diff) return t;
                        var o = this._projection.map.fromGlobalPixels(t, e);
                        return this._projection.self.toGlobalPixels(o, e)
                    }, _resolveProjection: function () {
                        var t = this._layer.options.get("projection"),
                            e = this._layer.getMap().options.get("projection");
                        this._projection = {self: t, map: e, diff: e != t}
                    }, _roundZoom: function (t) {
                        var e = this._layer.options.get("tilesRoundingMethod", "round");
                        return "function" == typeof e ? e(t) : "round" == e ? Math.round(t) : Math.floor(t)
                    }
                }), t(r)
            });
        }],
        ['6k', function (ym) {
            ym.modules.define("hotspot.layer.optionMapper", ["option.Mapper"], function (o, e) {
                o(new e)
            });
        }],
        ['6V', function (ym) {
            ym.modules.define("layer.optionMapper", ["option.Mapper"], function (e, n) {
                e(new n)
            });
        }],
        ['*L', function (ym) {
            ym.modules.define("theme.islands.hotspot.meta.full", ["theme.islands.hotspot.meta.hint", "theme.islands.hotspot.meta.balloon"], function (t) {
                t(!0)
            });
        }],
        ['6H', function (ym) {
            ym.modules.define("interactivityModel.EventController", ["util.defineClass", "util.array", "constants.mapDomEvents", "interactivityModel.storage"], function (t, i, e, n, o) {
                function a(t) {
                    this._interactivityModel = o.get(t)
                }

                for (var r = {}, l = 0, c = n.length; l < c; l++) r[n[l]] = !0;
                i(a, {
                    setInteractivityModel: function (t) {
                        this._interactivityModel = o.get(t)
                    }, getInteractivityModel: function () {
                        return this._interactivityModel
                    }, onBeforeEventFiring: function (t, i, e) {
                        var n;
                        if (this._interactivityModel && r[i]) {
                            var o = this._interactivityModel[i];
                            o && ("function" == typeof o ? o(e) : (o.allowMapEvent && e.allowMapEvent(), o.stopPropagation && e.stopPropagation(), o.cancel && (n = !1)))
                        }
                        return n
                    }
                }), t(a)
            });
        }],
        [');', function (ym) {
            ym.modules.define("util.jsonp", ["util.id", "util.querystring", "util.script"], function (e, o, r, n) {
                function t(e) {
                    return t.handler ? t.handler(e, i) : i(e)
                }

                function i(e) {
                    if (!e.url) return ym.vow.resolve();
                    var t, i, d = !1, f = "undefined" == typeof e.checkResponse || e.checkResponse,
                        p = e.responseFieldName || "response",
                        m = e.requestParams ? "&" + r.stringify(e.requestParams, null, null, {joinArrays: !0}) : "",
                        w = ym.vow.defer(), y = w.promise(), h = e.timeout || 3e4, v = setTimeout(function () {
                            d = !0, w.reject(l)
                        }, h), g = function () {
                            s(i, t, d), clearTimeout(v), v = null
                        };
                    if (!e.padding) {
                        if (t = e.paddingKey || o.prefix() + o.gen(), "function" == typeof window[t] && window[t].promise) return window[t].promise;
                        c(t), window[t] = function (e) {
                            if (f) {
                                var o = !e || e.error || e[p] && e[p].error;
                                o ? w.reject(o) : w.resolve(e && e[p] || e)
                            } else w.resolve(e)
                        }, window[t].promise = y
                    }
                    var j = e.url + (/\?/.test(e.url) ? "&" : "?") + (e.paramName || "callback") + "=" + (e.padding || t) + (e.noCache ? "&_=" + Math.floor(1e7 * Math.random()) : "") + m;
                    if (e.postprocessUrl) if ("function" == typeof e.postprocessUrl) j = e.postprocessUrl(j); else for (; e.postprocessUrl.length;) j = e.postprocessUrl.shift()(j);
                    return i = n.create(j), i.onerror = function () {
                        w.reject(a)
                    }, i.onload = function () {
                        d && !e.padding && t && u(t)
                    }, y.always(g), y
                }

                function s(e, o, r) {
                    o && u(o, r), setTimeout(function () {
                        e && e.parentNode && e.parentNode.removeChild(e)
                    }, 0)
                }

                function u(e, o) {
                    window[e] = d, f[e] = setTimeout(function () {
                        if (!o) try {
                            window[e] = void 0, delete window[e]
                        } catch (r) {
                        }
                    }, 500)
                }

                function c(e) {
                    f[e] && (clearTimeout(f[e]), f[e] = null)
                }

                var l = {message: "timeoutExceeded"}, a = {message: "scriptError"}, d = function () {
                }, f = {};
                e(t)
            });
        }],
        [')f', function (ym) {
            ym.modules.define("util.Chunker", ["util.defineClass", "util.extend", "util.scheduler.strategy.Raf"], function (t, i, s, n) {
                var e = window.setTimeout, h = window.clearTimeout, u = function (t, i) {
                    this._array = t, this.options = s({
                        useRaf: !1,
                        timeout: 0,
                        chunkSize: 1
                    }, i), this._isActive = !1, this._position = 0, this._callback = null, this._scheduler = null, this._nextChunkTimeout = null, this._nextChunkBinded = null
                };
                i(u, {
                    start: function (t) {
                        this._isActive || (this._isActive = !0, this._callback = t, this._nextChunkBinded = this._nextChunk.bind(this), this.options.useRaf ? (this._scheduler = new n(this._nextChunkBinded), this._scheduler.start()) : this._nextChunk())
                    }, stop: function () {
                        this._nextChunkTimeout && (h(this._nextChunkTimeout), this._nextChunkTimeout = null), this._scheduler && (this._scheduler.stop(), this._scheduler = null), this._nextChunkBinded = null, this._isActive = !1, this._callback = null, this._position = 0
                    }, isActive: function () {
                        return this._isActive
                    }, _nextChunk: function () {
                        for (var t = this.options, i = t.worker, s = this._array, n = s.length, h = 0; h < t.chunkSize && this._position < n; h++) i(s[this._position++]);
                        this._position == n ? (this._callback && this._callback(), this.stop()) : this._isActive && (t.useRaf ? this._scheduler.start() : this._nextChunkTimeout = e(this._nextChunkBinded, t.timeout))
                    }
                }), t(u)
            });
        }],
        [')l', function (ym) {
            ym.modules.define("util.coordinates.convert", ["util.coordinates.reverse"], function (o, n) {
                function t(o, t, r) {
                    if ("longlat" != t && "latlong" != t || "longlat" != r && "latlong" != r) throw new Error("util.coordinates.convert: bad coordinates convertion from " + t + " to " + r);
                    return t == r ? o : n(o)
                }

                o(t)
            });
        }],
        ['0J', function (ym) {
            ym.modules.define("constants.zIndex", [], function (e) {
                e({
                    layer: 200,
                    mapTypeLayer: 150,
                    overlay: 650,
                    icon: 675,
                    hover: 700,
                    drag: 725,
                    behavior: 750,
                    active: 755,
                    routeViaPointHover: 757,
                    balloon: 760,
                    activePoint: 775,
                    hint: 1100
                })
            });
        }],
        ['6T', function (ym) {
            ym.modules.define("layer.component.TileSource", ["util.hd", "util.math.cycleRestrict", "util.processUrlTemplate"], function (e, t, r, i) {
                var l = function (e) {
                    this._layer = e
                };
                l.prototype = {
                    getTileUrl: function (e, t) {
                        var r = this._layer.restrict(e, t), i = r ? this._renderTemplate(r, t) : null;
                        return i
                    }, restrict: function (e, t) {
                        var i = this._layer.getTileSize(t),
                            l = [Math.ceil(Math.pow(2, t + 8) / i[0]), Math.ceil(Math.pow(2, t + 8) / i[1])], n = e[0],
                            a = e[1], o = this._layer.options.get("projection").isCycled();
                        if (n < 0 || n >= l[0]) {
                            if (!o[0]) return null;
                            n = r(n, 0, l[0])
                        }
                        if (a < 0 || a >= l[1]) {
                            if (!o[1]) return null;
                            a = r(a, 0, l[1])
                        }
                        return [n, a]
                    }, _renderTemplate: function (e, r) {
                        var l = this._layer.getTileUrlTemplate();
                        if ("function" == typeof l) return l(e, r);
                        var n = t.getLimitedPixelRatio(), a = {tileNumber: e, zoom: r, scale: n < 1 ? 1 : n};
                        return "object" == typeof l ? {template: l, urlTemplateData: a} : i(l, a)
                    }
                }, e(l)
            });
        }],
        ['6S', function (ym) {
            ym.modules.define("layer.component.TilePositioner", ["util.math.cycleRestrict"], function (t, o) {
                var e = function (t) {
                    return [Math.round(t[0]), Math.round(t[1])]
                }, i = function (t) {
                    this._layer = t, this._projections = {self: null, parent: null, differ: !1}
                };
                i.prototype = {
                    numberToGlobalBounds: function (t, o, e) {
                        var i = this._layer.getTileSize(o), n = [i[0] * Math.pow(2, e - o), i[1] * Math.pow(2, e - o)],
                            r = [t[0] * n[0], t[1] * n[1]], s = [r, [r[0] + n[0], r[1] + n[1]]];
                        if (this._projections.differ) {
                            var l = {from: this._projections.self, to: this._projections.parent};
                            s = [this._convertGlobalPixelPoint(s[0], e, l), this._convertGlobalPixelPoint(s[1], e, l)]
                        }
                        return s
                    }, numberToClientBounds: function (t, o) {
                        var i = this.numberToGlobalBounds(t, o, this._layer.getZoom());
                        return [e(this._layer.toClientPixels(i[0])), e(this._layer.toClientPixels(i[1]))]
                    }, clientPixelsToNumber: function (t, o) {
                        var e = this._layer.getTileSize(o), i = this._layer.getZoom(),
                            n = [e[0] * Math.pow(2, i - o), e[1] * Math.pow(2, i - o)],
                            r = this._layer.fromClientPixels(t);
                        if (this._projections.differ) {
                            var s = {from: this._projections.parent, to: this._projections.self};
                            r = this._convertGlobalPixelPoint(r, i, s)
                        }
                        return [Math.floor(r[0] / n[0]), Math.floor(r[1] / n[1])]
                    }, onAddToMap: function (t) {
                        this._projections = this._resolveProjections(), this._layer.options.events.add("change", this._onOptionsChange, this)
                    }, onRemoveFromMap: function (t) {
                        this._layer.options.events.remove("change", this._onOptionsChange, this)
                    }, _resolveProjections: function () {
                        var t = this._layer, o = t.options.get("projection"),
                            e = t.getParent().options.get("projection");
                        return {self: o, parent: e, differ: o != e}
                    }, _onOptionsChange: function () {
                        var t = this._projections, o = this._resolveProjections();
                        t.self == o.self && t.parent == o.parent || (this._projections = o, this._layer.update())
                    }, _convertGlobalPixelPoint: function (t, e, i) {
                        var n = Math.pow(2, e + 8), r = i.to.isCycled(),
                            s = [r[0] ? Math.floor(t[0] / n) * n : 0, r[1] ? Math.floor(t[1] / n) * n : 0],
                            l = [r[0] ? o(t[0], 0, n) : t[0], r[1] ? o(t[1], 0, n) : t[1]],
                            a = i.from.fromGlobalPixels(l, e), h = i.to.toGlobalPixels(a, e);
                        return [h[0] + s[0], h[1] + s[1]]
                    }
                }, t(i)
            });
        }],
        ['8b', function (ym) {
            ym.modules.define("map.pane.helper.ground", ["pane.MovablePane", "constants.paneZIndex", "map.pane.helper.storage", "map.metaOptions", "theme.browser.current"], function (e, n, a, r, o) {
                r.add("ground", function (e) {
                    return new n(e, {zIndex: a.ground, margin: o.get("groundPaneViewportMargin", 128)})
                }), e({})
            });
        }],
        [':j', function (ym) {
            ym.modules.define('layer.domTileNotFound.css', ["not-found-tile"], function (provide) {
                provide({});
            });
        }],
        ['0.', function (ym) {
            ym.modules.define("component.ProviderObserver", ["util.defineClass", "util.array", "util.id", "vow"], function (e, t, r, s, i) {
                var n = function (e) {
                    this._providers = [], this._stricts = [], this._requests = {}, this._parameters = e
                };
                t(n, {
                    destroy: function () {
                        this._providers = [];
                        for (var e in this._requests) if (this._requests.hasOwnProperty(e)) {
                            var t = this._requests[e];
                            t.deferred.reject("noProvider"), window.clearTimeout(t.timeout)
                        }
                    }, addProvider: function (e, t) {
                        return r.indexOf(this._providers, e) == -1 && (this._providers.push(e), this._stricts.push(t), this._parameters.changeCallback && (this._parameters.changeEventType && e.events.add(this._parameters.changeEventType, this._parameters.changeCallback, this), this._parameters.changeCallback())), this
                    }, removeProvider: function (e) {
                        var t = r.indexOf(this._providers, e);
                        return t != -1 && (this._providers.splice(t, 1), this._stricts.splice(t, 1), this._parameters.changeCallback && (this._parameters.changeEventType && e.events.remove(this._parameters.changeEventType, this._parameters.changeCallback, this), this._parameters.changeCallback())), this
                    }, get: function (e) {
                        var t = i.defer(), r = {resolved: [], rejected: [], stricts: [], timeoutExceeded: 0},
                            n = this._requests, a = [], o = this._providers.slice(), h = o.length, d = this._stricts;
                        if (h) {
                            for (var c = {deferred: t, result: r, pending: h, answers: []}, u = function (e) {
                                return function (t) {
                                    a[e].ready = !0, a[e].result = t, --c.pending || l()
                                }
                            }, p = function (e) {
                                return function (t) {
                                    a[e].ready = !0, a[e].result = t, a[e].rejected = !0, --c.pending || l()
                                }
                            }, l = function () {
                                window.clearTimeout(c.timeout), delete n[s.get(c)];
                                for (var e = 0; e < h; e++) a[e].ready && (a[e].rejected ? r.rejected.push(a[e].result) : (r.resolved.push(a[e].result), r.stricts.push(d[e])));
                                t.resolve(r)
                            }, v = 0; v < h; v++) a[v] = {}, this._parameters.makeRequest(this._providers[v], e).then(u(v), p(v));
                            c.pending && (n[s.get(c)] = c, c.timeout = window.setTimeout(function () {
                                r.timeoutExceeded = c.pending, l()
                            }, this._parameters.requestTimeout || 3e4))
                        } else t.reject("noProvider");
                        return t.promise()
                    }
                }), e(n)
            });
        }],
        ['0;', function (ym) {
            ym.modules.define("component.ZoomRangeObserver", ["util.defineClass", "component.ProviderObserver", "vow"], function (e, r, n, t) {
                var o = function (e) {
                    o.superclass.constructor.call(this, {
                        changeEventType: "zoomrangechange",
                        changeCallback: e,
                        makeRequest: function (e, r) {
                            return e.getZoomRange(r)
                        }
                    })
                };
                r(o, n, {
                    get: function (e) {
                        var r, n, a = t.defer();
                        return o.superclass.get.call(this, e).then(function (e) {
                            if (e.resolved.length) {
                                var t = e.resolved[0].slice();
                                for (r = 1, n = e.resolved.length; r < n; r++) {
                                    var o = e.stricts[r];
                                    t = [(o ? Math.max : Math.min)(t[0], e.resolved[r][0]), (o ? Math.min : Math.max)(t[1], e.resolved[r][1])]
                                }
                                a.resolve(t)
                            } else {
                                var s = !0;
                                for (r = 0, n = e.rejected.length; r < n; r++) if ("noProvider" != e.rejected[r]) {
                                    s = !1;
                                    break
                                }
                                s ? a.reject("noProvider") : a.reject("noData")
                            }
                        }, function (e) {
                            a.reject(e)
                        }), a.promise()
                    }
                }), e(o)
            });
        }],
        [',N', function (ym) {
            ym.modules.define("util.shapeFactory", ["geometry.pixel.Rectangle", "geometry.pixel.Circle", "geometry.pixel.Polygon", "geometry.pixel.MultiPolygon", "shape.Rectangle", "shape.Circle", "shape.Polygon", "shape.MultiPolygon"], function (e, n, o, t, r, l, a, i, c) {
                var s = {
                    create: function (e) {
                        switch (e.type) {
                            case"Rectangle":
                                return new l(new n(e.coordinates));
                            case"Circle":
                                return new a(new o(e.coordinates, e.radius));
                            case"Polygon":
                                return new i(new t(e.coordinates));
                            case"MultiPolygon":
                                return new c(new r(e.coordinates))
                        }
                    }
                };
                e(s)
            });
        }],
        ['6;', function (ym) {
            ym.modules.define("layout.pieChart.builder", ["util.array", "util.base64", "graphics.util.color"], function (t, r, e, i) {
                var o = {
                    generateIconDataUri: function (t) {
                        var r = this._drawIcon(t);
                        return "data:image/svg+xml;base64," + e.encode(r)
                    }, _drawIcon: function (t) {
                        var e = t.pieChartRadius, i = t.pieChartStrokeWidth, o = t.pieChartStrokeStyle,
                            a = Math.round(e + i / 2), n = 2 * a, s = [a, a], h = 0, d = 0;
                        r.each(t.data, function (t) {
                            t.weight > 0 && (d += t.weight, h++)
                        });
                        var c = [];
                        if (h >= 1) {
                            var l = t.data.filter(function (t) {
                                return t.weight > 0
                            }).sort(function (t, r) {
                                return r.weight - t.weight
                            });
                            c.push(this._drawCircle({
                                center: s,
                                radius: e,
                                fill: l[0].color,
                                stroke: o,
                                strokeWidth: i
                            }));
                            for (var u = 270 + 360 * l[0].weight / d, p = 1; p < l.length; p++) {
                                var w = u + 360 * l[p].weight / d;
                                c.push(this._drawSector({
                                    center: s,
                                    radius: e,
                                    startAt: u,
                                    endAt: w,
                                    fill: l[p].color,
                                    stroke: o,
                                    strokeWidth: i
                                })), u = w
                            }
                        }
                        return c.push(this._drawCircle({
                            center: s,
                            radius: t.pieChartCoreRadius,
                            fill: t.pieChartCoreFillStyle,
                            stroke: "transparent",
                            strokeWidth: 0
                        })), '<svg viewbox="0 0 ' + n + " " + n + '" width="' + n + '" height="' + n + '" xmlns="http://www.w3.org/2000/svg" version="1.1">' + c.join("") + "</svg>"
                    }, _drawSector: function (t) {
                        var r = t.radius, e = Math.PI / 180,
                            i = ["M " + t.center.join(" "), "L", Math.round(t.center[0] + r * Math.cos(t.startAt * e)), Math.round(t.center[1] + r * Math.sin(t.startAt * e)), "A " + r + " " + r + " 0 " + (t.endAt - t.startAt > 180 ? "1 " : "0 ") + "1", Math.round(t.center[0] + r * Math.cos(t.endAt * e)), Math.round(t.center[0] + r * Math.sin(t.endAt * e)), "z"].join(" ");
                        return "<path " + ['d="' + i + '"', 'fill="' + this._prepareColor(t.fill) + '"', 'stroke="' + this._prepareColor(t.stroke) + '"', 'stroke-width="' + t.strokeWidth + '"', 'stroke-linejoin="round"'].join(" ") + " />"
                    }, _drawCircle: function (t) {
                        return "<circle " + ['cx="' + t.center[0] + '"', 'cy="' + t.center[1] + '"', 'r="' + t.radius + '"', 'stroke="' + this._prepareColor(t.stroke) + '"', 'stroke-width="' + t.strokeWidth + '"', 'fill="' + this._prepareColor(t.fill) + '"'].join(" ") + "/>"
                    }, _prepareColor: function (t) {
                        return 0 === t.indexOf("#") ? i.convert(t) : t
                    }
                };
                t({getDataUri: o.generateIconDataUri.bind(o)})
            });
        }],
        ['6j', function (ym) {
            ym.modules.define('layout.pieChart.html', [], function (provide) {
                provide([0, "<ymaps class=\"ymaps-2-1-76-pie-chart\"><ymaps class=\"ymaps-2-1-76-pie-chart-icon ymaps-2-1-76-patched-for-print\"></ymaps><ymaps class=\"ymaps-2-1-76-pie-chart-content\"></ymaps></ymaps>", 2003, "data.get(\"properties.iconCaption\")", 0, "<ymaps class=\"ymaps-2-1-76-pie-chart-caption\">", 2001, ["properties.iconCaption", []], 0, "</ymaps>", 2005, null]);
            });
        }],
        ['6q', function (ym) {
            ym.modules.define('layout.pieChart.css', ["system.provideCss"], function (provide, systemProvideCss) {
                systemProvideCss('.ymaps-2-1-76-pie-chart,.ymaps-2-1-76-pie-chart-caption{position:absolute;display:block;font-family:Arial,sans;font-size:13px}.ymaps-2-1-76-pie-chart{text-align:center;background-size:100% 100%;overflow:visible;z-index:1}.ymaps-2-1-76-pie-chart-caption{-webkit-transform:translate(-50%,0);transform:translate(-50%,0);background-color:rgba(255,255,255,.8);border-radius:3px;padding:0 8px;line-height:24px;max-width:200px;box-sizing:border-box;text-overflow:ellipsis;overflow:hidden;white-space:nowrap;z-index:-1}.ymaps-2-1-76-pie-chart-content,.ymaps-2-1-76-pie-chart-icon{position:absolute;top:0;left:0;height:100%;width:100%}.ymaps-2-1-76-pie-chart-icon{z-index:0}.ymaps-2-1-76-pie-chart-content{z-index:1}', provide);
            });
        }],
        ['6i', function (ym) {
            ym.modules.define("layout.pieChart.metaOptions", ["map.metaOptions"], function (t, e) {
                var o = function (t) {
                    for (var e = 0, o = 0, r = t.length; o < r; o++) e += t[o].weight;
                    return 25 + 2 * Math.floor(Math.log(e))
                }, r = function (t) {
                    for (var e = 0, o = 0, r = t.length; o < r; o++) e += t[o].weight;
                    return 10 + 2 * Math.floor(Math.log(e))
                };
                e.set({
                    geoObjectIconPieChartStrokeStyle: "white",
                    geoObjectIconPieChartStrokeWidth: 2,
                    geoObjectIconPieChartCoreRadius: r,
                    geoObjectIconPieChartRadius: o,
                    geoObjectIconPieChartCoreFillStyle: "white",
                    geoObjectPieChartCaptionMaxWidth: 200,
                    clusterIconPieChartStrokeStyle: "white",
                    clusterIconPieChartStrokeWidth: 2,
                    clusterIconPieChartCoreRadius: r,
                    clusterIconPieChartRadius: o,
                    clusterIconPieChartCoreFillStyle: "white",
                    clusterIconPieChartCaptionMaxWidth: 200
                }), t(!0)
            });
        }],
        [')h', function (ym) {
            ym.modules.define("util.ContentSizeObserver", ["event.Manager", "Event", "util.ImageLoadObserver", "util.nodeSize"], function (e, t, n, i, r) {
                function s(e, n, i, r) {
                    this._element = e, this._params = n || {}, this._timer = "undefined" != typeof i ? i : 100, this._imageLoadObserver = null, this._listeners = null, this._nodeSizeByContent = null, this._currentInterval = null, this.events = new t
                }

                s.prototype = {
                    observe: function () {
                        var e, t = !1, n = this;
                        this.destroy(), this._recount(), this._imageLoadObserver = new i(this._element), this._listeners = this._imageLoadObserver.events.group().add("imageload", function () {
                            "number" == typeof n._timer ? t = !0 : n._recount()
                        }, this), "number" == typeof this._timer && (this._listeners.add("complete", function () {
                            e = !0
                        }), this._currentInterval = setInterval(function () {
                            t && (n._recount(), t = !1), e && n.destroy()
                        }, this._timer))
                    }, destroy: function () {
                        this._imageLoadObserver && (this._listeners.removeAll(), this._imageLoadObserver.destroy(), this._imageLoadObserver = null), this._currentInterval && (clearInterval(this._currentInterval), this._currentInterval = null)
                    }, _recount: function () {
                        var e = r.computeByContent(this._element, this._params);
                        this._isSizeChanged(this._nodeSizeByContent, e) && (this._nodeSizeByContent = e, this._fire())
                    }, _isSizeChanged: function (e, t) {
                        if (!e || !t || typeof e != typeof t) return !0;
                        for (var n = 0, i = ["height", "width", "overflowX", "overflowY"], r = i.length; n < r; n++) if (e[i[n]] != t[i[n]]) return !0;
                        return !1
                    }, _fire: function () {
                        this.events.fire("sizechange", new n({
                            target: this._element,
                            sizeByContent: this._nodeSizeByContent || {}
                        }))
                    }
                }, e(s)
            });
        }],
        ['7b', function (ym) {
            ym.modules.define("layout.SubLayoutEventMappingTable", ["util.defineClass", "constants.mapDomEvents", "Event", "util.array"], function (t, e, n, a, i) {
                function s(t) {
                    this._parentLayout = t, i.each(n, function (t) {
                        "mousenter" == t || "mouseleave" == t ? this[t] = !1 : this[t] = this._defaultMapping
                    }, this), this.parentelementchange = !1, this.emptinesschange = !1, this.shapechange = !1, this["*"] = this._defaultMapping
                }

                e(s, {
                    _defaultMapping: function (t) {
                        return new a({
                            type: t.get("type"),
                            target: t.get("target"),
                            currentTarget: this._parentLayout
                        }, t)
                    }
                }), t(s)
            });
        }],
        ['9W', function (ym) {
            ym.modules.define("BaseObjectManager", ["util.defineClass", "option.Manager", "data.Manager", "vow", "Event", "Monitor", "objectManager.optionMapper", "geoObject.optionMapper", "objectManager.component.ClusterListener", "objectManager.component.Filter", "util.array", "util.extend", "event.Mapper", "objectManager.CollectionMappingTable"], function (e, t, n, i, s, o, l, r, c, a, h, u, b, _, d) {
                function j(e, t) {
                    return t + e.slice(0, 1).toUpperCase() + e.slice(1)
                }

                function f(e, t) {
                    var n = e.replace(t, "");
                    return n.slice(0, 1).toLowerCase() + n.slice(1)
                }

                function g(e, t) {
                    var n = [];
                    return u.each(e, function (e) {
                        u.indexOf(t, e) == -1 && n.push(e)
                    }), n
                }

                var p = {
                    geoObjectBalloonManager: "objectManager#balloon",
                    geoObjectHintManager: "objectManager#hint",
                    clusterHintManager: "objectManager#hint",
                    clusterBalloonManager: "objectManager#balloon"
                }, O = function (e, t) {
                    this._eventManager = t.events, this.geometry = null, this.options = new n(b({}, p, e), (void 0), "objectManager", r), this.options.events.add("change", this._onOptionsChange, this), this.properties = new i, this.state = new i, this._objectsCollection = t.objects, this._objectsCollection.options.setParent(this.options), this._clustersCollection = t.clusters, this._clustersCollection.options.setParent(this.options), this._clusterListener = new a(this);
                    var s = new _(this._eventManager, new d(this));
                    this._objectsCollection.events.setParent(s), this._clustersCollection.events.setParent(s), this._components = t
                };
                O.NoOverlayError = function () {
                    return new Error("ObjectManager doesn't have an overlay.")
                }, t(O, {
                    getOverlay: function () {
                        return s.reject(new O.NoOverlayError)
                    }, getOverlaySync: function () {
                        return null
                    }, onAddToMap: function (e) {
                        this._startObjectCollectionListening(), this._showObjects(), this._clusterListener.setMap(e)
                    }, onRemoveFromMap: function (e) {
                        this._clusterListener.setMap(null), this._hideObjects(), this._stopObjectCollectionListening()
                    }, setFilter: function (e) {
                        if (e != this._filterFunction) {
                            var t, n = this._filter, i = [], s = [];
                            n && (i = n.getFilteredObjects(), n.destroy()), this._filterFunction = e, e ? (this._filter = new h(e), this._filter.add(this._objectsCollection.getAll()), t = this._filter.getFilteredObjects(), i.length && (s = g(i, t)), this.getMap() && (this._removeDisplayedObjects(t), s.length && this._addDisplayedObjects(s))) : i.length && (this._filter = null, this._addDisplayedObjects(i))
                        }
                        return this
                    }, getFilter: function () {
                        return this._filterFunction
                    }, getObjectState: function (e) {
                        var t = {found: !1};
                        if (this.getMap()) {
                            var n = this._objectsCollection.getById(e);
                            n && (t = {found: !0, isFilteredOut: !!this._filter && this._filter.isFilteredOut(n)})
                        }
                        return t
                    }, _addDisplayedObjects: function (e) {
                        this._components.addDisplayedObjects.callback.call(this._components.addDisplayedObjects.context, e)
                    }, _removeDisplayedObjects: function (e) {
                        this._components.removeDisplayedObjects.callback.call(this._components.removeDisplayedObjects.context, e)
                    }, _startObjectCollectionListening: function () {
                        this._objectCollectionListener = this._objectsCollection.events.group().add("objectsadd", this._onObjectsAdd, this).add("objectsremove", this._onObjectsRemove, this)
                    }, _stopObjectCollectionListening: function () {
                        this._objectCollectionListener.removeAll()
                    }, _onObjectsAdd: function (e) {
                        var t = e.get("objects"), n = [];
                        if (this._filter && this._filter.add(t), this._filter) for (var i = 0, s = t.length; i < s; i++) this._filter.isFilteredOut(t[i]) || n.push(t[i]); else n = t;
                        this._addDisplayedObjects(n)
                    }, _onObjectsRemove: function (e) {
                        var t = e.get("objects"), n = [];
                        if (this._filter) for (var i = 0, s = t.length; i < s; i++) this._filter.isFilteredOut(t[i]) || n.push(t[i]); else n = t;
                        this._filter && this._filter.remove(t), this._removeDisplayedObjects(n)
                    }, _showObjects: function () {
                        if (this._objectsCollection.getLength()) {
                            var e;
                            e = this._filter ? this._filter.getValidObjects() : this._objectsCollection.getAll(), this._addDisplayedObjects(e)
                        }
                    }, _hideObjects: function () {
                        if (this._objectsCollection.getLength()) {
                            var e = this._components.removeAll;
                            e.callback.call(e.context)
                        }
                    }, _onOptionsChange: function () {
                        this.events.fire("optionschange")
                    }
                }), r.setRule({
                    name: "objectCollection", rule: function (e, t) {
                        return [j(e, "geoObject"), e]
                    }
                }), r.setRule({
                    name: "clusterCollection", rule: function (e, t) {
                        return [j(e, "cluster"), e]
                    }
                }), c.setRule({
                    name: "objectManager", rule: function (e, t) {
                        return 0 == e.indexOf("geoObject") ? f(e, "geoObject") : e
                    }
                }), c.setRule({name: "objectManager", key: ["projection"], rule: "plain"}), e(O)
            });
        }],
        ['9!', function (ym) {
            ym.modules.define("objectManager.component.OnceLoadingDataController", ["util.defineClass", "objectManager.component.BaseDataLoadController", "objectManager.component.TileLoadTree", "objectManager.parseData", "objectManager.util"], function (e, t, a, o, n, r) {
                var i = function (e) {
                    i.superclass.constructor.call(this, e), this._tileLoadTree = new o(e)
                };
                t(i, a, {
                    onMapZoomChange: function (e) {
                        var t = e.get("newTileBounds"),
                            a = this.getNotLoadedTiles(r.getTilesArrayFromTileBoundsArray(t, Math.round(this.context.getMap().getZoom())));
                        a.length && this.loadData(a)
                    }, getNotLoadedTiles: function (e) {
                        for (var t, a, o = [], n = 0, r = e.length; n < r; n++) t = e[n].tileNumber, a = e[n].zoom, this._tileLoadTree.isTileLoaded(t, a) || (o = o.concat(this._tileLoadTree.getMissingTiles(t, a)));
                        return o
                    }, onDataLoad: function (e, t) {
                        for (var a = 0, o = e.length; a < o; a++) this._tileLoadTree.addLoadedTile(e[a].tileNumber, e[a].zoom);
                        for (var r = [], a = 0, o = t.length; a < o; a++) r = r.concat(n(t[a]));
                        this.storage.add(r), this._showData(e), i.superclass.onDataLoad.call(this, e, t)
                    }, reloadData: function () {
                        this._tileLoadTree.clear(), i.superclass.reloadData.call(this)
                    }, _showData: function (e) {
                        for (var t = 0, a = e.length; t < a; t++) this.events.fire("statechange", {
                            added: this._getTileDataFromStorage(e[t].tileNumber, e[t].zoom),
                            removed: []
                        })
                    }
                }), e(i)
            });
        }],
        ['9z', function (ym) {
            ym.modules.define("objectManager.component.View", ["util.defineClass", "vow", "util.cancelableCallback", "geometry.pixel.Point", "overlay.storage", "option.Manager", "option.Router", "Event", "util.id", "constants.zIndex", "objectManager.objectCollection.overlayOptionMapper", "objectManager.clusterCollection.overlayOptionMapper", "util.extend", "objectManager.component.createGeometry", "util.Chunker"], function (e, t, s, o, r, i, a, n, l, c, h, v, _, u, g, d) {
                var y = function (e, t, s) {
                    this._context = e, this._objectsEditingEventManager = t, this._clustersEditingEventManager = s, this._contextListener = null, this._overlayStorageCallbacks = {}, this._overlayCreateCallbacks = {}, this._objectCollectionListener = null, this._clusterCollectionListener = null, this._overlayListeners = {}, this._startObjectManagerListening(), this._startListeningObjectCollection(), this._startListeningClusterCollection(), this._startOverlaysListening(), this._geometries = {}, this._geometriesListeners = {}, this._chunker = null, this._removeFromMapQueue = {}
                };
                t(y, {
                    setObjectManager: function (e) {
                        e != this._context && (this._context && this._onObjectManagerRemove(), this._context = e, this._context && this._onObjectManagerAdd())
                    }, destroy: function () {
                        this._stopOverlaysListening(), this._stopListeningClusterCollection(), this._stopListeningObjectCollection(), this._stopObjectManagerListening(), this._clearOverlayCreateCallbacks(), this._clearOverlayStorageCallbacks()
                    }, _startObjectManagerListening: function () {
                        this._contextListener = this._context.events.group().add("statechange", this._onStateChange, this)
                    }, _stopObjectManagerListening: function () {
                        this._contextListener.removeAll()
                    }, _startListeningObjectCollection: function () {
                        this._objectCollectionListener = this._context.objects.events.group().add("objectoptionschange", this._onObjectOptionsChange, this).add("objectpropertieschange", this._onObjectPropertiesChange, this)
                    }, _stopListeningObjectCollection: function () {
                        this._objectCollectionListener.removeAll()
                    }, _startListeningClusterCollection: function () {
                        this._clusterCollectionListener = this._context.clusters.events.group().add("clusteroptionschange", this._onClusterOptionsChange, this).add("clusterpropertieschange", this._onClusterPropertiesChange, this)
                    }, _stopListeningClusterCollection: function () {
                        this._clusterCollectionListener.removeAll()
                    }, _startOverlaysListening: function () {
                        this._context.objects.overlays.events.add("mouseenter", this._onOverlayMouseEnter, this).add(["mouseleave", "mapchange"], this._onOverlayMouseLeave, this), this._context.clusters.overlays.events.add("mouseenter", this._onOverlayMouseEnter, this).add(["mouseleave", "mapchange"], this._onOverlayMouseLeave, this)
                    }, _stopOverlaysListening: function () {
                        this._context.objects.overlays.events.remove("mouseenter", this._onOverlayMouseEnter, this).remove(["mouseleave", "mapchange"], this._onOverlayMouseLeave, this), this._context.clusters.overlays.events.remove("mouseenter", this._onOverlayMouseEnter, this).remove(["mouseleave", "mapchange"], this._onOverlayMouseLeave, this)
                    }, _onObjectOptionsChange: function (e) {
                        var t = e.get("objectId"), s = this._context.objects.overlays.getById(t);
                        s && this._setParentOptionManager(s, this._context.objects.getById(t), "object")
                    }, _onClusterOptionsChange: function (e) {
                        var t = e.get("objectId"), s = this._context.clusters.overlays.getById(t);
                        s && this._setParentOptionManager(s, this._context.clusters.getById(t), "cluster")
                    }, _onObjectPropertiesChange: function (e) {
                        var t = e.get("objectId"), s = this._context.objects.overlays.getById(t);
                        s && s.setData(this._context.objects.getById(t))
                    }, _onClusterPropertiesChange: function (e) {
                        var t = e.get("objectId"), s = this._context.clusters.overlays.getById(t);
                        s && s.setData(this._context.clusters.getById(t))
                    }, _onStateChange: function (e) {
                        var t = e.get("added"), s = e.get("removed"), o = e.get("update"), r = e.get("addedClusters"),
                            i = e.get("removedClusters"), a = e.get("sync");
                        a ? (s && s.length && this._removeObjectsFromMapSync(s), i && i.length && this._removeClustersFromMapSync(i)) : (s && s.length && this._removeObjectsFromMap(s), i && i.length && this._removeClustersFromMap(i)), r && r.length && this._addClustersToMap(r), t && t.length && this._addObjectsToMap(t), o && o.length && this._updateObjects(o)
                    }, _addObjectsToMap: function (e) {
                        for (var t = 0, s = e.length; t < s; t++) this._removeFromMapQueue[e[t].id] ? delete this._removeFromMapQueue[e[t].id] : this._setupObjectView(e[t], "object")
                    }, _removeObjectsFromMap: function (e) {
                        for (var t = 0, s = e.length; t < s; t++) this._removeFromMapQueue[e[t].id] = !0;
                        new d(e, {worker: this._removeObjectFromMap.bind(this), chunkSize: 1e3, useRaf: !0}).start()
                    }, _removeClustersFromMap: function (e) {
                        for (var t = 0, s = e.length; t < s; t++) this._removeFromMapQueue[e[t].id] = !0;
                        new d(e, {worker: this._removeClusterFromMap.bind(this), chunkSize: 1e3, useRaf: !0}).start()
                    }, _removeObjectsFromMapSync: function (e) {
                        for (var t = 0, s = e.length; t < s; t++) {
                            var o = e[t];
                            this._removeFromMapQueue[o.id] = !0, this._removeObjectFromMap(o)
                        }
                    }, _removeClustersFromMapSync: function (e) {
                        for (var t = 0, s = e.length; t < s; t++) {
                            var o = e[t];
                            this._removeFromMapQueue[o.id] = !0, this._removeClusterFromMap(o)
                        }
                    }, _removeObjectFromMap: function (e) {
                        this._removeFromMapQueue[e.id] && (this._clearOverlayData(e, "object"), this._destroyObjectView(e, "object"), delete this._removeFromMapQueue[e.id])
                    }, _addClustersToMap: function (e) {
                        for (var t = 0, s = e.length; t < s; t++) this._removeFromMapQueue[e[t].id] ? delete this._removeFromMapQueue[e[t].id] : this._setupObjectView(e[t], "cluster")
                    }, _removeClusterFromMap: function (e) {
                        this._removeFromMapQueue[e.id] && (this._clearOverlayData(e, "cluster"), this._destroyObjectView(e, "cluster"), delete this._removeFromMapQueue[e.id])
                    }, _setupObjectView: function (e, t) {
                        var s = e.id;
                        if (this._context.options.get("syncOverlayInit", !1)) {
                            var r = this._createObjectOverlaySync(e);
                            this._addOverlayToMap(r, e, t)
                        } else this._overlayCreateCallbacks[s] = o.create(function (o) {
                            this._overlayCreateCallbacks[s] && delete this._overlayCreateCallbacks[s], this._addOverlayToMap(o, e, t)
                        }, this), this._createObjectOverlay(e).done(this._overlayCreateCallbacks[s])
                    }, _addOverlayToMap: function (e, t, s) {
                        var o = "object" == s,
                            r = new l({target: this, type: "addoverlay", objectId: t.id, overlay: e});
                        o ? this._objectsEditingEventManager.fire("addoverlay", r) : this._clustersEditingEventManager.fire("addoverlay", r);
                        var i = null != (o ? this._context.objects.overlays.getById(t.id) : this._context.clusters.overlays.getById(t.id));
                        i && (this._setParentOptionManager(e, t, s), e.setMap(this._context.getMap()))
                    }, _clearOverlayData: function (e, t) {
                        var s = e.id;
                        this._geometries[s] && (this._geometries[s].setMap(null), delete this._geometries[s], this._geometriesListeners[e.id].removeAll(), delete this._geometriesListeners[e.id]), this._overlayCreateCallbacks[s] && (this._overlayCreateCallbacks[s].cancel(), delete this._overlayCreateCallbacks[s]), this._overlayStorageCallbacks[s] && (this._overlayStorageCallbacks[s].cancel(), delete this._overlayStorageCallbacks[s])
                    }, _destroyObjectView: function (e, t) {
                        var s = e.id, o = "object" == t,
                            r = o ? this._context.objects.overlays.getById(s) : this._context.clusters.overlays.getById(s);
                        if (r) {
                            r.setMap(null), r.options.setParent(null);
                            var i = new l({type: "remove", target: this, overlay: r, objectId: s});
                            o ? this._objectsEditingEventManager.fire("removeoverlay", i) : this._clustersEditingEventManager.fire("removeoverlay", i)
                        }
                    }, _createObjectOverlay: function (e) {
                        var t = s.defer();
                        return this._getOverlay(e, function (s) {
                            var o = this._createOverlay(s, e);
                            t.resolve(o)
                        }), t.promise()
                    }, _createObjectOverlaySync: function (e) {
                        var t = this._getOverlaySync(e);
                        return this._createOverlay(t, e)
                    }, _createOverlay: function (e, t) {
                        return new e(this._createPixelGeometry(t), t)
                    }, _updateOverlay: function (e, t) {
                        t && t.setGeometry(this._createPixelGeometry(e))
                    }, _updateObjects: function (e) {
                        for (var t, s = 0, o = e.length; s < o; s++) t = this._context.objects.overlays.getById(e[s].id) || this._context.clusters.overlays.getById(e[s].id), t && "Point" == e[s].geometry.type && this._updateOverlay(e[s], t)
                    }, _getOverlay: function (e, t) {
                        var s = this._resolveOverlay(e), r = i.get(s);
                        "undefined" == typeof r ? (this._overlayStorageCallbacks[e.id] = o.create(function (s) {
                            this._overlayStorageCallbacks[e.id] && delete this._overlayStorageCallbacks[e.id], t.call(this, s)
                        }, this), i.require([s], this._overlayStorageCallbacks[e.id])) : t.call(this, r)
                    }, _getOverlaySync: function (e) {
                        var t = this._resolveOverlay(e);
                        return i.get(t)
                    }, _resolveOverlay: function (e) {
                        var t = null != this._context.objects.getById(e.id),
                            s = t ? this._context.objects.options : this._context.clusters.options;
                        return e.options && e.options.overlay || s.get(e.geometry.type + "Overlay", "default#placemark")
                    }, _setParentOptionManager: function (e, t, s) {
                        var o = "object" == s,
                            r = o ? this._context.objects.overlays.options : this._context.clusters.overlays.options;
                        if (t.options) {
                            var i = new a(t.options);
                            o ? i.setMapper(v) : i.setMapper(_), e.options.setParent(new n(i, r))
                        } else e.options.setParent(r);
                        this._setOverlayZIndex(e, "zIndex", this._isMouseOver ? "hover" : "overlay")
                    }, _onOverlayMouseEnter: function (e) {
                        this._isMouseOver = !0, this._setupHoverZIndex(e.get("overlay"))
                    }, _onOverlayMouseLeave: function (e) {
                        this._isMouseOver = !1, this._clearOverlayZIndex(e.get("overlay"))
                    }, _setupHoverZIndex: function (e) {
                        this._setOverlayZIndex(e, "zIndexHover", "hover")
                    }, _clearOverlayZIndex: function (e) {
                        this._setOverlayZIndex(e, "zIndex", "overlay")
                    }, _setOverlayZIndex: function (e, t, s) {
                        var o = e.options.getParent(), r = o.resolve(t), i = o.resolve("interactiveZIndex");
                        "undefined" == typeof i && (i = !0), "auto" == i && (i = "Point" == e.getGeometry().getType()), i && (r || (r = o.resolve("icon" + t.charAt(0).toUpperCase() + t.substr(1))), e.options.set("zIndex", r || h[s]))
                    }, _clearOverlayCreateCallbacks: function () {
                        for (var e in this._overlayCreateCallbacks) this._overlayCreateCallbacks.hasOwnProperty(e) && this._overlayCreateCallbacks[e].cancel()
                    }, _clearOverlayStorageCallbacks: function () {
                        for (var e in this._overlayStorageCallbacks) this._overlayStorageCallbacks.hasOwnProperty(e) && this._overlayStorageCallbacks[e].cancel()
                    }, _createPixelGeometry: function (e) {
                        return "Point" == e.geometry.type ? new r(this._context.options.get("projection").toGlobalPixels(e.geometry.coordinates, this._context.getMap().getZoom())) : (this._geometries[e.id] || (this._geometries[e.id] = g(e, this._context.options.get("projection")), this._geometries[e.id].setMap(this._context.getMap()), this._geometriesListeners[e.id] = this._geometries[e.id].events.group().add("pixelgeometrychange", function () {
                            this._updateOverlay(e, this._context.objects.overlays.getById(e.id))
                        }, this)), this._geometries[e.id].getPixelGeometry())
                    }
                }), e(y)
            });
        }],
        ['9@', function (ym) {
            ym.modules.define("objectManager.component.ObjectControllerAddon", ["util.defineClass", "Monitor", "clusterer.component.GridClusterer", "objectManager.component.ObjectController", "option.Manager", "event.Manager"], function (e, t, o, n, r, s, i) {
                var l = function (e, t) {
                    this._context = e, this._map = null, this._objectController = null, this._objectControllerListener = null, this._parameters = t || {}, this.events = new i({context: this})
                };
                t(l, {
                    setMap: function (e) {
                        this._map = e, e ? this._addToMap(e) : this._removeFromMap(e)
                    }, getController: function () {
                        return this._objectController
                    }, _addToMap: function (e) {
                        this._setupObjectController(), this._parameters.clusteringDisabled || (this._optionMonitor = new o(this._context.options).add(["clusterize"], this._onClusterizeChange, this))
                    }, _removeFromMap: function (e) {
                        this._optionMonitor && this._optionMonitor.destroy(), this._clearObjectController()
                    }, _setupObjectController: function () {
                        !this._parameters.clusteringDisabled && this._context.options.get("clusterize", !1) ? this._objectController = new n(new s((void 0), this._context.options, "clusterer")) : this._objectController = new r(this._context.options), this._objectControllerListener = this._objectController.events.group().add("statechange", function (e) {
                            this._fireStateChange({
                                added: e.get("added"),
                                removed: e.get("removed"),
                                addedClusters: e.get("addedClusters"),
                                removedClusters: e.get("removedClusters"),
                                update: e.get("update"),
                                sync: e.get("sync")
                            })
                        }, this).add("pixelboundschange", function () {
                            this.events.fire("pixelboundschange")
                        }, this), this._objectController.setMap(this._context.getMap())
                    }, _clearObjectController: function () {
                        this._objectController && (this._objectController.destroy(), this._objectControllerListener.removeAll())
                    }, _onClusterizeChange: function () {
                        var e = [];
                        this._objectController && (e = this._objectController.getAll()), this._clearObjectController(), this._setupObjectController(), this._objectController && this._objectController.add(e)
                    }, _fireStateChange: function (e) {
                        this.events.fire("statechange", {
                            added: e.added || [],
                            removed: e.removed || [],
                            addedClusters: e.addedClusters || [],
                            removedClusters: e.removedClusters || [],
                            update: e.update || [],
                            sync: e.sync
                        })
                    }
                }), e(l)
            });
        }],
        ['9i', function (ym) {
            ym.modules.define("objectManager.component.TileSource", ["util.processUrlTemplate", "util.defineClass"], function (e, t, n) {
                function a(e) {
                    this._objectManager = e
                }

                n(a, {
                    getTileUrl: function (e) {
                        var n = this._objectManager;
                        return t(n.getUrlTemplate(), e)
                    }, getPadding: function (e) {
                        var n = this._objectManager.options.get("paddingTemplate", null);
                        return n ? t(n, e).replace(/\W/g, "_") : null
                    }
                }), e(a)
            });
        }],
        ['7.', function (ym) {
            ym.modules.define("map.event.Manager", ["util.defineClass", "event.Manager", "MapEvent", "util.extend"], function (e, t, n, a, c) {
                function r(e) {
                    r.superclass.constructor.call(this, e)
                }

                t(r, n, {
                    createEventObject: function (e, t, n) {
                        return new a(c({type: e, target: n, map: n}, t))
                    }
                }), e(r)
            });
        }],
        ['7U', function (ym) {
            ym.modules.define("map.action.Sequence", ["util.extend", "map.action.Single"], function (t, i, n) {
                function c(t, i) {
                    this.options = i || {}, this._ticks = t, this._active = !1, this._actionManager = null
                }

                c.prototype = {
                    begin: function (t) {
                        return this._actionManager = t, this._active = !0, this._executeAction(0), this
                    }, end: function () {
                        this._clearCurrentAction(), this._end()
                    }, isActive: function () {
                        return this._active
                    }, _clearCurrentAction: function () {
                        this._currentAction && (this._currentAction.end(), this._currentAction = null)
                    }, _executeAction: function (t) {
                        this._currentAction = new n(i({}, this._ticks[t], {callback: this._getCallback(t, t == this._ticks.length - 1)})), this._currentAction.end = function () {
                            this._currentAction && (n.prototype.end.call(this._currentAction), this._currentAction = null, this._end())
                        }.bind(this), this._actionManager.execute(this._currentAction)
                    }, _getCallback: function (t, i) {
                        return function (n) {
                            if (this._active) if (this._currentAction = null, n) this.options.callback && this.options.callback(n); else if (this._ticks[t].callback && this._ticks[t].callback.call(n), i) this._end(); else {
                                var c = this._ticks[t];
                                if (!c.globalPixelCenter) {
                                    var e = this._actionManager.getMap().options.get("projection");
                                    c.globalPixelCenter = e.toGlobalPixels(c.center, c.zoom)
                                }
                                this._executeAction(t + 1)
                            }
                        }.bind(this)
                    }, _end: function () {
                        this._active && (this._active = !1, this.options.callback && this.options.callback(null))
                    }
                }, t(c)
            });
        }],
        ['7R', function (ym) {
            ym.modules.define("map.action.AreaRestrictionManager", ["util.defineClass", "event.Manager", "map.action.Single", "util.bounds", "util.array", "Monitor", "vow"], function (t, i, e, o, n, s, r, a) {
                var c = function (t) {
                    this._map = t, this.events = new e, this._restrictBounds = null, this._minZoom = null, this._calculate(), this._setupListeners()
                };
                i(c, {
                    getArea: function () {
                        return this._restrictBounds
                    }, getZoomRange: function () {
                        var t = this._map.options, i = t.get("minZoom", 0);
                        return i = Math.max(i, this._minZoom), a.resolve([i, t.get("maxZoom")])
                    }, correctTick: function (t) {
                        if (this._restrictBounds) {
                            var i = this._map.container.getSize(),
                                e = n.toGlobalPixelBounds(this._restrictBounds, t.zoom, this._map.options.get("projection")),
                                o = [i[0] / 2, i[1] / 2],
                                s = [[t.globalPixelCenter[0] - o[0], t.globalPixelCenter[1] - o[1]], [t.globalPixelCenter[0] + o[0], t.globalPixelCenter[1] + o[1]]],
                                r = [0, 0];
                            e[0][0] > s[0][0] ? r[0] = e[0][0] - s[0][0] : e[1][0] < s[1][0] && (r[0] = e[1][0] - s[1][0]), e[0][1] > s[0][1] ? r[1] = e[0][1] - s[0][1] : e[1][1] < s[1][1] && (r[1] = e[1][1] - s[1][1]), (r[0] || r[1]) && (t.globalPixelCenter[0] += r[0], t.globalPixelCenter[1] += r[1])
                        }
                    }, fixZoom: function (t) {
                        if (this._restrictBounds) {
                            var i = this._map.options,
                                e = n.getCenterAndZoom(this._restrictBounds, this._map.container.getSize(), i.get("projection"), {
                                    inscribe: !1,
                                    preciseZoom: !0
                                });
                            i.get("avoidFractionalZoom") && (e.zoom = Math.ceil(e.zoom)), t < e.zoom && (t = e.zoom);
                            var o = Math.ceil(e.zoom);
                            this._minZoom != o && (this._minZoom = o)
                        }
                        return t
                    }, destroy: function () {
                        this._clearListeners(), this._restrictBounds = null, this._minZoom = null
                    }, _setupListeners: function () {
                        this._mapOptionsMonitor = new r(this._map.options).add("restrictMapArea", this._onRestrictOptionsChange, this), this._mapListeners = this._map.events.group().add(["sizechange", "create"], this._runAction, this)
                    }, _clearListeners: function () {
                        this._mapOptionsMonitor.destroy(), this._mapListeners.removeAll()
                    }, _calculate: function () {
                        var t = this._map.options.get("restrictMapArea", !1);
                        if (t) {
                            if (s.isArray(t)) this._restrictBounds = t; else if (!this._restrictBounds) {
                                var i = this._map.getBounds();
                                this._restrictBounds = [[i[0][0] - 1e-6, i[0][1] - 1e-6], [i[1][0] + 1e-6, i[1][1] + 1e-6]]
                            }
                        } else this._restrictBounds = null, this._minZoom = this._map.options.get("minZoom", 0)
                    }, _runAction: function () {
                        this._restrictBounds && this._map.action.execute(new o({
                            globalPixelCenter: this._map.getGlobalPixelCenter(),
                            zoom: this._map.getZoom()
                        }))
                    }, _onRestrictOptionsChange: function () {
                        this._calculate(), this._restrictBounds && this._runAction()
                    }
                }), t(c)
            });
        }],
        ['7j', function (ym) {
            ym.modules.define("map.optionMapper", ["option.Mapper"], function (p, e) {
                p(new e)
            });
        }],
        [')k', function (ym) {
            ym.modules.define("util.coordinates.getClosestPixelPosition", [], function (o) {
                var t = function (o, t, a, i) {
                    var e = i.isCycled(), r = Math.pow(2, a + 8);
                    if (e[0]) {
                        var n = t[0] - o[0];
                        2 * Math.abs(n) > r && (t[0] += (n > 0 ? -1 : 1) * (Math.floor(t[0] / r) + 1) * r)
                    }
                    if (e[1]) {
                        var s = t[1] - o[1];
                        2 * Math.abs(s) > r && (t[1] += (s > 0 ? -1 : 1) * (Math.floor(t[1] / r) + 1) * r)
                    }
                    return t
                };
                o(t)
            });
        }],
        ['()', function (ym) {
            ym.modules.define("util.animation.getFlyingTicks", [], function (o) {
                function e(o, e, a, l, t) {
                    var n = Math.ceil(Math.max(Math.log(Math.abs(a[0]) / (2 * t[0])) * Math.LOG2E, Math.log(Math.abs(a[1]) / (2 * t[1])) * Math.LOG2E)),
                        i = (o.zoom, Math.round(o.zoom + (e.zoom - o.zoom) / 2 - n)),
                        r = [a[0] / 4 * Math.pow(2, o.zoom - l), a[1] / 4 * Math.pow(2, o.zoom - l)],
                        g = [(o.globalPixelCenter[0] + r[0]) / Math.pow(2, o.zoom - i), (o.globalPixelCenter[1] + r[1]) / Math.pow(2, o.zoom - i)],
                        m = [a[0] / 4 * Math.pow(2, e.zoom - l), a[1] / 4 * Math.pow(2, e.zoom - l)],
                        M = [(e.globalPixelCenter[0] - m[0]) / Math.pow(2, e.zoom - i), (e.globalPixelCenter[1] - m[1]) / Math.pow(2, e.zoom - i)],
                        h = .4 * e.duration;
                    return [{
                        globalPixelCenter: g,
                        zoom: i,
                        timingFunction: "ease-out",
                        delay: e.delay,
                        duration: h,
                        checkZoomRange: e.checkZoomRange,
                        useMapMargin: e.useMapMargin
                    }, {
                        globalPixelCenter: M,
                        zoom: i,
                        delay: 0,
                        timingFunction: e.timingFunction,
                        duration: Math.round(.3 * e.duration),
                        checkZoomRange: e.checkZoomRange,
                        useMapMargin: e.useMapMargin
                    }, {
                        globalPixelCenter: e.globalPixelCenter,
                        zoom: e.zoom,
                        delay: 0,
                        timingFunction: "ease-in",
                        duration: h,
                        callback: e.callback,
                        checkZoomRange: e.checkZoomRange,
                        useMapMargin: e.useMapMargin
                    }]
                }

                var a = function (o, a) {
                    for (var l = [], t = {
                        globalPixelCenter: a.getGlobalPixelCenter(),
                        zoom: a.getZoom()
                    }, n = 0, i = o.length; n < i; n++) {
                        var r = o[n], g = r.duration;
                        if (0 != g) {
                            r.globalPixelCenter || (r.globalPixelCenter = a.options.get("projection").toGlobalPixels(r.center, r.zoom));
                            var m, M;
                            if (r.zoom == t.zoom) m = [r.globalPixelCenter[0] - t.globalPixelCenter[0], r.globalPixelCenter[1] - t.globalPixelCenter[1]], M = r.zoom; else {
                                M = Math.round(t.zoom + (r.zoom - t.zoom) / 2);
                                var h = [t.globalPixelCenter[0] * Math.pow(2, M - t.zoom), t.globalPixelCenter[1] * Math.pow(2, M - t.zoom)],
                                    c = [r.globalPixelCenter[0] / Math.pow(2, r.zoom - M), r.globalPixelCenter[1] / Math.pow(2, r.zoom - M)];
                                m = [c[0] - h[0], c[1] - h[1]]
                            }
                            var u = a.container.getSize(), z = Math.abs(m[0]) > 2 * u[0] || Math.abs(m[1]) > 2 * u[1];
                            z ? l = [].concat(l, e(t, r, m, M, u)) : l.push(r), t = r
                        } else l.push(r), t = r
                    }
                    return l
                };
                o(a)
            });
        }],
        [':w', function (ym) {
            ym.modules.define("yandex.state.component.Map", ["yandex.state.associate", "Monitor", "projection.zeroZoom", "util.coordinates.toLatLong", "util.extend", "util.defineClass"], function (e, t, n, s, a, i, o) {
                function p(e) {
                    this._map = e, this._mapListeners = null, this._mapType = null, this._model = i({}, l), this._yandexState = t.get(e), this._setupListeners(), this._init()
                }

                var l = {center: null, zoom: null, bounds: null}, h = {
                    "yandex#map": "map",
                    "yandex#satellite": "sat",
                    "yandex#hybrid": "sat,skl",
                    "yandex#publicMap": "map",
                    "yandex#publicMapHybrid": "sat,skl"
                };
                o(p, {
                    destroy: function () {
                        this._clearListeners(), this._yandexState = null
                    }, _init: function () {
                        var e = this._map, t = e.getZoom(), n = e.getBounds(), o = e.getGlobalPixelBounds();
                        i(this._model, {
                            center: a(e.getCenter()),
                            zoom: t,
                            bounds: [a(n[0]), a(n[1])],
                            zeroZoomBounds: [s.fromGlobalPixels(o[0], t), s.fromGlobalPixels(o[1], t)]
                        }), this._setMapType(), this._setYandexState()
                    }, _setupListeners: function () {
                        this._mapListeners = this._map.events.group().add("boundschange", this._onBoundsChange, this).add("typechange", this._onTypeChange, this), this._mapStateMonitor = new n(this._map.state).add(["mapSid", "mapSourceType"], this._onUserMapChange, this)
                    }, _clearListeners: function () {
                        this._mapListeners.removeAll(), this._mapListeners = null, this._mapStateMonitor.removeAll(), this._mapStateMonitor = null
                    }, _onBoundsChange: function (e) {
                        var t = e.get("newBounds"), n = e.get("newZoom"), o = e.get("target").getGlobalPixelBounds();
                        i(this._model, {
                            center: a(e.get("newCenter")),
                            zoom: n,
                            bounds: [a(t[0]), a(t[1])],
                            zeroZoomBounds: [s.fromGlobalPixels(o[0], n), s.fromGlobalPixels(o[1], n)]
                        }), this._setYandexState()
                    }, _onTypeChange: function () {
                        this._setMapType()
                    }, _onUserMapChange: function (e) {
                        this._yandexState.setUserMap(e.mapSourceType, e.mapSid)
                    }, _getMapType: function () {
                        return h[this._map.getType()]
                    }, _setMapType: function () {
                        var e = this._mapType;
                        e && this._yandexState.removeLayers(e), e = this._mapType = this._getMapType(), e && this._yandexState.pushLayers(e)
                    }, _setYandexState: function () {
                        this._yandexState.setMapState(this._model)
                    }
                }), e(p)
            });
        }],
        [':x', function (ym) {
            ym.modules.define("yandex.state.component.MapGeoObjects", ["util.defineClass", "yandex.state.associate", "util.coordinates.toLatLong", "util.tailThrottle", "util.vector", "util.WeakMap", "map.associate.serviceGeoObjects"], function (t, e, n, o, i, s, r, a) {
                function l(t) {
                    this._collection = t, this._serviceGeoObjects = a.get(t.getMap()), this._collectionListeners = null, this._yandexState = n.get(t.getMap()), this._throttledUpdate = i(_, this._setYandexState), this._setupListeners()
                }

                function c(t, e) {
                    if (g(t) && e.push(t), t.getIterator) for (var n, o = t.getIterator(); (n = o.getNext()) != o.STOP_ITERATION;) "undefined" != typeof n && c(n, e)
                }

                function g(t) {
                    return 0 != t.options.get("visible") && !f.get(t) && h(t)
                }

                function h(t) {
                    return null != t.geometry && !f.get(t) && t.geometry.getType() == p && null != t.geometry.getCoordinates()
                }

                function u(t, e, n) {
                    for (var o = [], i = 0, r = t.length; i < r; i++) {
                        var a = t[i].geometry.getPixelGeometry().getCoordinates();
                        o.push({geoObject: t[i], distance: s.length([e[0] - a[0], e[1] - a[1]])})
                    }
                    o.sort(function (t, e) {
                        return t.distance - e.distance
                    });
                    for (var l = [], i = 0, r = o.length; i < r; i++) l.push(o[i].geoObject);
                    return l
                }

                function d(t, e) {
                    var n = t;
                    do {
                        if (e.indexOf(n) != -1) return !1;
                        n = n.getParent && n.getParent()
                    } while (n);
                    return !0
                }

                var p = "Point", _ = 300, f = new r;
                e(l, {
                    destroy: function () {
                        this._clearListeners(), this._collection = null, this._yandexState = null, this._throttledUpdate.clear()
                    }, _setupListeners: function () {
                        this._collectionListeners = this._collection.events.group().add(["add", "remove", "geometrychange", "overlaychange", "balloonopen", "balloonclose"], this._throttledUpdate, this), this._mapListeners = this._collection.getMap().events.group().add(["boundschange"], this._throttledUpdate, this)
                    }, _clearListeners: function () {
                        this._mapListeners.removeAll(), this._collectionListeners.removeAll()
                    }, _setYandexState: function () {
                        this._yandexState && this._yandexState.setPoints(this._getPoints())
                    }, _getPoints: function () {
                        var t = this._collection, e = t.getMap(), n = e.balloon && e.balloon.getOwner(),
                            i = n && n.geometry && n.state.get("active") && n.options.get("visible") === !1 && d(n, this._serviceGeoObjects),
                            s = [];
                        if (i && h(n) && s.push(n), c(t, s), s.length > 1e3) return [];
                        s.length > 10 && (s = u(s, e.getGlobalPixelCenter(), e.options.get("projection")));
                        for (var r = [], a = 0, l = s.length; a < l && a < 10; a++) r.push(o(s[a].geometry.getCoordinates()));
                        return r
                    }
                }), l.ignoreGeoObject = function (t) {
                    f.set(t, !0)
                }, t(l)
            });
        }],
        [')@', function (ym) {
            ym.modules.define("util.lazy", [], function (n) {
                function t(n, t) {
                    for (var u, e = [], r = !1, f = 0, i = 2, l = arguments.length; i < l; f++, i++) e[f] = arguments[i];
                    return function () {
                        return r || (u = n.apply(t, e), r = !0), u
                    }
                }

                n(t)
            });
        }],
        [',7', function (ym) {
            ym.modules.define("vectorEngine.collectStatistics", [], function (e) {
                e(function () {
                    ym.supports.vector.isSupported() || ym.count("error", {
                        path: ["vectorEngine.vectorNotSupported", ym.env.browser.platform, ym.env.browser.name].join("."),
                        share: .01
                    })
                })
            });
        }],
        ['$(', function (ym) {
            ym.modules.define("package.yandex", function (e) {
                var a = {map: "Map", sat: "Satellite", skl: "Skeleton"},
                    r = {map: ["map"], satellite: ["sat"], hybrid: ["sat", "skl"]};
                if (e.env.restrictions && e.env.restrictions.prohibitedLayers) for (var t = e.env.restrictions.prohibitedLayers.split(","), n = 0, i = t.length; n < i; n++) delete a[t[n]];
                var s = ["yandex.mapType.metaOptions", "yandex.counterStorage", "yandex.layer.VectorMap"];
                for (var i in a) a.hasOwnProperty(i) && s.push("yandex.layer." + a[i]);
                for (var o in r) if (r.hasOwnProperty(o)) {
                    for (var p = r[o], n = 0, i = p.length; n < i && a[p[n]]; n++) ;
                    n == i && s.push("yandex.mapType." + o)
                }
                return s
            }, function (e) {
                e(!0)
            });
        }],
        ['7P', function (ym) {
            ym.modules.define("map.action.Base", ["event.Manager"], function (e, n) {
                function t() {
                    this.events = new n({context: this}), this._actionManager = null
                }

                t.prototype = {
                    isActive: function () {
                        return !!this._actionManager
                    }, begin: function (e) {
                        this._actionManager = e, this.events.fire("begin")
                    }, end: function () {
                        this._actionManager = null, this.events.fire("end")
                    }, getActionManager: function () {
                        return this._actionManager
                    }, fixTick: function (e, n) {
                        var t = n.getCurrentState(), i = t.zoom, o = "undefined" == typeof e.zoom ? i : Number(e.zoom),
                            a = e.globalPixelCenter;
                        if (!a) if (!e.pixelOffset && e.center) a = n.getMap().options.get("projection").toGlobalPixels(e.center, o); else {
                            var r = t.globalPixelCenter.slice(), l = Math.pow(2, o - i);
                            if (e.pixelOffset) {
                                var c = e.pixelOffset;
                                a = r, a[0] -= c[0], a[1] -= c[1]
                            } else a = r;
                            a[0] *= l, a[1] *= l
                        }
                        return {
                            zoom: o,
                            globalPixelCenter: a,
                            duration: Number(e.duration) || 0,
                            timingFunction: e.timingFunction || "linear"
                        }
                    }
                }, e(t)
            });
        }],
        ['0)', function (ym) {
            ym.modules.define("component.sharedEntity.manager.Popup", ["util.defineClass", "sharedEntity.proxy.Popup", "component.sharedEntity.manager.Base"], function (t, e, n, o) {
                function s(t, e, o, r) {
                    s.superclass.constructor.call(this, t, e, o, r || n)
                }

                for (var r = ["open", "close", "setPosition", "isOpen", "getOverlay", "getOverlaySync", "getPosition", "setData", "getData", "setOptions", "getOptions"], a = {}, i = 0, p = r.length; i < p; i++) a[r[i]] = function (t) {
                    return function () {
                        return this.perform(t, Array.prototype.slice.call(arguments))
                    }
                }(r[i]);
                e(s, o, a), t(s)
            });
        }],
        ['.s', function (ym) {
            ym.modules.define("sharedEntity.proxy.Balloon", ["util.defineClass", "sharedEntity.proxy.Popup", "util.component"], function (o, t, n, e) {
                function l(o) {
                    l.superclass.constructor.call(this, o), this._balloon = o
                }

                o(t(l, n, e.createProxyMethods(function () {
                    return this._balloon
                }, ["autoPan"])))
            });
        }],
        ['$e', function (ym) {
            ym.modules.define("option.Router", ["util.defineClass", "util.array", "event.manager.Base", "Event"], function (e, t, n, s, i) {
                var r = t(function (e) {
                    this._parents = Array.prototype.slice.call(arguments), this._setupChangeListeners(this._parents), this.events = new s
                }, {
                    getParentsLength: function () {
                        return this._parents.length
                    }, indexOfParent: function (e) {
                        return n.indexOf(this._parents, e)
                    }, spliceParents: function (e, t) {
                        var n, s = arguments.length;
                        return s > 2 ? (n = this._parents.splice.apply(this._parents, arguments), this._setupChangeListeners(this._parents.slice(e, (e || 0) + s - 2))) : n = this._parents.splice(e, t), this._clearChangeListeners(n), this._fireChange(), n
                    }, resolve: function (e, t) {
                        for (var n, s = 0, i = this._parents.length; s < i && (n = this._parents[s].resolve(e, t), "undefined" == typeof n); s++) ;
                        return n
                    }, _setupChangeListeners: function (e) {
                        for (var t = 0, n = e.length; t < n; t++) e[t].events.add("change", this._fireChange, this)
                    }, _clearChangeListeners: function (e) {
                        for (var t = 0, n = e.length; t < n; t++) e[t].events.remove("change", this._fireChange, this)
                    }, _fireChange: function () {
                        this.events.fire("change", new i({target: this, type: "change"}))
                    }
                });
                e(r)
            });
        }],
        ['7!', function (ym) {
            ym.modules.define("map.GeneralCollection", ["util.defineClass", "option.Manager", "event.Manager"], function (t, e, n, s) {
                function i(t, e, i, o) {
                    this.events = new s({context: this}), this.options = new n(e || {}, t.options, i, o), this._map = t, this._map.events.add("destroy", this.onMapDestroy, this)
                }

                e(i, {
                    getMap: function () {
                        return this._map
                    }, onMapDestroy: function () {
                        this._map.events.remove("destroy", this.onMapDestroy, this), this.events.fire("mapchange", {
                            oldMap: this._map,
                            newMap: null
                        }), this.options.setParent(null)
                    }
                }), t(i)
            });
        }],
        [')7', function (ym) {
            ym.modules.define("util.fullscreen.Manager", ["util.defineClass", "util.fullscreen.native.Manager", "util.fullscreen.element.Manager", "event.Manager", "option.Manager", "Monitor"], function (e, n, t, r, s, i, a) {
                function l(e, n) {
                    this._element = e, this._manager = null, this.events = new s, this.options = new i(n), this._optionsMonitor = new a(this.options).add("nativeFullscreen", this._onNativeFullscreenChange, this)
                }

                l.fullscreenSupported = r.fullscreenSupported || t.fullscreenSupported, n(l, {
                    enterFullscreen: function () {
                        this._getOrCreateManager().enterFullscreen()
                    }, exitFullscreen: function () {
                        this._getOrCreateManager().exitFullscreen()
                    }, toggleFullscreen: function () {
                        this._getOrCreateManager().toggleFullscreen()
                    }, isInFullscreen: function () {
                        return this._getOrCreateManager().isInFullscreen()
                    }, getSize: function () {
                        return this._getOrCreateManager().getSize()
                    }, destroy: function () {
                        this._destroyCurrentManager(), this._optionsMonitor.destroy()
                    }, _getOrCreateManager: function () {
                        if (this._manager) return this._manager;
                        var e = this.options.get("nativeFullscreen", !1) && t.fullscreenSupported ? t : r;
                        return this._manager = new e(this._element, this.options), this._manager.events.setParent(this.events), this._manager
                    }, _destroyCurrentManager: function () {
                        this._manager && (this._manager.isInFullscreen() && this._manager.events.once("fullscreenexit", function (e) {
                            this.events.fire(e.get("type"))
                        }, this), this._manager.destroy(), this._manager = null)
                    }, _onNativeFullscreenChange: function (e) {
                        this._manager && t.fullscreenSupported && this._destroyCurrentManager()
                    }
                }), e(l)
            });
        }],
        [':I', function (ym) {
            ym.modules.define('map.css', ["map-css"], function (provide) {
                provide({});
            });
        }],
        ['7_', function (ym) {
            ym.modules.define("map.copyrights.StaticProvider", ["util.defineClass", "event.Manager", "util.math.differ", "vow"], function (t, e, i, n, r) {
                var s = function (t, e) {
                    this._copyrights = [].concat(t), this._manager = e, this.events = new i({context: this})
                };
                e(s, {
                    getCopyrights: function () {
                        return r.resolve(this._copyrights)
                    }, setCopyrights: function (t) {
                        var e = [].concat(t);
                        n(e, t) && (this._copyrights = e, this.events.fire("copyrightschange"))
                    }, remove: function () {
                        this._manager.removeProvider(this)
                    }
                }), t(s)
            });
        }],
        ['7-', function (ym) {
            ym.modules.define("map.copyrights.Promo", ["data.Manager", "Monitor", "projection.wgs84Mercator", "projection.sphericalMercator", "yandex.state.associate", "util.defineClass", "util.dom.element", "util.css", "inception.MapsButton", "system.browser", "yandex.counter", "util.tailThrottle", "map.copyrights.promo.css"], function (t, e, i, s, n, a, o, h, r, _, p, l, c) {
                function u(t, e) {
                    this._parentElement = t, this._copyrightsManager = e, this._map = e.getMap(), this._throttledUpdateData = c(d, this.refresh), this._mapsButton = null, this._copyrightsStateMonitor = null, this._mapContainerListeners = null, this._enabled = !0, this._setupData(), this._setupListeners(), this._setupPromoBlock()
                }

                var m = 20, d = 100, g = "suppressMapOpenBlock", f = "copyrightsVisible", y = "copyrightsPosition",
                    B = "copyrightsFloat";
                o(u, {
                    destroy: function () {
                        this._clearPromoBlock(), this._clearListeners(), this._clearData(), this._map = null, this._parentElement = null, this._mapsButton = null
                    }, getLink: function () {
                        if (this._mapsButton) return this._mapsButton.getLink()
                    }, toggle: function (t) {
                        this._enabled = t, this._resetPromoBlock()
                    }, refresh: function () {
                        this._mapsButton && this._mapsButton.refresh()
                    }, _getElement: function () {
                        return this._element || (this._element = h.create({
                            className: r.addPrefix("map-copyrights-promo"),
                            parentNode: this._parentElement
                        }))
                    }, _setupData: function () {
                        this._yandexState = a.get(this._map), this._data = new e({mapState: this._yandexState.getAll()}), this._yandexState.events.add("change", this._onMapStateChange, this), this._data.events.add("change", this._throttledUpdateData, this)
                    }, _clearData: function () {
                        this._data.events.remove("change", this._throttledUpdateData, this), this._data.destroy(), this._data = null, this._yandexState.events.remove("change", this._onMapStateChange, this), this._yandexState = null
                    }, _onMapStateChange: function () {
                        this._data.set("mapState", this._yandexState.getAll())
                    }, _setupListeners: function () {
                        this._mapOptionsMonitor = new i(this._map.options).add([f, y, B], this._updateVisible, this, {defaultValue: !1}).add(g, this._resetPromoBlock, this)
                    }, _clearListeners: function () {
                        this._mapOptionsMonitor.destroy()
                    }, _setupPromoBlock: function () {
                        var t = this._map.options.get(g, !1), e = this._map.options.get("projection");
                        !this._enabled || t || e != s && e != n || (this._setupSizeChangeListeners(), this._setAvailWidth(), this.render())
                    }, _resetPromoBlock: function () {
                        this._clearPromoBlock(), this._setupPromoBlock()
                    }, render: function () {
                        this._mapsButton = new _({data: this._data}), this._mapsButton.setParentElement(this._getElement()), this._mapsButton.events.add("click", this._onClick, this)
                    }, _onClick: function () {
                        var t = this._mapsButton.getContext().indexOf("common") == -1 ? this._currentContext : "common";
                        l.countByKey("distribution", ["mapsButton" + (this._data.get("mapState.userMap") ? "-constructor" : ""), "context_" + t, p.platform, l.versionPrefix].join(".")), window.open(this._mapsButton.getLink(), "_blank")
                    }, _clearPromoBlock: function () {
                        this._mapsButton && (this._mapsButton.destroy(), this._mapsButton = null, this._clearSizeChangeListeners())
                    }, _setupSizeChangeListeners: function () {
                        this._mapContainerListeners = this._map.container.events.group().add("sizechange", this._setAvailWidth, this), this._copyrightsStateMonitor = new i(this._copyrightsManager.getState()).add("copyrightsWidth", this._setAvailWidth, this)
                    }, _clearSizeChangeListeners: function () {
                        this._mapContainerListeners.removeAll(), this._copyrightsStateMonitor.destroy()
                    }, _updateVisible: function () {
                        var t = this._mapOptionsMonitor;
                        t.get(f) || t.get(y) || t.get(B) ? this._mapsButton && this._clearPromoBlock() : this._mapsButton || this._setupPromoBlock()
                    }, _getAvailWidth: function () {
                        return this._map.container.getSize()[0] - (this._copyrightsStateMonitor.get("copyrightsWidth") + m)
                    }, _setAvailWidth: function () {
                        this._data.set("availWidth", this._getAvailWidth())
                    }
                }), t(u)
            });
        }]
    ]
);
